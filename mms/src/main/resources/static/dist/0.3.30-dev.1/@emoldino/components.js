const gf = {
  data: {
    description: `
    - type: object[]
    - chart에 들어갈 데이터
    - 이 데이터중 하나의 데이터의 중심이 될 항목을 category로 설정합니다.
    `
  },
  category: {
    description: `
    - type: string
    - x축의 기준이 될 데이터
    `
  },
  axisDataBinder: {
    description: `
    - type: object
    - 축의 형식을 정의합니다.

    key
     - xAxis:
       - name: x axis name
       - type: ('CategoryAxis' || )
     - yAxis:
       - name: y axis name
       - type: ('ValueAxis' || )
       - isLeft: 왼쪽에 전시할 것인지 여부
     - ySecondAxis:
       - name: second y axis name
       - type: ('ValueAxis' || )
       - isLeft: 왼쪽에 전시할 것인지 여부
    `
  },
  lineDataBinder: {
    description: `
    - type: object[]
    라인 차트를 보여줄 항목

    key
     - key: data로 넘겨준 항목의 key
     - displayName: 이 데이터가 차트에 표시될 때 나타낼 이름
     - color(optional): 이 데이터를 차트에 표시될 때 나타낼 색상
     - isYSecondAxis(optional): 이 데이터를 두 번째 y 축으로 설정할 것인지를 정의합니다.
     - tooltipHTML(optional): tooltip 을 설정합니다.
    `
  },
  bubbleDataBinder: {
    description: `
    - type: object[]
    - 버블 차트를 보여줄 항목
    - lineDataBinder와 같은 형식입니다.
    `
  },
  barDataBinder: {
    description: `
    - type: object[]
    - 막대 차트를 보여줄 항목
    - lineDataBinder와 같은 형식입니다.
    `
  },
  candlestickDataBinder: {
    description: `
    - type: object[]
    - 캔들스틱 차트를 보여줄 항목
    - lineDataBinder와 같은 형식입니다.
    `
  },
  timsScale: {
    description: `
    - type: string
    - 시간 단위
    - 사용 가능한 값: 'MINUTELY', 'HOURLY', 'DAILY', 'WEEKLY', 'MONTHLY', 'YEARLY'
    `
  },
  selectionMin: {
    description: "선택된 최소 값."
  },
  selectionMax: {
    description: "선택된 최대 값."
  },
  tooltipHTML: {
    description: "기본으로 보여줄 tooltip html"
  },
  xAxisGridStrokeOpacityAdapter: {
    description: `
     @description x축 grid의 선 투명도를 개별로 조정하는 어댑터

     @param {object} target - xAxis 개별 항목
     @returns {number} grid stroke opacity
    `
  },
  xAxisLabelTextAdapter: {
    description: `
    * @description x축 label을 개별로 조정하는 어댑터
   *
   * @param {string} text - 현재 저장되어 있는 개별 xAxis label text
   * @param {object} target - xAxis 개별 항목
   * @returns {string} xAxis label text
    ,`
  },
  xAxisTooltipLabelTextAdapter: {
    description: `
    * @description x축 끝에 나오는 tooltip 을 조정하는 어댑터
    *
    * @param {string} text - 현재 저장되어 있는 개별 xAxis tooltip text
    * @param {object} target - xAxis 개별 항목
    * @returns {string} xAxis tooltip label text
    `
  },
  seriesTooltipLabelHtmlAdapter: {
    description: `
    * @description 전체적인 시리즈의 tooltip 을 조정하는 어댑터
    *
    * @param {string} html - 현재 저장되어 있는 개별 xAxis tooltip HTML
    * @param {object} target - series 개별 항목
    * @param {object} item - chart data binder item (displayName || key || color)
    `
  },
  xScrollbarXAxisLabelTextAdapter: {
    description: `
    * @description 스크롤바의 x축 label을 개별로 조정하는 어댑터
    *
    * @param {string} text - 현재 저장되어 있는 개별 dettail scrollbar xAxis label text
    * @param {object} target - detailScrollbar xAxis 개별 항목
    `
  },
  seriesTooltipForceHiddenAdapter: {
    description: `
    * @description 시리즈의 툴팁을 숨길지 여부를 정의하는 어댑터
    *
    * @param {object} forceHidden - 현재 forceHidden 여부
    * @param {object} target - series 개별 항목
    * @param {object} item - chart data binder item (displayName || key || color)
    `
  },
  getWheelCursorPositionX: {
    description: `

    `
  },
  chartItemClickHandler: {
    description: `
    * @description chart의 항목을 클릭할 때 동작하는 함수
    *
    * @param {string} event - click event
    `
  },
  setSelectionMin: {
    description: `
    * @description 현재 선택된 가장 작은 value를 저장하는 함수
    * @param {string} selectionMin - 선택된 최소값 (카테고리)
    `
  },
  setSelectionMax: {
    description: `
    * @description 현재 선택된 가장 큰 value를 저장하는 함수
    * @param {string} selectionMax - 선택된 최대값 (카테고리)
    `
  },
  zoomHandler: {
    description: `
    /**
     * @description zoom 동작 시 동작하는 함수
     * @param {string} zoomSelectionMin - zoom을 동작시킬 때 선택된 최소 값
     * @param {string} zoomSelectionMax - zoom을 동작시킬 때 선택된 최대 값
    `
  },
  panHandler: {
    description: `
    * @description drag 동작 시 동작하는 함수
    * @param {string} param - ('next' || 'previous')
    `
  },
  styleProps: {
    description: `
    * @description  차트 컨테이너를 구성하는 style
    `
  },
  chartSet: {
    description: `
    * @description - 기본 차트 설정
    *
    * key
    *
    *  - refProps(string):
    *    > 차트의 ref 를 설정합니다
    *    > default: "defaultXYChart"
    *
    *  - id(string):
    *    > 차트의 id 를 설정합니다
    *    > default: "defaultXYChart"
    *
    *  - chartType:
    *    > 현재 차트가 상세 스크롤바 차트인지 기본 차트인지를 구분합니다.
    *    > 선택 가능한 값: ('default' || 'overall' || none)
    *    > default: 'default'
    *
    *  - titleLabel(object):
    *    - text (string):
    *      > default: "0000-00-00 ~ 0000-00-00"
    *    - fontSize (number):
    *      > title label 의 글자 크기를 설정합니다.(px)
    *      > default: 12
    *    - fontWeight (string):
    *      > title label 의 글자 두께를 설정합니다.
    *      > default: "normal"
    *    - textAlign (string):
    *      > title label의 글자 정렬을 설정합니다.
    *      > default: "center"
    *    - x (number):
    *      > x 축의 위치를 설정합니다.
    *      > default: 5
    *    - centerX (number):
    *      > x 축 중심의 위치를 설정합니다.
    *      > default: 0
    *    - paddingTop (number):
    *      > 상단 padding 을 설정합니다.
    *      > default: 0
    *    - paddingBottom (number):
    *      > 하단 padding 을 설정합니다.
    *      > default: 0
    *    - color (string):
    *      > title label의 글자 색을 설정합니다.
    *      > default: "#555"
    *
    *  - isZoomOutButton:
    *    > zoom out 버튼을 사용할 것인지 여부를 정의합니다.
    *    > default: false
    *
    *  - isYAxesPlotContainerVisible:
    *    > yAxisPlotContainer를 보여줄 것인지 여부를 정의합니다.
    *    > yAxisPlotContainer 가 뭔데요? 링크로 알려주기
    *    > default: true
    *
    *  - isBottomAxesContainerVisible:
    *    > bottomAxesContainer를 보여줄 것인지 여부를 정의합니다.
    *    > bottomAxesContainer 가 뭔데요?  링크로 알려주기
    *    > default: true
    *
    *  - chartLayout:
    *    > default: "verticalLayout"
    *
    *  - panX:
    *    > x 축을 드래그 할 수 있도록 할 것인지 여부를 정의합니다.
    *    > default: true
    *
    *  - panY:
    *    > y 축을 드래그 할 수 있도록 할 것인지 여부를 정의합니다.
    *    > default: false
    *
    *  - wheelX:
    *    > 사용 가능한 값:
    *    > default: ""
    *
    *  - wheelY:
    *    > 사용 가능한 값:
    *    > default: "zoomX"
    `
  },
  legendSet: {
    description: `
    * @description - 기본 범례 설정
    *
    * key
    *  - isVisible (boolean): (default: true)
    *  - layout ('gridLayout' || ): (default: "gridLayout")
    *  - x (number): (default: 50)
    *  - centerX (number): (default: 50)
    *  - y (number): (default: 100)
    *  - centerY (number): (default: 100)
    `
  },
  candlestickSet: {
    description: `
    * @description 기본 candlestick chart 설정
    * 
    * key
    *  - riseColor(string): (default: "#ff0000")
    *  - dropColor(string): (default: "#0000ff")
    `
  },
  lineSet: {
    description: `
    * @description 기본 line chart 설정
    *
    * key
    *  - isLineVisible(boolean): (default: false)
    *  - strokeWidth(number): (default: 2)
    *  - fillOpacity(number): (default: 0.1)
    *  - bullet(object): (default: { strokeWidth: 2, radius: 3 })
    *  - colorList(array): (default: ["#f08080", "#fa8072", "#e9967a", "#ff7f50", "#ff6347", "#f4a460", "#ffa07a"])
    `
  },
  bubbleSet: {
    description: `
    * @description 기본 bubble chart 설정
    * 
    * key
    *  - strokeWidth(number): (default: 2)
    *  - bullet(object): (default: { strokeWidth: 2, radius: 3 })
    *  - colorList(array): (default: [ "#f08080", "#fa8072", "#e9967a", "#ff7f50", "#ff6347", "#f4a460", "#ffa07a" ])
    `
  },
  barSet: {
    description: `
    * @description 기본 bar chart 설정
    * 
    * key
    *  - isStacked(boolean): (default: false)
    *  - isClustered(boolean): (default: false)
    *  - width(number): (default: 15)
    *  - strokeWidth(number): (default: 1.5)
    *  - fillOpacity(number): (default: 0.3)
    *  - cornerRadius(object): (default: { topLeft: 0, topRight: 0 })
    *  - colorList(array): (default: [ "#BCE2C7", "#4EBCD5", "#1A2281", "#4169e1", "#1e90ff", "#0000cd", "#000080" ])
    `
  },
  defaultScrollbarSet: {
    description: `
    * @description 기본 scrollbar 설정
    * 
    * key
    *  - isVisible(boolean): (default: true)
    *  - isX(boolean): (default: false)
    *  - isY(boolean): (default: false)
    *  - isStartGrip (boolean): (default: false)
    *  - isEndGrip (boolean): (default: false)
    *  - isXDown (boolean): (default: false)
    *  - thumb (object): (default: { fill: "#550000", fillOpacity: 0.05 })
    *  - gripScale (number): (default: 0.9)
    *  - startPosition (number): (default: 0.2)
    *  - endPosition (number): (default: 0.8)
    `
  },
  detailScrollSet: {
    description: `
    * @description 상세 scrollbar 설정
    * 
    * key
    *  - isVisible (boolean): (default: true)
    *  - mainValue (object):
    *    - key: "",
    *    - displayName: ""
    *  - height (number): (default: 50)
    *  - line (object): (default: { color: "#fb9f57", strokeWidth: 2, fillOpacity: 0.2 })
    *  - background (object): {
    *    - fill (string): (default: "#000000")
    *    - fillOpacity (number): (default: 0.05)
    *    - cornerRadius(object): {
    *      - topLeft(number): (default: 0)
    *      - topRight(number): (default: 10)
    *      - bottomLeft(number): (default: 10)
    *      - bottomRight(number): (default: 10)
    `
  }
}, WO = {
  storybookChartargTypes: gf
};
function mf(i, e, t, s, r) {
  return t.trim().length > 0 && i.toLowerCase().includes(t) && !s.includes(e) ? (s.push(e), r(s), !0) : !1;
}
function _f(i, e, t, s, r) {
  let n = !1;
  s.length > 0 && s.indexOf(e) >= 0 && s.indexOf(e) === r - 1 && (n = !0);
  const a = new RegExp(t, "gi");
  return i.replace(
    a,
    (l, u) => String.raw`
      <span
        id="${e}-${u}"
        class="highlight ${n ? "focus" : ""}"
        tabindex="0"
      >
        ${l}
      </span>
    `
  );
}
const UO = {
  setHighlightJS: _f,
  getHasKeywordJS: mf
};
var Yo = function(i, e) {
  return Yo = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, s) {
    t.__proto__ = s;
  } || function(t, s) {
    for (var r in s)
      Object.prototype.hasOwnProperty.call(s, r) && (t[r] = s[r]);
  }, Yo(i, e);
};
function bf(i, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
  Yo(i, e);
  function t() {
    this.constructor = i;
  }
  i.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
}
function Ih(i) {
  var e = typeof Symbol == "function" && Symbol.iterator, t = e && i[e], s = 0;
  if (t)
    return t.call(i);
  if (i && typeof i.length == "number")
    return {
      next: function() {
        return i && s >= i.length && (i = void 0), { value: i && i[s++], done: !i };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function yf(i) {
  var e;
  jt(i, (e = Wl()) === null || e === void 0 ? void 0 : e.proxy);
}
var No, pn = [], Rh = (
  /** @class */
  function() {
    function i(e) {
      this.active = !0, this.effects = [], this.cleanups = [], this.vm = e;
    }
    return i.prototype.run = function(e) {
      if (this.active)
        try {
          return this.on(), e();
        } finally {
          this.off();
        }
      else
        ({}).NODE_ENV !== "production" && yf("cannot run an inactive effect scope.");
    }, i.prototype.on = function() {
      this.active && (pn.push(this), No = this);
    }, i.prototype.off = function() {
      this.active && (pn.pop(), No = pn[pn.length - 1]);
    }, i.prototype.stop = function() {
      this.active && (this.vm.$destroy(), this.effects.forEach(function(e) {
        return e.stop();
      }), this.cleanups.forEach(function(e) {
        return e();
      }), this.active = !1);
    }, i;
  }()
);
(function(i) {
  bf(e, i);
  function e(t) {
    t === void 0 && (t = !1);
    var s = this, r = void 0;
    return Df(function() {
      r = Fh(Na());
    }), s = i.call(this, r) || this, t || vf(s), s;
  }
  return e;
})(Rh);
function vf(i, e) {
  var t;
  if (e = e || No, e && e.active) {
    e.effects.push(i);
    return;
  }
  var s = (t = Wl()) === null || t === void 0 ? void 0 : t.proxy;
  s && s.$on("hook:destroyed", function() {
    return i.stop();
  });
}
function xf(i) {
  if (!i.scope) {
    var e = new Rh(i.proxy);
    i.scope = e, i.proxy.$on("hook:destroyed", function() {
      return e.stop();
    });
  }
  return i.scope;
}
var $o = void 0;
try {
  var Ji = require("vue");
  Ji && Mu(Ji) ? $o = Ji : Ji && "default" in Ji && Mu(Ji.default) && ($o = Ji.default);
} catch {
}
var cs = null, Os = null, On = !0, Yh = "__composition_api_installed__";
function Mu(i) {
  return i && ls(i) && i.name === "Vue";
}
function wf(i) {
  return cs && si(i, Yh);
}
function Na() {
  return {}.NODE_ENV !== "production" && Ul(cs, "must call Vue.use(VueCompositionAPI) before using any function."), cs;
}
function Nh() {
  var i = cs || $o;
  return {}.NODE_ENV !== "production" && Ul(i, "No vue dependency found."), i;
}
function Sf(i) {
  ({}).NODE_ENV !== "production" && cs && i.__proto__ !== cs.__proto__ && jt("[vue-composition-api] another instance of Vue installed"), cs = i, Object.defineProperty(i, Yh, {
    configurable: !0,
    writable: !0,
    value: !0
  });
}
function Df(i) {
  var e = On;
  On = !1;
  try {
    i();
  } finally {
    On = e;
  }
}
function Ou(i) {
  if (On) {
    var e = Os;
    e == null || e.scope.off(), Os = i, Os == null || Os.scope.on();
  }
}
function Wl() {
  return Os;
}
var uo = /* @__PURE__ */ new WeakMap();
function zn(i) {
  if (uo.has(i))
    return uo.get(i);
  var e = {
    proxy: i,
    update: i.$forceUpdate,
    type: i.$options,
    uid: i._uid,
    // $emit is defined on prototype and it expected to be bound
    emit: i.$emit.bind(i),
    parent: null,
    root: null
    // to be immediately set
  };
  xf(e);
  var t = [
    "data",
    "props",
    "attrs",
    "refs",
    "vnode",
    "slots"
  ];
  return t.forEach(function(s) {
    gt(e, s, {
      get: function() {
        return i["$".concat(s)];
      }
    });
  }), gt(e, "isMounted", {
    get: function() {
      return i._isMounted;
    }
  }), gt(e, "isUnmounted", {
    get: function() {
      return i._isDestroyed;
    }
  }), gt(e, "isDeactivated", {
    get: function() {
      return i._inactive;
    }
  }), gt(e, "emitted", {
    get: function() {
      return i._events;
    }
  }), uo.set(i, e), i.$parent && (e.parent = zn(i.$parent)), i.$root && (e.root = zn(i.$root)), e;
}
var Pf = function(i) {
  return Object.prototype.toString.call(i);
};
function Au(i) {
  return typeof i == "function" && /native code/.test(i.toString());
}
var Tf = typeof Symbol < "u" && Au(Symbol) && typeof Reflect < "u" && Au(Reflect.ownKeys), js = function(i) {
  return i;
};
function gt(i, e, t) {
  var s = t.get, r = t.set;
  Object.defineProperty(i, e, {
    enumerable: !0,
    configurable: !0,
    get: s || js,
    set: r || js
  });
}
function $h(i, e, t, s) {
  Object.defineProperty(i, e, {
    value: t,
    enumerable: !!s,
    writable: !0,
    configurable: !0
  });
}
function si(i, e) {
  return Object.hasOwnProperty.call(i, e);
}
function Ul(i, e) {
  if (!i)
    throw new Error("[vue-composition-api] ".concat(e));
}
function kf(i) {
  return typeof i == "string" || typeof i == "number" || // $flow-disable-line
  typeof i == "symbol" || typeof i == "boolean";
}
function Vs(i) {
  return Array.isArray(i);
}
var Cf = 4294967295;
function Mf(i) {
  var e = parseFloat(String(i));
  return e >= 0 && Math.floor(e) === e && isFinite(i) && e <= Cf;
}
function Xn(i) {
  return i !== null && typeof i == "object";
}
function Ii(i) {
  return Pf(i) === "[object Object]";
}
function ls(i) {
  return typeof i == "function";
}
function Of(i) {
  return i == null;
}
function jt(i, e) {
  var t = Nh();
  !t || !t.util ? console.warn("[vue-composition-api] ".concat(i)) : t.util.warn(i, e);
}
function Fh(i, e) {
  e === void 0 && (e = {});
  var t = i.config.silent;
  i.config.silent = !0;
  var s = new i(e);
  return i.config.silent = t, s;
}
function Af(i) {
  var e = Na();
  return e && i instanceof e;
}
function Lf(i, e) {
  return function() {
    for (var t = [], s = 0; s < arguments.length; s++)
      t[s] = arguments[s];
    return i.$scopedSlots[e] ? i.$scopedSlots[e].apply(i, t) : {}.NODE_ENV !== "production" ? jt("slots.".concat(e, '() got called outside of the "render()" scope'), i) : void 0;
  };
}
function jf(i, e) {
  var t;
  if (!i)
    t = {};
  else {
    if (i._normalized)
      return i._normalized;
    t = {};
    for (var s in i)
      i[s] && s[0] !== "$" && (t[s] = !0);
  }
  for (var s in e)
    s in t || (t[s] = !0);
  return t;
}
var Or = "composition-api.refKey", Lu = /* @__PURE__ */ new WeakMap(), Ef = /* @__PURE__ */ new WeakMap();
function If(i, e, t) {
  var s = Na(), r = s.util, n = r.warn, a = r.defineReactive;
  ({}).NODE_ENV !== "production" && (Of(i) || kf(i)) && n("Cannot set reactive property on undefined, null, or primitive value: ".concat(i));
  var o = i.__ob__;
  function l() {
    o && Xn(t) && !si(t, "__ob__") && Gl(t);
  }
  if (Vs(i)) {
    if (Mf(e))
      return i.length = Math.max(i.length, e), i.splice(e, 1, t), l(), t;
    if (e === "length" && t !== i.length)
      return i.length = t, o == null || o.dep.notify(), t;
  }
  return e in i && !(e in Object.prototype) ? (i[e] = t, l(), t) : i._isVue || o && o.vmCount ? ({}.NODE_ENV !== "production" && n("Avoid adding reactive properties to a Vue instance or its root $data at runtime - declare it upfront in the data option."), t) : o ? (a(o.value, e, t), Xh(i, e, t), l(), o.dep.notify(), t) : (i[e] = t, t);
}
var Bh = (
  /** @class */
  function() {
    function i(e) {
      var t = e.get, s = e.set;
      gt(this, "value", {
        get: t,
        set: s
      });
    }
    return i;
  }()
);
function Hh(i, e, t) {
  e === void 0 && (e = !1), t === void 0 && (t = !1);
  var s = new Bh(i);
  t && (s.effect = !0);
  var r = Object.seal(s);
  return e && Ef.set(r, !0), r;
}
function ju(i) {
  var e;
  if (Ke(i))
    return i;
  var t = Wh((e = {}, e[Or] = i, e));
  return Hh({
    get: function() {
      return t[Or];
    },
    set: function(s) {
      return t[Or] = s;
    }
  });
}
function Ke(i) {
  return i instanceof Bh;
}
function ho(i) {
  return Ke(i) ? i.value : i;
}
function Rf(i) {
  if ({}.NODE_ENV !== "production" && !Es(i) && jt("toRefs() expects a reactive object but received a plain one."), !Ii(i))
    return i;
  var e = {};
  for (var t in i)
    e[t] = Yf(i, t);
  return e;
}
function Yf(i, e) {
  e in i || If(i, e, void 0);
  var t = i[e];
  return Ke(t) ? t : Hh({
    get: function() {
      return i[e];
    },
    set: function(s) {
      return i[e] = s;
    }
  });
}
var zh = "__v_skip";
function Ws(i) {
  var e;
  return Boolean(i && si(i, "__ob__") && typeof i.__ob__ == "object" && ((e = i.__ob__) === null || e === void 0 ? void 0 : e[zh]));
}
function Es(i) {
  var e;
  return Boolean(i && si(i, "__ob__") && typeof i.__ob__ == "object" && !(!((e = i.__ob__) === null || e === void 0) && e[zh]));
}
function Fo(i) {
  if (!(!Ii(i) || Ws(i) || Vs(i) || Ke(i) || Af(i) || Lu.has(i))) {
    Lu.set(i, !0);
    for (var e = Object.keys(i), t = 0; t < e.length; t++)
      Xh(i, e[t]);
  }
}
function Xh(i, e, t) {
  if (e !== "__ob__" && !Ws(i[e])) {
    var s, r, n = Object.getOwnPropertyDescriptor(i, e);
    if (n) {
      if (n.configurable === !1)
        return;
      s = n.get, r = n.set, (!s || r) && arguments.length === 2 && (t = i[e]);
    }
    Fo(t), gt(i, e, {
      get: function() {
        var o = s ? s.call(i) : t;
        return e !== Or && Ke(o) ? o.value : o;
      },
      set: function(o) {
        s && !r || (e !== Or && Ke(t) && !Ke(o) ? t.value = o : (r && r.call(i, o), t = o), Fo(o));
      }
    });
  }
}
function Vh(i) {
  var e = Nh(), t;
  if (e.observable)
    t = e.observable(i);
  else {
    var s = Fh(e, {
      data: {
        $$state: i
      }
    });
    t = s._data.$$state;
  }
  return si(t, "__ob__") || Gl(t), t;
}
function Gl(i, e) {
  var t, s;
  if (e === void 0 && (e = /* @__PURE__ */ new Set()), !(e.has(i) || si(i, "__ob__") || !Object.isExtensible(i))) {
    $h(i, "__ob__", Nf(i)), e.add(i);
    try {
      for (var r = Ih(Object.keys(i)), n = r.next(); !n.done; n = r.next()) {
        var a = n.value, o = i[a];
        !(Ii(o) || Vs(o)) || Ws(o) || !Object.isExtensible(o) || Gl(o, e);
      }
    } catch (l) {
      t = { error: l };
    } finally {
      try {
        n && !n.done && (s = r.return) && s.call(r);
      } finally {
        if (t)
          throw t.error;
      }
    }
  }
}
function Nf(i) {
  return i === void 0 && (i = {}), {
    value: i,
    dep: {
      notify: js,
      depend: js,
      addSub: js,
      removeSub: js
    }
  };
}
function $f() {
  return Vh({}).__ob__;
}
function Wh(i) {
  if (!Xn(i))
    return {}.NODE_ENV !== "production" && jt('"reactive()" must be called on an object.'), i;
  if (!(Ii(i) || Vs(i)) || Ws(i) || !Object.isExtensible(i))
    return i;
  var e = Vh(i);
  return Fo(e), e;
}
function Ff(i, e, t) {
  var s = i.__composition_api_state__ = i.__composition_api_state__ || {};
  s[e] = t;
}
function Bf(i, e) {
  return (i.__composition_api_state__ || {})[e];
}
var Li = {
  set: Ff,
  get: Bf
};
function Hf(i, e, t) {
  var s = i.$options.props;
  !(e in i) && !(s && si(s, e)) ? (Ke(t) ? gt(i, e, {
    get: function() {
      return t.value;
    },
    set: function(r) {
      t.value = r;
    }
  }) : gt(i, e, {
    get: function() {
      return Es(t) && t.__ob__.dep.depend(), t;
    },
    set: function(r) {
      t = r;
    }
  }), {}.NODE_ENV !== "production" && i.$nextTick(function() {
    Object.keys(i._data).indexOf(e) === -1 && (Ke(t) ? gt(i._data, e, {
      get: function() {
        return t.value;
      },
      set: function(r) {
        t.value = r;
      }
    }) : gt(i._data, e, {
      get: function() {
        return t;
      },
      set: function(r) {
        t = r;
      }
    }));
  })) : {}.NODE_ENV !== "production" && (s && si(s, e) ? jt('The setup binding property "'.concat(e, '" is already declared as a prop.'), i) : jt('The setup binding property "'.concat(e, '" is already declared.'), i));
}
function zf(i) {
  var e = Li.get(i, "rawBindings") || {};
  if (!(!e || !Object.keys(e).length)) {
    for (var t = i.$refs, s = Li.get(i, "refs") || [], r = 0; r < s.length; r++) {
      var n = s[r], a = e[n];
      !t[n] && a && Ke(a) && (a.value = null);
    }
    for (var o = Object.keys(t), l = [], r = 0; r < o.length; r++) {
      var n = o[r], a = e[n];
      t[n] && a && Ke(a) && (a.value = t[n], l.push(n));
    }
    Li.set(i, "refs", l);
  }
}
function Eu(i) {
  for (var e = [i._vnode]; e.length; ) {
    var t = e.pop();
    if (t && (t.context && zf(t.context), t.children))
      for (var s = 0; s < t.children.length; ++s)
        e.push(t.children[s]);
  }
}
function Iu(i, e) {
  var t, s;
  if (i) {
    var r = Li.get(i, "attrBindings");
    if (!(!r && !e)) {
      if (!r) {
        var n = Wh({});
        r = { ctx: e, data: n }, Li.set(i, "attrBindings", r), gt(e, "attrs", {
          get: function() {
            return r == null ? void 0 : r.data;
          },
          set: function() {
            ({}).NODE_ENV !== "production" && jt("Cannot assign to '$attrs' because it is a read-only property", i);
          }
        });
      }
      var a = i.$attrs, o = function(c) {
        si(r.data, c) || gt(r.data, c, {
          get: function() {
            return i.$attrs[c];
          }
        });
      };
      try {
        for (var l = Ih(Object.keys(a)), u = l.next(); !u.done; u = l.next()) {
          var h = u.value;
          o(h);
        }
      } catch (c) {
        t = { error: c };
      } finally {
        try {
          u && !u.done && (s = l.return) && s.call(l);
        } finally {
          if (t)
            throw t.error;
        }
      }
    }
  }
}
function Ru(i, e) {
  var t = i.$options._parentVnode;
  if (t) {
    for (var s = Li.get(i, "slots") || [], r = jf(t.data.scopedSlots, i.$slots), n = 0; n < s.length; n++) {
      var a = s[n];
      r[a] || delete e[a];
    }
    for (var o = Object.keys(r), n = 0; n < o.length; n++) {
      var a = o[n];
      e[a] || (e[a] = Lf(i, a));
    }
    Li.set(i, "slots", o);
  }
}
function co(i, e, t) {
  var s = Wl();
  Ou(i);
  try {
    return e(i);
  } catch (r) {
    if (t)
      t(r);
    else
      throw r;
  } finally {
    Ou(s);
  }
}
function Xf(i) {
  i.mixin({
    beforeCreate: e,
    mounted: function() {
      Eu(this);
    },
    beforeUpdate: function() {
      Iu(this);
    },
    updated: function() {
      Eu(this);
    }
  });
  function e() {
    var a = this, o = a.$options, l = o.setup, u = o.render;
    if (u && (o.render = function() {
      for (var c = this, d = [], f = 0; f < arguments.length; f++)
        d[f] = arguments[f];
      return co(zn(a), function() {
        return u.apply(c, d);
      });
    }), !!l) {
      if (!ls(l)) {
        ({}).NODE_ENV !== "production" && jt('The "setup" option should be a function that returns a object in component definitions.', a);
        return;
      }
      var h = o.data;
      o.data = function() {
        return t(a, a.$props), ls(h) ? h.call(a, a) : h || {};
      };
    }
  }
  function t(a, o) {
    o === void 0 && (o = {});
    var l = a.$options.setup, u = n(a), h = zn(a);
    h.setupContext = u, $h(o, "__ob__", $f()), Ru(a, u.slots);
    var c;
    if (co(h, function() {
      c = l(o, u);
    }), !!c) {
      if (ls(c)) {
        var d = c;
        a.$options.render = function() {
          return Ru(a, u.slots), co(h, function() {
            return d();
          });
        };
        return;
      } else if (Xn(c)) {
        Es(c) && (c = Rf(c)), Li.set(a, "rawBindings", c);
        var f = c;
        Object.keys(f).forEach(function(g) {
          var p = f[g];
          if (!Ke(p))
            if (Es(p))
              Vs(p) && (p = ju(p));
            else if (ls(p)) {
              var m = p;
              p = p.bind(a), Object.keys(m).forEach(function(_) {
                p[_] = m[_];
              });
            } else
              Xn(p) ? r(p) && s(p) : p = ju(p);
          Hf(a, g, p);
        });
        return;
      }
      ({}).NODE_ENV !== "production" && Ul(!1, '"setup" must return a "Object" or a "Function", got "'.concat(Object.prototype.toString.call(c).slice(8, -1), '"'));
    }
  }
  function s(a, o) {
    if (o === void 0 && (o = /* @__PURE__ */ new Set()), !o.has(a) && !(!Ii(a) || Ke(a) || Es(a) || Ws(a))) {
      var l = Na(), u = l.util.defineReactive;
      Object.keys(a).forEach(function(h) {
        var c = a[h];
        u(a, h, c), c && (o.add(c), s(c, o));
      });
    }
  }
  function r(a, o) {
    return o === void 0 && (o = /* @__PURE__ */ new Map()), o.has(a) ? o.get(a) : (o.set(a, !1), Vs(a) && Es(a) ? (o.set(a, !0), !0) : !Ii(a) || Ws(a) || Ke(a) ? !1 : Object.keys(a).some(function(l) {
      return r(a[l], o);
    }));
  }
  function n(a) {
    var o = { slots: {} }, l = [
      "root",
      "parent",
      "refs",
      "listeners",
      "isServer",
      "ssrContext"
    ], u = ["emit"];
    return l.forEach(function(h) {
      var c = "$".concat(h);
      gt(o, h, {
        get: function() {
          return a[c];
        },
        set: function() {
          ({}).NODE_ENV !== "production" && jt("Cannot assign to '".concat(h, "' because it is a read-only property"), a);
        }
      });
    }), Iu(a, o), u.forEach(function(h) {
      var c = "$".concat(h);
      gt(o, h, {
        get: function() {
          return function() {
            for (var d = [], f = 0; f < arguments.length; f++)
              d[f] = arguments[f];
            var g = a[c];
            g.apply(a, d);
          };
        }
      });
    }), {}.NODE_ENV === "test" && (o._vm = a), o;
  }
}
function Uh(i, e) {
  if (!i)
    return e;
  if (!e)
    return i;
  for (var t, s, r, n = Tf ? Reflect.ownKeys(i) : Object.keys(i), a = 0; a < n.length; a++)
    t = n[a], t !== "__ob__" && (s = e[t], r = i[t], si(e, t) ? s !== r && Ii(s) && !Ke(s) && Ii(r) && !Ke(r) && Uh(r, s) : e[t] = r);
  return e;
}
function Vf(i) {
  if (wf(i)) {
    ({}).NODE_ENV !== "production" && jt("[vue-composition-api] already installed. Vue.use(VueCompositionAPI) should be called only once.");
    return;
  }
  ({}).NODE_ENV !== "production" && (i.version ? (i.version[0] !== "2" || i.version[1] !== ".") && jt("[vue-composition-api] only works with Vue 2, v".concat(i.version, " found.")) : jt("[vue-composition-api] no Vue version found")), i.config.optionMergeStrategies.setup = function(e, t) {
    return function(r, n) {
      return Uh(ls(e) ? e(r, n) || {} : void 0, ls(t) ? t(r, n) || {} : void 0);
    };
  }, Sf(i), Xf(i);
}
var Wf = {
  install: function(i) {
    return Vf(i);
  }
};
typeof window < "u" && window.Vue && window.Vue.use(Wf);
const Uf = {
  props: {
    styleProps: {
      type: [String, Object]
    }
  },
  data() {
    return {
      active: !1
    };
  },
  methods: {
    /**
     * Gets called when the user clicks on the accordion
     */
    openPannel() {
      this.active = !this.active;
      let i = this.$refs.panel;
      i.style.maxHeight ? i.style.maxHeight = "" : i.style.maxHeight = i.scrollHeight + "px";
    }
  }
}, Gf = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iOSIgaGVpZ2h0PSI1IiB2aWV3Qm94PSIwIDAgOSA1IiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPg0KICAgIDxwYXRoIGQ9Ik00LjQyODgzIDMuNTQ2MzVMMS4wODAwOCAwLjM1NDU2OUMwLjk2MTE4MiAwLjI0MTY2MyAwLjgwMDA1OCAwLjE3ODM2NCAwLjYzMjE1NCAwLjE3ODU5OUMwLjQ2NDI1IDAuMTc4ODMzIDAuMzAzMzIxIDAuMjQyNTgxIDAuMTg0NzY5IDAuMzU1ODE5QzAuMDY2MjE3NyAwLjQ2OTA1NyAtMC4wMDAyNDU2NTIgMC42MjI1MDkgNC45Njg4NmUtMDcgMC43ODI0MTdDMC4wMDAyNDY2NDUgMC45NDIzMjYgMC4wNjcxODIxIDEuMDk1NTkgMC4xODYwODIgMS4yMDg1TDMuOTc4ODMgNC44MjQ1N0M0LjA5NCA0LjkzMzgyIDQuMjQ4OTUgNC45OTY2MSA0LjQxMTQ2IDQuOTk5ODdDNC41NzM5OCA1LjAwMzEzIDQuNzMxNTYgNC45NDY2MSA0Ljg1MTQ2IDQuODQyMDdMOC42NzM4MyAxLjIxMUM4Ljc5MjczIDEuMDk4MDkgOC44NTk2NyAwLjk0NDgyNSA4Ljg1OTkxIDAuNzg0OTE3QzguODYwMTYgMC42MjUwMDkgOC43OTM3IDAuNDcxNTU3IDguNjc1MTQgMC4zNTgzMTlDOC41NTY1OSAwLjI0NTA4MSA4LjM5NTY2IDAuMTgxMzMzIDguMjI3NzYgMC4xODEwOThDOC4wNTk4NiAwLjE4MDg2NCA3Ljg5ODczIDAuMjQ0MTYzIDcuNzc5ODMgMC4zNTcwNjlMNC40Mjg4MyAzLjU0NjM1WiIgZmlsbD0iIzM0OTFGRiIvPg0KICAgIDwvc3ZnPg0KICAgIA==";
var Zf = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    class: i.$style.accordion_main,
    style: i.styleProps
  }, [t("button", {
    class: i.$style.heading,
    on: {
      click: i.openPannel
    }
  }, [t("span", [i._t("header")], 2), t("span", {
    class: [i.active ? i.$style.icon_rotate : i.$style.icon, i.$style.accordion_icon]
  }, [t("img", {
    attrs: {
      src: Gf,
      alt: "embd-accordian-icon"
    }
  })])]), t("div", {
    ref: "panel",
    class: i.$style.panel
  }, [i._t("body")], 2)]);
}, Kf = [];
const Qf = "_accordion_main_1kuar_1", Jf = "_heading_1kuar_6", qf = "_accordion_icon_1kuar_28", ep = "_icon_rotate_1kuar_31", tp = "_icon_1kuar_31", ip = "_panel_1kuar_37", sp = {
  accordion_main: Qf,
  heading: Jf,
  accordion_icon: qf,
  icon_rotate: ep,
  icon: tp,
  panel: ip
};
function te(i, e, t, s, r, n, a, o) {
  var l = typeof i == "function" ? i.options : i;
  e && (l.render = e, l.staticRenderFns = t, l._compiled = !0), s && (l.functional = !0), n && (l._scopeId = "data-v-" + n);
  var u;
  if (a ? (u = function(d) {
    d = d || // cached call
    this.$vnode && this.$vnode.ssrContext || // stateful
    this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext, !d && typeof __VUE_SSR_CONTEXT__ < "u" && (d = __VUE_SSR_CONTEXT__), r && r.call(this, d), d && d._registeredComponents && d._registeredComponents.add(a);
  }, l._ssrRegister = u) : r && (u = o ? function() {
    r.call(
      this,
      (l.functional ? this.parent : this).$root.$options.shadowRoot
    );
  } : r), u)
    if (l.functional) {
      l._injectStyles = u;
      var h = l.render;
      l.render = function(f, g) {
        return u.call(g), h(f, g);
      };
    } else {
      var c = l.beforeCreate;
      l.beforeCreate = c ? [].concat(c, u) : [u];
    }
  return {
    exports: i,
    options: l
  };
}
const Bo = {};
Bo.$style = sp;
var rp = /* @__PURE__ */ te(
  Uf,
  Zf,
  Kf,
  !1,
  np,
  null,
  null,
  null
);
function np(i) {
  for (let e in Bo)
    this[e] = Bo[e];
}
const GO = /* @__PURE__ */ function() {
  return rp.exports;
}(), ap = {
  props: {
    emit: Function,
    active: Boolean,
    disabled: Boolean,
    iconType: {
      type: String,
      default: ""
    },
    size: {
      type: String,
      default: ""
    },
    imgSrc: {
      type: String
    },
    label: {
      type: String
    }
  },
  computed: {
    intputTextChange() {
      return this.iconType === "change-state" ? "Change State" : this.iconType === "disable" ? "Disable" : this.iconType === "note" ? "Note" : this.iconType === "edit" ? "Edit" : this.iconType === "enable" ? "Enable" : this.iconType === "export" ? "Export" : this.iconType === "view" ? "View" : this.iconType === "reset" ? "Reset" : this.iconType === "register" ? "Register" : this.iconType === "view-edit-history" ? "View Edit History" : this.iconType === "shift-config" ? "Shift Config" : this.iconType === "role-user-config" ? "Role-User Config" : this.iconType === "remove-from-product" ? "Remove from Product" : this.iconType === "role-permission-config" ? "Set Permission" : this.label;
    },
    buttonClassComputed() {
      return `default default-color ${this.iconType} ${this.size}`;
    }
  },
  methods: {
    /**
     * Handle the emit
     * @return void
     */
    executor() {
      this.emit && this.emit();
    }
  }
};
var op = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    class: i.buttonClassComputed,
    attrs: {
      active: i.active,
      disabled: i.disabled
    },
    on: {
      click: i.executor
    }
  }, [i.iconType === "custom" ? t("span", [i._v(i._s(i.label))]) : t("span", [i._v(i._s(i.intputTextChange))]), i.iconType === "custom" ? t("img", {
    staticClass: "right-side-image",
    attrs: {
      src: i.imgSrc,
      alt: "embd-actionbar-custom-icon"
    }
  }) : t("img", {
    class: i.iconType,
    attrs: {
      src: "#",
      alt: "embd-button-actionbar-icon"
    }
  })]);
}, lp = [];
const Yu = {};
var up = /* @__PURE__ */ te(
  ap,
  op,
  lp,
  !1,
  hp,
  "3fd69a20",
  null,
  null
);
function hp(i) {
  for (let e in Yu)
    this[e] = Yu[e];
}
const ZO = /* @__PURE__ */ function() {
  return up.exports;
}(), cp = "_center_align_1pk4p_4", dp = "_default_btn_1pk4p_8", fp = "_radio_button_1pk4p_23", pp = "_radio_button_inner_1pk4p_23", gp = "_small_1pk4p_69", mp = "_check_list_1pk4p_81", _p = "_check_list_inner_1pk4p_84", bp = "_checkbox_1pk4p_119", yp = "_icon_size_1pk4p_139", vp = "_label_styles_1pk4p_151", xp = "_large_1pk4p_157", gn = {
  center_align: cp,
  default_btn: dp,
  radio_button: fp,
  radio_button_inner: pp,
  default: "_default_1pk4p_8",
  small: gp,
  check_list: mp,
  check_list_inner: _p,
  checkbox: bp,
  icon_size: yp,
  label_styles: vp,
  large: xp
}, wp = {
  name: "checkbox-button",
  props: {
    clickHandler: Function,
    labelText: {
      type: String,
      default: ""
    },
    size: {
      type: String
    },
    active: {
      type: Boolean,
      defualt: !0
    },
    disabled: Boolean,
    buttonType: {
      type: String,
      default: "check_list"
    }
  },
  watch: {
    active(i) {
      this.check = i;
    }
  },
  data() {
    return {
      hover: !1,
      check: !0
    };
  },
  computed: {
    buttonClassComputed() {
      let i = `${gn.default_btn} ${gn[this.buttonType]} `;
      return this.size && (i += `${gn[this.size]} `), i;
    },
    innerShapeStyleComputed() {
      return gn[this.buttonType + "_inner"];
    }
  },
  methods: {
    truncateText(i, e) {
      return i.length > e ? i.substring(0, e) + "..." : i;
    },
    executor() {
      this.clickHandler && (this.check = !this.check, this.clickHandler(this.check));
    }
  },
  mounted() {
    this.check = this.active;
  }
};
var Sp = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    class: i.$style.center_align
  }, [t("div", {
    class: i.buttonClassComputed,
    attrs: {
      active: i.check,
      disabled: i.disabled
    },
    on: {
      click: i.executor
    }
  }, [i.buttonType === "checkbox" && (i.hover || i.active) ? t("img", {
    class: i.$style.icon_size,
    attrs: {
      src: "#",
      alt: ""
    }
  }) : t("div", {
    class: i.innerShapeStyleComputed
  })]), i.labelText != "" ? t("label", [t("span", {
    class: [i.size ? i.$style[i.size] : "", i.$style.label_styles]
  }, [i._v(" " + i._s(i.truncateText(i.labelText, 40)) + " ")])]) : i._e()]);
}, Dp = [];
const Pp = "_center_align_1pk4p_4", Tp = "_default_btn_1pk4p_8", kp = "_radio_button_1pk4p_23", Cp = "_radio_button_inner_1pk4p_23", Mp = "_small_1pk4p_69", Op = "_check_list_1pk4p_81", Ap = "_check_list_inner_1pk4p_84", Lp = "_checkbox_1pk4p_119", jp = "_icon_size_1pk4p_139", Ep = "_label_styles_1pk4p_151", Ip = "_large_1pk4p_157", Rp = {
  center_align: Pp,
  default_btn: Tp,
  radio_button: kp,
  radio_button_inner: Cp,
  default: "_default_1pk4p_8",
  small: Mp,
  check_list: Op,
  check_list_inner: Ap,
  checkbox: Lp,
  icon_size: jp,
  label_styles: Ep,
  large: Ip
}, Ho = {};
Ho.$style = Rp;
var Yp = /* @__PURE__ */ te(
  wp,
  Sp,
  Dp,
  !1,
  Np,
  null,
  null,
  null
);
function Np(i) {
  for (let e in Ho)
    this[e] = Ho[e];
}
const Gh = /* @__PURE__ */ function() {
  return Yp.exports;
}(), $p = {
  name: "alert-box",
  props: {
    checkBoxHandler: Function,
    showAlertBox: {
      type: Boolean,
      default: !0
    },
    title: String,
    checkbox: {
      type: Boolean,
      default: !1
    },
    checkboxLabel: {
      type: String,
      default: "Don't show this warning again."
    },
    showCloseButton: {
      type: Boolean,
      default: !1
    },
    styleProp: String,
    titleIconUrl: {
      type: String,
      default: "warning"
    },
    onClose: Function
  },
  components: {
    CheckboxButton: Gh
  },
  computed: {
    computeTitleIcon() {
      return `title-icon title-icon-${this.titleIconUrl}`;
    }
  },
  data() {
    return {
      visibleSuccess: !1,
      active: !1
    };
  },
  methods: {
    handleClose() {
      this.$nextTick(() => {
        var i;
        (i = this.onClose) == null || i.call(this);
      });
    },
    handleCheckboxClick() {
      this.$nextTick(() => {
        var i;
        this.active = !this.active, (i = this.checkBoxHandler) == null || i.call(this, this.active);
      });
    }
  }
};
var Fp = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    class: i.$style["emdn-alert-box-modal-root"],
    style: i.showAlertBox ? "" : {
      display: "none"
    },
    attrs: {
      bodystyle: "[object Object]"
    }
  }, [t("div", {
    class: i.$style["alert-box-modal-mask"],
    style: i.showAlertBox ? "" : {
      display: "none"
    },
    on: {
      click: function(s) {
        return s.target !== s.currentTarget ? null : i.handleClose.apply(null, arguments);
      }
    }
  }, [t("div", {
    class: [i.$style["alert-box-modal-wrap"], i.$style["alert-box-modal-centered"]],
    style: i.showAlertBox ? "" : {
      display: "none"
    },
    attrs: {
      tabindex: "-1",
      role: "dialog"
    }
  }, [t("div", {
    class: i.$style["alert-box-modal"],
    style: i.styleProp,
    attrs: {
      role: "document"
    }
  }, [t("div", {
    staticStyle: {
      width: "0px",
      height: "0px",
      overflow: "hidden"
    },
    attrs: {
      tabindex: "0",
      "aria-hidden": "true"
    }
  }), t("div", {
    class: i.$style["custom-modal-body-user"]
  }, [t("div", {
    class: i.$style["close-btn"],
    style: i.showCloseButton ? "" : {
      visibility: "hidden"
    }
  }, [t("div", {
    class: [i.$style["t-close-button"], i.$style["close-button"]],
    attrs: {
      "aria-hidden": "true"
    },
    on: {
      click: function(s) {
        return s.stopPropagation(), i.handleClose.apply(null, arguments);
      }
    }
  }, [t("span", {
    class: i.$style["t-icon-close"]
  })])]), t("div", {
    class: i.$style["modal-body"]
  }, [t("div", {
    class: i.$style["content-div"]
  }, [t("div", {
    class: i.$style["main-title"]
  }, [t("img", {
    class: [i.$style["title-icon"], i.$style[`title-icon-${i.titleIconUrl}`]],
    attrs: {
      src: i.titleIconUrl
    }
  }), t("span", {
    class: i.$style.title
  }, [i._v(i._s(i.title))])]), t("div", {
    class: i.$style["message-and-btn"]
  }, [t("div", [t("span", {
    class: i.$style["message-style"]
  }, [i._t("messagebody")], 2), i.checkbox ? t("div", {
    class: i.$style["check-box-styles"]
  }, [t("checkbox-button", {
    attrs: {
      "button-type": "check_list",
      "label-text": i.checkboxLabel,
      size: "small",
      "click-handler": i.handleCheckboxClick,
      active: i.active
    }
  })], 1) : i._e()])])]), t("div", {
    class: i.$style.footer
  }, [t("div", {
    class: i.$style["btn-styles"]
  }, [t("div", {
    class: i.$style["btn-ind-style"]
  }, [i._t("successbutton")], 2), t("div", {
    class: i.$style["btn-ind-style"]
  }, [i._t("rejectbutton")], 2)])])])])])])])]);
}, Bp = [];
const Hp = "_title_141ac_69", zp = "_footer_141ac_107", Xp = {
  "emdn-alert-box-modal-root": "_emdn-alert-box-modal-root_141ac_1",
  "alert-box-modal-mask": "_alert-box-modal-mask_141ac_4",
  "alert-box-modal-wrap": "_alert-box-modal-wrap_141ac_17",
  "alert-box-modal-centered": "_alert-box-modal-centered_141ac_20",
  "alert-box-modal": "_alert-box-modal_141ac_4",
  "custom-modal-body-user": "_custom-modal-body-user_141ac_26",
  "close-btn": "_close-btn_141ac_33",
  "t-close-button": "_t-close-button_141ac_39",
  "t-icon-close": "_t-icon-close_141ac_46",
  "modal-body": "_modal-body_141ac_53",
  "content-div": "_content-div_141ac_61",
  "main-title": "_main-title_141ac_64",
  "title-icon": "_title-icon_141ac_69",
  "title-icon-warning": "_title-icon-warning_141ac_69",
  "title-icon-info": "_title-icon-info_141ac_75",
  title: Hp,
  "message-and-btn": "_message-and-btn_141ac_90",
  "message-style": "_message-style_141ac_96",
  "check-box-styles": "_check-box-styles_141ac_104",
  footer: zp,
  "btn-styles": "_btn-styles_141ac_110",
  "btn-ind-style": "_btn-ind-style_141ac_114"
}, zo = {};
zo.$style = Xp;
var Vp = /* @__PURE__ */ te(
  $p,
  Fp,
  Bp,
  !1,
  Wp,
  null,
  null,
  null
);
function Wp(i) {
  for (let e in zo)
    this[e] = zo[e];
}
const KO = /* @__PURE__ */ function() {
  return Vp.exports;
}(), Up = "_center_jodbo_82", Gp = "_small_jodbo_104", Zp = "_text_jodbo_108", Kp = "_blue_jodbo_119", Qp = "_green_jodbo_150", Jp = "_red_jodbo_181", qp = "_white_jodbo_211", eg = "_dropdown_jodbo_229", tg = "_right_side_image_jodbo_229", ig = "_upload_jodbo_281", sg = "_hyperlink_jodbo_291", rg = "_top_right_side_image_jodbo_298", fr = {
  default: "_default_jodbo_66",
  center: Up,
  small: Gp,
  text: Zp,
  blue: Kp,
  "blue-border-show": "_blue-border-show_jodbo_1",
  "blue-fill": "_blue-fill_jodbo_136",
  "blue-fill-border-show": "_blue-fill-border-show_jodbo_1",
  green: Qp,
  "green-border-show": "_green-border-show_jodbo_1",
  "green-fill": "_green-fill_jodbo_166",
  "green-fill-border-show": "_green-fill-border-show_jodbo_1",
  red: Jp,
  "red-border-show": "_red-border-show_jodbo_1",
  "red-fill": "_red-fill_jodbo_196",
  "red-fill-border-show": "_red-fill-border-show_jodbo_1",
  white: qp,
  "white-border-show": "_white-border-show_jodbo_1",
  dropdown: eg,
  right_side_image: tg,
  "date-picker": "_date-picker_jodbo_260",
  export: "_export_jodbo_274",
  upload: ig,
  hyperlink: sg,
  top_right_side_image: rg
}, ng = {
  props: {
    styleProps: {
      type: String
    },
    clickHandler: Function,
    active: Boolean,
    disabled: Boolean,
    colorType: String,
    type: {
      type: String,
      default: "button"
    },
    /**
     * @deprecated Use variant instead.
     */
    buttonType: {
      type: String
    },
    variant: {
      type: String
    },
    size: {
      type: String
    }
  },
  computed: {
    colorTypeComputed() {
      const i = this.variant ?? this.buttonType;
      return i === "text" || i === "text dropdown" || i === "text hyperlink" ? null : i === "export" ? "blue-fill" : this.colorType ? this.colorType : "blue";
    },
    textPositionComputed() {
      return this.imagePosition ? null : "center";
    },
    // TODO; has bugs to append undefined class name
    buttonClassComputed() {
      let i = `${fr.default} `;
      this.size && (i += `${fr[this.size]} `), this.colorTypeComputed && (i += `${fr[this.colorTypeComputed]} `), this.textPositionComputed && (i += `${fr[this.textPositionComputed]} `);
      const e = this.variant ?? this.buttonType;
      return e == null || e.split(" ").forEach((t) => {
        i += `${fr[t]} `;
      }), i;
    },
    imagePosition() {
      const i = this.variant ?? this.buttonType;
      return i === "text" || !i ? null : i === "text hyperlink" ? "top-right" : "right";
    },
    showIcon() {
      const i = this.variant ?? this.buttonType;
      return i == "dropdown" && this.colorType != "red" && this.colorType != "green" || i == "date-picker" && this.colorType != "red" && this.colorType != "green" && this.colorType != "white" ? !0 : i != "dropdown" && i != "date-picker";
    }
  },
  methods: {
    executor() {
      this.clickHandler && this.clickHandler();
    }
  }
};
var ag = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("button", {
    class: i.buttonClassComputed,
    style: i.styleProps,
    attrs: {
      type: i.type,
      active: i.active,
      disabled: i.disabled
    },
    on: {
      click: function(s) {
        return s.stopPropagation(), i.executor.apply(null, arguments);
      }
    }
  }, [i.imagePosition === "left" ? t("img", {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: i.showIcon,
      expression: "showIcon"
    }],
    class: i.$style.left_side_image,
    attrs: {
      alt: "button-left-side-image"
    }
  }) : i._e(), i._t("default"), i.imagePosition === "right" ? t("img", {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: i.showIcon,
      expression: "showIcon"
    }],
    class: i.$style.right_side_image,
    attrs: {
      alt: "button-right-side-image"
    }
  }) : i._e(), i.imagePosition === "top-right" ? t("div", [t("img", {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: i.showIcon,
      expression: "showIcon"
    }],
    class: i.$style.top_right_side_image,
    attrs: {
      alt: "button-top-right-side-image"
    }
  })]) : i._e()], 2);
}, og = [];
const lg = "_center_jodbo_82", ug = "_small_jodbo_104", hg = "_text_jodbo_108", cg = "_blue_jodbo_119", dg = "_green_jodbo_150", fg = "_red_jodbo_181", pg = "_white_jodbo_211", gg = "_dropdown_jodbo_229", mg = "_right_side_image_jodbo_229", _g = "_upload_jodbo_281", bg = "_hyperlink_jodbo_291", yg = "_top_right_side_image_jodbo_298", vg = {
  default: "_default_jodbo_66",
  center: lg,
  small: ug,
  text: hg,
  blue: cg,
  "blue-border-show": "_blue-border-show_jodbo_1",
  "blue-fill": "_blue-fill_jodbo_136",
  "blue-fill-border-show": "_blue-fill-border-show_jodbo_1",
  green: dg,
  "green-border-show": "_green-border-show_jodbo_1",
  "green-fill": "_green-fill_jodbo_166",
  "green-fill-border-show": "_green-fill-border-show_jodbo_1",
  red: fg,
  "red-border-show": "_red-border-show_jodbo_1",
  "red-fill": "_red-fill_jodbo_196",
  "red-fill-border-show": "_red-fill-border-show_jodbo_1",
  white: pg,
  "white-border-show": "_white-border-show_jodbo_1",
  dropdown: gg,
  right_side_image: mg,
  "date-picker": "_date-picker_jodbo_260",
  export: "_export_jodbo_274",
  upload: _g,
  hyperlink: bg,
  top_right_side_image: yg
}, Xo = {};
Xo.$style = vg;
var xg = /* @__PURE__ */ te(
  ng,
  ag,
  og,
  !1,
  wg,
  "61864e99",
  null,
  null
);
function wg(i) {
  for (let e in Xo)
    this[e] = Xo[e];
}
const $a = /* @__PURE__ */ function() {
  return xg.exports;
}();
//! moment.js
//! version : 2.29.4
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com
var Zh;
function P() {
  return Zh.apply(null, arguments);
}
function Sg(i) {
  Zh = i;
}
function Zt(i) {
  return i instanceof Array || Object.prototype.toString.call(i) === "[object Array]";
}
function ds(i) {
  return i != null && Object.prototype.toString.call(i) === "[object Object]";
}
function be(i, e) {
  return Object.prototype.hasOwnProperty.call(i, e);
}
function Zl(i) {
  if (Object.getOwnPropertyNames)
    return Object.getOwnPropertyNames(i).length === 0;
  var e;
  for (e in i)
    if (be(i, e))
      return !1;
  return !0;
}
function yt(i) {
  return i === void 0;
}
function mi(i) {
  return typeof i == "number" || Object.prototype.toString.call(i) === "[object Number]";
}
function rn(i) {
  return i instanceof Date || Object.prototype.toString.call(i) === "[object Date]";
}
function Kh(i, e) {
  var t = [], s, r = i.length;
  for (s = 0; s < r; ++s)
    t.push(e(i[s], s));
  return t;
}
function ki(i, e) {
  for (var t in e)
    be(e, t) && (i[t] = e[t]);
  return be(e, "toString") && (i.toString = e.toString), be(e, "valueOf") && (i.valueOf = e.valueOf), i;
}
function oi(i, e, t, s) {
  return vc(i, e, t, s, !0).utc();
}
function Dg() {
  return {
    empty: !1,
    unusedTokens: [],
    unusedInput: [],
    overflow: -2,
    charsLeftOver: 0,
    nullInput: !1,
    invalidEra: null,
    invalidMonth: null,
    invalidFormat: !1,
    userInvalidated: !1,
    iso: !1,
    parsedDateParts: [],
    era: null,
    meridiem: null,
    rfc2822: !1,
    weekdayMismatch: !1
  };
}
function le(i) {
  return i._pf == null && (i._pf = Dg()), i._pf;
}
var Vo;
Array.prototype.some ? Vo = Array.prototype.some : Vo = function(i) {
  var e = Object(this), t = e.length >>> 0, s;
  for (s = 0; s < t; s++)
    if (s in e && i.call(this, e[s], s, e))
      return !0;
  return !1;
};
function Kl(i) {
  if (i._isValid == null) {
    var e = le(i), t = Vo.call(e.parsedDateParts, function(r) {
      return r != null;
    }), s = !isNaN(i._d.getTime()) && e.overflow < 0 && !e.empty && !e.invalidEra && !e.invalidMonth && !e.invalidWeekday && !e.weekdayMismatch && !e.nullInput && !e.invalidFormat && !e.userInvalidated && (!e.meridiem || e.meridiem && t);
    if (i._strict && (s = s && e.charsLeftOver === 0 && e.unusedTokens.length === 0 && e.bigHour === void 0), Object.isFrozen == null || !Object.isFrozen(i))
      i._isValid = s;
    else
      return s;
  }
  return i._isValid;
}
function Fa(i) {
  var e = oi(NaN);
  return i != null ? ki(le(e), i) : le(e).userInvalidated = !0, e;
}
var Nu = P.momentProperties = [], fo = !1;
function Ql(i, e) {
  var t, s, r, n = Nu.length;
  if (yt(e._isAMomentObject) || (i._isAMomentObject = e._isAMomentObject), yt(e._i) || (i._i = e._i), yt(e._f) || (i._f = e._f), yt(e._l) || (i._l = e._l), yt(e._strict) || (i._strict = e._strict), yt(e._tzm) || (i._tzm = e._tzm), yt(e._isUTC) || (i._isUTC = e._isUTC), yt(e._offset) || (i._offset = e._offset), yt(e._pf) || (i._pf = le(e)), yt(e._locale) || (i._locale = e._locale), n > 0)
    for (t = 0; t < n; t++)
      s = Nu[t], r = e[s], yt(r) || (i[s] = r);
  return i;
}
function nn(i) {
  Ql(this, i), this._d = new Date(i._d != null ? i._d.getTime() : NaN), this.isValid() || (this._d = new Date(NaN)), fo === !1 && (fo = !0, P.updateOffset(this), fo = !1);
}
function Kt(i) {
  return i instanceof nn || i != null && i._isAMomentObject != null;
}
function Qh(i) {
  P.suppressDeprecationWarnings === !1 && typeof console < "u" && console.warn && console.warn("Deprecation warning: " + i);
}
function Bt(i, e) {
  var t = !0;
  return ki(function() {
    if (P.deprecationHandler != null && P.deprecationHandler(null, i), t) {
      var s = [], r, n, a, o = arguments.length;
      for (n = 0; n < o; n++) {
        if (r = "", typeof arguments[n] == "object") {
          r += `
[` + n + "] ";
          for (a in arguments[0])
            be(arguments[0], a) && (r += a + ": " + arguments[0][a] + ", ");
          r = r.slice(0, -2);
        } else
          r = arguments[n];
        s.push(r);
      }
      Qh(
        i + `
Arguments: ` + Array.prototype.slice.call(s).join("") + `
` + new Error().stack
      ), t = !1;
    }
    return e.apply(this, arguments);
  }, e);
}
var $u = {};
function Jh(i, e) {
  P.deprecationHandler != null && P.deprecationHandler(i, e), $u[i] || (Qh(e), $u[i] = !0);
}
P.suppressDeprecationWarnings = !1;
P.deprecationHandler = null;
function li(i) {
  return typeof Function < "u" && i instanceof Function || Object.prototype.toString.call(i) === "[object Function]";
}
function Pg(i) {
  var e, t;
  for (t in i)
    be(i, t) && (e = i[t], li(e) ? this[t] = e : this["_" + t] = e);
  this._config = i, this._dayOfMonthOrdinalParseLenient = new RegExp(
    (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source
  );
}
function Wo(i, e) {
  var t = ki({}, i), s;
  for (s in e)
    be(e, s) && (ds(i[s]) && ds(e[s]) ? (t[s] = {}, ki(t[s], i[s]), ki(t[s], e[s])) : e[s] != null ? t[s] = e[s] : delete t[s]);
  for (s in i)
    be(i, s) && !be(e, s) && ds(i[s]) && (t[s] = ki({}, t[s]));
  return t;
}
function Jl(i) {
  i != null && this.set(i);
}
var Uo;
Object.keys ? Uo = Object.keys : Uo = function(i) {
  var e, t = [];
  for (e in i)
    be(i, e) && t.push(e);
  return t;
};
var Tg = {
  sameDay: "[Today at] LT",
  nextDay: "[Tomorrow at] LT",
  nextWeek: "dddd [at] LT",
  lastDay: "[Yesterday at] LT",
  lastWeek: "[Last] dddd [at] LT",
  sameElse: "L"
};
function kg(i, e, t) {
  var s = this._calendar[i] || this._calendar.sameElse;
  return li(s) ? s.call(e, t) : s;
}
function ri(i, e, t) {
  var s = "" + Math.abs(i), r = e - s.length, n = i >= 0;
  return (n ? t ? "+" : "" : "-") + Math.pow(10, Math.max(0, r)).toString().substr(1) + s;
}
var ql = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, mn = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, po = {}, Fs = {};
function Q(i, e, t, s) {
  var r = s;
  typeof s == "string" && (r = function() {
    return this[s]();
  }), i && (Fs[i] = r), e && (Fs[e[0]] = function() {
    return ri(r.apply(this, arguments), e[1], e[2]);
  }), t && (Fs[t] = function() {
    return this.localeData().ordinal(
      r.apply(this, arguments),
      i
    );
  });
}
function Cg(i) {
  return i.match(/\[[\s\S]/) ? i.replace(/^\[|\]$/g, "") : i.replace(/\\/g, "");
}
function Mg(i) {
  var e = i.match(ql), t, s;
  for (t = 0, s = e.length; t < s; t++)
    Fs[e[t]] ? e[t] = Fs[e[t]] : e[t] = Cg(e[t]);
  return function(r) {
    var n = "", a;
    for (a = 0; a < s; a++)
      n += li(e[a]) ? e[a].call(r, i) : e[a];
    return n;
  };
}
function An(i, e) {
  return i.isValid() ? (e = qh(e, i.localeData()), po[e] = po[e] || Mg(e), po[e](i)) : i.localeData().invalidDate();
}
function qh(i, e) {
  var t = 5;
  function s(r) {
    return e.longDateFormat(r) || r;
  }
  for (mn.lastIndex = 0; t >= 0 && mn.test(i); )
    i = i.replace(
      mn,
      s
    ), mn.lastIndex = 0, t -= 1;
  return i;
}
var Og = {
  LTS: "h:mm:ss A",
  LT: "h:mm A",
  L: "MM/DD/YYYY",
  LL: "MMMM D, YYYY",
  LLL: "MMMM D, YYYY h:mm A",
  LLLL: "dddd, MMMM D, YYYY h:mm A"
};
function Ag(i) {
  var e = this._longDateFormat[i], t = this._longDateFormat[i.toUpperCase()];
  return e || !t ? e : (this._longDateFormat[i] = t.match(ql).map(function(s) {
    return s === "MMMM" || s === "MM" || s === "DD" || s === "dddd" ? s.slice(1) : s;
  }).join(""), this._longDateFormat[i]);
}
var Lg = "Invalid date";
function jg() {
  return this._invalidDate;
}
var Eg = "%d", Ig = /\d{1,2}/;
function Rg(i) {
  return this._ordinal.replace("%d", i);
}
var Yg = {
  future: "in %s",
  past: "%s ago",
  s: "a few seconds",
  ss: "%d seconds",
  m: "a minute",
  mm: "%d minutes",
  h: "an hour",
  hh: "%d hours",
  d: "a day",
  dd: "%d days",
  w: "a week",
  ww: "%d weeks",
  M: "a month",
  MM: "%d months",
  y: "a year",
  yy: "%d years"
};
function Ng(i, e, t, s) {
  var r = this._relativeTime[t];
  return li(r) ? r(i, e, t, s) : r.replace(/%d/i, i);
}
function $g(i, e) {
  var t = this._relativeTime[i > 0 ? "future" : "past"];
  return li(t) ? t(e) : t.replace(/%s/i, e);
}
var Ar = {};
function ct(i, e) {
  var t = i.toLowerCase();
  Ar[t] = Ar[t + "s"] = Ar[e] = i;
}
function Ht(i) {
  return typeof i == "string" ? Ar[i] || Ar[i.toLowerCase()] : void 0;
}
function eu(i) {
  var e = {}, t, s;
  for (s in i)
    be(i, s) && (t = Ht(s), t && (e[t] = i[s]));
  return e;
}
var ec = {};
function dt(i, e) {
  ec[i] = e;
}
function Fg(i) {
  var e = [], t;
  for (t in i)
    be(i, t) && e.push({ unit: t, priority: ec[t] });
  return e.sort(function(s, r) {
    return s.priority - r.priority;
  }), e;
}
function Ba(i) {
  return i % 4 === 0 && i % 100 !== 0 || i % 400 === 0;
}
function Yt(i) {
  return i < 0 ? Math.ceil(i) || 0 : Math.floor(i);
}
function de(i) {
  var e = +i, t = 0;
  return e !== 0 && isFinite(e) && (t = Yt(e)), t;
}
function or(i, e) {
  return function(t) {
    return t != null ? (tc(this, i, t), P.updateOffset(this, e), this) : Vn(this, i);
  };
}
function Vn(i, e) {
  return i.isValid() ? i._d["get" + (i._isUTC ? "UTC" : "") + e]() : NaN;
}
function tc(i, e, t) {
  i.isValid() && !isNaN(t) && (e === "FullYear" && Ba(i.year()) && i.month() === 1 && i.date() === 29 ? (t = de(t), i._d["set" + (i._isUTC ? "UTC" : "") + e](
    t,
    i.month(),
    Ua(t, i.month())
  )) : i._d["set" + (i._isUTC ? "UTC" : "") + e](t));
}
function Bg(i) {
  return i = Ht(i), li(this[i]) ? this[i]() : this;
}
function Hg(i, e) {
  if (typeof i == "object") {
    i = eu(i);
    var t = Fg(i), s, r = t.length;
    for (s = 0; s < r; s++)
      this[t[s].unit](i[t[s].unit]);
  } else if (i = Ht(i), li(this[i]))
    return this[i](e);
  return this;
}
var ic = /\d/, It = /\d\d/, sc = /\d{3}/, tu = /\d{4}/, Ha = /[+-]?\d{6}/, Te = /\d\d?/, rc = /\d\d\d\d?/, nc = /\d\d\d\d\d\d?/, za = /\d{1,3}/, iu = /\d{1,4}/, Xa = /[+-]?\d{1,6}/, lr = /\d+/, Va = /[+-]?\d+/, zg = /Z|[+-]\d\d:?\d\d/gi, Wa = /Z|[+-]\d\d(?::?\d\d)?/gi, Xg = /[+-]?\d+(\.\d{1,3})?/, an = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, Wn;
Wn = {};
function V(i, e, t) {
  Wn[i] = li(e) ? e : function(s, r) {
    return s && t ? t : e;
  };
}
function Vg(i, e) {
  return be(Wn, i) ? Wn[i](e._strict, e._locale) : new RegExp(Wg(i));
}
function Wg(i) {
  return Ot(
    i.replace("\\", "").replace(
      /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
      function(e, t, s, r, n) {
        return t || s || r || n;
      }
    )
  );
}
function Ot(i) {
  return i.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
}
var Go = {};
function xe(i, e) {
  var t, s = e, r;
  for (typeof i == "string" && (i = [i]), mi(e) && (s = function(n, a) {
    a[e] = de(n);
  }), r = i.length, t = 0; t < r; t++)
    Go[i[t]] = s;
}
function on(i, e) {
  xe(i, function(t, s, r, n) {
    r._w = r._w || {}, e(t, r._w, r, n);
  });
}
function Ug(i, e, t) {
  e != null && be(Go, i) && Go[i](e, t._a, t, i);
}
var ut = 0, ci = 1, ti = 2, Ze = 3, Wt = 4, di = 5, us = 6, Gg = 7, Zg = 8;
function Kg(i, e) {
  return (i % e + e) % e;
}
var Ye;
Array.prototype.indexOf ? Ye = Array.prototype.indexOf : Ye = function(i) {
  var e;
  for (e = 0; e < this.length; ++e)
    if (this[e] === i)
      return e;
  return -1;
};
function Ua(i, e) {
  if (isNaN(i) || isNaN(e))
    return NaN;
  var t = Kg(e, 12);
  return i += (e - t) / 12, t === 1 ? Ba(i) ? 29 : 28 : 31 - t % 7 % 2;
}
Q("M", ["MM", 2], "Mo", function() {
  return this.month() + 1;
});
Q("MMM", 0, 0, function(i) {
  return this.localeData().monthsShort(this, i);
});
Q("MMMM", 0, 0, function(i) {
  return this.localeData().months(this, i);
});
ct("month", "M");
dt("month", 8);
V("M", Te);
V("MM", Te, It);
V("MMM", function(i, e) {
  return e.monthsShortRegex(i);
});
V("MMMM", function(i, e) {
  return e.monthsRegex(i);
});
xe(["M", "MM"], function(i, e) {
  e[ci] = de(i) - 1;
});
xe(["MMM", "MMMM"], function(i, e, t, s) {
  var r = t._locale.monthsParse(i, s, t._strict);
  r != null ? e[ci] = r : le(t).invalidMonth = i;
});
var Qg = "January_February_March_April_May_June_July_August_September_October_November_December".split(
  "_"
), ac = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), oc = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, Jg = an, qg = an;
function em(i, e) {
  return i ? Zt(this._months) ? this._months[i.month()] : this._months[(this._months.isFormat || oc).test(e) ? "format" : "standalone"][i.month()] : Zt(this._months) ? this._months : this._months.standalone;
}
function tm(i, e) {
  return i ? Zt(this._monthsShort) ? this._monthsShort[i.month()] : this._monthsShort[oc.test(e) ? "format" : "standalone"][i.month()] : Zt(this._monthsShort) ? this._monthsShort : this._monthsShort.standalone;
}
function im(i, e, t) {
  var s, r, n, a = i.toLocaleLowerCase();
  if (!this._monthsParse)
    for (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = [], s = 0; s < 12; ++s)
      n = oi([2e3, s]), this._shortMonthsParse[s] = this.monthsShort(
        n,
        ""
      ).toLocaleLowerCase(), this._longMonthsParse[s] = this.months(n, "").toLocaleLowerCase();
  return t ? e === "MMM" ? (r = Ye.call(this._shortMonthsParse, a), r !== -1 ? r : null) : (r = Ye.call(this._longMonthsParse, a), r !== -1 ? r : null) : e === "MMM" ? (r = Ye.call(this._shortMonthsParse, a), r !== -1 ? r : (r = Ye.call(this._longMonthsParse, a), r !== -1 ? r : null)) : (r = Ye.call(this._longMonthsParse, a), r !== -1 ? r : (r = Ye.call(this._shortMonthsParse, a), r !== -1 ? r : null));
}
function sm(i, e, t) {
  var s, r, n;
  if (this._monthsParseExact)
    return im.call(this, i, e, t);
  for (this._monthsParse || (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = []), s = 0; s < 12; s++) {
    if (r = oi([2e3, s]), t && !this._longMonthsParse[s] && (this._longMonthsParse[s] = new RegExp(
      "^" + this.months(r, "").replace(".", "") + "$",
      "i"
    ), this._shortMonthsParse[s] = new RegExp(
      "^" + this.monthsShort(r, "").replace(".", "") + "$",
      "i"
    )), !t && !this._monthsParse[s] && (n = "^" + this.months(r, "") + "|^" + this.monthsShort(r, ""), this._monthsParse[s] = new RegExp(n.replace(".", ""), "i")), t && e === "MMMM" && this._longMonthsParse[s].test(i))
      return s;
    if (t && e === "MMM" && this._shortMonthsParse[s].test(i))
      return s;
    if (!t && this._monthsParse[s].test(i))
      return s;
  }
}
function lc(i, e) {
  var t;
  if (!i.isValid())
    return i;
  if (typeof e == "string") {
    if (/^\d+$/.test(e))
      e = de(e);
    else if (e = i.localeData().monthsParse(e), !mi(e))
      return i;
  }
  return t = Math.min(i.date(), Ua(i.year(), e)), i._d["set" + (i._isUTC ? "UTC" : "") + "Month"](e, t), i;
}
function uc(i) {
  return i != null ? (lc(this, i), P.updateOffset(this, !0), this) : Vn(this, "Month");
}
function rm() {
  return Ua(this.year(), this.month());
}
function nm(i) {
  return this._monthsParseExact ? (be(this, "_monthsRegex") || hc.call(this), i ? this._monthsShortStrictRegex : this._monthsShortRegex) : (be(this, "_monthsShortRegex") || (this._monthsShortRegex = Jg), this._monthsShortStrictRegex && i ? this._monthsShortStrictRegex : this._monthsShortRegex);
}
function am(i) {
  return this._monthsParseExact ? (be(this, "_monthsRegex") || hc.call(this), i ? this._monthsStrictRegex : this._monthsRegex) : (be(this, "_monthsRegex") || (this._monthsRegex = qg), this._monthsStrictRegex && i ? this._monthsStrictRegex : this._monthsRegex);
}
function hc() {
  function i(a, o) {
    return o.length - a.length;
  }
  var e = [], t = [], s = [], r, n;
  for (r = 0; r < 12; r++)
    n = oi([2e3, r]), e.push(this.monthsShort(n, "")), t.push(this.months(n, "")), s.push(this.months(n, "")), s.push(this.monthsShort(n, ""));
  for (e.sort(i), t.sort(i), s.sort(i), r = 0; r < 12; r++)
    e[r] = Ot(e[r]), t[r] = Ot(t[r]);
  for (r = 0; r < 24; r++)
    s[r] = Ot(s[r]);
  this._monthsRegex = new RegExp("^(" + s.join("|") + ")", "i"), this._monthsShortRegex = this._monthsRegex, this._monthsStrictRegex = new RegExp(
    "^(" + t.join("|") + ")",
    "i"
  ), this._monthsShortStrictRegex = new RegExp(
    "^(" + e.join("|") + ")",
    "i"
  );
}
Q("Y", 0, 0, function() {
  var i = this.year();
  return i <= 9999 ? ri(i, 4) : "+" + i;
});
Q(0, ["YY", 2], 0, function() {
  return this.year() % 100;
});
Q(0, ["YYYY", 4], 0, "year");
Q(0, ["YYYYY", 5], 0, "year");
Q(0, ["YYYYYY", 6, !0], 0, "year");
ct("year", "y");
dt("year", 1);
V("Y", Va);
V("YY", Te, It);
V("YYYY", iu, tu);
V("YYYYY", Xa, Ha);
V("YYYYYY", Xa, Ha);
xe(["YYYYY", "YYYYYY"], ut);
xe("YYYY", function(i, e) {
  e[ut] = i.length === 2 ? P.parseTwoDigitYear(i) : de(i);
});
xe("YY", function(i, e) {
  e[ut] = P.parseTwoDigitYear(i);
});
xe("Y", function(i, e) {
  e[ut] = parseInt(i, 10);
});
function Lr(i) {
  return Ba(i) ? 366 : 365;
}
P.parseTwoDigitYear = function(i) {
  return de(i) + (de(i) > 68 ? 1900 : 2e3);
};
var cc = or("FullYear", !0);
function om() {
  return Ba(this.year());
}
function lm(i, e, t, s, r, n, a) {
  var o;
  return i < 100 && i >= 0 ? (o = new Date(i + 400, e, t, s, r, n, a), isFinite(o.getFullYear()) && o.setFullYear(i)) : o = new Date(i, e, t, s, r, n, a), o;
}
function Fr(i) {
  var e, t;
  return i < 100 && i >= 0 ? (t = Array.prototype.slice.call(arguments), t[0] = i + 400, e = new Date(Date.UTC.apply(null, t)), isFinite(e.getUTCFullYear()) && e.setUTCFullYear(i)) : e = new Date(Date.UTC.apply(null, arguments)), e;
}
function Un(i, e, t) {
  var s = 7 + e - t, r = (7 + Fr(i, 0, s).getUTCDay() - e) % 7;
  return -r + s - 1;
}
function dc(i, e, t, s, r) {
  var n = (7 + t - s) % 7, a = Un(i, s, r), o = 1 + 7 * (e - 1) + n + a, l, u;
  return o <= 0 ? (l = i - 1, u = Lr(l) + o) : o > Lr(i) ? (l = i + 1, u = o - Lr(i)) : (l = i, u = o), {
    year: l,
    dayOfYear: u
  };
}
function Br(i, e, t) {
  var s = Un(i.year(), e, t), r = Math.floor((i.dayOfYear() - s - 1) / 7) + 1, n, a;
  return r < 1 ? (a = i.year() - 1, n = r + fi(a, e, t)) : r > fi(i.year(), e, t) ? (n = r - fi(i.year(), e, t), a = i.year() + 1) : (a = i.year(), n = r), {
    week: n,
    year: a
  };
}
function fi(i, e, t) {
  var s = Un(i, e, t), r = Un(i + 1, e, t);
  return (Lr(i) - s + r) / 7;
}
Q("w", ["ww", 2], "wo", "week");
Q("W", ["WW", 2], "Wo", "isoWeek");
ct("week", "w");
ct("isoWeek", "W");
dt("week", 5);
dt("isoWeek", 5);
V("w", Te);
V("ww", Te, It);
V("W", Te);
V("WW", Te, It);
on(
  ["w", "ww", "W", "WW"],
  function(i, e, t, s) {
    e[s.substr(0, 1)] = de(i);
  }
);
function um(i) {
  return Br(i, this._week.dow, this._week.doy).week;
}
var hm = {
  dow: 0,
  // Sunday is the first day of the week.
  doy: 6
  // The week that contains Jan 6th is the first week of the year.
};
function cm() {
  return this._week.dow;
}
function dm() {
  return this._week.doy;
}
function fm(i) {
  var e = this.localeData().week(this);
  return i == null ? e : this.add((i - e) * 7, "d");
}
function pm(i) {
  var e = Br(this, 1, 4).week;
  return i == null ? e : this.add((i - e) * 7, "d");
}
Q("d", 0, "do", "day");
Q("dd", 0, 0, function(i) {
  return this.localeData().weekdaysMin(this, i);
});
Q("ddd", 0, 0, function(i) {
  return this.localeData().weekdaysShort(this, i);
});
Q("dddd", 0, 0, function(i) {
  return this.localeData().weekdays(this, i);
});
Q("e", 0, 0, "weekday");
Q("E", 0, 0, "isoWeekday");
ct("day", "d");
ct("weekday", "e");
ct("isoWeekday", "E");
dt("day", 11);
dt("weekday", 11);
dt("isoWeekday", 11);
V("d", Te);
V("e", Te);
V("E", Te);
V("dd", function(i, e) {
  return e.weekdaysMinRegex(i);
});
V("ddd", function(i, e) {
  return e.weekdaysShortRegex(i);
});
V("dddd", function(i, e) {
  return e.weekdaysRegex(i);
});
on(["dd", "ddd", "dddd"], function(i, e, t, s) {
  var r = t._locale.weekdaysParse(i, s, t._strict);
  r != null ? e.d = r : le(t).invalidWeekday = i;
});
on(["d", "e", "E"], function(i, e, t, s) {
  e[s] = de(i);
});
function gm(i, e) {
  return typeof i != "string" ? i : isNaN(i) ? (i = e.weekdaysParse(i), typeof i == "number" ? i : null) : parseInt(i, 10);
}
function mm(i, e) {
  return typeof i == "string" ? e.weekdaysParse(i) % 7 || 7 : isNaN(i) ? null : i;
}
function su(i, e) {
  return i.slice(e, 7).concat(i.slice(0, e));
}
var _m = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), fc = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), bm = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), ym = an, vm = an, xm = an;
function wm(i, e) {
  var t = Zt(this._weekdays) ? this._weekdays : this._weekdays[i && i !== !0 && this._weekdays.isFormat.test(e) ? "format" : "standalone"];
  return i === !0 ? su(t, this._week.dow) : i ? t[i.day()] : t;
}
function Sm(i) {
  return i === !0 ? su(this._weekdaysShort, this._week.dow) : i ? this._weekdaysShort[i.day()] : this._weekdaysShort;
}
function Dm(i) {
  return i === !0 ? su(this._weekdaysMin, this._week.dow) : i ? this._weekdaysMin[i.day()] : this._weekdaysMin;
}
function Pm(i, e, t) {
  var s, r, n, a = i.toLocaleLowerCase();
  if (!this._weekdaysParse)
    for (this._weekdaysParse = [], this._shortWeekdaysParse = [], this._minWeekdaysParse = [], s = 0; s < 7; ++s)
      n = oi([2e3, 1]).day(s), this._minWeekdaysParse[s] = this.weekdaysMin(
        n,
        ""
      ).toLocaleLowerCase(), this._shortWeekdaysParse[s] = this.weekdaysShort(
        n,
        ""
      ).toLocaleLowerCase(), this._weekdaysParse[s] = this.weekdays(n, "").toLocaleLowerCase();
  return t ? e === "dddd" ? (r = Ye.call(this._weekdaysParse, a), r !== -1 ? r : null) : e === "ddd" ? (r = Ye.call(this._shortWeekdaysParse, a), r !== -1 ? r : null) : (r = Ye.call(this._minWeekdaysParse, a), r !== -1 ? r : null) : e === "dddd" ? (r = Ye.call(this._weekdaysParse, a), r !== -1 || (r = Ye.call(this._shortWeekdaysParse, a), r !== -1) ? r : (r = Ye.call(this._minWeekdaysParse, a), r !== -1 ? r : null)) : e === "ddd" ? (r = Ye.call(this._shortWeekdaysParse, a), r !== -1 || (r = Ye.call(this._weekdaysParse, a), r !== -1) ? r : (r = Ye.call(this._minWeekdaysParse, a), r !== -1 ? r : null)) : (r = Ye.call(this._minWeekdaysParse, a), r !== -1 || (r = Ye.call(this._weekdaysParse, a), r !== -1) ? r : (r = Ye.call(this._shortWeekdaysParse, a), r !== -1 ? r : null));
}
function Tm(i, e, t) {
  var s, r, n;
  if (this._weekdaysParseExact)
    return Pm.call(this, i, e, t);
  for (this._weekdaysParse || (this._weekdaysParse = [], this._minWeekdaysParse = [], this._shortWeekdaysParse = [], this._fullWeekdaysParse = []), s = 0; s < 7; s++) {
    if (r = oi([2e3, 1]).day(s), t && !this._fullWeekdaysParse[s] && (this._fullWeekdaysParse[s] = new RegExp(
      "^" + this.weekdays(r, "").replace(".", "\\.?") + "$",
      "i"
    ), this._shortWeekdaysParse[s] = new RegExp(
      "^" + this.weekdaysShort(r, "").replace(".", "\\.?") + "$",
      "i"
    ), this._minWeekdaysParse[s] = new RegExp(
      "^" + this.weekdaysMin(r, "").replace(".", "\\.?") + "$",
      "i"
    )), this._weekdaysParse[s] || (n = "^" + this.weekdays(r, "") + "|^" + this.weekdaysShort(r, "") + "|^" + this.weekdaysMin(r, ""), this._weekdaysParse[s] = new RegExp(n.replace(".", ""), "i")), t && e === "dddd" && this._fullWeekdaysParse[s].test(i))
      return s;
    if (t && e === "ddd" && this._shortWeekdaysParse[s].test(i))
      return s;
    if (t && e === "dd" && this._minWeekdaysParse[s].test(i))
      return s;
    if (!t && this._weekdaysParse[s].test(i))
      return s;
  }
}
function km(i) {
  if (!this.isValid())
    return i != null ? this : NaN;
  var e = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
  return i != null ? (i = gm(i, this.localeData()), this.add(i - e, "d")) : e;
}
function Cm(i) {
  if (!this.isValid())
    return i != null ? this : NaN;
  var e = (this.day() + 7 - this.localeData()._week.dow) % 7;
  return i == null ? e : this.add(i - e, "d");
}
function Mm(i) {
  if (!this.isValid())
    return i != null ? this : NaN;
  if (i != null) {
    var e = mm(i, this.localeData());
    return this.day(this.day() % 7 ? e : e - 7);
  } else
    return this.day() || 7;
}
function Om(i) {
  return this._weekdaysParseExact ? (be(this, "_weekdaysRegex") || ru.call(this), i ? this._weekdaysStrictRegex : this._weekdaysRegex) : (be(this, "_weekdaysRegex") || (this._weekdaysRegex = ym), this._weekdaysStrictRegex && i ? this._weekdaysStrictRegex : this._weekdaysRegex);
}
function Am(i) {
  return this._weekdaysParseExact ? (be(this, "_weekdaysRegex") || ru.call(this), i ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex) : (be(this, "_weekdaysShortRegex") || (this._weekdaysShortRegex = vm), this._weekdaysShortStrictRegex && i ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex);
}
function Lm(i) {
  return this._weekdaysParseExact ? (be(this, "_weekdaysRegex") || ru.call(this), i ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex) : (be(this, "_weekdaysMinRegex") || (this._weekdaysMinRegex = xm), this._weekdaysMinStrictRegex && i ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex);
}
function ru() {
  function i(h, c) {
    return c.length - h.length;
  }
  var e = [], t = [], s = [], r = [], n, a, o, l, u;
  for (n = 0; n < 7; n++)
    a = oi([2e3, 1]).day(n), o = Ot(this.weekdaysMin(a, "")), l = Ot(this.weekdaysShort(a, "")), u = Ot(this.weekdays(a, "")), e.push(o), t.push(l), s.push(u), r.push(o), r.push(l), r.push(u);
  e.sort(i), t.sort(i), s.sort(i), r.sort(i), this._weekdaysRegex = new RegExp("^(" + r.join("|") + ")", "i"), this._weekdaysShortRegex = this._weekdaysRegex, this._weekdaysMinRegex = this._weekdaysRegex, this._weekdaysStrictRegex = new RegExp(
    "^(" + s.join("|") + ")",
    "i"
  ), this._weekdaysShortStrictRegex = new RegExp(
    "^(" + t.join("|") + ")",
    "i"
  ), this._weekdaysMinStrictRegex = new RegExp(
    "^(" + e.join("|") + ")",
    "i"
  );
}
function nu() {
  return this.hours() % 12 || 12;
}
function jm() {
  return this.hours() || 24;
}
Q("H", ["HH", 2], 0, "hour");
Q("h", ["hh", 2], 0, nu);
Q("k", ["kk", 2], 0, jm);
Q("hmm", 0, 0, function() {
  return "" + nu.apply(this) + ri(this.minutes(), 2);
});
Q("hmmss", 0, 0, function() {
  return "" + nu.apply(this) + ri(this.minutes(), 2) + ri(this.seconds(), 2);
});
Q("Hmm", 0, 0, function() {
  return "" + this.hours() + ri(this.minutes(), 2);
});
Q("Hmmss", 0, 0, function() {
  return "" + this.hours() + ri(this.minutes(), 2) + ri(this.seconds(), 2);
});
function pc(i, e) {
  Q(i, 0, 0, function() {
    return this.localeData().meridiem(
      this.hours(),
      this.minutes(),
      e
    );
  });
}
pc("a", !0);
pc("A", !1);
ct("hour", "h");
dt("hour", 13);
function gc(i, e) {
  return e._meridiemParse;
}
V("a", gc);
V("A", gc);
V("H", Te);
V("h", Te);
V("k", Te);
V("HH", Te, It);
V("hh", Te, It);
V("kk", Te, It);
V("hmm", rc);
V("hmmss", nc);
V("Hmm", rc);
V("Hmmss", nc);
xe(["H", "HH"], Ze);
xe(["k", "kk"], function(i, e, t) {
  var s = de(i);
  e[Ze] = s === 24 ? 0 : s;
});
xe(["a", "A"], function(i, e, t) {
  t._isPm = t._locale.isPM(i), t._meridiem = i;
});
xe(["h", "hh"], function(i, e, t) {
  e[Ze] = de(i), le(t).bigHour = !0;
});
xe("hmm", function(i, e, t) {
  var s = i.length - 2;
  e[Ze] = de(i.substr(0, s)), e[Wt] = de(i.substr(s)), le(t).bigHour = !0;
});
xe("hmmss", function(i, e, t) {
  var s = i.length - 4, r = i.length - 2;
  e[Ze] = de(i.substr(0, s)), e[Wt] = de(i.substr(s, 2)), e[di] = de(i.substr(r)), le(t).bigHour = !0;
});
xe("Hmm", function(i, e, t) {
  var s = i.length - 2;
  e[Ze] = de(i.substr(0, s)), e[Wt] = de(i.substr(s));
});
xe("Hmmss", function(i, e, t) {
  var s = i.length - 4, r = i.length - 2;
  e[Ze] = de(i.substr(0, s)), e[Wt] = de(i.substr(s, 2)), e[di] = de(i.substr(r));
});
function Em(i) {
  return (i + "").toLowerCase().charAt(0) === "p";
}
var Im = /[ap]\.?m?\.?/i, Rm = or("Hours", !0);
function Ym(i, e, t) {
  return i > 11 ? t ? "pm" : "PM" : t ? "am" : "AM";
}
var mc = {
  calendar: Tg,
  longDateFormat: Og,
  invalidDate: Lg,
  ordinal: Eg,
  dayOfMonthOrdinalParse: Ig,
  relativeTime: Yg,
  months: Qg,
  monthsShort: ac,
  week: hm,
  weekdays: _m,
  weekdaysMin: bm,
  weekdaysShort: fc,
  meridiemParse: Im
}, ke = {}, pr = {}, Hr;
function Nm(i, e) {
  var t, s = Math.min(i.length, e.length);
  for (t = 0; t < s; t += 1)
    if (i[t] !== e[t])
      return t;
  return s;
}
function Fu(i) {
  return i && i.toLowerCase().replace("_", "-");
}
function $m(i) {
  for (var e = 0, t, s, r, n; e < i.length; ) {
    for (n = Fu(i[e]).split("-"), t = n.length, s = Fu(i[e + 1]), s = s ? s.split("-") : null; t > 0; ) {
      if (r = Ga(n.slice(0, t).join("-")), r)
        return r;
      if (s && s.length >= t && Nm(n, s) >= t - 1)
        break;
      t--;
    }
    e++;
  }
  return Hr;
}
function Fm(i) {
  return i.match("^[^/\\\\]*$") != null;
}
function Ga(i) {
  var e = null, t;
  if (ke[i] === void 0 && typeof module < "u" && module && module.exports && Fm(i))
    try {
      e = Hr._abbr, t = require, t("./locale/" + i), ji(e);
    } catch {
      ke[i] = null;
    }
  return ke[i];
}
function ji(i, e) {
  var t;
  return i && (yt(e) ? t = xi(i) : t = au(i, e), t ? Hr = t : typeof console < "u" && console.warn && console.warn(
    "Locale " + i + " not found. Did you forget to load it?"
  )), Hr._abbr;
}
function au(i, e) {
  if (e !== null) {
    var t, s = mc;
    if (e.abbr = i, ke[i] != null)
      Jh(
        "defineLocaleOverride",
        "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
      ), s = ke[i]._config;
    else if (e.parentLocale != null)
      if (ke[e.parentLocale] != null)
        s = ke[e.parentLocale]._config;
      else if (t = Ga(e.parentLocale), t != null)
        s = t._config;
      else
        return pr[e.parentLocale] || (pr[e.parentLocale] = []), pr[e.parentLocale].push({
          name: i,
          config: e
        }), null;
    return ke[i] = new Jl(Wo(s, e)), pr[i] && pr[i].forEach(function(r) {
      au(r.name, r.config);
    }), ji(i), ke[i];
  } else
    return delete ke[i], null;
}
function Bm(i, e) {
  if (e != null) {
    var t, s, r = mc;
    ke[i] != null && ke[i].parentLocale != null ? ke[i].set(Wo(ke[i]._config, e)) : (s = Ga(i), s != null && (r = s._config), e = Wo(r, e), s == null && (e.abbr = i), t = new Jl(e), t.parentLocale = ke[i], ke[i] = t), ji(i);
  } else
    ke[i] != null && (ke[i].parentLocale != null ? (ke[i] = ke[i].parentLocale, i === ji() && ji(i)) : ke[i] != null && delete ke[i]);
  return ke[i];
}
function xi(i) {
  var e;
  if (i && i._locale && i._locale._abbr && (i = i._locale._abbr), !i)
    return Hr;
  if (!Zt(i)) {
    if (e = Ga(i), e)
      return e;
    i = [i];
  }
  return $m(i);
}
function Hm() {
  return Uo(ke);
}
function ou(i) {
  var e, t = i._a;
  return t && le(i).overflow === -2 && (e = t[ci] < 0 || t[ci] > 11 ? ci : t[ti] < 1 || t[ti] > Ua(t[ut], t[ci]) ? ti : t[Ze] < 0 || t[Ze] > 24 || t[Ze] === 24 && (t[Wt] !== 0 || t[di] !== 0 || t[us] !== 0) ? Ze : t[Wt] < 0 || t[Wt] > 59 ? Wt : t[di] < 0 || t[di] > 59 ? di : t[us] < 0 || t[us] > 999 ? us : -1, le(i)._overflowDayOfYear && (e < ut || e > ti) && (e = ti), le(i)._overflowWeeks && e === -1 && (e = Gg), le(i)._overflowWeekday && e === -1 && (e = Zg), le(i).overflow = e), i;
}
var zm = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, Xm = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, Vm = /Z|[+-]\d\d(?::?\d\d)?/, _n = [
  ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
  ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
  ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
  ["GGGG-[W]WW", /\d{4}-W\d\d/, !1],
  ["YYYY-DDD", /\d{4}-\d{3}/],
  ["YYYY-MM", /\d{4}-\d\d/, !1],
  ["YYYYYYMMDD", /[+-]\d{10}/],
  ["YYYYMMDD", /\d{8}/],
  ["GGGG[W]WWE", /\d{4}W\d{3}/],
  ["GGGG[W]WW", /\d{4}W\d{2}/, !1],
  ["YYYYDDD", /\d{7}/],
  ["YYYYMM", /\d{6}/, !1],
  ["YYYY", /\d{4}/, !1]
], go = [
  ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
  ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
  ["HH:mm:ss", /\d\d:\d\d:\d\d/],
  ["HH:mm", /\d\d:\d\d/],
  ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
  ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
  ["HHmmss", /\d\d\d\d\d\d/],
  ["HHmm", /\d\d\d\d/],
  ["HH", /\d\d/]
], Wm = /^\/?Date\((-?\d+)/i, Um = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, Gm = {
  UT: 0,
  GMT: 0,
  EDT: -4 * 60,
  EST: -5 * 60,
  CDT: -5 * 60,
  CST: -6 * 60,
  MDT: -6 * 60,
  MST: -7 * 60,
  PDT: -7 * 60,
  PST: -8 * 60
};
function _c(i) {
  var e, t, s = i._i, r = zm.exec(s) || Xm.exec(s), n, a, o, l, u = _n.length, h = go.length;
  if (r) {
    for (le(i).iso = !0, e = 0, t = u; e < t; e++)
      if (_n[e][1].exec(r[1])) {
        a = _n[e][0], n = _n[e][2] !== !1;
        break;
      }
    if (a == null) {
      i._isValid = !1;
      return;
    }
    if (r[3]) {
      for (e = 0, t = h; e < t; e++)
        if (go[e][1].exec(r[3])) {
          o = (r[2] || " ") + go[e][0];
          break;
        }
      if (o == null) {
        i._isValid = !1;
        return;
      }
    }
    if (!n && o != null) {
      i._isValid = !1;
      return;
    }
    if (r[4])
      if (Vm.exec(r[4]))
        l = "Z";
      else {
        i._isValid = !1;
        return;
      }
    i._f = a + (o || "") + (l || ""), uu(i);
  } else
    i._isValid = !1;
}
function Zm(i, e, t, s, r, n) {
  var a = [
    Km(i),
    ac.indexOf(e),
    parseInt(t, 10),
    parseInt(s, 10),
    parseInt(r, 10)
  ];
  return n && a.push(parseInt(n, 10)), a;
}
function Km(i) {
  var e = parseInt(i, 10);
  return e <= 49 ? 2e3 + e : e <= 999 ? 1900 + e : e;
}
function Qm(i) {
  return i.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
}
function Jm(i, e, t) {
  if (i) {
    var s = fc.indexOf(i), r = new Date(
      e[0],
      e[1],
      e[2]
    ).getDay();
    if (s !== r)
      return le(t).weekdayMismatch = !0, t._isValid = !1, !1;
  }
  return !0;
}
function qm(i, e, t) {
  if (i)
    return Gm[i];
  if (e)
    return 0;
  var s = parseInt(t, 10), r = s % 100, n = (s - r) / 100;
  return n * 60 + r;
}
function bc(i) {
  var e = Um.exec(Qm(i._i)), t;
  if (e) {
    if (t = Zm(
      e[4],
      e[3],
      e[2],
      e[5],
      e[6],
      e[7]
    ), !Jm(e[1], t, i))
      return;
    i._a = t, i._tzm = qm(e[8], e[9], e[10]), i._d = Fr.apply(null, i._a), i._d.setUTCMinutes(i._d.getUTCMinutes() - i._tzm), le(i).rfc2822 = !0;
  } else
    i._isValid = !1;
}
function e_(i) {
  var e = Wm.exec(i._i);
  if (e !== null) {
    i._d = new Date(+e[1]);
    return;
  }
  if (_c(i), i._isValid === !1)
    delete i._isValid;
  else
    return;
  if (bc(i), i._isValid === !1)
    delete i._isValid;
  else
    return;
  i._strict ? i._isValid = !1 : P.createFromInputFallback(i);
}
P.createFromInputFallback = Bt(
  "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
  function(i) {
    i._d = new Date(i._i + (i._useUTC ? " UTC" : ""));
  }
);
function As(i, e, t) {
  return i ?? e ?? t;
}
function t_(i) {
  var e = new Date(P.now());
  return i._useUTC ? [
    e.getUTCFullYear(),
    e.getUTCMonth(),
    e.getUTCDate()
  ] : [e.getFullYear(), e.getMonth(), e.getDate()];
}
function lu(i) {
  var e, t, s = [], r, n, a;
  if (!i._d) {
    for (r = t_(i), i._w && i._a[ti] == null && i._a[ci] == null && i_(i), i._dayOfYear != null && (a = As(i._a[ut], r[ut]), (i._dayOfYear > Lr(a) || i._dayOfYear === 0) && (le(i)._overflowDayOfYear = !0), t = Fr(a, 0, i._dayOfYear), i._a[ci] = t.getUTCMonth(), i._a[ti] = t.getUTCDate()), e = 0; e < 3 && i._a[e] == null; ++e)
      i._a[e] = s[e] = r[e];
    for (; e < 7; e++)
      i._a[e] = s[e] = i._a[e] == null ? e === 2 ? 1 : 0 : i._a[e];
    i._a[Ze] === 24 && i._a[Wt] === 0 && i._a[di] === 0 && i._a[us] === 0 && (i._nextDay = !0, i._a[Ze] = 0), i._d = (i._useUTC ? Fr : lm).apply(
      null,
      s
    ), n = i._useUTC ? i._d.getUTCDay() : i._d.getDay(), i._tzm != null && i._d.setUTCMinutes(i._d.getUTCMinutes() - i._tzm), i._nextDay && (i._a[Ze] = 24), i._w && typeof i._w.d < "u" && i._w.d !== n && (le(i).weekdayMismatch = !0);
  }
}
function i_(i) {
  var e, t, s, r, n, a, o, l, u;
  e = i._w, e.GG != null || e.W != null || e.E != null ? (n = 1, a = 4, t = As(
    e.GG,
    i._a[ut],
    Br(Pe(), 1, 4).year
  ), s = As(e.W, 1), r = As(e.E, 1), (r < 1 || r > 7) && (l = !0)) : (n = i._locale._week.dow, a = i._locale._week.doy, u = Br(Pe(), n, a), t = As(e.gg, i._a[ut], u.year), s = As(e.w, u.week), e.d != null ? (r = e.d, (r < 0 || r > 6) && (l = !0)) : e.e != null ? (r = e.e + n, (e.e < 0 || e.e > 6) && (l = !0)) : r = n), s < 1 || s > fi(t, n, a) ? le(i)._overflowWeeks = !0 : l != null ? le(i)._overflowWeekday = !0 : (o = dc(t, s, r, n, a), i._a[ut] = o.year, i._dayOfYear = o.dayOfYear);
}
P.ISO_8601 = function() {
};
P.RFC_2822 = function() {
};
function uu(i) {
  if (i._f === P.ISO_8601) {
    _c(i);
    return;
  }
  if (i._f === P.RFC_2822) {
    bc(i);
    return;
  }
  i._a = [], le(i).empty = !0;
  var e = "" + i._i, t, s, r, n, a, o = e.length, l = 0, u, h;
  for (r = qh(i._f, i._locale).match(ql) || [], h = r.length, t = 0; t < h; t++)
    n = r[t], s = (e.match(Vg(n, i)) || [])[0], s && (a = e.substr(0, e.indexOf(s)), a.length > 0 && le(i).unusedInput.push(a), e = e.slice(
      e.indexOf(s) + s.length
    ), l += s.length), Fs[n] ? (s ? le(i).empty = !1 : le(i).unusedTokens.push(n), Ug(n, s, i)) : i._strict && !s && le(i).unusedTokens.push(n);
  le(i).charsLeftOver = o - l, e.length > 0 && le(i).unusedInput.push(e), i._a[Ze] <= 12 && le(i).bigHour === !0 && i._a[Ze] > 0 && (le(i).bigHour = void 0), le(i).parsedDateParts = i._a.slice(0), le(i).meridiem = i._meridiem, i._a[Ze] = s_(
    i._locale,
    i._a[Ze],
    i._meridiem
  ), u = le(i).era, u !== null && (i._a[ut] = i._locale.erasConvertYear(u, i._a[ut])), lu(i), ou(i);
}
function s_(i, e, t) {
  var s;
  return t == null ? e : i.meridiemHour != null ? i.meridiemHour(e, t) : (i.isPM != null && (s = i.isPM(t), s && e < 12 && (e += 12), !s && e === 12 && (e = 0)), e);
}
function r_(i) {
  var e, t, s, r, n, a, o = !1, l = i._f.length;
  if (l === 0) {
    le(i).invalidFormat = !0, i._d = new Date(NaN);
    return;
  }
  for (r = 0; r < l; r++)
    n = 0, a = !1, e = Ql({}, i), i._useUTC != null && (e._useUTC = i._useUTC), e._f = i._f[r], uu(e), Kl(e) && (a = !0), n += le(e).charsLeftOver, n += le(e).unusedTokens.length * 10, le(e).score = n, o ? n < s && (s = n, t = e) : (s == null || n < s || a) && (s = n, t = e, a && (o = !0));
  ki(i, t || e);
}
function n_(i) {
  if (!i._d) {
    var e = eu(i._i), t = e.day === void 0 ? e.date : e.day;
    i._a = Kh(
      [e.year, e.month, t, e.hour, e.minute, e.second, e.millisecond],
      function(s) {
        return s && parseInt(s, 10);
      }
    ), lu(i);
  }
}
function a_(i) {
  var e = new nn(ou(yc(i)));
  return e._nextDay && (e.add(1, "d"), e._nextDay = void 0), e;
}
function yc(i) {
  var e = i._i, t = i._f;
  return i._locale = i._locale || xi(i._l), e === null || t === void 0 && e === "" ? Fa({ nullInput: !0 }) : (typeof e == "string" && (i._i = e = i._locale.preparse(e)), Kt(e) ? new nn(ou(e)) : (rn(e) ? i._d = e : Zt(t) ? r_(i) : t ? uu(i) : o_(i), Kl(i) || (i._d = null), i));
}
function o_(i) {
  var e = i._i;
  yt(e) ? i._d = new Date(P.now()) : rn(e) ? i._d = new Date(e.valueOf()) : typeof e == "string" ? e_(i) : Zt(e) ? (i._a = Kh(e.slice(0), function(t) {
    return parseInt(t, 10);
  }), lu(i)) : ds(e) ? n_(i) : mi(e) ? i._d = new Date(e) : P.createFromInputFallback(i);
}
function vc(i, e, t, s, r) {
  var n = {};
  return (e === !0 || e === !1) && (s = e, e = void 0), (t === !0 || t === !1) && (s = t, t = void 0), (ds(i) && Zl(i) || Zt(i) && i.length === 0) && (i = void 0), n._isAMomentObject = !0, n._useUTC = n._isUTC = r, n._l = t, n._i = i, n._f = e, n._strict = s, a_(n);
}
function Pe(i, e, t, s) {
  return vc(i, e, t, s, !1);
}
var l_ = Bt(
  "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
  function() {
    var i = Pe.apply(null, arguments);
    return this.isValid() && i.isValid() ? i < this ? this : i : Fa();
  }
), u_ = Bt(
  "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
  function() {
    var i = Pe.apply(null, arguments);
    return this.isValid() && i.isValid() ? i > this ? this : i : Fa();
  }
);
function xc(i, e) {
  var t, s;
  if (e.length === 1 && Zt(e[0]) && (e = e[0]), !e.length)
    return Pe();
  for (t = e[0], s = 1; s < e.length; ++s)
    (!e[s].isValid() || e[s][i](t)) && (t = e[s]);
  return t;
}
function h_() {
  var i = [].slice.call(arguments, 0);
  return xc("isBefore", i);
}
function c_() {
  var i = [].slice.call(arguments, 0);
  return xc("isAfter", i);
}
var d_ = function() {
  return Date.now ? Date.now() : +new Date();
}, gr = [
  "year",
  "quarter",
  "month",
  "week",
  "day",
  "hour",
  "minute",
  "second",
  "millisecond"
];
function f_(i) {
  var e, t = !1, s, r = gr.length;
  for (e in i)
    if (be(i, e) && !(Ye.call(gr, e) !== -1 && (i[e] == null || !isNaN(i[e]))))
      return !1;
  for (s = 0; s < r; ++s)
    if (i[gr[s]]) {
      if (t)
        return !1;
      parseFloat(i[gr[s]]) !== de(i[gr[s]]) && (t = !0);
    }
  return !0;
}
function p_() {
  return this._isValid;
}
function g_() {
  return Qt(NaN);
}
function Za(i) {
  var e = eu(i), t = e.year || 0, s = e.quarter || 0, r = e.month || 0, n = e.week || e.isoWeek || 0, a = e.day || 0, o = e.hour || 0, l = e.minute || 0, u = e.second || 0, h = e.millisecond || 0;
  this._isValid = f_(e), this._milliseconds = +h + u * 1e3 + // 1000
  l * 6e4 + // 1000 * 60
  o * 1e3 * 60 * 60, this._days = +a + n * 7, this._months = +r + s * 3 + t * 12, this._data = {}, this._locale = xi(), this._bubble();
}
function Ln(i) {
  return i instanceof Za;
}
function Zo(i) {
  return i < 0 ? Math.round(-1 * i) * -1 : Math.round(i);
}
function m_(i, e, t) {
  var s = Math.min(i.length, e.length), r = Math.abs(i.length - e.length), n = 0, a;
  for (a = 0; a < s; a++)
    (t && i[a] !== e[a] || !t && de(i[a]) !== de(e[a])) && n++;
  return n + r;
}
function wc(i, e) {
  Q(i, 0, 0, function() {
    var t = this.utcOffset(), s = "+";
    return t < 0 && (t = -t, s = "-"), s + ri(~~(t / 60), 2) + e + ri(~~t % 60, 2);
  });
}
wc("Z", ":");
wc("ZZ", "");
V("Z", Wa);
V("ZZ", Wa);
xe(["Z", "ZZ"], function(i, e, t) {
  t._useUTC = !0, t._tzm = hu(Wa, i);
});
var __ = /([\+\-]|\d\d)/gi;
function hu(i, e) {
  var t = (e || "").match(i), s, r, n;
  return t === null ? null : (s = t[t.length - 1] || [], r = (s + "").match(__) || ["-", 0, 0], n = +(r[1] * 60) + de(r[2]), n === 0 ? 0 : r[0] === "+" ? n : -n);
}
function cu(i, e) {
  var t, s;
  return e._isUTC ? (t = e.clone(), s = (Kt(i) || rn(i) ? i.valueOf() : Pe(i).valueOf()) - t.valueOf(), t._d.setTime(t._d.valueOf() + s), P.updateOffset(t, !1), t) : Pe(i).local();
}
function Ko(i) {
  return -Math.round(i._d.getTimezoneOffset());
}
P.updateOffset = function() {
};
function b_(i, e, t) {
  var s = this._offset || 0, r;
  if (!this.isValid())
    return i != null ? this : NaN;
  if (i != null) {
    if (typeof i == "string") {
      if (i = hu(Wa, i), i === null)
        return this;
    } else
      Math.abs(i) < 16 && !t && (i = i * 60);
    return !this._isUTC && e && (r = Ko(this)), this._offset = i, this._isUTC = !0, r != null && this.add(r, "m"), s !== i && (!e || this._changeInProgress ? Pc(
      this,
      Qt(i - s, "m"),
      1,
      !1
    ) : this._changeInProgress || (this._changeInProgress = !0, P.updateOffset(this, !0), this._changeInProgress = null)), this;
  } else
    return this._isUTC ? s : Ko(this);
}
function y_(i, e) {
  return i != null ? (typeof i != "string" && (i = -i), this.utcOffset(i, e), this) : -this.utcOffset();
}
function v_(i) {
  return this.utcOffset(0, i);
}
function x_(i) {
  return this._isUTC && (this.utcOffset(0, i), this._isUTC = !1, i && this.subtract(Ko(this), "m")), this;
}
function w_() {
  if (this._tzm != null)
    this.utcOffset(this._tzm, !1, !0);
  else if (typeof this._i == "string") {
    var i = hu(zg, this._i);
    i != null ? this.utcOffset(i) : this.utcOffset(0, !0);
  }
  return this;
}
function S_(i) {
  return this.isValid() ? (i = i ? Pe(i).utcOffset() : 0, (this.utcOffset() - i) % 60 === 0) : !1;
}
function D_() {
  return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
}
function P_() {
  if (!yt(this._isDSTShifted))
    return this._isDSTShifted;
  var i = {}, e;
  return Ql(i, this), i = yc(i), i._a ? (e = i._isUTC ? oi(i._a) : Pe(i._a), this._isDSTShifted = this.isValid() && m_(i._a, e.toArray()) > 0) : this._isDSTShifted = !1, this._isDSTShifted;
}
function T_() {
  return this.isValid() ? !this._isUTC : !1;
}
function k_() {
  return this.isValid() ? this._isUTC : !1;
}
function Sc() {
  return this.isValid() ? this._isUTC && this._offset === 0 : !1;
}
var C_ = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, M_ = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
function Qt(i, e) {
  var t = i, s = null, r, n, a;
  return Ln(i) ? t = {
    ms: i._milliseconds,
    d: i._days,
    M: i._months
  } : mi(i) || !isNaN(+i) ? (t = {}, e ? t[e] = +i : t.milliseconds = +i) : (s = C_.exec(i)) ? (r = s[1] === "-" ? -1 : 1, t = {
    y: 0,
    d: de(s[ti]) * r,
    h: de(s[Ze]) * r,
    m: de(s[Wt]) * r,
    s: de(s[di]) * r,
    ms: de(Zo(s[us] * 1e3)) * r
    // the millisecond decimal point is included in the match
  }) : (s = M_.exec(i)) ? (r = s[1] === "-" ? -1 : 1, t = {
    y: qi(s[2], r),
    M: qi(s[3], r),
    w: qi(s[4], r),
    d: qi(s[5], r),
    h: qi(s[6], r),
    m: qi(s[7], r),
    s: qi(s[8], r)
  }) : t == null ? t = {} : typeof t == "object" && ("from" in t || "to" in t) && (a = O_(
    Pe(t.from),
    Pe(t.to)
  ), t = {}, t.ms = a.milliseconds, t.M = a.months), n = new Za(t), Ln(i) && be(i, "_locale") && (n._locale = i._locale), Ln(i) && be(i, "_isValid") && (n._isValid = i._isValid), n;
}
Qt.fn = Za.prototype;
Qt.invalid = g_;
function qi(i, e) {
  var t = i && parseFloat(i.replace(",", "."));
  return (isNaN(t) ? 0 : t) * e;
}
function Bu(i, e) {
  var t = {};
  return t.months = e.month() - i.month() + (e.year() - i.year()) * 12, i.clone().add(t.months, "M").isAfter(e) && --t.months, t.milliseconds = +e - +i.clone().add(t.months, "M"), t;
}
function O_(i, e) {
  var t;
  return i.isValid() && e.isValid() ? (e = cu(e, i), i.isBefore(e) ? t = Bu(i, e) : (t = Bu(e, i), t.milliseconds = -t.milliseconds, t.months = -t.months), t) : { milliseconds: 0, months: 0 };
}
function Dc(i, e) {
  return function(t, s) {
    var r, n;
    return s !== null && !isNaN(+s) && (Jh(
      e,
      "moment()." + e + "(period, number) is deprecated. Please use moment()." + e + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."
    ), n = t, t = s, s = n), r = Qt(t, s), Pc(this, r, i), this;
  };
}
function Pc(i, e, t, s) {
  var r = e._milliseconds, n = Zo(e._days), a = Zo(e._months);
  i.isValid() && (s = s ?? !0, a && lc(i, Vn(i, "Month") + a * t), n && tc(i, "Date", Vn(i, "Date") + n * t), r && i._d.setTime(i._d.valueOf() + r * t), s && P.updateOffset(i, n || a));
}
var A_ = Dc(1, "add"), L_ = Dc(-1, "subtract");
function Tc(i) {
  return typeof i == "string" || i instanceof String;
}
function j_(i) {
  return Kt(i) || rn(i) || Tc(i) || mi(i) || I_(i) || E_(i) || i === null || i === void 0;
}
function E_(i) {
  var e = ds(i) && !Zl(i), t = !1, s = [
    "years",
    "year",
    "y",
    "months",
    "month",
    "M",
    "days",
    "day",
    "d",
    "dates",
    "date",
    "D",
    "hours",
    "hour",
    "h",
    "minutes",
    "minute",
    "m",
    "seconds",
    "second",
    "s",
    "milliseconds",
    "millisecond",
    "ms"
  ], r, n, a = s.length;
  for (r = 0; r < a; r += 1)
    n = s[r], t = t || be(i, n);
  return e && t;
}
function I_(i) {
  var e = Zt(i), t = !1;
  return e && (t = i.filter(function(s) {
    return !mi(s) && Tc(i);
  }).length === 0), e && t;
}
function R_(i) {
  var e = ds(i) && !Zl(i), t = !1, s = [
    "sameDay",
    "nextDay",
    "lastDay",
    "nextWeek",
    "lastWeek",
    "sameElse"
  ], r, n;
  for (r = 0; r < s.length; r += 1)
    n = s[r], t = t || be(i, n);
  return e && t;
}
function Y_(i, e) {
  var t = i.diff(e, "days", !0);
  return t < -6 ? "sameElse" : t < -1 ? "lastWeek" : t < 0 ? "lastDay" : t < 1 ? "sameDay" : t < 2 ? "nextDay" : t < 7 ? "nextWeek" : "sameElse";
}
function N_(i, e) {
  arguments.length === 1 && (arguments[0] ? j_(arguments[0]) ? (i = arguments[0], e = void 0) : R_(arguments[0]) && (e = arguments[0], i = void 0) : (i = void 0, e = void 0));
  var t = i || Pe(), s = cu(t, this).startOf("day"), r = P.calendarFormat(this, s) || "sameElse", n = e && (li(e[r]) ? e[r].call(this, t) : e[r]);
  return this.format(
    n || this.localeData().calendar(r, this, Pe(t))
  );
}
function $_() {
  return new nn(this);
}
function F_(i, e) {
  var t = Kt(i) ? i : Pe(i);
  return this.isValid() && t.isValid() ? (e = Ht(e) || "millisecond", e === "millisecond" ? this.valueOf() > t.valueOf() : t.valueOf() < this.clone().startOf(e).valueOf()) : !1;
}
function B_(i, e) {
  var t = Kt(i) ? i : Pe(i);
  return this.isValid() && t.isValid() ? (e = Ht(e) || "millisecond", e === "millisecond" ? this.valueOf() < t.valueOf() : this.clone().endOf(e).valueOf() < t.valueOf()) : !1;
}
function H_(i, e, t, s) {
  var r = Kt(i) ? i : Pe(i), n = Kt(e) ? e : Pe(e);
  return this.isValid() && r.isValid() && n.isValid() ? (s = s || "()", (s[0] === "(" ? this.isAfter(r, t) : !this.isBefore(r, t)) && (s[1] === ")" ? this.isBefore(n, t) : !this.isAfter(n, t))) : !1;
}
function z_(i, e) {
  var t = Kt(i) ? i : Pe(i), s;
  return this.isValid() && t.isValid() ? (e = Ht(e) || "millisecond", e === "millisecond" ? this.valueOf() === t.valueOf() : (s = t.valueOf(), this.clone().startOf(e).valueOf() <= s && s <= this.clone().endOf(e).valueOf())) : !1;
}
function X_(i, e) {
  return this.isSame(i, e) || this.isAfter(i, e);
}
function V_(i, e) {
  return this.isSame(i, e) || this.isBefore(i, e);
}
function W_(i, e, t) {
  var s, r, n;
  if (!this.isValid())
    return NaN;
  if (s = cu(i, this), !s.isValid())
    return NaN;
  switch (r = (s.utcOffset() - this.utcOffset()) * 6e4, e = Ht(e), e) {
    case "year":
      n = jn(this, s) / 12;
      break;
    case "month":
      n = jn(this, s);
      break;
    case "quarter":
      n = jn(this, s) / 3;
      break;
    case "second":
      n = (this - s) / 1e3;
      break;
    case "minute":
      n = (this - s) / 6e4;
      break;
    case "hour":
      n = (this - s) / 36e5;
      break;
    case "day":
      n = (this - s - r) / 864e5;
      break;
    case "week":
      n = (this - s - r) / 6048e5;
      break;
    default:
      n = this - s;
  }
  return t ? n : Yt(n);
}
function jn(i, e) {
  if (i.date() < e.date())
    return -jn(e, i);
  var t = (e.year() - i.year()) * 12 + (e.month() - i.month()), s = i.clone().add(t, "months"), r, n;
  return e - s < 0 ? (r = i.clone().add(t - 1, "months"), n = (e - s) / (s - r)) : (r = i.clone().add(t + 1, "months"), n = (e - s) / (r - s)), -(t + n) || 0;
}
P.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
P.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
function U_() {
  return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
}
function G_(i) {
  if (!this.isValid())
    return null;
  var e = i !== !0, t = e ? this.clone().utc() : this;
  return t.year() < 0 || t.year() > 9999 ? An(
    t,
    e ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"
  ) : li(Date.prototype.toISOString) ? e ? this.toDate().toISOString() : new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", An(t, "Z")) : An(
    t,
    e ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ"
  );
}
function Z_() {
  if (!this.isValid())
    return "moment.invalid(/* " + this._i + " */)";
  var i = "moment", e = "", t, s, r, n;
  return this.isLocal() || (i = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone", e = "Z"), t = "[" + i + '("]', s = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY", r = "-MM-DD[T]HH:mm:ss.SSS", n = e + '[")]', this.format(t + s + r + n);
}
function K_(i) {
  i || (i = this.isUtc() ? P.defaultFormatUtc : P.defaultFormat);
  var e = An(this, i);
  return this.localeData().postformat(e);
}
function Q_(i, e) {
  return this.isValid() && (Kt(i) && i.isValid() || Pe(i).isValid()) ? Qt({ to: this, from: i }).locale(this.locale()).humanize(!e) : this.localeData().invalidDate();
}
function J_(i) {
  return this.from(Pe(), i);
}
function q_(i, e) {
  return this.isValid() && (Kt(i) && i.isValid() || Pe(i).isValid()) ? Qt({ from: this, to: i }).locale(this.locale()).humanize(!e) : this.localeData().invalidDate();
}
function eb(i) {
  return this.to(Pe(), i);
}
function kc(i) {
  var e;
  return i === void 0 ? this._locale._abbr : (e = xi(i), e != null && (this._locale = e), this);
}
var Cc = Bt(
  "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
  function(i) {
    return i === void 0 ? this.localeData() : this.locale(i);
  }
);
function Mc() {
  return this._locale;
}
var Gn = 1e3, Bs = 60 * Gn, Zn = 60 * Bs, Oc = (365 * 400 + 97) * 24 * Zn;
function Hs(i, e) {
  return (i % e + e) % e;
}
function Ac(i, e, t) {
  return i < 100 && i >= 0 ? new Date(i + 400, e, t) - Oc : new Date(i, e, t).valueOf();
}
function Lc(i, e, t) {
  return i < 100 && i >= 0 ? Date.UTC(i + 400, e, t) - Oc : Date.UTC(i, e, t);
}
function tb(i) {
  var e, t;
  if (i = Ht(i), i === void 0 || i === "millisecond" || !this.isValid())
    return this;
  switch (t = this._isUTC ? Lc : Ac, i) {
    case "year":
      e = t(this.year(), 0, 1);
      break;
    case "quarter":
      e = t(
        this.year(),
        this.month() - this.month() % 3,
        1
      );
      break;
    case "month":
      e = t(this.year(), this.month(), 1);
      break;
    case "week":
      e = t(
        this.year(),
        this.month(),
        this.date() - this.weekday()
      );
      break;
    case "isoWeek":
      e = t(
        this.year(),
        this.month(),
        this.date() - (this.isoWeekday() - 1)
      );
      break;
    case "day":
    case "date":
      e = t(this.year(), this.month(), this.date());
      break;
    case "hour":
      e = this._d.valueOf(), e -= Hs(
        e + (this._isUTC ? 0 : this.utcOffset() * Bs),
        Zn
      );
      break;
    case "minute":
      e = this._d.valueOf(), e -= Hs(e, Bs);
      break;
    case "second":
      e = this._d.valueOf(), e -= Hs(e, Gn);
      break;
  }
  return this._d.setTime(e), P.updateOffset(this, !0), this;
}
function ib(i) {
  var e, t;
  if (i = Ht(i), i === void 0 || i === "millisecond" || !this.isValid())
    return this;
  switch (t = this._isUTC ? Lc : Ac, i) {
    case "year":
      e = t(this.year() + 1, 0, 1) - 1;
      break;
    case "quarter":
      e = t(
        this.year(),
        this.month() - this.month() % 3 + 3,
        1
      ) - 1;
      break;
    case "month":
      e = t(this.year(), this.month() + 1, 1) - 1;
      break;
    case "week":
      e = t(
        this.year(),
        this.month(),
        this.date() - this.weekday() + 7
      ) - 1;
      break;
    case "isoWeek":
      e = t(
        this.year(),
        this.month(),
        this.date() - (this.isoWeekday() - 1) + 7
      ) - 1;
      break;
    case "day":
    case "date":
      e = t(this.year(), this.month(), this.date() + 1) - 1;
      break;
    case "hour":
      e = this._d.valueOf(), e += Zn - Hs(
        e + (this._isUTC ? 0 : this.utcOffset() * Bs),
        Zn
      ) - 1;
      break;
    case "minute":
      e = this._d.valueOf(), e += Bs - Hs(e, Bs) - 1;
      break;
    case "second":
      e = this._d.valueOf(), e += Gn - Hs(e, Gn) - 1;
      break;
  }
  return this._d.setTime(e), P.updateOffset(this, !0), this;
}
function sb() {
  return this._d.valueOf() - (this._offset || 0) * 6e4;
}
function rb() {
  return Math.floor(this.valueOf() / 1e3);
}
function nb() {
  return new Date(this.valueOf());
}
function ab() {
  var i = this;
  return [
    i.year(),
    i.month(),
    i.date(),
    i.hour(),
    i.minute(),
    i.second(),
    i.millisecond()
  ];
}
function ob() {
  var i = this;
  return {
    years: i.year(),
    months: i.month(),
    date: i.date(),
    hours: i.hours(),
    minutes: i.minutes(),
    seconds: i.seconds(),
    milliseconds: i.milliseconds()
  };
}
function lb() {
  return this.isValid() ? this.toISOString() : null;
}
function ub() {
  return Kl(this);
}
function hb() {
  return ki({}, le(this));
}
function cb() {
  return le(this).overflow;
}
function db() {
  return {
    input: this._i,
    format: this._f,
    locale: this._locale,
    isUTC: this._isUTC,
    strict: this._strict
  };
}
Q("N", 0, 0, "eraAbbr");
Q("NN", 0, 0, "eraAbbr");
Q("NNN", 0, 0, "eraAbbr");
Q("NNNN", 0, 0, "eraName");
Q("NNNNN", 0, 0, "eraNarrow");
Q("y", ["y", 1], "yo", "eraYear");
Q("y", ["yy", 2], 0, "eraYear");
Q("y", ["yyy", 3], 0, "eraYear");
Q("y", ["yyyy", 4], 0, "eraYear");
V("N", du);
V("NN", du);
V("NNN", du);
V("NNNN", Sb);
V("NNNNN", Db);
xe(
  ["N", "NN", "NNN", "NNNN", "NNNNN"],
  function(i, e, t, s) {
    var r = t._locale.erasParse(i, s, t._strict);
    r ? le(t).era = r : le(t).invalidEra = i;
  }
);
V("y", lr);
V("yy", lr);
V("yyy", lr);
V("yyyy", lr);
V("yo", Pb);
xe(["y", "yy", "yyy", "yyyy"], ut);
xe(["yo"], function(i, e, t, s) {
  var r;
  t._locale._eraYearOrdinalRegex && (r = i.match(t._locale._eraYearOrdinalRegex)), t._locale.eraYearOrdinalParse ? e[ut] = t._locale.eraYearOrdinalParse(i, r) : e[ut] = parseInt(i, 10);
});
function fb(i, e) {
  var t, s, r, n = this._eras || xi("en")._eras;
  for (t = 0, s = n.length; t < s; ++t) {
    switch (typeof n[t].since) {
      case "string":
        r = P(n[t].since).startOf("day"), n[t].since = r.valueOf();
        break;
    }
    switch (typeof n[t].until) {
      case "undefined":
        n[t].until = 1 / 0;
        break;
      case "string":
        r = P(n[t].until).startOf("day").valueOf(), n[t].until = r.valueOf();
        break;
    }
  }
  return n;
}
function pb(i, e, t) {
  var s, r, n = this.eras(), a, o, l;
  for (i = i.toUpperCase(), s = 0, r = n.length; s < r; ++s)
    if (a = n[s].name.toUpperCase(), o = n[s].abbr.toUpperCase(), l = n[s].narrow.toUpperCase(), t)
      switch (e) {
        case "N":
        case "NN":
        case "NNN":
          if (o === i)
            return n[s];
          break;
        case "NNNN":
          if (a === i)
            return n[s];
          break;
        case "NNNNN":
          if (l === i)
            return n[s];
          break;
      }
    else if ([a, o, l].indexOf(i) >= 0)
      return n[s];
}
function gb(i, e) {
  var t = i.since <= i.until ? 1 : -1;
  return e === void 0 ? P(i.since).year() : P(i.since).year() + (e - i.offset) * t;
}
function mb() {
  var i, e, t, s = this.localeData().eras();
  for (i = 0, e = s.length; i < e; ++i)
    if (t = this.clone().startOf("day").valueOf(), s[i].since <= t && t <= s[i].until || s[i].until <= t && t <= s[i].since)
      return s[i].name;
  return "";
}
function _b() {
  var i, e, t, s = this.localeData().eras();
  for (i = 0, e = s.length; i < e; ++i)
    if (t = this.clone().startOf("day").valueOf(), s[i].since <= t && t <= s[i].until || s[i].until <= t && t <= s[i].since)
      return s[i].narrow;
  return "";
}
function bb() {
  var i, e, t, s = this.localeData().eras();
  for (i = 0, e = s.length; i < e; ++i)
    if (t = this.clone().startOf("day").valueOf(), s[i].since <= t && t <= s[i].until || s[i].until <= t && t <= s[i].since)
      return s[i].abbr;
  return "";
}
function yb() {
  var i, e, t, s, r = this.localeData().eras();
  for (i = 0, e = r.length; i < e; ++i)
    if (t = r[i].since <= r[i].until ? 1 : -1, s = this.clone().startOf("day").valueOf(), r[i].since <= s && s <= r[i].until || r[i].until <= s && s <= r[i].since)
      return (this.year() - P(r[i].since).year()) * t + r[i].offset;
  return this.year();
}
function vb(i) {
  return be(this, "_erasNameRegex") || fu.call(this), i ? this._erasNameRegex : this._erasRegex;
}
function xb(i) {
  return be(this, "_erasAbbrRegex") || fu.call(this), i ? this._erasAbbrRegex : this._erasRegex;
}
function wb(i) {
  return be(this, "_erasNarrowRegex") || fu.call(this), i ? this._erasNarrowRegex : this._erasRegex;
}
function du(i, e) {
  return e.erasAbbrRegex(i);
}
function Sb(i, e) {
  return e.erasNameRegex(i);
}
function Db(i, e) {
  return e.erasNarrowRegex(i);
}
function Pb(i, e) {
  return e._eraYearOrdinalRegex || lr;
}
function fu() {
  var i = [], e = [], t = [], s = [], r, n, a = this.eras();
  for (r = 0, n = a.length; r < n; ++r)
    e.push(Ot(a[r].name)), i.push(Ot(a[r].abbr)), t.push(Ot(a[r].narrow)), s.push(Ot(a[r].name)), s.push(Ot(a[r].abbr)), s.push(Ot(a[r].narrow));
  this._erasRegex = new RegExp("^(" + s.join("|") + ")", "i"), this._erasNameRegex = new RegExp("^(" + e.join("|") + ")", "i"), this._erasAbbrRegex = new RegExp("^(" + i.join("|") + ")", "i"), this._erasNarrowRegex = new RegExp(
    "^(" + t.join("|") + ")",
    "i"
  );
}
Q(0, ["gg", 2], 0, function() {
  return this.weekYear() % 100;
});
Q(0, ["GG", 2], 0, function() {
  return this.isoWeekYear() % 100;
});
function Ka(i, e) {
  Q(0, [i, i.length], 0, e);
}
Ka("gggg", "weekYear");
Ka("ggggg", "weekYear");
Ka("GGGG", "isoWeekYear");
Ka("GGGGG", "isoWeekYear");
ct("weekYear", "gg");
ct("isoWeekYear", "GG");
dt("weekYear", 1);
dt("isoWeekYear", 1);
V("G", Va);
V("g", Va);
V("GG", Te, It);
V("gg", Te, It);
V("GGGG", iu, tu);
V("gggg", iu, tu);
V("GGGGG", Xa, Ha);
V("ggggg", Xa, Ha);
on(
  ["gggg", "ggggg", "GGGG", "GGGGG"],
  function(i, e, t, s) {
    e[s.substr(0, 2)] = de(i);
  }
);
on(["gg", "GG"], function(i, e, t, s) {
  e[s] = P.parseTwoDigitYear(i);
});
function Tb(i) {
  return jc.call(
    this,
    i,
    this.week(),
    this.weekday(),
    this.localeData()._week.dow,
    this.localeData()._week.doy
  );
}
function kb(i) {
  return jc.call(
    this,
    i,
    this.isoWeek(),
    this.isoWeekday(),
    1,
    4
  );
}
function Cb() {
  return fi(this.year(), 1, 4);
}
function Mb() {
  return fi(this.isoWeekYear(), 1, 4);
}
function Ob() {
  var i = this.localeData()._week;
  return fi(this.year(), i.dow, i.doy);
}
function Ab() {
  var i = this.localeData()._week;
  return fi(this.weekYear(), i.dow, i.doy);
}
function jc(i, e, t, s, r) {
  var n;
  return i == null ? Br(this, s, r).year : (n = fi(i, s, r), e > n && (e = n), Lb.call(this, i, e, t, s, r));
}
function Lb(i, e, t, s, r) {
  var n = dc(i, e, t, s, r), a = Fr(n.year, 0, n.dayOfYear);
  return this.year(a.getUTCFullYear()), this.month(a.getUTCMonth()), this.date(a.getUTCDate()), this;
}
Q("Q", 0, "Qo", "quarter");
ct("quarter", "Q");
dt("quarter", 7);
V("Q", ic);
xe("Q", function(i, e) {
  e[ci] = (de(i) - 1) * 3;
});
function jb(i) {
  return i == null ? Math.ceil((this.month() + 1) / 3) : this.month((i - 1) * 3 + this.month() % 3);
}
Q("D", ["DD", 2], "Do", "date");
ct("date", "D");
dt("date", 9);
V("D", Te);
V("DD", Te, It);
V("Do", function(i, e) {
  return i ? e._dayOfMonthOrdinalParse || e._ordinalParse : e._dayOfMonthOrdinalParseLenient;
});
xe(["D", "DD"], ti);
xe("Do", function(i, e) {
  e[ti] = de(i.match(Te)[0]);
});
var Ec = or("Date", !0);
Q("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
ct("dayOfYear", "DDD");
dt("dayOfYear", 4);
V("DDD", za);
V("DDDD", sc);
xe(["DDD", "DDDD"], function(i, e, t) {
  t._dayOfYear = de(i);
});
function Eb(i) {
  var e = Math.round(
    (this.clone().startOf("day") - this.clone().startOf("year")) / 864e5
  ) + 1;
  return i == null ? e : this.add(i - e, "d");
}
Q("m", ["mm", 2], 0, "minute");
ct("minute", "m");
dt("minute", 14);
V("m", Te);
V("mm", Te, It);
xe(["m", "mm"], Wt);
var Ib = or("Minutes", !1);
Q("s", ["ss", 2], 0, "second");
ct("second", "s");
dt("second", 15);
V("s", Te);
V("ss", Te, It);
xe(["s", "ss"], di);
var Rb = or("Seconds", !1);
Q("S", 0, 0, function() {
  return ~~(this.millisecond() / 100);
});
Q(0, ["SS", 2], 0, function() {
  return ~~(this.millisecond() / 10);
});
Q(0, ["SSS", 3], 0, "millisecond");
Q(0, ["SSSS", 4], 0, function() {
  return this.millisecond() * 10;
});
Q(0, ["SSSSS", 5], 0, function() {
  return this.millisecond() * 100;
});
Q(0, ["SSSSSS", 6], 0, function() {
  return this.millisecond() * 1e3;
});
Q(0, ["SSSSSSS", 7], 0, function() {
  return this.millisecond() * 1e4;
});
Q(0, ["SSSSSSSS", 8], 0, function() {
  return this.millisecond() * 1e5;
});
Q(0, ["SSSSSSSSS", 9], 0, function() {
  return this.millisecond() * 1e6;
});
ct("millisecond", "ms");
dt("millisecond", 16);
V("S", za, ic);
V("SS", za, It);
V("SSS", za, sc);
var Ci, Ic;
for (Ci = "SSSS"; Ci.length <= 9; Ci += "S")
  V(Ci, lr);
function Yb(i, e) {
  e[us] = de(("0." + i) * 1e3);
}
for (Ci = "S"; Ci.length <= 9; Ci += "S")
  xe(Ci, Yb);
Ic = or("Milliseconds", !1);
Q("z", 0, 0, "zoneAbbr");
Q("zz", 0, 0, "zoneName");
function Nb() {
  return this._isUTC ? "UTC" : "";
}
function $b() {
  return this._isUTC ? "Coordinated Universal Time" : "";
}
var I = nn.prototype;
I.add = A_;
I.calendar = N_;
I.clone = $_;
I.diff = W_;
I.endOf = ib;
I.format = K_;
I.from = Q_;
I.fromNow = J_;
I.to = q_;
I.toNow = eb;
I.get = Bg;
I.invalidAt = cb;
I.isAfter = F_;
I.isBefore = B_;
I.isBetween = H_;
I.isSame = z_;
I.isSameOrAfter = X_;
I.isSameOrBefore = V_;
I.isValid = ub;
I.lang = Cc;
I.locale = kc;
I.localeData = Mc;
I.max = u_;
I.min = l_;
I.parsingFlags = hb;
I.set = Hg;
I.startOf = tb;
I.subtract = L_;
I.toArray = ab;
I.toObject = ob;
I.toDate = nb;
I.toISOString = G_;
I.inspect = Z_;
typeof Symbol < "u" && Symbol.for != null && (I[Symbol.for("nodejs.util.inspect.custom")] = function() {
  return "Moment<" + this.format() + ">";
});
I.toJSON = lb;
I.toString = U_;
I.unix = rb;
I.valueOf = sb;
I.creationData = db;
I.eraName = mb;
I.eraNarrow = _b;
I.eraAbbr = bb;
I.eraYear = yb;
I.year = cc;
I.isLeapYear = om;
I.weekYear = Tb;
I.isoWeekYear = kb;
I.quarter = I.quarters = jb;
I.month = uc;
I.daysInMonth = rm;
I.week = I.weeks = fm;
I.isoWeek = I.isoWeeks = pm;
I.weeksInYear = Ob;
I.weeksInWeekYear = Ab;
I.isoWeeksInYear = Cb;
I.isoWeeksInISOWeekYear = Mb;
I.date = Ec;
I.day = I.days = km;
I.weekday = Cm;
I.isoWeekday = Mm;
I.dayOfYear = Eb;
I.hour = I.hours = Rm;
I.minute = I.minutes = Ib;
I.second = I.seconds = Rb;
I.millisecond = I.milliseconds = Ic;
I.utcOffset = b_;
I.utc = v_;
I.local = x_;
I.parseZone = w_;
I.hasAlignedHourOffset = S_;
I.isDST = D_;
I.isLocal = T_;
I.isUtcOffset = k_;
I.isUtc = Sc;
I.isUTC = Sc;
I.zoneAbbr = Nb;
I.zoneName = $b;
I.dates = Bt(
  "dates accessor is deprecated. Use date instead.",
  Ec
);
I.months = Bt(
  "months accessor is deprecated. Use month instead",
  uc
);
I.years = Bt(
  "years accessor is deprecated. Use year instead",
  cc
);
I.zone = Bt(
  "moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
  y_
);
I.isDSTShifted = Bt(
  "isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
  P_
);
function Fb(i) {
  return Pe(i * 1e3);
}
function Bb() {
  return Pe.apply(null, arguments).parseZone();
}
function Rc(i) {
  return i;
}
var ye = Jl.prototype;
ye.calendar = kg;
ye.longDateFormat = Ag;
ye.invalidDate = jg;
ye.ordinal = Rg;
ye.preparse = Rc;
ye.postformat = Rc;
ye.relativeTime = Ng;
ye.pastFuture = $g;
ye.set = Pg;
ye.eras = fb;
ye.erasParse = pb;
ye.erasConvertYear = gb;
ye.erasAbbrRegex = xb;
ye.erasNameRegex = vb;
ye.erasNarrowRegex = wb;
ye.months = em;
ye.monthsShort = tm;
ye.monthsParse = sm;
ye.monthsRegex = am;
ye.monthsShortRegex = nm;
ye.week = um;
ye.firstDayOfYear = dm;
ye.firstDayOfWeek = cm;
ye.weekdays = wm;
ye.weekdaysMin = Dm;
ye.weekdaysShort = Sm;
ye.weekdaysParse = Tm;
ye.weekdaysRegex = Om;
ye.weekdaysShortRegex = Am;
ye.weekdaysMinRegex = Lm;
ye.isPM = Em;
ye.meridiem = Ym;
function Kn(i, e, t, s) {
  var r = xi(), n = oi().set(s, e);
  return r[t](n, i);
}
function Yc(i, e, t) {
  if (mi(i) && (e = i, i = void 0), i = i || "", e != null)
    return Kn(i, e, t, "month");
  var s, r = [];
  for (s = 0; s < 12; s++)
    r[s] = Kn(i, s, t, "month");
  return r;
}
function pu(i, e, t, s) {
  typeof i == "boolean" ? (mi(e) && (t = e, e = void 0), e = e || "") : (e = i, t = e, i = !1, mi(e) && (t = e, e = void 0), e = e || "");
  var r = xi(), n = i ? r._week.dow : 0, a, o = [];
  if (t != null)
    return Kn(e, (t + n) % 7, s, "day");
  for (a = 0; a < 7; a++)
    o[a] = Kn(e, (a + n) % 7, s, "day");
  return o;
}
function Hb(i, e) {
  return Yc(i, e, "months");
}
function zb(i, e) {
  return Yc(i, e, "monthsShort");
}
function Xb(i, e, t) {
  return pu(i, e, t, "weekdays");
}
function Vb(i, e, t) {
  return pu(i, e, t, "weekdaysShort");
}
function Wb(i, e, t) {
  return pu(i, e, t, "weekdaysMin");
}
ji("en", {
  eras: [
    {
      since: "0001-01-01",
      until: 1 / 0,
      offset: 1,
      name: "Anno Domini",
      narrow: "AD",
      abbr: "AD"
    },
    {
      since: "0000-12-31",
      until: -1 / 0,
      offset: 1,
      name: "Before Christ",
      narrow: "BC",
      abbr: "BC"
    }
  ],
  dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
  ordinal: function(i) {
    var e = i % 10, t = de(i % 100 / 10) === 1 ? "th" : e === 1 ? "st" : e === 2 ? "nd" : e === 3 ? "rd" : "th";
    return i + t;
  }
});
P.lang = Bt(
  "moment.lang is deprecated. Use moment.locale instead.",
  ji
);
P.langData = Bt(
  "moment.langData is deprecated. Use moment.localeData instead.",
  xi
);
var ui = Math.abs;
function Ub() {
  var i = this._data;
  return this._milliseconds = ui(this._milliseconds), this._days = ui(this._days), this._months = ui(this._months), i.milliseconds = ui(i.milliseconds), i.seconds = ui(i.seconds), i.minutes = ui(i.minutes), i.hours = ui(i.hours), i.months = ui(i.months), i.years = ui(i.years), this;
}
function Nc(i, e, t, s) {
  var r = Qt(e, t);
  return i._milliseconds += s * r._milliseconds, i._days += s * r._days, i._months += s * r._months, i._bubble();
}
function Gb(i, e) {
  return Nc(this, i, e, 1);
}
function Zb(i, e) {
  return Nc(this, i, e, -1);
}
function Hu(i) {
  return i < 0 ? Math.floor(i) : Math.ceil(i);
}
function Kb() {
  var i = this._milliseconds, e = this._days, t = this._months, s = this._data, r, n, a, o, l;
  return i >= 0 && e >= 0 && t >= 0 || i <= 0 && e <= 0 && t <= 0 || (i += Hu(Qo(t) + e) * 864e5, e = 0, t = 0), s.milliseconds = i % 1e3, r = Yt(i / 1e3), s.seconds = r % 60, n = Yt(r / 60), s.minutes = n % 60, a = Yt(n / 60), s.hours = a % 24, e += Yt(a / 24), l = Yt($c(e)), t += l, e -= Hu(Qo(l)), o = Yt(t / 12), t %= 12, s.days = e, s.months = t, s.years = o, this;
}
function $c(i) {
  return i * 4800 / 146097;
}
function Qo(i) {
  return i * 146097 / 4800;
}
function Qb(i) {
  if (!this.isValid())
    return NaN;
  var e, t, s = this._milliseconds;
  if (i = Ht(i), i === "month" || i === "quarter" || i === "year")
    switch (e = this._days + s / 864e5, t = this._months + $c(e), i) {
      case "month":
        return t;
      case "quarter":
        return t / 3;
      case "year":
        return t / 12;
    }
  else
    switch (e = this._days + Math.round(Qo(this._months)), i) {
      case "week":
        return e / 7 + s / 6048e5;
      case "day":
        return e + s / 864e5;
      case "hour":
        return e * 24 + s / 36e5;
      case "minute":
        return e * 1440 + s / 6e4;
      case "second":
        return e * 86400 + s / 1e3;
      case "millisecond":
        return Math.floor(e * 864e5) + s;
      default:
        throw new Error("Unknown unit " + i);
    }
}
function Jb() {
  return this.isValid() ? this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + de(this._months / 12) * 31536e6 : NaN;
}
function wi(i) {
  return function() {
    return this.as(i);
  };
}
var qb = wi("ms"), ey = wi("s"), ty = wi("m"), iy = wi("h"), sy = wi("d"), ry = wi("w"), ny = wi("M"), ay = wi("Q"), oy = wi("y");
function ly() {
  return Qt(this);
}
function uy(i) {
  return i = Ht(i), this.isValid() ? this[i + "s"]() : NaN;
}
function Ds(i) {
  return function() {
    return this.isValid() ? this._data[i] : NaN;
  };
}
var hy = Ds("milliseconds"), cy = Ds("seconds"), dy = Ds("minutes"), fy = Ds("hours"), py = Ds("days"), gy = Ds("months"), my = Ds("years");
function _y() {
  return Yt(this.days() / 7);
}
var hi = Math.round, Is = {
  ss: 44,
  // a few seconds to seconds
  s: 45,
  // seconds to minute
  m: 45,
  // minutes to hour
  h: 22,
  // hours to day
  d: 26,
  // days to month/week
  w: null,
  // weeks to month
  M: 11
  // months to year
};
function by(i, e, t, s, r) {
  return r.relativeTime(e || 1, !!t, i, s);
}
function yy(i, e, t, s) {
  var r = Qt(i).abs(), n = hi(r.as("s")), a = hi(r.as("m")), o = hi(r.as("h")), l = hi(r.as("d")), u = hi(r.as("M")), h = hi(r.as("w")), c = hi(r.as("y")), d = n <= t.ss && ["s", n] || n < t.s && ["ss", n] || a <= 1 && ["m"] || a < t.m && ["mm", a] || o <= 1 && ["h"] || o < t.h && ["hh", o] || l <= 1 && ["d"] || l < t.d && ["dd", l];
  return t.w != null && (d = d || h <= 1 && ["w"] || h < t.w && ["ww", h]), d = d || u <= 1 && ["M"] || u < t.M && ["MM", u] || c <= 1 && ["y"] || ["yy", c], d[2] = e, d[3] = +i > 0, d[4] = s, by.apply(null, d);
}
function vy(i) {
  return i === void 0 ? hi : typeof i == "function" ? (hi = i, !0) : !1;
}
function xy(i, e) {
  return Is[i] === void 0 ? !1 : e === void 0 ? Is[i] : (Is[i] = e, i === "s" && (Is.ss = e - 1), !0);
}
function wy(i, e) {
  if (!this.isValid())
    return this.localeData().invalidDate();
  var t = !1, s = Is, r, n;
  return typeof i == "object" && (e = i, i = !1), typeof i == "boolean" && (t = i), typeof e == "object" && (s = Object.assign({}, Is, e), e.s != null && e.ss == null && (s.ss = e.s - 1)), r = this.localeData(), n = yy(this, !t, s, r), t && (n = r.pastFuture(+this, n)), r.postformat(n);
}
var mo = Math.abs;
function Ts(i) {
  return (i > 0) - (i < 0) || +i;
}
function Qa() {
  if (!this.isValid())
    return this.localeData().invalidDate();
  var i = mo(this._milliseconds) / 1e3, e = mo(this._days), t = mo(this._months), s, r, n, a, o = this.asSeconds(), l, u, h, c;
  return o ? (s = Yt(i / 60), r = Yt(s / 60), i %= 60, s %= 60, n = Yt(t / 12), t %= 12, a = i ? i.toFixed(3).replace(/\.?0+$/, "") : "", l = o < 0 ? "-" : "", u = Ts(this._months) !== Ts(o) ? "-" : "", h = Ts(this._days) !== Ts(o) ? "-" : "", c = Ts(this._milliseconds) !== Ts(o) ? "-" : "", l + "P" + (n ? u + n + "Y" : "") + (t ? u + t + "M" : "") + (e ? h + e + "D" : "") + (r || s || i ? "T" : "") + (r ? c + r + "H" : "") + (s ? c + s + "M" : "") + (i ? c + a + "S" : "")) : "P0D";
}
var me = Za.prototype;
me.isValid = p_;
me.abs = Ub;
me.add = Gb;
me.subtract = Zb;
me.as = Qb;
me.asMilliseconds = qb;
me.asSeconds = ey;
me.asMinutes = ty;
me.asHours = iy;
me.asDays = sy;
me.asWeeks = ry;
me.asMonths = ny;
me.asQuarters = ay;
me.asYears = oy;
me.valueOf = Jb;
me._bubble = Kb;
me.clone = ly;
me.get = uy;
me.milliseconds = hy;
me.seconds = cy;
me.minutes = dy;
me.hours = fy;
me.days = py;
me.weeks = _y;
me.months = gy;
me.years = my;
me.humanize = wy;
me.toISOString = Qa;
me.toString = Qa;
me.toJSON = Qa;
me.locale = kc;
me.localeData = Mc;
me.toIsoString = Bt(
  "toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
  Qa
);
me.lang = Cc;
Q("X", 0, 0, "unix");
Q("x", 0, 0, "valueOf");
V("x", Va);
V("X", Xg);
xe("X", function(i, e, t) {
  t._d = new Date(parseFloat(i) * 1e3);
});
xe("x", function(i, e, t) {
  t._d = new Date(de(i));
});
//! moment.js
P.version = "2.29.4";
Sg(Pe);
P.fn = I;
P.min = h_;
P.max = c_;
P.now = d_;
P.utc = oi;
P.unix = Fb;
P.months = Hb;
P.isDate = rn;
P.locale = ji;
P.invalid = Fa;
P.duration = Qt;
P.isMoment = Kt;
P.weekdays = Xb;
P.parseZone = Bb;
P.localeData = xi;
P.isDuration = Ln;
P.monthsShort = zb;
P.weekdaysMin = Wb;
P.defineLocale = au;
P.updateLocale = Bm;
P.locales = Hm;
P.weekdaysShort = Vb;
P.normalizeUnits = Ht;
P.relativeTimeRounding = vy;
P.relativeTimeThreshold = xy;
P.calendarFormat = Y_;
P.prototype = I;
P.HTML5_FMT = {
  DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
  // <input type="datetime-local" />
  DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
  // <input type="datetime-local" step="1" />
  DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
  // <input type="datetime-local" step="0.001" />
  DATE: "YYYY-MM-DD",
  // <input type="date" />
  TIME: "HH:mm",
  // <input type="time" />
  TIME_SECONDS: "HH:mm:ss",
  // <input type="time" step="1" />
  TIME_MS: "HH:mm:ss.SSS",
  // <input type="time" step="0.001" />
  WEEK: "GGGG-[W]WW",
  // <input type="week" />
  MONTH: "YYYY-MM"
  // <input type="month" />
};
const Sy = {
  props: {
    styleProps: {
      type: String,
      default: ""
    },
    isDaily: Boolean,
    displayMonth: [Number, String],
    displayYear: [Number, String],
    minDate: [Object, Date],
    maxDate: [Object, Date],
    prevBtnHandler: Function,
    nextBtnHandler: Function,
    disableModal: {
      type: Boolean,
      default: !1
    }
  },
  data() {
    return {
      isOpenedModal: !1,
      currentYear: new Date().getFullYear(),
      baseYear: new Date().getFullYear(),
      minMonth: 1,
      maxMonth: 12,
      minYear: 2016,
      maxYear: 9999,
      selectedYear: 0
    };
  },
  methods: {
    toggleModal() {
      this.disableModal || (this.isOpenedModal = !this.isOpenedModal);
    },
    closeModal(i) {
      var r;
      const e = this.$refs.calendarModalRef, t = this.$refs.calendarModalOpenBtn, s = i.target;
      s === e || (r = t == null ? void 0 : t.parentNode) != null && r.contains(s) || e.contains(s) || (this.isOpenedModal = !1);
    },
    selectYear(i) {
      this.selectedYear = i, this.$emit("setSelectedYear", i), this.isOpenedModal = !1;
    },
    headerPrevBtnHandler() {
      this.prevBtnHandler && this.prevBtnHandler(), this.isDaily || this.$emit("setSelectedYear", Number(this.displayYear) - 1), this.isOpenedModal = !1;
    },
    headerNextBtnHandler() {
      this.nextBtnHandler && this.nextBtnHandler(), this.isDaily || this.$emit("setSelectedYear", Number(this.displayYear) + 1), this.isOpenedModal = !1;
    },
    modalPrevBtnHandler() {
      this.baseYear = this.baseYear - 9;
    },
    modalNextBtnHandler() {
      this.baseYear = this.baseYear + 9;
    }
  },
  computed: {
    yearRangeComputed() {
      let i = [];
      for (let e = 0; e < 9; e++)
        i.unshift(this.baseYear - e);
      return i;
    },
    maxDateComputed() {
      return this.maxDate ? P(this.maxDate).year() : P(new Date()).year();
    },
    displayMonthComputed() {
      return typeof this.displayMonth == "string" ? Number(P().month(this.displayMonth).format("MM")) : Number(this.displayMonth);
    },
    isDisabledPrevBtn() {
      if (this.isDaily) {
        if (this.displayMonthComputed === this.minMonth && Number(this.displayYear) === this.minYear)
          return !0;
      } else if (Number(this.displayYear) === this.minYear)
        return !0;
      return !1;
    },
    isDisabledNextBtn() {
      if (this.isDaily) {
        if (this.displayMonthComputed === this.maxMonth && Number(this.displayYear) === this.maxYear)
          return !0;
      } else if (Number(this.displayYear) === this.maxDateComputed)
        return !0;
      return !1;
    }
  },
  watch: {
    isOpenedModal() {
      this.isOpenedModal ? window.addEventListener("click", this.closeModal) : window.removeEventListener("click", this.closeModal);
    }
  },
  mounted() {
    this.minDate && (this.minYear = Number(P(this.minDate).format("YYYY")), this.minMonth = Number(P(this.minDate).format("MM"))), this.maxDate && (this.maxYear = Number(P(this.maxDate).format("YYYY")), this.maxMonth = Number(P(this.maxDate).format("MM")));
  },
  unmounted() {
    window.removeEventListener("click", this.closeModal);
  }
};
var Dy = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", [t("div", {
    class: i.$style["calender-header-container"],
    style: i.styleProps
  }, [t("span", {
    class: [i.$style["arrow-icon"], i.$style["-left"]],
    attrs: {
      disabled: i.isDisabledPrevBtn
    },
    on: {
      click: i.headerPrevBtnHandler
    }
  }), t("div", {
    ref: "calendarModalOpenBtn",
    class: i.$style["display-date"],
    attrs: {
      disabled: i.disableModal
    },
    on: {
      click: i.toggleModal
    }
  }, [i._t("default")], 2), t("span", {
    class: [i.$style["arrow-icon"], i.$style["-right"]],
    attrs: {
      disabled: i.isDisabledNextBtn
    },
    on: {
      click: i.headerNextBtnHandler
    }
  }), t("transition", {
    attrs: {
      name: "fade-transition"
    }
  }, [i.isOpenedModal ? t("div", {
    ref: "calendarModalRef",
    class: i.$style["inner-modal-container"]
  }, [t("div", [t("span", {
    class: [i.$style["modal-arrow-icon"], i.$style["-left"]],
    on: {
      click: i.modalPrevBtnHandler
    }
  })]), t("div", {
    class: i.$style["btn-group"]
  }, i._l(i.yearRangeComputed, function(s) {
    return t("div", {
      key: s,
      class: i.$style[`${Number(i.displayYear) === s ? "selected-year" : ""}`],
      attrs: {
        disabled: s < i.minYear || s > i.maxDateComputed
      },
      on: {
        click: function(r) {
          return i.selectYear(s);
        }
      }
    }, [i._v(" " + i._s(s) + " ")]);
  }), 0), t("div", [t("span", {
    class: [i.$style["modal-arrow-icon"], i.$style["-right"]],
    on: {
      click: i.modalNextBtnHandler
    }
  })])]) : i._e()])], 1)]);
}, Py = [];
const Ty = {
  "calender-header-container": "_calender-header-container_nxrn4_8",
  "display-date": "_display-date_nxrn4_17",
  "arrow-icon": "_arrow-icon_nxrn4_25",
  "-left": "_-left_nxrn4_32",
  "-right": "_-right_nxrn4_35",
  "inner-modal-container": "_inner-modal-container_nxrn4_43",
  "btn-group": "_btn-group_nxrn4_57",
  "selected-year": "_selected-year_nxrn4_84",
  "modal-arrow-icon": "_modal-arrow-icon_nxrn4_97"
};
const Jo = {};
Jo.$style = Ty;
var ky = /* @__PURE__ */ te(
  Sy,
  Dy,
  Py,
  !1,
  Cy,
  "5082660f",
  null,
  null
);
function Cy(i) {
  for (let e in Jo)
    this[e] = Jo[e];
}
const Ja = /* @__PURE__ */ function() {
  return ky.exports;
}();
var My = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    staticClass: "emdn-daily-calendar"
  }, [t("div", {
    staticClass: "daily-container"
  }, [t("calendar-header", {
    attrs: {
      "style-props": "margin-bottom: 12px;",
      "display-month": i.displayMonth,
      "display-year": i.displayYear,
      "prev-btn-handler": i.prevBtnHandler,
      "next-btn-handler": i.nextBtnHandler,
      "min-date": i.minDate,
      "max-date": i.maxDate,
      "is-daily": !0
    },
    on: {
      setSelectedYear: i.setDisplayYear
    }
  }, [t("span", [i._v(i._s(i.displayMonthComputed) + " ")]), t("span", {
    staticStyle: {
      color: "#3491ff"
    }
  }, [i._v(i._s(i.displayYear))])]), t("v-date-picker", {
    ref: "calendarRef",
    attrs: {
      attributes: i.attrs,
      mode: "single",
      "min-date": i.changeToDateObj(i.minDate),
      "max-date": i.changeToDateObj(i.maxDate),
      "is-inline": !0,
      "is-range": i.mode === "range"
    },
    on: {
      input: i.executor,
      "update:from-page": i.pageChange
    },
    scopedSlots: i._u([{
      key: "header-left-button",
      fn: function() {
        return [t("span")];
      },
      proxy: !0
    }, {
      key: "header-right-button",
      fn: function() {
        return [t("span")];
      },
      proxy: !0
    }, {
      key: "header",
      fn: function() {
        return [t("span")];
      },
      proxy: !0
    }]),
    model: {
      value: i.date,
      callback: function(s) {
        i.date = s;
      },
      expression: "date"
    }
  })], 1)]);
}, Oy = [];
const Ay = {
  name: "EmdnCalendar",
  components: { CalendarHeader: Ja },
  props: {
    attrs: Array,
    minDate: {
      type: [Date, Object],
      default: () => new Date(P("20160101", "YYYYMMDD"))
    },
    maxDate: {
      type: [Date, Object],
      default: () => new Date()
    },
    clickHandler: Function,
    mode: String,
    dateRangeComputed: Object,
    setDateRangeData: Function
  },
  data() {
    return {
      date: "",
      displayYear: 0,
      minMonth: 1,
      maxMonth: 12,
      displayMonth: ""
    };
  },
  computed: {
    displayMonthComputed() {
      return typeof this.displayMonth == "number" ? P(String(this.displayMonth), "MM").format("MMMM") : P(this.displayMonth, "MMMM").format("MMMM");
    }
  },
  mounted() {
    const i = this.$refs.calendarRef;
    let e = this.dateRangeComputed.start, t = this.dateRangeComputed.end;
    this.dateRangeComputed.start || (e = this.dateRangeComputed), this.minDate && (this.minMonth = Number(P(this.minDate).format("MM"))), this.maxMonth && (this.maxMonth = Number(P(this.maxDate).format("MM"))), this.mode === "single" ? (this.date = P(e).format("YYYY-MM-DD"), this.displayYear = P(e).format("YYYY"), this.displayMonth = P(e).format("MMMM"), this.setDateRangeData && this.setDateRangeData({
      start: P(e),
      end: P(e)
    }), i.move(this.date, { transition: "none" })) : (this.date = {
      ...this.date,
      start: P(e),
      end: P(t)
    }, this.displayYear = P(e).format("YYYY"), this.displayMonth = P(e).format("MMMM"), i.move(this.date.start, { transition: "none" }));
  },
  methods: {
    executor() {
      this.date && this.mode === "single" && this.clickHandler({ start: this.date, end: this.date }), this.date && this.mode === "range" && this.clickHandler(this.date);
    },
    prevBtnHandler() {
      if (typeof this.displayMonth == "string" && (this.displayMonth = Number(
        P().month(this.displayMonth).format("MM")
      )), Number(P(this.minDate).format("YYYY")) === Number(this.displayYear) && this.displayMonth === this.minMonth)
        return;
      this.$refs.calendarRef.move(-1, { transition: "none" });
    },
    nextBtnHandler() {
      if (Number(P(this.maxDate).format("YYYY")) === Number(this.displayYear) && Number(this.displayMonth) === Number(this.maxMonth))
        return;
      this.$refs.calendarRef.move(1, { transition: "none" });
    },
    pageChange(i) {
      this.displayYear = i.year, this.displayMonth = i.month;
    },
    setDisplayYear(i) {
      this.$refs.calendarRef.move(
        {
          month: i === Number(P(this.minDate).format("YYYY")) ? this.minMonth : i === Number(P(this.maxDate).format("YYYY")) ? this.maxMonth : 1,
          year: i
        },
        { transition: "none" }
      );
    },
    changeToDateObj(i) {
      return new Date(i);
    }
  }
}, zu = {};
var Ly = /* @__PURE__ */ te(
  Ay,
  My,
  Oy,
  !1,
  jy,
  null,
  null,
  null
);
function jy(i) {
  for (let e in zu)
    this[e] = zu[e];
}
const Ey = /* @__PURE__ */ function() {
  return Ly.exports;
}();
var Iy = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    staticClass: "monthly-date-picker-container"
  }, [t("calendar-header", {
    attrs: {
      "style-props": "margin-bottom: 20px;",
      "prev-btn-handler": i.prevBtnHandler,
      "next-btn-handler": i.nextBtnHandler,
      "min-date": i.minDate,
      "max-date": i.maxDate,
      "display-year": i.currentYear
    },
    on: {
      setSelectedYear: i.setDisplayYear
    }
  }, [i.selectedMonth ? t("span", [i._v(i._s(i.selectedMonthToString) + " ")]) : i._e(), t("span", {
    staticStyle: {
      color: "#3491ff"
    }
  }, [i._v(i._s(i.currentYear))])]), t("div", {
    staticClass: "date-picker-body"
  }, i._l(i.getNumberOfMonth(), function(s, r) {
    return t("div", {
      key: r,
      staticClass: "date-picker-month-item"
    }, [t("span", {
      staticClass: "date-picker-month-text",
      class: {
        "date-picker-today": i.currentYear == i.getMaxYear && s == i.getCurrentMonth(i.today),
        "date-picker-selected-month": i.isSelected(s),
        "date-picker-disable": i.getIsDisabledMonth(s)
      },
      on: {
        click: function(n) {
          return i.selectMonthHandler(s, i.currentYear);
        }
      }
    }, [i._v(i._s(i.displayMonthName(s)))])]);
  }), 0)], 1);
}, Ry = [];
const Yy = {
  components: { CalendarHeader: Ja },
  props: {
    dateRangeComputed: {
      type: Object,
      default: () => ({ start: P(new Date()), end: P(new Date()) })
    },
    setDateRangeData: Function,
    clickHandler: Function,
    dateRange: Object,
    minDate: {
      type: [Object, Date],
      default: () => P("20160101", "YYYYMMDD")
    },
    maxDate: { type: [Object, Date], default: () => P(new Date()) }
  },
  data() {
    return {
      today: "",
      currentYear: "",
      selectedMonth: "",
      selectedYear: ""
    };
  },
  mounted() {
    this.today = new Date(), this.dateRange.start ? this.currentYear = this.getCurrentYear(this.dateRange.start) : this.currentYear = this.getCurrentYear(this.today), this.selectMonthHandler(this.selectedMonth, this.currentYear);
  },
  watch: {
    dateRangeComputed: {
      handler(i) {
        this.selectedMonth = this.getCurrentMonth(i.end), this.selectedYear = this.getCurrentYear(i.end);
      },
      immediate: !0,
      deep: !0
    }
  },
  computed: {
    getMaxYear() {
      return this.maxDate ? P(this.maxDate).year() : P(this.today).year();
    },
    selectedMonthToString() {
      return P(this.selectedMonth, "MM").format("MMMM");
    }
  },
  methods: {
    prevBtnHandler() {
      this.currentYear--;
    },
    nextBtnHandler() {
      this.currentYear++;
    },
    displayMonthName(i) {
      return P(i, "MM").format("MMM");
    },
    getNumberOfMonth() {
      return Number(P(`${this.currentYear}1231`, "YYYYMMDD").format("MM"));
    },
    getCurrentMonth(i) {
      return Number(P(new Date(i)).format("MM"));
    },
    getIsDisabledMonth(i) {
      return Number(this.currentYear) === Number(P(this.minDate).format("YYYY")) && P(this.minDate).format("MM") > i || Number(this.currentYear) === Number(P(this.maxDate).format("YYYY")) && P(this.maxDate).format("MM") < i;
    },
    isSelected(i) {
      return i == this.selectedMonth && this.currentYear == this.selectedYear;
    },
    selectMonthHandler(i, e) {
      i < 10 && (i = "0" + i);
      let t = `${e}${i}`, s = P(t, "YYYYMM").toDate(), r = P(t, "YYYYMM").endOf("month").toDate();
      this.setDateRangeData && this.setDateRangeData({ start: s, end: r }), this.clickHandler({ start: s, end: r });
    },
    getCurrentYear(i) {
      return P(i).format("YYYY");
    },
    setDisplayYear(i) {
      this.selectedMonth = "", this.currentYear = i;
    }
  }
}, Xu = {};
var Ny = /* @__PURE__ */ te(
  Yy,
  Iy,
  Ry,
  !1,
  $y,
  "1ed97250",
  null,
  null
);
function $y(i) {
  for (let e in Xu)
    this[e] = Xu[e];
}
const Fy = /* @__PURE__ */ function() {
  return Ny.exports;
}();
var By = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    staticClass: "weekly-date-picker-container"
  }, [t("calendar-header", {
    attrs: {
      "display-year": i.displayYear,
      "min-date": i.minDate,
      "max-date": i.maxDate
    },
    on: {
      setSelectedYear: i.setDisplayYear
    }
  }, [t("span", [i._v("Week ")]), i.displayYear == i.selectedYear ? t("span", [i._v(i._s(i.selectedWeek) + " ")]) : i._e(), t("span", {
    staticStyle: {
      color: "#3491ff"
    }
  }, [i._v(i._s(i.displayYear))])]), t("div", {
    staticClass: "date-picker-body"
  }, i._l(i.getNumberOfWeek(), function(s, r) {
    return t("div", {
      key: r,
      staticClass: "date-picker-week-item",
      class: {
        "date-picker-disable": i.isDisabledWeek(s, i.displayYear)
      },
      on: {
        click: function(n) {
          return i.selectWeekHandler(s, i.displayYear);
        }
      }
    }, [t("span", {
      staticClass: "date-picker-week-number",
      class: {
        "date-picker-today": i.displayYear == i.currentYear && s == i.getCurrentWeek(),
        "date-picker-selected": i.isSelectedWeek(s)
      }
    }, [i._v(" " + i._s(s) + " ")])]);
  }), 0)], 1);
}, Hy = [];
const zy = {
  components: { CalendarHeader: Ja },
  props: {
    clickHandler: Function,
    minDate: {
      type: [Object, Date],
      default: () => P("20160101", "YYYYMMDD")
    },
    maxDate: { type: [Object, Date], default: () => P(new Date()) },
    dateRangeComputed: {
      type: Object,
      default: () => ({ start: P(), end: P() })
    },
    setDateRangeData: Function
  },
  data() {
    return {
      displayYear: 0,
      currentYear: P(new Date()).format("YYYY"),
      // 올해
      selectedWeek: null,
      // 선택된 주
      selectedYear: null,
      // 선택된 년도
      selectedSecondWeek: null,
      // 선택된 두번째 주(range일 때 사용?)
      selectedSecondYear: null
      // 선택된 두번째 년도(range 일때 사용?)
    };
  },
  watch: {
    dateRangeComputed: {
      handler(i) {
        this.selectedWeek = this.getWeek(i.end), this.selectedYear = this.getYear(i.end);
      },
      immediate: !0,
      deep: !0
    }
  },
  mounted() {
    this.dateRangeComputed.start ? this.displayYear = P(this.dateRangeComputed.end).format("YYYY") : this.displayYear = P(new Date()).format("YYYY"), this.currentYear = P(new Date()).format("YYYY"), this.selectWeekHandler(this.selectedWeek, this.selectedYear);
    let i = P(this.dateRangeComputed.end).startOf("week"), e = P(this.dateRangeComputed.end).endOf("week");
    this.setDateRangeData({ start: i, end: e });
  },
  computed: {
    getMaxYear() {
      return new Date().getFullYear();
    }
  },
  methods: {
    selectWeekHandler(i, e) {
      let t = `${e}${i}`, s = P(t, "YYYYWW").startOf("week"), r = P(t, "YYYYWW").endOf("week");
      this.setDateRangeData({ start: s, end: r }), this.clickHandler({ start: s, end: r });
    },
    // param으로 넘어온 주가 선택된 주인지 확인
    isSelectedWeek(i) {
      return i == this.selectedWeek && this.selectedYear == this.displayYear;
    },
    // 선택된 날짜가 몇째주인지 구하기
    getWeek(i) {
      return P(i, "YYYYMMDD").subtract(3, "days").format("WW");
    },
    // 오늘 날짜가 몇 번째 주인지 구하기
    getCurrentWeek() {
      return P(new Date()).format("WW");
    },
    // 현재 년도에 몇주까지 있는지 구하기
    getNumberOfWeek() {
      return Number(P(this.displayYear, "YYYY").isoWeeksInYear());
    },
    // 현재 년도가 몇인지 반환
    getYear(i) {
      return P(i, "YYYYMMDD").subtract(3, "days").format("YYYY");
    },
    // 헤더에서 받아온 연도로 displayYear 교체
    setDisplayYear(i) {
      this.displayYear = i;
    },
    // 해당 주차가 min or maxDate에 걸리는지 여부 반환
    isDisabledWeek(i, e) {
      return Number(e) === Number(P(this.minDate).format("YYYY")) && Number(P(this.minDate).format("WW")) > i || Number(e) === Number(P(this.maxDate).format("YYYY")) && Number(P(this.maxDate).format("WW")) < i;
    }
  }
}, Vu = {};
var Xy = /* @__PURE__ */ te(
  zy,
  By,
  Hy,
  !1,
  Vy,
  "66e0f763",
  null,
  null
);
function Vy(i) {
  for (let e in Vu)
    this[e] = Vu[e];
}
const Wy = /* @__PURE__ */ function() {
  return Xy.exports;
}();
var Uy = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    staticClass: "date-block"
  }, [t("div", {
    staticClass: "yearly block"
  }, [t("calendar-header", {
    attrs: {
      "style-props": "margin-bottom: 12px;",
      "disable-modal": !0,
      "prev-btn-handler": i.prevYearRange,
      "next-btn-handler": i.nextYearRange
    }
  }, [t("span", [i._v(i._s(i.yearRange) + "-" + i._s(i.yearRange + 11))])]), i.today.getFullYear() < i.yearRange ? t("div", {
    staticClass: "wrapper-year"
  }, i._l(12, function(s) {
    return t("div", {
      key: s,
      staticClass: "year-item"
    }, [t("span", {
      staticClass: "disable year-text"
    }, [i._v(i._s(i.yearRange + s - 1))])]);
  }), 0) : i.today.getFullYear() <= i.yearRange + 11 && i.today.getFullYear() >= i.yearRange ? t("div", {
    staticClass: "wrapper-year"
  }, i._l(12, function(s) {
    return t("div", {
      key: s,
      staticClass: "year-item"
    }, [i.yearRange + s - 1 > i.today.getFullYear() ? t("span", {
      staticClass: "disable year-text"
    }, [i._v(i._s(i.yearRange + s - 1))]) : i.yearRange + s - 1 == i.today.getFullYear() ? t("span", {
      staticClass: "today year-text",
      class: {
        selected: i.isSelected(s)
      },
      on: {
        click: function(r) {
          return i.handleSelectYear(i.yearRange + s - 1);
        }
      }
    }, [i._v(i._s(i.yearRange + s - 1))]) : t("span", {
      staticClass: "year-text",
      class: {
        selected: i.isSelected(s)
      },
      on: {
        click: function(r) {
          return i.handleSelectYear(i.yearRange + s - 1);
        }
      }
    }, [i._v(i._s(i.yearRange + s - 1))])]);
  }), 0) : t("div", {
    staticClass: "wrapper-year"
  }, i._l(12, function(s) {
    return t("div", {
      key: s,
      staticClass: "year-item"
    }, [t("span", {
      staticClass: "year-text",
      class: {
        selected: i.isSelected(s)
      },
      on: {
        click: function(r) {
          return i.handleSelectYear(i.yearRange + s - 1);
        }
      }
    }, [i._v(i._s(i.yearRange + s - 1))])]);
  }), 0)], 1)]);
}, Gy = [];
const Zy = {
  components: { CalendarHeader: Ja },
  props: {
    clickHandler: Function,
    isRange: {
      type: Boolean,
      default: () => !1
    },
    minDate: {
      type: [Object, Date],
      default: () => P("20160101", "YYYYMMDD")
    },
    maxDate: { type: [Object, Date], default: () => P(new Date()) },
    currentDate: {
      type: Object,
      default: () => ({})
    },
    dateRange: {
      type: Object,
      default: () => ({
        minDate: null,
        maxDate: P(new Date())
      })
    },
    frequency: {
      type: String,
      default: () => ""
    },
    dateRangeComputed: {
      type: Object,
      default: () => ({})
    },
    setDateRangeData: Function
  },
  data() {
    return {
      date: {
        start: null,
        end: null
      },
      dateTitle: {
        start: "",
        end: ""
      },
      yearRange: 2016,
      selectedYear: null,
      selectedSecondYear: null,
      pickStep: 0,
      minYear: 0,
      maxYear: 9999
    };
  },
  created() {
    this.today = new Date();
    let i = new Date().getFullYear();
    this.dateRangeComputed ? this.handleSelectYear(
      P(this.dateRangeComputed.start).format("YYYY")
    ) : this.handleSelectYear(i), this.minDate && (this.yearRange = Number(P(this.minDate).format("YYYY")));
  },
  computed: {},
  watch: {
    frequency(i) {
      i.includes("YEAR") && this.clearPickingData();
    }
  },
  methods: {
    isSelected(i) {
      return this.yearRange + i - 1 == this.selectedYear || this.yearRange + i - 1 == this.selectedSecondYear;
    },
    getFrequency() {
      return this.isRange ? "YEARLY_RANGE" : "YEARLY";
    },
    changeDate() {
      let i = this.getDateRange(), e = {
        start: i.start ? P(i.start).format("YYYY-MM-DD") : "",
        end: i.end ? P(i.end).format("YYYY-MM-DD") : ""
      };
      this.clickHandler(i), this.$emit("change-date", i, e);
    },
    prevYearRange() {
      this.yearRange <= 18 ? this.yearRange = 1 : this.yearRange -= 12;
    },
    nextYearRange() {
      this.yearRange == 1 ? this.yearRange = 18 : this.yearRange += 12;
    },
    handleSelectYear(i) {
      this.isRange ? this.pickStep == 2 ? this.clearPickingData() : this.pickStep == 0 ? i != this.selectedYear ? (this.selectedYear = i, this.pickStep++) : this.clearPickingData() : this.pickStep == 1 && (i != this.selectedYear ? (i < this.selectedYear ? (this.selectedSecondYear = this.selectedYear, this.selectedYear = i) : this.selectedSecondYear = i, this.pickStep++) : this.clearPickingData()) : this.selectedYear != i ? this.selectedYear = i : this.selectedYear = new Date().getFullYear(), this.changeDate();
    },
    getDateRange() {
      let i = null, e = null;
      return this.isRange ? (this.selectedYear && (i = new Date(this.selectedYear, 0, 1)), this.selectedSecondYear && (e = new Date(this.selectedSecondYear, 0, 1))) : this.selectedYear && (i = new Date(this.selectedYear, 0, 1), e = new Date(this.selectedYear, 11, 31)), {
        start: i,
        end: e
      };
    },
    clearPickingData() {
      this.selectedYear = new Date().getFullYear(), this.changeDate(), this.selectedSecondYear = null, this.pickStep = 0;
    }
  }
}, Wu = {};
var Ky = /* @__PURE__ */ te(
  Zy,
  Uy,
  Gy,
  !1,
  Qy,
  "736262f4",
  null,
  null
);
function Qy(i) {
  for (let e in Wu)
    this[e] = Wu[e];
}
const Jy = /* @__PURE__ */ function() {
  return Ky.exports;
}();
var qy = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    staticClass: "date-picker-input-container"
  }, [t("div", {
    staticClass: "input-box"
  }, [t("label", [i._v("From")]), t("input", {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: i.fromDate,
      expression: "fromDate"
    }],
    attrs: {
      placeholder: "yyyy-mm-dd",
      type: "text"
    },
    domProps: {
      value: i.fromDate
    },
    on: {
      input: function(s) {
        s.target.composing || (i.fromDate = s.target.value);
      }
    }
  })]), t("div", {
    staticClass: "input-box"
  }, [t("label", [i._v("To")]), t("input", {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: i.toDate,
      expression: "toDate"
    }],
    attrs: {
      placeholder: "yyyy-mm-dd",
      type: "text"
    },
    domProps: {
      value: i.toDate
    },
    on: {
      input: function(s) {
        s.target.composing || (i.toDate = s.target.value);
      }
    }
  })])]);
}, ev = [];
const tv = {
  name: "DatePickerInput",
  props: {
    dateRangeComputed: Object
  },
  data() {
    return {
      fromDate: "",
      toDate: ""
    };
  },
  watch: {
    dateRangeComputed: {
      handler(i) {
        this.fromDate = P(i.start).format("YYYY-MM-DD"), this.toDate = P(i.end).format("YYYY-MM-DD");
      },
      immediate: !0
    }
  }
}, Uu = {};
var iv = /* @__PURE__ */ te(
  tv,
  qy,
  ev,
  !1,
  sv,
  "f6e0fb66",
  null,
  null
);
function sv(i) {
  for (let e in Uu)
    this[e] = Uu[e];
}
const rv = /* @__PURE__ */ function() {
  return iv.exports;
}();
var nv = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", i._l(i.selectorOptions, function(s, r) {
    return t("CtaButton", {
      key: r,
      staticClass: "customStyle",
      attrs: {
        "color-type": s === i.timeScale ? "blue-fill" : "",
        "style-props": "width : 171px; height: 25px",
        "click-handler": function() {
          return i.executor(s);
        }
      }
    }, [i._v(" " + i._s(i.capitalizeFirstLetter(s)) + " ")]);
  }), 1);
}, av = [];
const ov = {
  components: {
    CtaButton: $a
  },
  name: "SelectorCalendar",
  props: {
    clickHandler: Function,
    timeScale: String,
    selectorOptions: {
      type: Array,
      default: () => ["date", "week", "month", "year", "custom"]
    }
  },
  methods: {
    executor(i) {
      this.clickHandler(i);
    },
    capitalizeFirstLetter(i) {
      return i.charAt(0).toUpperCase() + i.slice(1);
    }
  }
}, Gu = {};
var lv = /* @__PURE__ */ te(
  ov,
  nv,
  av,
  !1,
  uv,
  "041f8051",
  null,
  null
);
function uv(i) {
  for (let e in Gu)
    this[e] = Gu[e];
}
const hv = /* @__PURE__ */ function() {
  return lv.exports;
}();
var cv = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    class: [i.$style["calendar-container"]],
    style: i.styleProps
  }, [t("div", {
    class: i.$style[i.showSelector ? "" : "calendar-single"]
  }, [i.newTimeScale === "date" ? t("Daily", {
    key: "daily",
    attrs: {
      "click-handler": i.dateClickHandler,
      attributes: i.attrs,
      mode: "single",
      "max-date": i.maxDate,
      "min-date": i.minDate,
      "date-range-computed": i.dateRangeComputed,
      "set-date-range-data": i.setDateRangeData
    }
  }) : i._e(), i.newTimeScale === "month" ? t("Monthly", {
    attrs: {
      "click-handler": i.dateClickHandler,
      "date-range-computed": i.dateRangeComputed,
      "set-date-range-data": i.setDateRangeData,
      "date-range": i.dateRange,
      "max-date": i.maxDate,
      "min-date": i.minDate
    }
  }) : i._e(), i.newTimeScale === "week" ? t("Weekly", {
    attrs: {
      "click-handler": i.dateClickHandler,
      "date-range-computed": i.dateRangeComputed,
      "set-date-range-data": i.setDateRangeData,
      "max-date": i.maxDate,
      "min-date": i.minDate
    }
  }) : i._e(), i.newTimeScale === "year" ? t("yearly", {
    attrs: {
      "click-handler": i.dateClickHandler,
      "date-range-computed": i.dateRangeComputed,
      "set-date-range-data": i.setDateRangeData,
      "max-date": i.maxDate,
      "min-date": i.minDate
    }
  }) : i._e(), i.newTimeScale === "custom" ? t("Daily", {
    key: "custom",
    attrs: {
      "click-handler": i.dateClickHandler,
      attributes: i.attrs,
      mode: "range",
      "max-date": i.maxDate,
      "min-date": i.minDate,
      "date-range-computed": i.dateRangeComputed,
      "set-date-range-data": i.setDateRangeData
    }
  }) : i._e(), i.showSelector ? t("DatePickerInput", {
    attrs: {
      "date-range-computed": i.dateRangeComputed
    }
  }) : i._e()], 1), i.showSelector ? t("Selector", {
    attrs: {
      "click-handler": i.handleChange,
      "selector-options": i.selectorOptions,
      "time-scale": i.newTimeScale
    }
  }) : i._e()], 1);
}, dv = [];
const fv = {
  "calendar-container": "_calendar-container_10iou_7",
  "calendar-single": "_calendar-single_10iou_15"
}, pv = {
  components: {
    Daily: Ey,
    Monthly: Fy,
    Weekly: Wy,
    Yearly: Jy,
    DatePickerInput: rv,
    Selector: hv
  },
  name: "EmdnCalendar",
  props: {
    styleProps: String,
    showSelector: {
      type: Boolean,
      default: !1
    },
    attrs: Array,
    maxDate: Object,
    minDate: Object,
    timeScale: String,
    clickHandler: Function,
    dateFormat: { type: String, default: "" },
    selectorOptions: {
      type: Array,
      default: () => ["date", "week", "month", "year", "custom"]
    },
    dateRange: {
      type: Object,
      default: () => ({ start: P(new Date()), end: P(new Date()) })
    }
  },
  data() {
    return {
      dateRangeData: {},
      newTimeScale: ""
    };
  },
  computed: {
    dateRangeComputed() {
      return this.dateRangeData.start ? this.dateRangeData : this.dateRange;
    }
  },
  methods: {
    setDateRangeData(i) {
      this.dateRangeData = i;
    },
    dateClickHandler(i) {
      var t;
      this.dateRangeData = i;
      let e = {};
      return this.dateFormat ? e = {
        start: P(i.start).format(this.dateFormat),
        end: P(i.end).format(this.dateFormat)
      } : e = {
        start: P(i.start),
        end: P(i.end)
      }, this.clickHandler && this.clickHandler(e, (t = this.newTimeScale) == null ? void 0 : t.toUpperCase()), e;
    },
    handleChange(i) {
      this.newTimeScale = i;
    }
  },
  created() {
    this.newTimeScale = this.timeScale ? this.timeScale : this.selectorOptions[0];
  }
}, qo = {};
qo.$style = fv;
var gv = /* @__PURE__ */ te(
  pv,
  cv,
  dv,
  !1,
  mv,
  null,
  null,
  null
);
function mv(i) {
  for (let e in qo)
    this[e] = qo[e];
}
const QO = /* @__PURE__ */ function() {
  return gv.exports;
}(), _v = "_filter_1nevh_44", bv = "_icon_size_1nevh_47", yv = "_edit_1nevh_58", vv = "_trash_1nevh_64", xv = "_clone_1nevh_70", wv = "_check_1nevh_76", Sv = "_previous_1nevh_88", Dv = "_add_1nevh_116", Pv = "_remove_1nevh_119", Tv = "_download_1nevh_180", kv = "_next_1nevh_135", Cv = "_expand_1nevh_250", _o = {
  default: "_default_1nevh_7",
  "customizing-data-table": "_customizing-data-table_1nevh_25",
  filter: _v,
  icon_size: bv,
  "custom-colum": "_custom-colum_1nevh_51",
  "kebab-menu": "_kebab-menu_1nevh_54",
  edit: yv,
  trash: vv,
  clone: xv,
  check: wv,
  previous: Sv,
  "left-arrow": "_left-arrow_1nevh_102",
  add: Dv,
  remove: Pv,
  "row-inline-action-buttons": "_row-inline-action-buttons_1nevh_122",
  "next-previous-buttons": "_next-previous-buttons_1nevh_135",
  "plus-button": "_plus-button_1nevh_155",
  "minus-button": "_minus-button_1nevh_172",
  download: Tv,
  next: kv,
  "arrow-backward-skinny": "_arrow-backward-skinny_1nevh_204",
  "arrow-forward-skinny": "_arrow-forward-skinny_1nevh_214",
  "arrow-backward": "_arrow-backward_1nevh_204",
  "arrow-forward": "_arrow-forward_1nevh_214",
  "bar-filter": "_bar-filter_1nevh_244",
  expand: Cv
}, Mv = {
  name: "icon-button",
  props: {
    styleProps: {
      type: String,
      default: ""
    },
    clickHandler: Function,
    active: Boolean,
    disabled: Boolean,
    buttonType: {
      type: String,
      default: "filter"
    },
    iconUrl: {
      type: String
    }
  },
  computed: {
    buttonClassComputed() {
      return `${_o.default} ${_o[this.buttonType]} ${_o[this.classTypeForButton]} `;
    },
    classTypeForButton() {
      switch (this.buttonType) {
        case "filter":
        case "download":
        case "custom-colum":
        case "kebab-menu":
          return "customizing-data-table";
        case "edit":
        case "trash":
        case "check":
        case "clone":
          return "row-inline-action-buttons";
        case "add":
          return "plus-button";
        case "remove":
          return "minus-button";
        default:
          return "";
      }
    }
  },
  methods: {
    executor() {
      this.clickHandler && this.clickHandler();
    }
  }
};
var Ov = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    class: i.buttonClassComputed,
    style: i.styleProps,
    attrs: {
      active: i.active,
      disabled: i.disabled
    },
    on: {
      click: i.executor
    }
  }, [t("div", {
    class: i.$style.icon_size
  }, [i.buttonType === "custom-button" ? t("img", {
    attrs: {
      src: i.iconUrl,
      alt: "icon"
    }
  }) : t("img", {
    attrs: {
      src: "#",
      alt: "icon"
    }
  })])]);
}, Av = [];
const Lv = "_filter_1nevh_44", jv = "_icon_size_1nevh_47", Ev = "_edit_1nevh_58", Iv = "_trash_1nevh_64", Rv = "_clone_1nevh_70", Yv = "_check_1nevh_76", Nv = "_previous_1nevh_88", $v = "_add_1nevh_116", Fv = "_remove_1nevh_119", Bv = "_download_1nevh_180", Hv = "_next_1nevh_135", zv = "_expand_1nevh_250", Xv = {
  default: "_default_1nevh_7",
  "customizing-data-table": "_customizing-data-table_1nevh_25",
  filter: Lv,
  icon_size: jv,
  "custom-colum": "_custom-colum_1nevh_51",
  "kebab-menu": "_kebab-menu_1nevh_54",
  edit: Ev,
  trash: Iv,
  clone: Rv,
  check: Yv,
  previous: Nv,
  "left-arrow": "_left-arrow_1nevh_102",
  add: $v,
  remove: Fv,
  "row-inline-action-buttons": "_row-inline-action-buttons_1nevh_122",
  "next-previous-buttons": "_next-previous-buttons_1nevh_135",
  "plus-button": "_plus-button_1nevh_155",
  "minus-button": "_minus-button_1nevh_172",
  download: Bv,
  next: Hv,
  "arrow-backward-skinny": "_arrow-backward-skinny_1nevh_204",
  "arrow-forward-skinny": "_arrow-forward-skinny_1nevh_214",
  "arrow-backward": "_arrow-backward_1nevh_204",
  "arrow-forward": "_arrow-forward_1nevh_214",
  "bar-filter": "_bar-filter_1nevh_244",
  expand: zv
}, el = {};
el.$style = Xv;
var Vv = /* @__PURE__ */ te(
  Mv,
  Ov,
  Av,
  !1,
  Wv,
  "2883deae",
  null,
  null
);
function Wv(i) {
  for (let e in el)
    this[e] = el[e];
}
const gu = /* @__PURE__ */ function() {
  return Vv.exports;
}(), Uv = "_tooltip_fg4y3_1", Gv = "_mainTooltip_fg4y3_8", Zv = "_tooltiptextwhite_fg4y3_8", Kv = "_top_fg4y3_22", Qv = "_bottom_fg4y3_33", Jv = "_left_fg4y3_44", qv = "_right_fg4y3_55", ex = "_tooltiptextblack_fg4y3_66", tx = {
  tooltip: Uv,
  mainTooltip: Gv,
  tooltiptextwhite: Zv,
  top: Kv,
  bottom: Qv,
  left: Jv,
  right: qv,
  tooltiptextblack: ex
}, ix = {
  props: {
    styleProps: {
      type: String,
      default: ""
    },
    position: { type: String, default: "top" },
    color: { type: String, default: "black" }
  },
  methods: {
    handleHover() {
      const { clientWidth: i, clientHeight: e } = this.$refs.customWidth;
      this.position === "top" ? this.tooltipPos = `bottom : ${e + 9}px ` : this.position === "bottom" ? this.tooltipPos = `top : ${e + 9}px ` : this.position === "left" ? this.tooltipPos = `right : ${i + 6}px ` : this.tooltipPos = `left : ${i + 6}px `;
    }
  },
  data() {
    return {
      tooltipPos: "top : 0px"
    };
  },
  computed: {
    positionComputed() {
      let i = this.position;
      return i === "top" ? i = "top" : i === "bottom" ? i = "bottom" : i === "left" ? i = "right" : i === "right" ? i = "left" : i = "top", i;
    },
    tooltipClassComputed() {
      return `${tx[this.positionComputed]}`;
    }
  }
};
var sx = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    class: i.$style.tooltip,
    on: {
      mouseover: i.handleHover
    }
  }, [t("div", {
    ref: "customWidth"
  }, [i._t("context")], 2), t("div", {
    staticStyle: {
      position: "absolute"
    },
    style: i.tooltipPos
  }, [t("div", {
    class: i.$style.mainTooltip,
    style: i.styleProps
  }, [i.color === "white" ? t("span", {
    class: [i.tooltipClassComputed, i.$style.tooltiptextwhite]
  }, [i._t("body")], 2) : i._e(), i.color === "black" ? t("span", {
    class: [i.tooltipClassComputed, i.$style.tooltiptextblack]
  }, [i._t("body")], 2) : i._e()])])]);
}, rx = [];
const nx = "_tooltip_fg4y3_1", ax = "_mainTooltip_fg4y3_8", ox = "_tooltiptextwhite_fg4y3_8", lx = "_top_fg4y3_22", ux = "_bottom_fg4y3_33", hx = "_left_fg4y3_44", cx = "_right_fg4y3_55", dx = "_tooltiptextblack_fg4y3_66", fx = {
  tooltip: nx,
  mainTooltip: ax,
  tooltiptextwhite: ox,
  top: lx,
  bottom: ux,
  left: hx,
  right: cx,
  tooltiptextblack: dx
}, tl = {};
tl.$style = fx;
var px = /* @__PURE__ */ te(
  ix,
  sx,
  rx,
  !1,
  gx,
  null,
  null,
  null
);
function gx(i) {
  for (let e in tl)
    this[e] = tl[e];
}
const mx = /* @__PURE__ */ function() {
  return px.exports;
}(), _x = {
  components: { IconButton: gu, Tooltip: mx },
  props: {
    styleProps: {
      type: String,
      default: ""
    },
    headerText: {
      type: String,
      default: ""
    },
    infoText: {
      type: String,
      default: ""
    }
  },
  data() {
    return {
      isShowTooltip: !1
    };
  }
};
var bx = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    class: i.$style["widget-container"],
    style: i.styleProps
  }, [t("div", {
    class: i.$style["widget-header"]
  }, [t("div", {
    class: i.$style["widget-header-text"]
  }, [t("p", [i._v(i._s(i.headerText))]), i.infoText ? t("tooltip", {
    scopedSlots: i._u([{
      key: "context",
      fn: function() {
        return [t("span", {
          class: i.$style["info-icon"],
          on: {
            mouseover: function(s) {
              i.isShowTooltip = !0;
            },
            mouseout: function(s) {
              i.isShowTooltip = !1;
            }
          }
        })];
      },
      proxy: !0
    }, {
      key: "body",
      fn: function() {
        return [t("div", [t("p", [i._v(i._s(i.infoText))])])];
      },
      proxy: !0
    }], null, !1, 2152043039)
  }) : i._e()], 1), t("icon-button", {
    attrs: {
      "style-props": "flex-shrink: 0;",
      "button-type": "kebab-menu"
    }
  })], 1), t("div", {
    class: i.$style["widget-contents"]
  }, [i._t("default")], 2)]);
}, yx = [];
const vx = "_tooltip_1h4p9_45", xx = {
  "widget-container": "_widget-container_1h4p9_8",
  "widget-header": "_widget-header_1h4p9_16",
  "widget-header-text": "_widget-header-text_1h4p9_25",
  "info-icon": "_info-icon_1h4p9_38",
  tooltip: vx,
  "widget-contents": "_widget-contents_1h4p9_52"
}, il = {};
il.$style = xx;
var wx = /* @__PURE__ */ te(
  _x,
  bx,
  yx,
  !1,
  Sx,
  null,
  null,
  null
);
function Sx(i) {
  for (let e in il)
    this[e] = il[e];
}
const JO = /* @__PURE__ */ function() {
  return wx.exports;
}();
function $t(i) {
  return Number(i) !== i;
}
function Fc(i) {
  return {}.toString.call(i);
}
function Dx(i, e = "Assertion failed") {
  if (!i)
    throw new Error(e);
}
function pt(i) {
  if (i != null && !S(i)) {
    let e = Number(i);
    return $t(e) && Ri(i) && i != "" ? pt(i.replace(/[^0-9.\-]+/g, "")) : e;
  }
  return i;
}
function Bc(i) {
  if (Qn(i))
    return new Date(i);
  if (S(i))
    return new Date(i);
  {
    let e = Number(i);
    return S(e) ? new Date(e) : new Date(i);
  }
}
function Hc(i) {
  if ($t(i))
    return "NaN";
  if (i === 1 / 0)
    return "Infinity";
  if (i === -1 / 0)
    return "-Infinity";
  if (i === 0 && 1 / i === -1 / 0)
    return "-0";
  let e = i < 0;
  i = Math.abs(i);
  let t = /^([0-9]+)(?:\.([0-9]+))?(?:e[\+\-]([0-9]+))?$/.exec("" + i), s = t[1], r = t[2] || "", n;
  if (t[3] === void 0)
    n = r === "" ? s : s + "." + r;
  else {
    let a = +t[3];
    if (i < 1) {
      let o = a - 1;
      n = "0." + sl("0", o) + s + r;
    } else {
      let o = a - r.length;
      o === 0 ? n = s + r : o < 0 ? n = s + r.slice(0, o) + "." + r.slice(o) : n = s + r + sl("0", o);
    }
  }
  return e ? "-" + n : n;
}
function sl(i, e) {
  return new Array(e + 1).join(i);
}
function Qn(i) {
  return Fc(i) === "[object Date]";
}
function Ri(i) {
  return typeof i == "string";
}
function S(i) {
  return typeof i == "number" && Number(i) == i;
}
function Ps(i) {
  return typeof i == "object" && i !== null;
}
function Jn(i) {
  return Array.isArray(i);
}
const _i = "__§§§__", hs = "__§§§§__", Px = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  PLACEHOLDER: _i,
  PLACEHOLDER2: hs,
  assert: Dx,
  getType: Fc,
  isArray: Jn,
  isDate: Qn,
  isNaN: $t,
  isNumber: S,
  isObject: Ps,
  isString: Ri,
  numberToString: Hc,
  repeat: sl,
  toDate: Bc,
  toNumber: pt
}, Symbol.toStringTag, { value: "Module" }));
function Yi(i, e) {
  const t = i.length;
  for (let s = 0; s < t; ++s)
    if (i[s] === e)
      return s;
  return -1;
}
function zc(i, e) {
  const t = i.length;
  for (let s = 0; s < t; ++s)
    if (e(i[s]))
      return !0;
  return !1;
}
function qn(i, e) {
  const t = i.length, s = new Array(t);
  for (let r = 0; r < t; ++r)
    s[r] = e(i[r], r);
  return s;
}
function x(i, e) {
  const t = i.length;
  for (let s = 0; s < t; ++s)
    e(i[s], s);
}
function zs(i, e) {
  let t = i.length;
  for (; t > 0; )
    --t, e(i[t], t);
}
function mu(i, e) {
  const t = i.length;
  for (let s = 0; s < t && e(i[s], s); ++s)
    ;
}
function Tx(i, e) {
  const t = i.length;
  for (let s = e; s < t; ++s)
    i[s - e] = i[s];
  i.length = t - e;
}
function kx(i) {
  const e = i.length;
  return e ? i[e - 1] : void 0;
}
function Cx(i) {
  return i[0];
}
function Xc(i, e, t) {
  t = Math.max(0, Math.min(t, i.length)), i.splice(t, 0, e);
}
function Mx(i, e, t) {
  vt(i, e), Xc(i, e, t);
}
function Ox(i, e) {
  const t = e.length;
  for (let s = 0; s < t; ++s)
    i.push(e[s]);
}
function vt(i, e) {
  let t = !1, s = 0;
  for (; ; ) {
    if (s = i.indexOf(e, s), s === -1)
      return t;
    t = !0, i.splice(s, 1);
  }
}
function ot(i, e) {
  let t = i.indexOf(e);
  return t !== -1 ? (i.splice(t, 1), !0) : !1;
}
function Vc(i, e, t) {
  let s = Yi(i, e);
  s !== -1 && ta(i, s), t == null ? i.push(e) : Xs(i, t, e);
}
function Ax(i, e, t) {
  S(t) ? t === 0 ? i.unshift(e) : i.splice(t, 0, e) : i.push(e);
}
function Us(i, e) {
  i.indexOf(e) === -1 && i.push(e);
}
function Lx(i, e, t) {
  let s = i.indexOf(e);
  s !== -1 && i.splice(s, 1), S(t) ? i.splice(t, 0, e) : i.push(e);
}
function jx(i) {
  return Array.isArray(i) ? i : [i];
}
function Ex(i, e) {
  return Yi(i, e) !== -1;
}
function ea(i) {
  const e = i.length, t = new Array(e);
  for (let s = 0; s < e; ++s)
    t[s] = i[s];
  return t;
}
function Ix(i, e, t = i.length) {
  const s = new Array(t - e);
  for (let r = e; r < t; ++r)
    s[r - e] = i[r];
  return s;
}
function Xs(i, e, t) {
  i.splice(e, 0, t);
}
function ta(i, e) {
  i.splice(e, 1);
}
function _u(i, e) {
  const t = i.length;
  for (let s = 0; s < t; ++s)
    if (e(i[s], s))
      return s;
  return -1;
}
function Wc(i, e) {
  let t = i.length;
  for (; t > 0; )
    if (--t, e(i[t], t))
      return t;
  return -1;
}
function bu(i, e) {
  const t = _u(i, e);
  if (t !== -1)
    return i[t];
}
function Uc(i, e) {
  const t = Wc(i, e);
  if (t !== -1)
    return i[t];
}
function Rx(i, e) {
  const t = i.length;
  for (let s = 0; s < t; ++s) {
    const r = e(i[s], s);
    if (r !== void 0)
      return r;
  }
}
function Yx(i) {
  let e = i.length, t, s;
  for (; e !== 0; )
    s = Math.floor(Math.random() * e), e -= 1, t = i[e], i[e] = i[s], i[s] = t;
}
function Ei(i, e) {
  let t = 0, s = i.length, r = !1;
  for (; t < s; ) {
    const n = t + s >> 1, a = e(i[n]);
    a < 0 ? t = n + 1 : a === 0 ? (r = !0, t = n + 1) : s = n;
  }
  return {
    found: r,
    index: r ? t - 1 : t
  };
}
function Gc(i, e) {
  let t = 0, s = i.length, r = !1;
  for (; t < s; ) {
    const n = t + s >> 1, a = e(i[n]);
    a < 0 ? t = n + 1 : (a === 0 && (r = !0), s = n);
  }
  return {
    found: r,
    index: t
  };
}
function ln(i, e) {
  let t = i.length;
  for (; t > 0; )
    --t, e(i[t]) || i.splice(t, 1);
}
const Nx = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  add: Ax,
  any: zc,
  copy: ea,
  each: x,
  eachContinue: mu,
  eachReverse: zs,
  find: bu,
  findIndex: _u,
  findIndexReverse: Wc,
  findMap: Rx,
  findReverse: Uc,
  first: Cx,
  getFirstSortedIndex: Gc,
  getSortedIndex: Ei,
  has: Ex,
  indexOf: Yi,
  insert: Xc,
  insertIndex: Xs,
  keepIf: ln,
  last: kx,
  map: qn,
  move: Vc,
  pushAll: Ox,
  pushOne: Us,
  remove: vt,
  removeFirst: ot,
  removeIndex: ta,
  replace: Lx,
  setIndex: Mx,
  shiftLeft: Tx,
  shuffle: Yx,
  slice: Ix,
  toArray: jx
}, Symbol.toStringTag, { value: "Module" }));
class ur {
  /**
   * Constructor.
   */
  constructor() {
    Object.defineProperty(this, "_disposed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._disposed = !1;
  }
  /**
   * Checks if object is disposed.
   *
   * @return Disposed?
   */
  isDisposed() {
    return this._disposed;
  }
  /**
   * Disposes the object.
   */
  dispose() {
    this._disposed || (this._disposed = !0, this._dispose());
  }
}
class Ve {
  /**
   * Constructor.
   *
   * @param dispose  Function that disposes object
   */
  constructor(e) {
    Object.defineProperty(this, "_disposed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_dispose", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._disposed = !1, this._dispose = e;
  }
  /**
   * Checks if object is disposed.
   *
   * @return Disposed?
   */
  isDisposed() {
    return this._disposed;
  }
  /**
   * Disposes the object.
   */
  dispose() {
    this._disposed || (this._disposed = !0, this._dispose());
  }
}
class Zc extends ur {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_disposers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    });
  }
  _dispose() {
    x(this._disposers, (e) => {
      e.dispose();
    });
  }
}
class nt extends ur {
  constructor(e) {
    super(), Object.defineProperty(this, "_disposers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._disposers = e;
  }
  _dispose() {
    x(this._disposers, (e) => {
      e.dispose();
    });
  }
}
class $x extends ur {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_disposer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_value", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  _dispose() {
    this._disposer != null && (this._disposer.dispose(), this._disposer = void 0);
  }
  /**
   * Returns current value.
   *
   * @return Value
   */
  get() {
    return this._value;
  }
  /**
   * Sets value and disposes previous disposer if it was set.
   *
   * @param value     New value
   * @param disposer  Disposer
   */
  set(e, t) {
    this._disposer != null && this._disposer.dispose(), this._disposer = t, this._value = e;
  }
  /**
   * Resets the disposer value.
   */
  reset() {
    this.set(void 0, void 0);
  }
}
class qa extends Ve {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_counter", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    });
  }
  /**
   * [increment description]
   *
   * @todo Description
   */
  increment() {
    return ++this._counter, new Ve(() => {
      --this._counter, this._counter === 0 && this.dispose();
    });
  }
}
class hr {
  /**
   * Constructor
   */
  constructor() {
    Object.defineProperty(this, "_listeners", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_killed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_disabled", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_iterating", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_enabled", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_disposed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._listeners = [], this._killed = [], this._disabled = {}, this._iterating = 0, this._enabled = !0, this._disposed = !1;
  }
  /**
   * Returns if this object has been already disposed.
   *
   * @return Disposed?
   */
  isDisposed() {
    return this._disposed;
  }
  /**
   * Dispose (destroy) this object.
   */
  dispose() {
    if (!this._disposed) {
      this._disposed = !0;
      const e = this._listeners;
      this._iterating = 1, this._listeners = null, this._disabled = null;
      try {
        x(e, (t) => {
          t.disposer.dispose();
        });
      } finally {
        this._killed = null, this._iterating = null;
      }
    }
  }
  /**
   * Checks if this particular event dispatcher has any listeners set.
   *
   * @return Has listeners?
   */
  hasListeners() {
    return this._listeners.length !== 0;
  }
  /**
   * Checks if this particular event dispatcher has any particular listeners set.
   *
   * @return Has particular event listeners?
   */
  hasListenersByType(e) {
    return zc(this._listeners, (t) => (t.type === null || t.type === e) && !t.killed);
  }
  /**
   * Enable dispatching of events if they were previously disabled by
   * `disable()`.
   */
  enable() {
    this._enabled = !0;
  }
  /**
   * Disable dispatching of events until re-enabled by `enable()`.
   */
  disable() {
    this._enabled = !1;
  }
  /**
   * Enable dispatching particular event, if it was disabled before by
   * `disableType()`.
   *
   * @param type Event type
   */
  enableType(e) {
    delete this._disabled[e];
  }
  /**
   * Disable dispatching of events for a certain event type.
   *
   * Optionally, can set how many dispatches to skip before automatically
   * re-enabling the dispatching.
   *
   * @param type    Event type
   * @param amount  Number of event dispatches to skip
   */
  disableType(e, t = 1 / 0) {
    this._disabled[e] = t;
  }
  /**
   * Removes listener from dispatcher.
   *
   * Will throw an exception if such listener does not exists.
   *
   * @param listener Listener to remove
   */
  _removeListener(e) {
    if (this._iterating === 0) {
      const t = this._listeners.indexOf(e);
      if (t === -1)
        throw new Error("Invalid state: could not remove listener");
      this._listeners.splice(t, 1);
    } else
      this._killed.push(e);
  }
  /**
   * Removes existing listener by certain parameters.
   *
   * @param once         Listener's once setting
   * @param type         Listener's type
   * @param callback     Callback function
   * @param context      Callback context
   */
  _removeExistingListener(e, t, s, r) {
    if (this._disposed)
      throw new Error("EventDispatcher is disposed");
    this._eachListener((n) => {
      n.once === e && // TODO is this correct ?
      n.type === t && (s === void 0 || n.callback === s) && n.context === r && n.disposer.dispose();
    });
  }
  /**
   * Checks if dispatching for particular event type is enabled.
   *
   * @param type  Event type
   * @return Enabled?
   */
  isEnabled(e) {
    if (this._disposed)
      throw new Error("EventDispatcher is disposed");
    return this._enabled && this._listeners.length > 0 && this.hasListenersByType(e) && this._disabled[e] === void 0;
  }
  /**
   * Removes all listeners of a particular event type
   *
   * @param type  Listener's type
   */
  removeType(e) {
    if (this._disposed)
      throw new Error("EventDispatcher is disposed");
    this._eachListener((t) => {
      t.type === e && t.disposer.dispose();
    });
  }
  /**
   * Checks if there's already a listener with specific parameters.
   *
   * @param type      Listener's type
   * @param callback  Callback function
   * @param context   Callback context
   * @return Has listener?
   */
  has(e, t, s) {
    return _u(this._listeners, (n) => n.once !== !0 && // Ignoring "once" listeners
    n.type === e && (t === void 0 || n.callback === t) && n.context === s) !== -1;
  }
  /**
   * Checks whether event of the particular type should be dispatched.
   *
   * @param type  Event type
   * @return Dispatch?
   */
  _shouldDispatch(e) {
    if (this._disposed)
      throw new Error("EventDispatcher is disposed");
    const t = this._disabled[e];
    return S(t) ? (t <= 1 ? delete this._disabled[e] : --this._disabled[e], !1) : this._enabled;
  }
  /**
   * [_eachListener description]
   *
   * All of this extra code is needed when a listener is removed while iterating
   *
   * @todo Description
   * @param fn [description]
   */
  _eachListener(e) {
    ++this._iterating;
    try {
      x(this._listeners, e);
    } finally {
      --this._iterating, this._iterating === 0 && this._killed.length !== 0 && (x(this._killed, (t) => {
        this._removeListener(t);
      }), this._killed.length = 0);
    }
  }
  /**
   * Dispatches an event immediately without waiting for next cycle.
   *
   * @param type   Event type
   * @param event  Event object
   * @todo automatically add in type and target properties if they are missing
   */
  dispatch(e, t) {
    this._shouldDispatch(e) && this._eachListener((s) => {
      !s.killed && (s.type === null || s.type === e) && s.dispatch(e, t);
    });
  }
  /**
   * Shelves the event to be dispatched within next update cycle.
   *
   * @param type   Event type
   * @param event  Event object
   * @todo automatically add in type and target properties if they are missing
   */
  /*public dispatchLater<Key extends keyof T>(type: Key, event: T[Key]): void {
      if (this._shouldDispatch(type)) {
          this._eachListener((listener) => {
              // TODO check if it's faster to use an object of listeners rather than a single big array
              if (!listener.killed && (listener.type === null || listener.type === type)) {
                  // TODO if the function throws, maybe it should keep going ?
                  // TODO dispatch during the update cycle, rather than using whenIdle
                  $async.whenIdle(() => {
                      if (!listener.killed) {
                          listener.dispatch(type, event);
                      }
                  });
              }
          });
      }
  }*/
  /**
   * Creates, catalogs and returns an [[EventListener]].
   *
   * Event listener can be disposed.
   *
   * @param once         Listener's once setting
   * @param type         Listener's type
   * @param callback     Callback function
   * @param context      Callback context
   * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied
   * @param dispatch
   * @returns An event listener
   */
  _on(e, t, s, r, n, a) {
    if (this._disposed)
      throw new Error("EventDispatcher is disposed");
    this._removeExistingListener(e, t, s, r);
    const o = {
      type: t,
      callback: s,
      context: r,
      shouldClone: n,
      dispatch: a,
      killed: !1,
      once: e,
      disposer: new Ve(() => {
        o.killed = !0, this._removeListener(o);
      })
    };
    return this._listeners.push(o), o;
  }
  /**
   * Creates an event listener to be invoked on **any** event.
   *
   * @param callback     Callback function
   * @param context      Callback context
   * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied
   * @returns A disposable event listener
   */
  onAll(e, t, s = !0) {
    return this._on(!1, null, e, t, s, (r, n) => e.call(t, n)).disposer;
  }
  /**
   * Creates an event listener to be invoked on a specific event type.
   *
   * ```TypeScript
   * button.events.once("click", (ev) => {
   *   console.log("Button clicked");
   * }, this);
   * ```
   * ```JavaScript
   * button.events.once("click", (ev) => {
   *   console.log("Button clicked");
   * }, this);
   * ```
   *
   * The above will invoke our custom event handler whenever series we put
   * event on is hidden.
   *
   * @param type         Listener's type
   * @param callback     Callback function
   * @param context      Callback context
   * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied
   * @returns A disposable event listener
   */
  on(e, t, s, r = !0) {
    return this._on(!1, e, t, s, r, (n, a) => t.call(s, a)).disposer;
  }
  /**
   * Creates an event listener to be invoked on a specific event type once.
   *
   * Once the event listener is invoked, it is automatically disposed.
   *
   * ```TypeScript
   * button.events.once("click", (ev) => {
   *   console.log("Button clicked");
   * }, this);
   * ```
   * ```JavaScript
   * button.events.once("click", (ev) => {
   *   console.log("Button clicked");
   * }, this);
   * ```
   *
   * The above will invoke our custom event handler the first time series we
   * put event on is hidden.
   *
   * @param type         Listener's type
   * @param callback     Callback function
   * @param context      Callback context
   * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied
   * @returns A disposable event listener
   */
  once(e, t, s, r = !0) {
    const n = this._on(!0, e, t, s, r, (a, o) => {
      n.disposer.dispose(), t.call(s, o);
    });
    return n.disposer;
  }
  /**
   * Removes the event listener with specific parameters.
   *
   * @param type         Listener's type
   * @param callback     Callback function
   * @param context      Callback context
   */
  off(e, t, s) {
    this._removeExistingListener(!1, e, t, s);
  }
  /**
   * Copies all dispatcher parameters, including listeners, from another event
   * dispatcher.
   *
   * @param source Source event dispatcher
   * @ignore
   */
  copyFrom(e) {
    if (this._disposed)
      throw new Error("EventDispatcher is disposed");
    if (e === this)
      throw new Error("Cannot copyFrom the same TargetedEventDispatcher");
    const t = [];
    return x(e._listeners, (s) => {
      !s.killed && s.shouldClone && (s.type === null ? t.push(this.onAll(s.callback, s.context)) : s.once ? t.push(this.once(s.type, s.callback, s.context)) : t.push(this.on(s.type, s.callback, s.context)));
    }), new nt(t);
  }
}
function mr(i, e) {
  if (!(i >= 0 && i < e))
    throw new Error("Index out of bounds: " + i);
}
class cr {
  /**
   * Constructor
   *
   * @param initial  Inital list of values to add to list
   */
  constructor(e = []) {
    Object.defineProperty(this, "_values", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "events", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new hr()
    }), this._values = e;
  }
  /**
   * An array of values in the list.
   *
   * Do not use this property to add values. Rather use dedicated methods, like
   * `push()`, `removeIndex()`, etc.
   *
   * @readonly
   * @return List values
   */
  get values() {
    return this._values;
  }
  /**
   * Checks if list contains specific item reference.
   *
   * @param item  Item to search for
   * @return `true` if found, `false` if not found
   */
  contains(e) {
    return this._values.indexOf(e) !== -1;
  }
  /**
   * Removes specific item from the list.
   *
   * @param item An item to remove
   */
  removeValue(e) {
    let t = 0, s = this._values.length;
    for (; t < s; )
      this._values[t] === e ? (this.removeIndex(t), --s) : ++t;
  }
  /**
   * Searches the list for specific item and returns its index.
   *
   * @param item  An item to search for
   * @return Index or -1 if not found
   */
  indexOf(e) {
    return Yi(this._values, e);
  }
  /**
   * Number of items in list.
   *
   * @readonly
   * @return Number of items
   */
  get length() {
    return this._values.length;
  }
  /**
   * Checks if there's a value at specific index.
   *
   * @param index  Index
   * @return Value exists?
   */
  hasIndex(e) {
    return e >= 0 && e < this._values.length;
  }
  /**
   * Returns an item at specified index.
   *
   * @param index  Index
   * @return List item
   */
  getIndex(e) {
    return this._values[e];
  }
  _onPush(e) {
    this.events.isEnabled("push") && this.events.dispatch("push", {
      type: "push",
      target: this,
      newValue: e
    });
  }
  _onInsertIndex(e, t) {
    this.events.isEnabled("insertIndex") && this.events.dispatch("insertIndex", {
      type: "insertIndex",
      target: this,
      index: e,
      newValue: t
    });
  }
  _onSetIndex(e, t, s) {
    this.events.isEnabled("setIndex") && this.events.dispatch("setIndex", {
      type: "setIndex",
      target: this,
      index: e,
      oldValue: t,
      newValue: s
    });
  }
  _onRemoveIndex(e, t) {
    this.events.isEnabled("removeIndex") && this.events.dispatch("removeIndex", {
      type: "removeIndex",
      target: this,
      index: e,
      oldValue: t
    });
  }
  _onMoveIndex(e, t, s) {
    this.events.isEnabled("moveIndex") && this.events.dispatch("moveIndex", {
      type: "moveIndex",
      target: this,
      oldIndex: e,
      newIndex: t,
      value: s
    });
  }
  _onClear(e) {
    this.events.isEnabled("clear") && this.events.dispatch("clear", {
      type: "clear",
      target: this,
      oldValues: e
    });
  }
  /**
   * Sets value at specific index.
   *
   * If there's already a value at the index, it is overwritten.
   *
   * @param index  Index
   * @param value  New value
   * @return New value
   */
  setIndex(e, t) {
    mr(e, this._values.length);
    const s = this._values[e];
    return s !== t && (this._values[e] = t, this._onSetIndex(e, s, t)), s;
  }
  /**
   * Adds an item to the list at a specific index, which pushes all the other
   * items further down the list.
   *
   * @param index Index
   * @param item  An item to add
   */
  insertIndex(e, t) {
    return mr(e, this._values.length + 1), Xs(this._values, e, t), this._onInsertIndex(e, t), t;
  }
  /**
   * Swaps indexes of two items in the list.
   *
   * @param a  Item 1
   * @param b  Item 2
   */
  swap(e, t) {
    const s = this._values.length;
    if (mr(e, s), mr(t, s), e !== t) {
      const r = this._values[e], n = this._values[t];
      this._values[e] = n, this._onSetIndex(e, r, n), this._values[t] = r, this._onSetIndex(t, n, r);
    }
  }
  /**
   * Removes a value at specific index.
   *
   * @param index  Index of value to remove
   * @return Removed value
   */
  removeIndex(e) {
    mr(e, this._values.length);
    const t = this._values[e];
    return ta(this._values, e), this._onRemoveIndex(e, t), t;
  }
  /**
   * Moves an item to a specific index within the list.
   *
   * If the index is not specified it will move the item to the end of the
   * list.
   *
   * @param value  Item to move
   * @param index  Index to place item at
   */
  moveValue(e, t) {
    let s = this.indexOf(e);
    if (s !== -1)
      if (ta(this._values, s), t == null) {
        const r = this._values.length;
        this._values.push(e), this._onMoveIndex(s, r, e);
      } else
        Xs(this._values, t, e), this._onMoveIndex(s, t, e);
    else
      t == null ? (this._values.push(e), this._onPush(e)) : (Xs(this._values, t, e), this._onInsertIndex(t, e));
    return e;
  }
  /**
   * Adds an item to the end of the list.
   *
   * @param item  An item to add
   */
  push(e) {
    return this._values.push(e), this._onPush(e), e;
  }
  /**
   * Adds an item as a first item in the list.
   *
   * @param item  An item to add
   */
  unshift(e) {
    return this.insertIndex(0, e), e;
  }
  /**
   * Adds multiple items to the list.
   *
   * @param items  An Array of items to add
   */
  pushAll(e) {
    x(e, (t) => {
      this.push(t);
    });
  }
  /**
   * Copies and adds items from abother list.
   *
   * @param source  A list top copy items from
   */
  copyFrom(e) {
    this.pushAll(e._values);
  }
  /**
   * Returns the last item from the list, and removes it.
   *
   * @return Item
   */
  pop() {
    return this._values.length - 1 < 0 ? void 0 : this.removeIndex(this._values.length - 1);
  }
  /**
   * Returns the first item from the list, and removes it.
   *
   * @return Item
   */
  shift() {
    return this._values.length ? this.removeIndex(0) : void 0;
  }
  /**
   * Sets multiple items to the list.
   *
   * All current items are removed.
   *
   * @param newArray  New items
   */
  setAll(e) {
    const t = this._values;
    this._values = [], this._onClear(t), x(e, (s) => {
      this._values.push(s), this._onPush(s);
    });
  }
  /**
   * Removes all items from the list.
   */
  clear() {
    this.setAll([]);
  }
  /**
   * Returns an ES6 iterator for the list.
   */
  *[Symbol.iterator]() {
    const e = this._values.length;
    for (let t = 0; t < e; ++t)
      yield this._values[t];
  }
  /**
   * Calls `f` for each element in the list.
   *
   * `f` should have at least one parameter defined which will get a current
   * item, with optional second argument - index.
   */
  each(e) {
    x(this._values, e);
  }
  /**
   * Calls `f` for each element in the list, from right to left.
   *
   * `f` should have at least one parameter defined which will get a current
   * item, with optional second argument - index.
   */
  eachReverse(e) {
    zs(this._values, e);
  }
}
class ia extends cr {
  constructor() {
    super(...arguments), Object.defineProperty(this, "autoDispose", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "_disposed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    });
  }
  _onSetIndex(e, t, s) {
    this.autoDispose && t.dispose(), super._onSetIndex(e, t, s);
  }
  _onRemoveIndex(e, t) {
    this.autoDispose && t.dispose(), super._onRemoveIndex(e, t);
  }
  _onClear(e) {
    this.autoDispose && x(e, (t) => {
      t.dispose();
    }), super._onClear(e);
  }
  isDisposed() {
    return this._disposed;
  }
  dispose() {
    this._disposed || (this._disposed = !0, this.autoDispose && x(this._values, (e) => {
      e.dispose();
    }));
  }
}
class Ae extends ia {
  constructor(e, t) {
    super(), Object.defineProperty(this, "template", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "make", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.template = e, this.make = t;
  }
}
class Fx extends cr {
  constructor(e) {
    super(), Object.defineProperty(this, "_disposed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_container", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_events", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._container = e, this._events = this.events.onAll((t) => {
      if (t.type === "clear")
        x(t.oldValues, (s) => {
          this._onRemoved(s);
        });
      else if (t.type === "push")
        this._onInserted(t.newValue);
      else if (t.type === "setIndex")
        this._onRemoved(t.oldValue), this._onInserted(t.newValue, t.index);
      else if (t.type === "insertIndex")
        this._onInserted(t.newValue, t.index);
      else if (t.type === "removeIndex")
        this._onRemoved(t.oldValue);
      else if (t.type === "moveIndex")
        this._onRemoved(t.value), this._onInserted(t.value, t.newIndex);
      else
        throw new Error("Unknown IListEvent type");
    });
  }
  _onInserted(e, t) {
    e._setParent(this._container, !0);
    const s = this._container._childrenDisplay;
    t === void 0 ? s.addChild(e._display) : s.addChildAt(e._display, t);
  }
  _onRemoved(e) {
    this._container._childrenDisplay.removeChild(e._display), this._container.markDirtyBounds(), this._container.markDirty();
  }
  /**
   * Returns `true` if obejct is disposed.
   */
  isDisposed() {
    return this._disposed;
  }
  /**
   * Permanently dispose this object.
   */
  dispose() {
    this._disposed || (this._disposed = !0, this._events.dispose(), x(this.values, (e) => {
      e.dispose();
    }));
  }
}
class ne {
  /**
   * Constructor.
   *
   * @param percent  Percent value
   */
  constructor(e) {
    Object.defineProperty(this, "_value", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._value = e;
  }
  /**
   * Relative value.
   *
   * E.g. 100% is 1, 50% is 0.5, etc.
   *
   * This is useful to apply transformations to other values. E.g.:
   *
   * ```TypeScript
   * let value = 256;
   * let percent = new am5.p50;
   * console.log(value * percent.value); // outputs 128
   * ```
   * ```JavaScript
   * var value = 256;
   * var percent = new am5.p50;
   * console.log(value * percent.value); // outputs 128
   * ```
   *
   * Alternatively, you can use `am5.percent()` helper function:
   *
   * ```TypeScript
   * let value = 256;
   * let percent = am5.p50;
   * console.log(value * percent.value); // outputs 128
   * ```
   * ```JavaScript
   * var value = 256;
   * var percent = am5.p50;
   * console.log(value * percent.value); // outputs 128
   * ```
   *
   * @readonly
   * @return Relative value
   */
  get value() {
    return this._value / 100;
  }
  /**
   * Value in percent.
   *
   * @return Percent
   */
  get percent() {
    return this._value;
  }
  toString() {
    return "" + this._value + "%";
  }
  interpolate(e, t) {
    return e + this.value * (t - e);
  }
  static normalize(e, t, s) {
    return e instanceof ne ? e : t === s ? new ne(0) : new ne(Math.min(Math.max((e - t) * (1 / (s - t)), 0), 1) * 100);
  }
}
function Ce(i) {
  return new ne(i);
}
const Bx = Ce(0), R = Ce(100), ie = Ce(50);
function Ue(i, e, t, s) {
  function r(n) {
    return n instanceof t ? n : new t(function(a) {
      a(n);
    });
  }
  return new (t || (t = Promise))(function(n, a) {
    function o(h) {
      try {
        u(s.next(h));
      } catch (c) {
        a(c);
      }
    }
    function l(h) {
      try {
        u(s.throw(h));
      } catch (c) {
        a(c);
      }
    }
    function u(h) {
      h.done ? n(h.value) : r(h.value).then(o, l);
    }
    u((s = s.apply(i, e || [])).next());
  });
}
function Be(i) {
  return Object.keys(i);
}
function yu(i, e) {
  return Be(i).sort(e);
}
function Mi(i) {
  return Object.assign({}, i);
}
function _e(i, e) {
  Be(i).forEach((t) => {
    e(t, i[t]);
  });
}
function Kc(i, e) {
  for (let t in i)
    if (Qc(i, t) && !e(t, i[t]))
      break;
}
function Hx(i, e, t) {
  x(yu(i, t), (s) => {
    e(s, i[s]);
  });
}
function Qc(i, e) {
  return {}.hasOwnProperty.call(i, e);
}
function zx(i, e) {
  return _e(i, (t, s) => {
    s != null && e[t] == null && (e[t] = s);
  }), e;
}
const Xx = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  copy: Mi,
  each: _e,
  eachContinue: Kc,
  eachOrdered: Hx,
  hasKey: Qc,
  keys: Be,
  keysOrdered: yu,
  softCopyProperties: zx
}, Symbol.toStringTag, { value: "Module" }));
function Jc(i) {
  if (document.readyState !== "loading")
    i();
  else {
    const e = () => {
      document.readyState !== "loading" && (document.removeEventListener("readystatechange", e), i());
    };
    document.addEventListener("readystatechange", e);
  }
}
function qc(i) {
  i.parentNode && i.parentNode.removeChild(i);
}
function Ie(i, e, t, s) {
  return i.addEventListener(e, t, s || !1), new Ve(() => {
    i.removeEventListener(e, t, s || !1);
  });
}
function vu(i) {
  return Ie(window, "resize", (e) => {
    i();
  });
}
function Ut(i) {
  switch (i) {
    case "touchevents":
      return window.hasOwnProperty("TouchEvent");
    case "pointerevents":
      return window.hasOwnProperty("PointerEvent");
    case "mouseevents":
      return window.hasOwnProperty("MouseEvent");
    case "wheelevents":
      return window.hasOwnProperty("WheelEvent");
    case "keyboardevents":
      return window.hasOwnProperty("KeyboardEvent");
  }
  return !1;
}
function En(i) {
  return i.pointerId || 0;
}
function ed() {
  if (document.activeElement && document.activeElement != document.body)
    if (document.activeElement.blur)
      document.activeElement.blur();
    else {
      let i = document.createElement("button");
      i.style.position = "fixed", i.style.top = "0px", i.style.left = "-10000px", document.body.appendChild(i), i.focus(), i.blur(), document.body.removeChild(i);
    }
}
function td(i) {
  i && i.focus();
}
function sa(i) {
  if (Ut("pointerevents"))
    return i;
  if (Ut("touchevents"))
    switch (i) {
      case "pointerover":
        return "touchstart";
      case "pointerout":
        return "touchend";
      case "pointerdown":
        return "touchstart";
      case "pointermove":
        return "touchmove";
      case "pointerup":
        return "touchend";
      case "click":
        return "click";
      case "dblclick":
        return "dblclick";
    }
  else if (Ut("mouseevents"))
    switch (i) {
      case "pointerover":
        return "mouseover";
      case "pointerout":
        return "mouseout";
      case "pointerdown":
        return "mousedown";
      case "pointermove":
        return "mousemove";
      case "pointerup":
        return "mouseup";
      case "click":
        return "click";
      case "dblclick":
        return "dblclick";
    }
  return i;
}
function ra(i) {
  if (typeof Touch < "u" && i instanceof Touch)
    return !0;
  if (typeof PointerEvent < "u" && i instanceof PointerEvent && i.pointerType != null)
    switch (i.pointerType) {
      case "touch":
      case "pen":
      case 2:
        return !0;
      case "mouse":
      case 4:
        return !1;
      default:
        return !(i instanceof MouseEvent);
    }
  else if (i.type != null && i.type.match(/^mouse/))
    return !1;
  return !0;
}
function In(i, e, t) {
  i.style[e] = t;
}
function id(i, e) {
  return i.style[e];
}
function sd(i, e) {
  let t = e;
  for (; ; ) {
    if (i === t)
      return !0;
    if (t.parentNode === null) {
      if (t.host == null)
        return !1;
      t = t.host;
    } else
      t = t.parentNode;
  }
}
function eo(i, e) {
  return i.target && sd(e.root.dom, i.target);
}
function Rs(i, e) {
  e ? i.style.pointerEvents = "auto" : i.style.pointerEvents = "none";
}
function rd(i) {
  let e = i;
  for (; ; ) {
    if (e.parentNode === null)
      return e.host != null ? e : null;
    e = e.parentNode;
  }
}
let bo;
function Vx(i, e, t = "") {
  const s = document.createElement("style");
  return s.type = "text/css", t != "" && s.setAttribute("nonce", t), s.textContent = e, i === null ? document.head.appendChild(s) : i.appendChild(s), s;
}
function Wx(i, e = "") {
  if (i === null) {
    if (bo == null) {
      const t = document.createElement("style");
      t.type = "text/css", e != "" && t.setAttribute("nonce", e), document.head.appendChild(t), bo = t.sheet;
    }
    return bo;
  } else {
    const t = document.createElement("style");
    return t.type = "text/css", e != "" && t.setAttribute("nonce", e), i.appendChild(t), t.sheet;
  }
}
function Ux(i, e) {
  const t = i.cssRules.length;
  return i.insertRule(e + "{}", t), i.cssRules[t];
}
class Je extends ur {
  /**
   * Constructor.
   *
   * @param selector  CSS selector
   * @param styles    An object of style attribute - value pairs
   */
  constructor(e, t, s, r = "") {
    super(), Object.defineProperty(this, "_root", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_rule", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._root = Wx(e, r);
    try {
      this._rule = Ux(this._root, t), _e(s, (n, a) => {
        this.setStyle(n, a);
      });
    } catch {
      this._rule = new CSSStyleRule();
    }
  }
  /**
   * A CSS selector text.
   *
   * E.g.: `.myClass p`
   *
   * @param selector  CSS selector
   */
  set selector(e) {
    this._rule.selectorText = e;
  }
  /**
   * @return CSS selector
   */
  get selector() {
    return this._rule.selectorText;
  }
  // TODO test this
  _dispose() {
    const e = Yi(this._root.cssRules, this._rule);
    if (e === -1)
      throw new Error("Could not dispose StyleRule");
    this._root.deleteRule(e);
  }
  /**
   * Sets the same style properties with browser-specific prefixes.
   *
   * @param name   Attribute name
   * @param value  Attribute value
   */
  _setVendorPrefixName(e, t) {
    const s = this._rule.style;
    s.setProperty("-webkit-" + e, t, ""), s.setProperty("-moz-" + e, t, ""), s.setProperty("-ms-" + e, t, ""), s.setProperty("-o-" + e, t, ""), s.setProperty(e, t, "");
  }
  /**
   * Sets a value for specific style attribute.
   *
   * @param name   Attribute
   * @param value  Value
   */
  setStyle(e, t) {
    e === "transition" ? this._setVendorPrefixName(e, t) : this._rule.style.setProperty(e, t, "");
  }
}
class Gx extends ur {
  /**
   * Constructor.
   *
   * @param text  CSS stylesheet
   */
  constructor(e, t, s = "") {
    super(), Object.defineProperty(this, "_element", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._element = Vx(e, t, s);
  }
  _dispose() {
    this._element.parentNode && this._element.parentNode.removeChild(this._element);
  }
}
function Zx(i, e) {
  if (i)
    if (i.classList) {
      const t = e.split(" ");
      x(t, (s) => {
        i.classList.add(s);
      });
    } else {
      let t = i.getAttribute("class");
      t ? i.setAttribute("class", t.split(" ").filter((s) => s !== e).join(" ") + " " + e) : i.setAttribute("class", e);
    }
}
function Kx(i, e) {
  if (i)
    if (i.classList)
      i.classList.remove(e);
    else {
      let t = i.getAttribute("class");
      t && i.setAttribute("class", t.split(" ").filter((s) => s !== e).join(" "));
    }
}
function nd() {
  return /apple/i.test(navigator.vendor) && "ontouchend" in document;
}
function ad() {
  return nd() ? 1 : void 0;
}
function we(i, e) {
  return S(i) ? i : i != null && S(i.value) && S(e) ? e * i.value : 0;
}
function od(i) {
  let e = ("" + i).match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);
  return e ? Math.max(0, (e[1] ? e[1].length : 0) - (e[2] ? +e[2] : 0)) : 0;
}
function je(i, e = 0, t = "0") {
  return typeof i != "string" && (i = i.toString()), e > i.length ? Array(e - i.length + 1).join(t) + i : i;
}
function ld(i) {
  return i.replace(/^[\s]*/, "");
}
function ud(i) {
  return i.replace(/[\s]*$/, "");
}
function jr(i) {
  return ld(ud(i));
}
function hd(i) {
  if (typeof i > "u")
    return "string";
  i = i.toLowerCase().replace(/^\[[^\]]*\]/, ""), i = i.replace(/\[[^\]]+\]/, ""), i = i.trim();
  let e = i.match(/\/(date|number|duration)$/);
  return e ? e[1] : i === "number" ? "number" : i === "date" ? "date" : i === "duration" ? "duration" : i.match(/[#0]/) ? "number" : i.match(/[ymwdhnsqaxkzgtei]/) ? "date" : "string";
}
function to(i) {
  return i.replace(/\/(date|number|duration)$/i, "");
}
function na(i) {
  return i && i.replace(/<[^>]*>/g, "");
}
function Qx(i) {
  return i && na(("" + i).replace(/[\n\r]+/g, ". "));
}
function rl(i) {
  return i.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
}
function Jx(i) {
  let e = "";
  for (let t = 0; t < i.length; t++) {
    const s = i.charAt(t);
    s.toUpperCase() == s && t != 0 && (e += " "), e += s;
  }
  return e;
}
function nl(i, e = !1) {
  const t = new Date(i.getFullYear(), 0, 0), s = i.getTime() - t.getTime() + (t.getTimezoneOffset() - i.getTimezoneOffset()) * 60 * 1e3, r = 1e3 * 60 * 60 * 24;
  return Math.floor(s / r);
}
function Gs(i, e = !1) {
  const t = new Date(Date.UTC(i.getFullYear(), i.getMonth(), i.getDate())), s = t.getUTCDay() || 7;
  t.setUTCDate(t.getUTCDate() + 4 - s);
  const r = new Date(Date.UTC(t.getUTCFullYear(), 0, 1));
  return Math.ceil(((t.getTime() - r.getTime()) / 864e5 + 1) / 7);
}
function cd(i, e = !1) {
  const t = new Date(Date.UTC(i.getFullYear(), i.getMonth(), i.getDate())), s = t.getUTCDay() || 7;
  return t.setUTCDate(t.getUTCDate() + 4 - s), new Date(Date.UTC(t.getUTCFullYear(), 0, 1)).getFullYear();
}
function dd(i, e = !1) {
  const t = Gs(new Date(i.getFullYear(), i.getMonth(), 1), e);
  let s = Gs(i, e);
  return s == 1 && (s = 53), s - t + 1;
}
function fd(i, e, t = 1, s = !1) {
  let r = new Date(e, 0, 4, 0, 0, 0, 0);
  return s && r.setUTCFullYear(e), i * 7 + t - ((r.getDay() || 7) + 3);
}
function xr(i, e) {
  return i > 12 ? i -= 12 : i === 0 && (i = 12), e != null ? i + (e - 1) : i;
}
function wr(i, e = !1, t = !1, s = !1) {
  if (s)
    return e ? "Coordinated Universal Time" : "UTC";
  let r = i.toLocaleString("UTC"), n = i.toLocaleString("UTC", { timeZoneName: e ? "long" : "short" }).substr(r.length);
  return t === !1 && (n = n.replace(/ (standard|daylight|summer|winter) /i, " ")), n;
}
function pd(i) {
  const e = new Date(Date.UTC(2012, 0, 1, 0, 0, 0, 0)), t = new Date(e.toLocaleString("en-US", { timeZone: "UTC" }));
  return (new Date(e.toLocaleString("en-US", { timeZone: i })).getTime() - t.getTime()) / 6e4 * -1;
}
function al(i) {
  return i.charAt(0).toUpperCase() + i.slice(1);
}
function xu(i) {
  let e, t, s, r = i.h, n = i.s, a = i.l;
  if (n == 0)
    e = t = s = a;
  else {
    let o = function(c, d, f) {
      return f < 0 && (f += 1), f > 1 && (f -= 1), f < 0.16666666666666666 ? c + (d - c) * 6 * f : f < 0.5 ? d : f < 0.6666666666666666 ? c + (d - c) * (0.6666666666666666 - f) * 6 : c;
    }, l = a < 0.5 ? a * (1 + n) : a + n - a * n, u = 2 * a - l;
    e = o(u, l, r + 1 / 3), t = o(u, l, r), s = o(u, l, r - 1 / 3);
  }
  return {
    r: Math.round(e * 255),
    g: Math.round(t * 255),
    b: Math.round(s * 255)
  };
}
function wu(i) {
  let e = i.r / 255, t = i.g / 255, s = i.b / 255, r = Math.max(e, t, s), n = Math.min(e, t, s), a = 0, o = 0, l = (r + n) / 2;
  if (r === n)
    a = o = 0;
  else {
    let u = r - n;
    switch (o = l > 0.5 ? u / (2 - r - n) : u / (r + n), r) {
      case e:
        a = (t - s) / u + (t < s ? 6 : 0);
        break;
      case t:
        a = (s - e) / u + 2;
        break;
      case s:
        a = (e - t) / u + 4;
        break;
    }
    a /= 6;
  }
  return {
    h: a,
    s: o,
    l
  };
}
function gd(i, e) {
  return i && {
    r: Math.max(0, Math.min(255, i.r + Er(i.r, e))),
    g: Math.max(0, Math.min(255, i.g + Er(i.g, e))),
    b: Math.max(0, Math.min(255, i.b + Er(i.b, e))),
    a: i.a
  };
}
function Er(i, e) {
  let t = e > 0 ? 255 - i : i;
  return Math.round(t * e);
}
function md(i, e) {
  if (i) {
    let t = Math.min(Math.max(i.r, i.g, i.b), 230), s = Er(t, e);
    return {
      r: Math.max(0, Math.min(255, Math.round(i.r + s))),
      g: Math.max(0, Math.min(255, Math.round(i.g + s))),
      b: Math.max(0, Math.min(255, Math.round(i.b + s))),
      a: i.a
    };
  } else
    return i;
}
function qx(i, e) {
  return Math.round(255 * e);
}
function ol(i) {
  return (i.r * 299 + i.g * 587 + i.b * 114) / 1e3 >= 128;
}
function _d(i, e) {
  if (i === void 0 || e == 1)
    return i;
  let t = wu(i);
  return t.s = e, xu(t);
}
function bd(i, e = { r: 255, g: 255, b: 255 }, t = { r: 255, g: 255, b: 255 }) {
  let s = e, r = t;
  return ol(t) && (s = t, r = e), ol(i) ? r : s;
}
function se(i, e) {
  return i || (i = []), [...i, ...e].filter((t, s, r) => r.indexOf(t) === s);
}
function Su(i, e) {
  return !(!e || i.left != e.left || i.right != e.right || i.top != e.top || i.bottom != e.bottom);
}
const e0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  StyleRule: Je,
  StyleSheet: Gx,
  addClass: Zx,
  addEventListener: Ie,
  addSpacing: Jx,
  alternativeColor: bd,
  blur: ed,
  brighten: md,
  capitalizeFirst: al,
  cleanFormat: to,
  contains: sd,
  decimalPlaces: od,
  escapeForRgex: rl,
  focus: td,
  get12Hours: xr,
  getBrightnessStep: qx,
  getDayFromWeek: fd,
  getFormat: hd,
  getLightnessStep: Er,
  getMonthWeek: dd,
  getPointerId: En,
  getRendererEvent: sa,
  getSafeResolution: ad,
  getShadowRoot: rd,
  getStyle: id,
  getTimeZone: wr,
  getTimezoneOffset: pd,
  getWeek: Gs,
  getWeekYear: cd,
  getYearDay: nl,
  hslToRgb: xu,
  iOS: nd,
  isLight: ol,
  isLocalEvent: eo,
  isTouchEvent: ra,
  lighten: gd,
  mergeTags: se,
  onZoom: vu,
  padString: je,
  plainText: Qx,
  ready: Jc,
  relativeToValue: we,
  removeClass: Kx,
  removeElement: qc,
  rgbToHsl: wu,
  sameBounds: Su,
  saturate: _d,
  setInteractive: Rs,
  setStyle: In,
  stripTags: na,
  supports: Ut,
  trim: jr,
  trimLeft: ld,
  trimRight: ud
}, Symbol.toStringTag, { value: "Module" }));
function yd(i) {
  return i[0] === "#" && (i = i.substr(1)), i.length == 3 && (i = i[0].repeat(2) + i[1].repeat(2) + i[2].repeat(2)), parseInt(i, 16);
}
function t0(i) {
  i = i.replace(/[ ]/g, "");
  let e = i.match(/^rgb\(([0-9]*),([0-9]*),([0-9]*)\)/i);
  if (e)
    e.push("1");
  else if (e = i.match(/^rgba\(([0-9]*),([0-9]*),([0-9]*),([.0-9]*)\)/i), !e)
    return 0;
  let t = "";
  for (let s = 1; s <= 3; s++) {
    let r = parseInt(e[s]).toString(16);
    r.length == 1 && (r = "0" + r), t += r;
  }
  return yd(t);
}
function oe(i) {
  return X.fromAny(i);
}
class X {
  constructor(e) {
    Object.defineProperty(this, "_hex", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._hex = e | 0;
  }
  /**
   * Color numeric value.
   */
  get hex() {
    return this._hex;
  }
  /**
   * Value of color's R channel.
   * @return R value
   */
  get r() {
    return this._hex >>> 16;
  }
  /**
   * Value of color's G channel.
   * @return G value
   */
  get g() {
    return this._hex >> 8 & 255;
  }
  /**
   * Value of color's B channel.
   * @return B value
   */
  get b() {
    return this._hex & 255;
  }
  /**
   * Returns color CSS representation in form of `rgba(r, g, b, a)` string.
   *
   * @param   alpha  Opacity
   * @return         CSS string
   */
  toCSS(e = 1) {
    return "rgba(" + this.r + ", " + this.g + ", " + this.b + ", " + e + ")";
  }
  /**
   * Returns color CSS representation in form of `#rgb` string.
   *
   * @return         CSS string
   */
  toCSSHex() {
    return "#" + je(this.r.toString(16), 2) + je(this.g.toString(16), 2) + je(this.b.toString(16), 2);
  }
  /**
   * Returns color's HSL info.
   * @param   alpha Opacity
   * @return        HSL info
   */
  toHSL(e = 1) {
    return wu({
      r: this.r,
      g: this.g,
      b: this.b,
      a: e
    });
  }
  /**
   * Converts HSL values into a new [[Color]] object.
   *
   * @param   h H value
   * @param   s S value
   * @param   l L value
   * @return    Color object
   */
  static fromHSL(e, t, s) {
    const r = xu({
      h: e,
      s: t,
      l: s
    });
    return this.fromRGB(r.r, r.g, r.b);
  }
  toString() {
    return this.toCSSHex();
  }
  /**
   * Converts hex number into a new [[Color]] object.
   *
   * ```TypeScript
   * Color.fromHex(0xff0000) // red
   * ```
   * ```JavaScript
   * Color.fromHex(0xff0000) // red
   * ```
   *
   * @param   hex  Hex color
   * @return       Color
   */
  static fromHex(e) {
    return new X(e);
  }
  /**
   * Converts RGB values to a new [[Color]] object.
   *
   * @param   r  R value
   * @param   g  G value
   * @param   b  B value
   * @return     Color
   */
  static fromRGB(e, t, s) {
    return new X((s | 0) + (t << 8) + (e << 16));
  }
  /**
   * Converts RGB string to a new [[Color]] object.
   *
   * ```TypeScript
   * Color.fromString("#ff0000") // red
   * ```
   * ```JavaScript
   * Color.fromString("#ff0000") // red
   * ```
   *
   * @param   s  RGB string
   * @return     Color
   */
  static fromString(e) {
    return new X(yd(e));
  }
  /**
   * Converts CSS rgba() syntax to a new [[Color]] object.
   *
   * ```TypeScript
   * Color.fromCSS("rgba(255, 0, 0, 1)") // red
   * ```
   * ```JavaScript
   * Color.fromCSS("rgba(255, 0, 0, 1)") // red
   * ```
   *
   * @param  {string} s [description]
   * @return {Color}    [description]
   */
  static fromCSS(e) {
    return new X(t0(e));
  }
  /**
   * Convert to color from virtually anything.
   *
   * Will throw an exception if unable to resolve the color.
   *
   * @param   s  Source
   * @return     Color
   */
  static fromAny(e) {
    if (Ri(e)) {
      if (e[0] == "#")
        return X.fromString(e);
      if (e.substr(0, 3) == "rgb")
        return X.fromCSS(e);
    } else {
      if (S(e))
        return X.fromHex(e);
      if (e instanceof X)
        return X.fromHex(e.hex);
    }
    throw new Error("Unknown color syntax: " + e);
  }
  /**
   * Returns a new [[Color]] object based on either `lightAlternative` or
   * `darkAlternative` depending on which one is more contrasting with
   * the `color`.
   *
   * @param   color             Reference color
   * @param   lightAlternative  Light color
   * @param   darkAlternative   Dark color
   * @return                    Alternative color
   */
  static alternative(e, t, s) {
    const r = bd({ r: e.r, g: e.g, b: e.b }, t ? { r: t.r, g: t.g, b: t.b } : void 0, s ? { r: s.r, g: s.g, b: s.b } : void 0);
    return this.fromRGB(r.r, r.g, r.b);
  }
  /**
   * Returns an intermediate Color between two reference colors depending on
   * the progress (`diff`) between the two.
   *
   * @param   diff  Progress
   * @param   from  Source color
   * @param   to    Target color
   * @param   mode  Interpolation mode
   * @return        Color
   */
  static interpolate(e, t, s, r = "rgb") {
    if (r == "hsl") {
      const n = t.toHSL(), a = s.toHSL();
      return X.fromHSL(Di(e, n.h, a.h), Di(e, n.s, a.s), Di(e, n.l, a.l));
    } else
      return X.fromRGB(Di(e, t.r, s.r), Di(e, t.g, s.g), Di(e, t.b, s.b));
  }
  /**
   * Returns a new [[Color]] lightened by `percent` value.
   *
   * Use negative value to darken the color.
   *
   * @param   color    Source color
   * @param   percent  Percent
   * @return           New color
   */
  static lighten(e, t) {
    const s = gd({ r: e.r, g: e.g, b: e.b }, t);
    return X.fromRGB(s.r, s.g, s.b);
  }
  /**
   * Returns a new [[Color]] brightened by `percent` value.
   *
   * Use negative value to dim the color.
   *
   * @param   color    Source color
   * @param   percent  Percent
   * @return           New color
   */
  static brighten(e, t) {
    const s = md({ r: e.r, g: e.g, b: e.b }, t);
    return X.fromRGB(s.r, s.g, s.b);
  }
  /**
   * Returns a new [[Color]] saturated by `percent` value.
   *
   * Value range is between `0` (fully desaturated), to `1` (full color).
   *
   * @param   color    Source color
   * @param   percent  Percent
   * @return           New color
   */
  static saturate(e, t) {
    const s = _d({ r: e.r, g: e.g, b: e.b }, t);
    return X.fromRGB(s.r, s.g, s.b);
  }
}
function Zu(i) {
  return Ue(this, void 0, void 0, function* () {
    if (i !== void 0) {
      const e = [];
      _e(i, (t, s) => {
        e.push(s.waitForStop());
      }), yield Promise.all(e);
    }
  });
}
function Di(i, e, t) {
  return e + i * (t - e);
}
function i0(i, e, t) {
  return i >= 1 ? t : e;
}
function vd(i, e, t) {
  return new ne(Di(i, e.percent, t.percent));
}
function s0(i, e, t) {
  return X.interpolate(i, e, t);
}
function r0(i, e) {
  return typeof i == "number" && typeof e == "number" ? Di : i instanceof ne && e instanceof ne ? vd : i instanceof X && e instanceof X ? s0 : i0;
}
const io = Math.PI, xd = io / 2, ms = io / 180, fs = 180 / io;
function tt(i, e, t) {
  if (!S(e) || e <= 0) {
    let s = Math.round(i);
    return t && s - i == 0.5 && s--, s;
  } else {
    let s = Math.pow(10, e);
    return Math.round(i * s) / s;
  }
}
function wd(i, e) {
  if (!S(e) || e <= 0)
    return Math.ceil(i);
  {
    let t = Math.pow(10, e);
    return Math.ceil(i * t) / t;
  }
}
function n0(i, e, t, s, r) {
  return { x: (-i.x + e.x / s + t.x) * s, y: (-i.y + e.y / r + t.y) * r };
}
function a0(i, e, t, s, r) {
  return { x: (i.x + e.x / s - t.x) * s, y: (i.y + e.y / r - t.y) * r };
}
function Ne(i, e, t) {
  return Math.min(Math.max(i, e), t);
}
function qe(i) {
  return Math.sin(ms * i);
}
function o0(i) {
  return Math.tan(ms * i);
}
function ht(i) {
  return Math.cos(ms * i);
}
function _s(i) {
  return i = i % 360, i < 0 && (i += 360), i;
}
function aa(i, e, t, s, r) {
  let n = Number.MAX_VALUE, a = Number.MAX_VALUE, o = -Number.MAX_VALUE, l = -Number.MAX_VALUE, u = [];
  u.push(Rn(r, t)), u.push(Rn(r, s));
  let h = Math.min(Math.floor(t / 90) * 90, Math.floor(s / 90) * 90), c = Math.max(Math.ceil(t / 90) * 90, Math.ceil(s / 90) * 90);
  for (let d = h; d <= c; d += 90)
    d >= t && d <= s && u.push(Rn(r, d));
  for (let d = 0; d < u.length; d++) {
    let f = u[d];
    f.x < n && (n = f.x), f.y < a && (a = f.y), f.x > o && (o = f.x), f.y > l && (l = f.y);
  }
  return { left: i + n, top: e + a, right: i + o, bottom: e + l };
}
function Rn(i, e) {
  return { x: i * ht(e), y: i * qe(e) };
}
function Sd(i) {
  const e = i.length;
  if (e > 0) {
    let t = i[0], s = t.left, r = t.top, n = t.right, a = t.bottom;
    if (e > 1)
      for (let o = 1; o < e; o++)
        t = i[o], s = Math.min(t.left, s), n = Math.max(t.right, n), r = Math.min(t.top, r), a = Math.max(t.bottom, a);
    return { left: s, right: n, top: r, bottom: a };
  }
  return { left: 0, right: 0, top: 0, bottom: 0 };
}
function l0(i, e, t) {
  if (e > t) {
    let a = e;
    e = t, t = a;
  }
  i = _s(i);
  let s = (e - _s(e)) / 360;
  i < e && (i += 360 * (s + 1));
  let r = e + (t - e) / 2 + 180, n = e + (t - e) / 2 - 180;
  return i > t && (i - 360 > e ? i -= 360 : i < r ? i = t : i = e), i < e && (i > n ? i = e : i = t), i;
}
function u0(i, e) {
  return i.x >= e.left && i.y >= e.top && i.x <= e.right && i.y <= e.bottom;
}
function Dd(i, e) {
  e || (e = { x: i.x * 2, y: i.y * 2 });
  let t = e.x - i.x, s = e.y - i.y, r = Math.atan2(s, t) * fs;
  return r < 0 && (r += 360), _s(r);
}
function h0(i, e, t, s) {
  let r = (1 - s) * (1 - s) * i.x + 2 * (1 - s) * s * t.x + s * s * e.x, n = (1 - s) * (1 - s) * i.y + 2 * (1 - s) * s * t.y + s * s * e.y;
  return { x: r, y: n };
}
function c0(i, e, t) {
  return { x: i.x + (e.x - i.x) * t, y: i.y + (e.y - i.y) * t };
}
function Pd(i, e) {
  return i.reduce(function(t, s) {
    return Math.abs(s - e) < Math.abs(t - e) ? s : t;
  });
}
function d0(i, e) {
  return !(i.bottom < e.top || e.bottom < i.top || i.right < e.left || e.right < i.left);
}
const f0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  DEGREES: fs,
  HALFPI: xd,
  PI: io,
  RADIANS: ms,
  boundsOverlap: d0,
  ceil: wd,
  closest: Pd,
  cos: ht,
  fitAngleToRange: l0,
  fitToRange: Ne,
  getAngle: Dd,
  getArcBounds: aa,
  getArcPoint: Rn,
  getCubicControlPointA: n0,
  getCubicControlPointB: a0,
  getPointOnLine: c0,
  getPointOnQuadraticCurve: h0,
  inBounds: u0,
  mergeBounds: Sd,
  normalizeAngle: _s,
  round: tt,
  sin: qe,
  tan: o0
}, Symbol.toStringTag, { value: "Module" }));
function ll(i) {
  return i;
}
function p0(i) {
  return i * i;
}
function Ys(i) {
  return i * i * i;
}
function g0(i, e) {
  return Math.pow(i, e);
}
function m0(i) {
  return Math.pow(2, 10 * i - 10);
}
function _0(i) {
  return 1 - Math.cos(i * xd);
}
function b0(i) {
  return 1 - Math.sqrt(1 - i * i);
}
function y0(i) {
  return function(e) {
    return e < 0.5 ? i(e * 2) : i((1 - e) * 2);
  };
}
function Sr(i) {
  return function(e) {
    return 1 - i(1 - e);
  };
}
function v0(i) {
  return function(e) {
    return e <= 0.5 ? i(e * 2) / 2 : 1 - i((1 - e) * 2) / 2;
  };
}
let ul = 4 / 11, x0 = 6 / 11, w0 = 8 / 11, S0 = 3 / 4, D0 = 9 / 11, P0 = 10 / 11, T0 = 15 / 16, k0 = 21 / 22, C0 = 63 / 64, bn = 1 / ul / ul;
function M0(i) {
  return 1 - O0(1 - i);
}
function O0(i) {
  return i = i, i < ul ? bn * i * i : i < w0 ? bn * (i -= x0) * i + S0 : i < P0 ? bn * (i -= D0) * i + T0 : bn * (i -= k0) * i + C0;
}
let A0 = 2 * Math.PI, Td = 1, kd = 0.3 / A0, L0 = Math.asin(1 / Td) * kd;
function j0(i) {
  let e = i;
  return Td * Math.pow(2, 10 * --e) * Math.sin((L0 - e) / kd);
}
const E0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bounce: M0,
  circle: b0,
  cubic: Ys,
  elastic: j0,
  exp: m0,
  inOut: v0,
  linear: ll,
  out: Sr,
  pow: g0,
  quad: p0,
  sine: _0,
  yoyo: y0
}, Symbol.toStringTag, { value: "Module" }));
class I0 {
  constructor(e, t) {
    Object.defineProperty(this, "_entity", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_settings", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_userSettings", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), this._entity = e, this._settings = t, _e(t, (s) => {
      this._userSettings[s] = !0;
    });
  }
  get(e, t) {
    const s = this._settings[e];
    return s !== void 0 ? s : t;
  }
  /**
   * @ignore
   */
  setRaw(e, t) {
    this._settings[e] = t;
  }
  /**
   * Sets a setting `value` for the specified `key` to be set when the state
   * is applied.
   *
   * @param   key       Setting key
   * @param   value     Setting value
   * @return            Setting value
   */
  set(e, t) {
    this._userSettings[e] = !0, this.setRaw(e, t);
  }
  /**
   * Removes a setting value for the specified `key`.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
   * @param   key       Setting key
   */
  remove(e) {
    delete this._userSettings[e], delete this._settings[e];
  }
  /**
   * Sets multiple settings at once.
   *
   * `settings` must be an object with key: value pairs.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
   * @param settings Settings
   */
  setAll(e) {
    Be(e).forEach((t) => {
      this.set(t, e[t]);
    });
  }
  _eachSetting(e) {
    _e(this._settings, e);
  }
  /**
   * Applies the state to the target element.
   *
   * All setting values are set immediately.
   */
  apply() {
    const e = {};
    e.stateAnimationEasing = !0, e.stateAnimationDuration = !0;
    const t = this._entity.states.lookup("default");
    this._eachSetting((s, r) => {
      e[s] || (e[s] = !0, this !== t && (s in t._settings || (t._settings[s] = this._entity.get(s))), this._entity.set(s, r));
    });
  }
  /**
   * Applies the state to the target element.
   *
   * Returns an object representing all [[Animation]] objects created for
   * each setting key transition.
   *
   * @return           Animations
   */
  applyAnimate(e) {
    e == null && (e = this._settings.stateAnimationDuration), e == null && (e = this.get("stateAnimationDuration", this._entity.get("stateAnimationDuration", 0)));
    let t = this._settings.stateAnimationEasing;
    t == null && (t = this.get("stateAnimationEasing", this._entity.get("stateAnimationEasing", Ys)));
    const s = this._entity.states.lookup("default"), r = {};
    r.stateAnimationEasing = !0, r.stateAnimationDuration = !0;
    const n = {};
    return this._eachSetting((a, o) => {
      if (!r[a]) {
        r[a] = !0, this != s && (a in s._settings || (s._settings[a] = this._entity.get(a)));
        const l = this._entity.animate({
          key: a,
          to: o,
          duration: e,
          easing: t
        });
        l && (n[a] = l);
      }
    }), n;
  }
}
class R0 {
  constructor(e) {
    Object.defineProperty(this, "_states", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_entity", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._entity = e;
  }
  /**
   * Checks if a state by `name` exists. Returns it there is one.
   *
   * @param  name  State name
   * @return       State
   */
  lookup(e) {
    return this._states[e];
  }
  /**
   * Sets supplied `settings` on a state by the `name`.
   *
   * If such state does not yet exists, it is created.
   *
   * @param   name      State name
   * @param   settings  Settings
   * @return            New State
   */
  create(e, t) {
    const s = this._states[e];
    if (s)
      return s.setAll(t), s;
    {
      const r = new I0(this._entity, t);
      return this._states[e] = r, r;
    }
  }
  /**
   * Removes the state called `name`.
   *
   * @param   name      State name
   */
  remove(e) {
    delete this._states[e];
  }
  /**
   * Applies a named state to the target element.
   *
   * @param  newState  State name
   */
  apply(e) {
    const t = this._states[e];
    t && t.apply(), this._entity._applyState(e);
  }
  /**
   * Applies a named state to the element.
   *
   * Returns an object representing all [[Animation]] objects created for
   * each setting key transition.
   *
   * @param   newState  State name
   * @return            Animations
   */
  applyAnimate(e, t) {
    let s;
    const r = this._states[e];
    return r && (s = r.applyAnimate(t)), this._entity._applyStateAnimated(e, t), s;
  }
}
class Y0 {
  constructor() {
    Object.defineProperty(this, "version", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "5.3.7"
    }), Object.defineProperty(this, "licenses", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "entitiesById", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "rootElements", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    });
  }
}
const Lt = new Y0();
function N0(i) {
  Lt.licenses.push(i);
}
function $0() {
  let i;
  for (; i = Lt.rootElements.pop(); )
    i.dispose();
}
function Et(i, e) {
  return i === e ? 0 : i < e ? -1 : 1;
}
function Cd(i, e, t) {
  const s = i.length, r = e.length, n = Math.min(s, r);
  for (let a = 0; a < n; ++a) {
    const o = t(i[a], e[a]);
    if (o !== 0)
      return o;
  }
  return Et(s, r);
}
function Ku(i, e) {
  return i === e ? 0 : i < e ? -1 : 1;
}
class F0 {
  constructor(e) {
    Object.defineProperty(this, "_entity", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_callbacks", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_disabled", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), this._entity = e;
  }
  /**
   * Add a function (`callback`) that will modify value for setting `key`.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/adapters/} for more info
   */
  add(e, t) {
    let s = this._callbacks[e];
    return s === void 0 && (s = this._callbacks[e] = []), s.push(t), this._entity._markDirtyKey(e), new Ve(() => {
      ot(s, t) && this._entity._markDirtyKey(e);
    });
  }
  /**
   * Removes all adapters for the specific key.
   *
   * @since 5.1.0
   */
  remove(e) {
    const t = this._callbacks[e];
    t !== void 0 && (delete this._callbacks[e], t.length !== 0 && this._entity._markDirtyKey(e));
  }
  /**
   * Enables (previously disabled) adapters for specific key.
   *
   * @since 5.1.0
   */
  enable(e) {
    this._disabled[e] && (delete this._disabled[e], this._entity._markDirtyKey(e));
  }
  /**
   * Disables all adapters for specific key.
   *
   * @since 5.1.0
   */
  disable(e) {
    this._disabled[e] || (this._disabled[e] = !0, this._entity._markDirtyKey(e));
  }
  /**
   * @ignore
   */
  fold(e, t) {
    if (!this._disabled[e]) {
      const s = this._callbacks[e];
      if (s !== void 0)
        for (let r = 0, n = s.length; r < n; ++r)
          t = s[r](t, this._entity, e);
    }
    return t;
  }
}
class yn {
  constructor(e, t, s, r, n, a, o) {
    Object.defineProperty(this, "_animation", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_from", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_to", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_duration", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_easing", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_loops", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_interpolate", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_oldTime", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_time", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_stopped", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_playing", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "events", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new hr()
    }), this._animation = e, this._from = t, this._to = s, this._duration = r, this._easing = n, this._loops = a, this._interpolate = r0(t, s), this._oldTime = o;
  }
  get to() {
    return this._to;
  }
  get from() {
    return this._from;
  }
  get playing() {
    return this._playing;
  }
  get stopped() {
    return this._stopped;
  }
  stop() {
    this._stopped || (this._stopped = !0, this._playing = !1, this.events.isEnabled("stopped") && this.events.dispatch("stopped", {
      type: "stopped",
      target: this
    }));
  }
  pause() {
    this._playing = !1, this._oldTime = null;
  }
  play() {
    !this._stopped && !this._playing && (this._playing = !0, this._animation._startAnimation());
  }
  get percentage() {
    return this._time / this._duration;
  }
  waitForStop() {
    return new Promise((e, t) => {
      if (this._stopped)
        e();
      else {
        const s = () => {
          r.dispose(), e();
        }, r = this.events.on("stopped", s);
      }
    });
  }
  _checkEnded() {
    return this._loops > 1 ? (--this._loops, !1) : !0;
  }
  _run(e) {
    this._oldTime !== null && (this._time += e - this._oldTime, this._time > this._duration && (this._time = this._duration)), this._oldTime = e;
  }
  _reset(e) {
    this._oldTime = e, this._time = 0;
  }
  _value(e) {
    return this._interpolate(this._easing(e), this._from, this._to);
  }
}
let B0 = 0;
class Md {
  constructor(e) {
    Object.defineProperty(this, "uid", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ++B0
    }), Object.defineProperty(this, "_settings", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_privateSettings", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_settingEvents", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_privateSettingEvents", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_prevSettings", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_prevPrivateSettings", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_animatingSettings", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_animatingPrivateSettings", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_disposed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_userProperties", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), this._settings = e;
  }
  _checkDirty() {
    Be(this._settings).forEach((e) => {
      this._userProperties[e] = !0, this._markDirtyKey(e);
    });
  }
  /**
   * @ignore
   */
  resetUserSettings() {
    this._userProperties = {};
  }
  _runAnimation(e) {
    if (this.isDisposed())
      return !1;
    {
      let t = !1;
      return _e(this._animatingSettings, (s, r) => {
        if (r._stopped)
          this._stopAnimation(s);
        else if (r._playing) {
          r._run(e);
          const n = r.percentage;
          n >= 1 ? r._checkEnded() ? this.set(s, r._value(1)) : (t = !0, r._reset(e), this._set(s, r._value(1))) : (t = !0, this._set(s, r._value(n)));
        }
      }), _e(this._animatingPrivateSettings, (s, r) => {
        if (r._stopped)
          this._stopAnimationPrivate(s);
        else if (r._playing) {
          r._run(e);
          const n = r.percentage;
          n >= 1 ? r._checkEnded() ? this.setPrivate(s, r._value(1)) : (t = !0, r._reset(e), this._setPrivate(s, r._value(1))) : (t = !0, this._setPrivate(s, r._value(n)));
        }
      }), t;
    }
  }
  _markDirtyKey(e) {
    this.markDirty();
  }
  _markDirtyPrivateKey(e) {
    this.markDirty();
  }
  /**
   * Sets a callback function to invoke when specific key of settings changes
   * or is set.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/events/#Settings_value_change} for more info
   * @param   key       Settings key
   * @param   callback  Callback
   * @return            Disposer for event
   */
  on(e, t) {
    let s = this._settingEvents[e];
    return s === void 0 && (s = this._settingEvents[e] = []), s.push(t), new Ve(() => {
      ot(s, t), s.length === 0 && delete this._settingEvents[e];
    });
  }
  /**
   * Sets a callback function to invoke when specific key of private settings
   * changes or is set.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/events/#Settings_value_change} for more info
   * @ignore
   * @param   key       Private settings key
   * @param   callback  Callback
   * @return            Disposer for event
   */
  onPrivate(e, t) {
    let s = this._privateSettingEvents[e];
    return s === void 0 && (s = this._privateSettingEvents[e] = []), s.push(t), new Ve(() => {
      ot(s, t), s.length === 0 && delete this._privateSettingEvents[e];
    });
  }
  /**
   * @ignore
   */
  getRaw(e, t) {
    const s = this._settings[e];
    return s !== void 0 ? s : t;
  }
  get(e, t) {
    return this.getRaw(e, t);
  }
  _sendKeyEvent(e, t) {
    const s = this._settingEvents[e];
    s !== void 0 && x(s, (r) => {
      r(t, this, e);
    });
  }
  _sendPrivateKeyEvent(e, t) {
    const s = this._privateSettingEvents[e];
    s !== void 0 && x(s, (r) => {
      r(t, this, e);
    });
  }
  /**
   * @ignore
   */
  _setRaw(e, t, s) {
    this._prevSettings[e] = t, this._sendKeyEvent(e, s);
  }
  /**
   * @ignore
   */
  setRaw(e, t) {
    const s = this._settings[e];
    this._settings[e] = t, s !== t && this._setRaw(e, s, t);
  }
  /**
   * @ignore
   */
  _set(e, t) {
    const s = this._settings[e];
    this._settings[e] = t, s !== t && (this._setRaw(e, s, t), this._markDirtyKey(e));
  }
  _stopAnimation(e) {
    const t = this._animatingSettings[e];
    t && (delete this._animatingSettings[e], t.stop());
  }
  /**
   * Sets a setting `value` for the specified `key`, and returns the same `value`.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
   * @param   key       Setting key
   * @param   value     Setting value
   * @return            Setting value
   */
  set(e, t) {
    return this._set(e, t), this._stopAnimation(e), t;
  }
  /**
   * Removes a setting value for the specified `key`;
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
   * @param   key       Setting key
   */
  remove(e) {
    e in this._settings && (this._prevSettings[e] = this._settings[e], delete this._settings[e], this._sendKeyEvent(e, void 0), this._markDirtyKey(e)), this._stopAnimation(e);
  }
  /**
   * Removes all keys;
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
   */
  removeAll() {
    x(Be(this._settings), (e) => {
      this.remove(e);
    });
  }
  /**
   * Returns a value of a private setting.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/#Private_settings} for more info
   */
  getPrivate(e, t) {
    const s = this._privateSettings[e];
    return s !== void 0 ? s : t;
  }
  /**
   * @ignore
   */
  _setPrivateRaw(e, t, s) {
    this._prevPrivateSettings[e] = t, this._sendPrivateKeyEvent(e, s);
  }
  /**
   * @ignore
   */
  setPrivateRaw(e, t) {
    const s = this._privateSettings[e];
    this._privateSettings[e] = t, s !== t && this._setPrivateRaw(e, s, t);
  }
  /**
   * @ignore
   */
  _setPrivate(e, t) {
    const s = this._privateSettings[e];
    this._privateSettings[e] = t, s !== t && (this._setPrivateRaw(e, s, t), this._markDirtyPrivateKey(e));
  }
  _stopAnimationPrivate(e) {
    const t = this._animatingPrivateSettings[e];
    t && (t.stop(), delete this._animatingPrivateSettings[e]);
  }
  /**
   * @ignore
   */
  setPrivate(e, t) {
    return this._setPrivate(e, t), this._stopAnimationPrivate(e), t;
  }
  /**
   * @ignore
   */
  removePrivate(e) {
    e in this._privateSettings && (this._prevPrivateSettings[e] = this._privateSettings[e], delete this._privateSettings[e], this._markDirtyPrivateKey(e)), this._stopAnimationPrivate(e);
  }
  /**
   * Sets multiple settings at once.
   *
   * `settings` must be an object with key: value pairs.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
   * @param settings Settings
   */
  setAll(e) {
    _e(e, (t, s) => {
      this.set(t, s);
    });
  }
  /**
   * Animates setting values from current/start values to new ones.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/animations/#Animating_settings} for more info
   * @param   options  Animation options
   * @return           Animation object
   */
  animate(e) {
    const t = e.key, s = e.to, r = e.duration || 0, n = e.loops || 1, a = e.from === void 0 ? this.get(t) : e.from, o = e.easing === void 0 ? ll : e.easing;
    if (r === 0)
      this.set(t, s);
    else if (a === void 0 || a === s)
      this.set(t, s);
    else {
      this.set(t, a);
      const u = this._animatingSettings[t] = new yn(this, a, s, r, o, n, this._animationTime());
      return this._startAnimation(), u;
    }
    const l = new yn(this, a, s, r, o, n, null);
    return l.stop(), l;
  }
  /**
   * @ignore
   */
  animatePrivate(e) {
    const t = e.key, s = e.to, r = e.duration || 0, n = e.loops || 1, a = e.from === void 0 ? this.getPrivate(t) : e.from, o = e.easing === void 0 ? ll : e.easing;
    if (r === 0)
      this.setPrivate(t, s);
    else if (a === void 0 || a === s)
      this.setPrivate(t, s);
    else {
      this.setPrivate(t, a);
      const u = this._animatingPrivateSettings[t] = new yn(this, a, s, r, o, n, this._animationTime());
      return this._startAnimation(), u;
    }
    const l = new yn(this, a, s, r, o, n, null);
    return l.stop(), l;
  }
  _dispose() {
  }
  /**
   * Returns `true` if this element is disposed.
   *
   * @return Disposed
   */
  isDisposed() {
    return this._disposed;
  }
  /**
   * Disposes this object.
   */
  dispose() {
    this._disposed || (this._disposed = !0, this._dispose());
  }
}
class De extends Md {
  /**
   * IMPORTANT! Do not instantiate this class via `new Class()` syntax.
   *
   * Use static method `Class.new()` instead.
   *
   * @see {@link https://www.amcharts.com/docs/v5/getting-started/#New_element_syntax} for more info
   * @ignore
   */
  constructor(e, t, s, r = []) {
    if (super(t), Object.defineProperty(this, "_root", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_user_id", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "states", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new R0(this)
    }), Object.defineProperty(this, "adapters", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new F0(this)
    }), Object.defineProperty(this, "events", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._createEvents()
    }), Object.defineProperty(this, "_userPrivateProperties", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_dirty", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_dirtyPrivate", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_template", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_templates", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_internalTemplates", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_defaultThemes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_templateDisposers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_disposers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_runSetup", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "_disposerProperties", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), !s)
      throw new Error("You cannot use `new Class()`, instead use `Class.new()`");
    this._root = e, this._internalTemplates = r, t.id && this._registerId(t.id);
  }
  /**
   * Use this method to create an instance of this class.
   *
   * @see {@link https://www.amcharts.com/docs/v5/getting-started/#New_element_syntax} for more info
   * @param   root      Root element
   * @param   settings  Settings
   * @param   template  Template
   * @return            Instantiated object
   */
  static new(e, t, s) {
    const r = new this(e, t, !0);
    return r._template = s, r._afterNew(), r;
  }
  static _new(e, t, s = []) {
    const r = new this(e, t, !0, s);
    return r._afterNew(), r;
  }
  _afterNew() {
    this._checkDirty();
    let e = !1;
    const t = this._template;
    t && (e = !0, t._setObjectTemplate(this)), x(this._internalTemplates, (s) => {
      e = !0, s._setObjectTemplate(this);
    }), e && this._applyTemplates(!1), this.states.create("default", {}), this._setDefaults();
  }
  // This is the same as _afterNew, except it also applies the themes.
  // This should only be used for classes which don't have a parent (because they extend from Entity and not Sprite).
  _afterNewApplyThemes() {
    this._checkDirty();
    const e = this._template;
    e && e._setObjectTemplate(this), x(this._internalTemplates, (t) => {
      t._setObjectTemplate(this);
    }), this.states.create("default", {}), this._setDefaults(), this._applyThemes();
  }
  _createEvents() {
    return new hr();
  }
  /**
   * @ignore
   */
  get classNames() {
    return this.constructor.classNames;
  }
  /**
   * @ignore
   */
  get className() {
    return this.constructor.className;
  }
  _setDefaults() {
  }
  _setDefault(e, t) {
    e in this._settings || super.set(e, t);
  }
  _setRawDefault(e, t) {
    e in this._settings || super.setRaw(e, t);
  }
  _clearDirty() {
    Be(this._dirty).forEach((e) => {
      this._dirty[e] = !1;
    }), Be(this._dirtyPrivate).forEach((e) => {
      this._dirtyPrivate[e] = !1;
    });
  }
  /**
   * @ignore
   */
  isDirty(e) {
    return !!this._dirty[e];
  }
  /**
   * @ignore
   */
  isPrivateDirty(e) {
    return !!this._dirtyPrivate[e];
  }
  _markDirtyKey(e) {
    this._dirty[e] = !0, super._markDirtyKey(e);
  }
  _markDirtyPrivateKey(e) {
    this._dirtyPrivate[e] = !0, super._markDirtyKey(e);
  }
  /**
   * Checks if element is of certain class (or inherits one).
   *
   * @param   type  Class name to check
   * @return {boolean} Is of class?
   */
  isType(e) {
    return this.classNames.indexOf(e) !== -1;
  }
  _pushPropertyDisposer(e, t) {
    let s = this._disposerProperties[e];
    return s === void 0 && (s = this._disposerProperties[e] = []), s.push(t), t;
  }
  _disposeProperty(e) {
    const t = this._disposerProperties[e];
    t !== void 0 && (x(t, (s) => {
      s.dispose();
    }), delete this._disposerProperties[e]);
  }
  /**
   * @todo needs description
   * @param  value  Template
   */
  set template(e) {
    const t = this._template;
    t !== e && (this._template = e, t && t._removeObjectTemplate(this), e && e._setObjectTemplate(this), this._applyTemplates());
  }
  get template() {
    return this._template;
  }
  /**
   * @ignore
   */
  markDirty() {
    this._root._addDirtyEntity(this);
  }
  _startAnimation() {
    this._root._addAnimation(this);
  }
  _animationTime() {
    return this._root.animationTime;
  }
  _applyState(e) {
  }
  _applyStateAnimated(e, t) {
  }
  get(e, t) {
    const s = this.adapters.fold(e, this._settings[e]);
    return s !== void 0 ? s : t;
  }
  /**
   * @ignore
   */
  isUserSetting(e) {
    return this._userProperties[e] || !1;
  }
  /**
   * Sets a setting `value` for the specified `key`, and returns the same `value`.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
   * @param   key       Setting key
   * @param   value     Setting value
   * @return            Setting value
   */
  set(e, t) {
    return this._userProperties[e] = !0, super.set(e, t);
  }
  /**
   * @ignore
   */
  setRaw(e, t) {
    this._userProperties[e] = !0, super.setRaw(e, t);
  }
  /**
   * Sets a setting `value` for the specified `key` only if the value for this key was not set previously using set method, and returns the same `value`.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
   * @param   key       Setting key
   * @param   value     Setting value
   * @return            Setting value
   */
  _setSoft(e, t) {
    return this._userProperties[e] ? t : super.set(e, t);
  }
  /**
   * Removes a setting value for the specified `key`.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
   * @param   key       Setting key
   */
  remove(e) {
    delete this._userProperties[e], this._removeTemplateProperty(e);
  }
  /**
   * @ignore
   */
  setPrivate(e, t) {
    return this._userPrivateProperties[e] = !0, super.setPrivate(e, t);
  }
  /**
   * @ignore
   */
  setPrivateRaw(e, t) {
    this._userPrivateProperties[e] = !0, super.setPrivateRaw(e, t);
  }
  /**
   * @ignore
   */
  removePrivate(e) {
    delete this._userPrivateProperties[e], this._removeTemplatePrivateProperty(e);
  }
  _setTemplateProperty(e, t, s) {
    if (!this._userProperties[t]) {
      const r = this._findTemplateByKey(t);
      e === r && super.set(t, s);
    }
  }
  _setTemplatePrivateProperty(e, t, s) {
    if (!this._userPrivateProperties[t]) {
      const r = this._findTemplateByPrivateKey(t);
      e === r && super.setPrivate(t, s);
    }
  }
  _removeTemplateProperty(e) {
    if (!this._userProperties[e]) {
      const t = this._findTemplateByKey(e);
      t ? super.set(e, t._settings[e]) : super.remove(e);
    }
  }
  _removeTemplatePrivateProperty(e) {
    if (!this._userPrivateProperties[e]) {
      const t = this._findTemplateByPrivateKey(e);
      t ? super.setPrivate(e, t._privateSettings[e]) : super.removePrivate(e);
    }
  }
  _walkParents(e) {
    e(this._root._rootContainer), e(this);
  }
  // TODO faster version of this method which is specialized to just 1 key
  _applyStateByKey(e) {
    const t = this.states.create(e, {}), s = {};
    this._eachTemplate((r) => {
      const n = r.states.lookup(e);
      n && n._apply(t, s);
    }), _e(t._settings, (r) => {
      !s[r] && !t._userSettings[r] && t.remove(r);
    });
  }
  _applyTemplate(e, t) {
    this._templateDisposers.push(e._apply(this, t)), _e(e._settings, (s, r) => {
      !t.settings[s] && !this._userProperties[s] && (t.settings[s] = !0, super.set(s, r));
    }), _e(e._privateSettings, (s, r) => {
      !t.privateSettings[s] && !this._userPrivateProperties[s] && (t.privateSettings[s] = !0, super.setPrivate(s, r));
    }), this._runSetup && e.setup && (this._runSetup = !1, e.setup(this));
  }
  /**
   * Calls the closure with each template and returns the first template which is true
   */
  _findStaticTemplate(e) {
    if (this._template && e(this._template))
      return this._template;
  }
  _eachTemplate(e) {
    this._findStaticTemplate((t) => (e(t), !1)), zs(this._internalTemplates, e), x(this._templates, e);
  }
  _applyTemplates(e = !0) {
    e && this._disposeTemplates();
    const t = {
      settings: {},
      privateSettings: {},
      states: {}
    };
    this._eachTemplate((s) => {
      this._applyTemplate(s, t);
    }), e && (_e(this._settings, (s) => {
      !this._userProperties[s] && !t.settings[s] && super.remove(s);
    }), _e(this._privateSettings, (s) => {
      !this._userPrivateProperties[s] && !t.privateSettings[s] && super.removePrivate(s);
    }));
  }
  _findTemplate(e) {
    const t = this._findStaticTemplate(e);
    if (t === void 0) {
      const s = Uc(this._internalTemplates, e);
      return s === void 0 ? bu(this._templates, e) : s;
    } else
      return t;
  }
  _findTemplateByKey(e) {
    return this._findTemplate((t) => e in t._settings);
  }
  _findTemplateByPrivateKey(e) {
    return this._findTemplate((t) => e in t._privateSettings);
  }
  _disposeTemplates() {
    x(this._templateDisposers, (e) => {
      e.dispose();
    }), this._templateDisposers.length = 0;
  }
  _removeTemplates() {
    x(this._templates, (e) => {
      e._removeObjectTemplate(this);
    }), this._templates.length = 0;
  }
  _applyThemes() {
    let e = !1;
    const t = [];
    let s = [];
    const r = /* @__PURE__ */ new Set(), n = this.get("themeTagsSelf");
    return n && x(n, (a) => {
      r.add(a);
    }), this._walkParents((a) => {
      a === this._root._rootContainer && (e = !0), a._defaultThemes.length > 0 && t.push(a._defaultThemes);
      const o = a.get("themes");
      o && s.push(o);
      const l = a.get("themeTags");
      l && x(l, (u) => {
        r.add(u);
      });
    }), s = t.concat(s), this._removeTemplates(), e && zs(this.classNames, (a) => {
      const o = [];
      x(s, (l) => {
        x(l, (u) => {
          const h = u._lookupRules(a);
          h && zs(h, (c) => {
            if (c.tags.every((f) => r.has(f))) {
              const f = Gc(o, (g) => {
                const p = Et(c.tags.length, g.tags.length);
                return p === 0 ? Cd(c.tags, g.tags, Et) : p;
              });
              o.splice(f.index, 0, c);
            }
          });
        });
      }), x(o, (l) => {
        this._templates.push(l.template), l.template._setObjectTemplate(this);
      });
    }), this._applyTemplates(), e && (this._runSetup = !1), e;
  }
  _changed() {
  }
  _beforeChanged() {
    if (this.isDirty("id")) {
      const e = this.get("id");
      e && this._registerId(e);
      const t = this._prevSettings.id;
      t && delete Lt.entitiesById[t];
    }
  }
  _registerId(e) {
    if (Lt.entitiesById[e] && Lt.entitiesById[e] !== this)
      throw new Error('An entity with id "' + e + '" already exists.');
    Lt.entitiesById[e] = this;
  }
  _afterChanged() {
  }
  /**
   * @ignore
   */
  addDisposer(e) {
    return this._disposers.push(e), e;
  }
  _dispose() {
    super._dispose();
    const e = this._template;
    e && e._removeObjectTemplate(this), x(this._internalTemplates, (s) => {
      s._removeObjectTemplate(this);
    }), this._removeTemplates(), this._disposeTemplates(), this.events.dispose(), this._disposers.forEach((s) => {
      s.dispose();
    }), _e(this._disposerProperties, (s, r) => {
      x(r, (n) => {
        n.dispose();
      });
    });
    const t = this.get("id");
    t && delete Lt.entitiesById[t];
  }
  /**
   * Creates and returns a "disposable" timeout.
   *
   * @param   fn     Callback
   * @param   delay  Delay in milliseconds
   * @return         Timeout disposer
   */
  setTimeout(e, t) {
    const s = setTimeout(() => {
      this.removeDispose(r), e();
    }, t), r = new Ve(() => {
      clearTimeout(s);
    });
    return this._disposers.push(r), r;
  }
  /**
   * @ignore
   */
  removeDispose(e) {
    if (!this.isDisposed()) {
      let t = Yi(this._disposers, e);
      t > -1 && this._disposers.splice(t, 1);
    }
    e.dispose();
  }
  /**
   * @ignore
   */
  hasTag(e) {
    return Yi(this.get("themeTags", []), e) !== -1;
  }
  /**
   * @ignore
   */
  addTag(e) {
    if (!this.hasTag(e)) {
      const t = this.get("themeTags", []);
      t.push(e), this.set("themeTags", t);
    }
  }
  /**
   * @ignore
   */
  removeTag(e) {
    if (this.hasTag(e)) {
      const t = this.get("themeTags", []);
      vt(t, e), this.set("themeTags", t);
    }
  }
  _t(e, t, ...s) {
    return this._root.language.translate(e, t, ...s);
  }
  /**
   * An instance of [[Root]] object.
   *
   * @readonly
   * @since 5.0.6
   * @return Root object
   */
  get root() {
    return this._root;
  }
}
Object.defineProperty(De, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Entity"
});
Object.defineProperty(De, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: ["Entity"]
});
class H0 {
  constructor(e, t, s) {
    Object.defineProperty(this, "_settings", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_template", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._name = e, this._template = t, this._settings = s;
  }
  get(e, t) {
    const s = this._settings[e];
    return s !== void 0 ? s : t;
  }
  set(e, t) {
    this._settings[e] = t, this._template._stateChanged(this._name);
  }
  remove(e) {
    delete this._settings[e], this._template._stateChanged(this._name);
  }
  setAll(e) {
    Be(e).forEach((t) => {
      this._settings[t] = e[t];
    }), this._template._stateChanged(this._name);
  }
  _apply(e, t) {
    _e(this._settings, (s, r) => {
      !t[s] && !e._userSettings[s] && (t[s] = !0, e.setRaw(s, r));
    });
  }
}
class z0 {
  constructor(e) {
    Object.defineProperty(this, "_template", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_states", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), this._template = e;
  }
  lookup(e) {
    return this._states[e];
  }
  create(e, t) {
    const s = this._states[e];
    if (s)
      return s.setAll(t), s;
    {
      const r = new H0(e, this._template, t);
      return this._states[e] = r, this._template._stateChanged(e), r;
    }
  }
  remove(e) {
    delete this._states[e], this._template._stateChanged(e);
  }
  _apply(e, t) {
    _e(this._states, (s, r) => {
      let n = t.states[s];
      n == null && (n = t.states[s] = {});
      const a = e.states.create(s, {});
      r._apply(a, n);
    });
  }
}
class X0 {
  constructor() {
    Object.defineProperty(this, "_callbacks", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    });
  }
  add(e, t) {
    let s = this._callbacks[e];
    return s === void 0 && (s = this._callbacks[e] = []), s.push(t), new Ve(() => {
      ot(s, t), s.length === 0 && delete this._callbacks[e];
    });
  }
  remove(e) {
    this._callbacks[e] !== void 0 && delete this._callbacks[e];
  }
  _apply(e) {
    const t = [];
    return _e(this._callbacks, (s, r) => {
      x(r, (n) => {
        t.push(e.adapters.add(s, n));
      });
    }), new nt(t);
  }
}
class ge {
  constructor(e, t) {
    if (Object.defineProperty(this, "_settings", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_privateSettings", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_settingEvents", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_privateSettingEvents", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_entities", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "states", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new z0(this)
    }), Object.defineProperty(this, "adapters", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new X0()
    }), Object.defineProperty(this, "events", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new hr()
    }), Object.defineProperty(this, "setup", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), !t)
      throw new Error("You cannot use `new Class()`, instead use `Class.new()`");
    this._settings = e;
  }
  /**
   * Use this method to create an instance of this class.
   *
   * @see {@link https://www.amcharts.com/docs/v5/getting-started/#New_element_syntax} for more info
   * @param   root      Root element
   * @param   settings  Settings
   * @param   template  Template
   * @return            Instantiated object
   */
  static new(e) {
    return new ge(e, !0);
  }
  get(e, t) {
    const s = this._settings[e];
    return s !== void 0 ? s : t;
  }
  setRaw(e, t) {
    this._settings[e] = t;
  }
  set(e, t) {
    this._settings[e] !== t && (this.setRaw(e, t), this._entities.forEach((s) => {
      s._setTemplateProperty(this, e, t);
    }));
  }
  remove(e) {
    e in this._settings && (delete this._settings[e], this._entities.forEach((t) => {
      t._removeTemplateProperty(e);
    }));
  }
  removeAll() {
    _e(this._settings, (e, t) => {
      this.remove(e);
    });
  }
  getPrivate(e, t) {
    const s = this._privateSettings[e];
    return s !== void 0 ? s : t;
  }
  setPrivateRaw(e, t) {
    return this._privateSettings[e] = t, t;
  }
  setPrivate(e, t) {
    return this._privateSettings[e] !== t && (this.setPrivateRaw(e, t), this._entities.forEach((s) => {
      s._setTemplatePrivateProperty(this, e, t);
    })), t;
  }
  removePrivate(e) {
    e in this._privateSettings && (delete this._privateSettings[e], this._entities.forEach((t) => {
      t._removeTemplatePrivateProperty(e);
    }));
  }
  setAll(e) {
    _e(e, (t, s) => {
      this.set(t, s);
    });
  }
  // TODO code duplication with Properties
  on(e, t) {
    let s = this._settingEvents[e];
    return s === void 0 && (s = this._settingEvents[e] = []), s.push(t), new Ve(() => {
      ot(s, t), s.length === 0 && delete this._settingEvents[e];
    });
  }
  // TODO code duplication with Properties
  onPrivate(e, t) {
    let s = this._privateSettingEvents[e];
    return s === void 0 && (s = this._privateSettingEvents[e] = []), s.push(t), new Ve(() => {
      ot(s, t), s.length === 0 && delete this._privateSettingEvents[e];
    });
  }
  _apply(e, t) {
    const s = [];
    return _e(this._settingEvents, (r, n) => {
      x(n, (a) => {
        s.push(e.on(r, a));
      });
    }), _e(this._privateSettingEvents, (r, n) => {
      x(n, (a) => {
        s.push(e.onPrivate(r, a));
      });
    }), this.states._apply(e, t), s.push(this.adapters._apply(e)), s.push(e.events.copyFrom(this.events)), new nt(s);
  }
  _setObjectTemplate(e) {
    this._entities.push(e);
  }
  _removeObjectTemplate(e) {
    vt(this._entities, e);
  }
  _stateChanged(e) {
    this._entities.forEach((t) => {
      t._applyStateByKey(e);
    });
  }
}
class so extends hr {
  constructor(e) {
    super(), Object.defineProperty(this, "_sprite", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_rendererDisposers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_dispatchParents", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), this._sprite = e;
  }
  _makePointerEvent(e, t) {
    return {
      type: e,
      originalEvent: t.event,
      point: t.point,
      simulated: t.simulated,
      native: t.native,
      target: this._sprite
    };
  }
  _onRenderer(e, t) {
    this._sprite.set("interactive", !0), this._sprite._display.interactive = !0;
    let s = this._rendererDisposers[e];
    if (s === void 0) {
      const r = this._sprite._display.on(e, (n) => {
        t.call(this, n);
      });
      s = this._rendererDisposers[e] = new qa(() => {
        delete this._rendererDisposers[e], r.dispose();
      });
    }
    return s.increment();
  }
  _on(e, t, s, r, n, a) {
    const o = super._on(e, t, s, r, n, a), l = so.RENDERER_EVENTS[t];
    return l !== void 0 && (o.disposer = new nt([
      o.disposer,
      this._onRenderer(t, l)
    ])), o;
  }
  /**
   * Will stop any bubbling up of the event to element's parents.
   *
   * Should be called in an event handler, e.g.:
   *
   * ```TypeScript
   * element.events.on("pointerdown", function(ev) {
   *   // Do something here and prevent from "pointerdown" bubbling up
   *   // ...
   *   ev.target.events.stopParentDispatch();
   * });
   * ```
   * ```JavaScript
   * element.events.on("pointerdown", function(ev) {
   *   // Do something here and prevent from "pointerdown" bubbling up
   *   // ...
   *   ev.target.events.stopParentDispatch();
   * });
   * ```
   */
  stopParentDispatch() {
    this._dispatchParents = !1;
  }
  /**
   * @ignore
   */
  dispatchParents(e, t) {
    const s = this._dispatchParents;
    this._dispatchParents = !0;
    try {
      this.dispatch(e, t), this._dispatchParents && this._sprite.parent && this._sprite.parent.events.dispatchParents(e, t);
    } finally {
      this._dispatchParents = s;
    }
  }
}
Object.defineProperty(so, "RENDERER_EVENTS", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: {
    click: function(i) {
      this.isEnabled("click") && !this._sprite.isDragging() && this._sprite._hasDown() && !this._sprite._hasMoved(this._makePointerEvent("click", i)) && this.dispatch("click", this._makePointerEvent("click", i));
    },
    rightclick: function(i) {
      this.isEnabled("rightclick") && this.dispatch("rightclick", this._makePointerEvent("rightclick", i));
    },
    middleclick: function(i) {
      this.isEnabled("middleclick") && this.dispatch("middleclick", this._makePointerEvent("middleclick", i));
    },
    dblclick: function(i) {
      this.dispatchParents("dblclick", this._makePointerEvent("dblclick", i));
    },
    pointerover: function(i) {
      this.isEnabled("pointerover") && this.dispatch("pointerover", this._makePointerEvent("pointerover", i));
    },
    pointerout: function(i) {
      this.isEnabled("pointerout") && this.dispatch("pointerout", this._makePointerEvent("pointerout", i));
    },
    pointerdown: function(i) {
      this.dispatchParents("pointerdown", this._makePointerEvent("pointerdown", i));
    },
    pointerup: function(i) {
      this.isEnabled("pointerup") && this.dispatch("pointerup", this._makePointerEvent("pointerup", i));
    },
    globalpointerup: function(i) {
      this.isEnabled("globalpointerup") && this.dispatch("globalpointerup", this._makePointerEvent("globalpointerup", i));
    },
    globalpointermove: function(i) {
      this.isEnabled("globalpointermove") && this.dispatch("globalpointermove", this._makePointerEvent("globalpointermove", i));
    },
    wheel: function(i) {
      this.dispatchParents("wheel", {
        type: "wheel",
        target: this._sprite,
        originalEvent: i.event,
        point: i.point
      });
    }
  }
});
class wt extends De {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_adjustedLocalBounds", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: { left: 0, right: 0, top: 0, bottom: 0 }
    }), Object.defineProperty(this, "_localBounds", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: { left: 0, right: 0, top: 0, bottom: 0 }
    }), Object.defineProperty(this, "_parent", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_dataItem", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_templateField", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_sizeDirty", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_isDragging", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_dragEvent", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_dragPoint", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_isHidden", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_isShowing", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_isHiding", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_isDown", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_downPoint", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_downPoints", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_toggleDp", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_dragDp", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_tooltipDp", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_hoverDp", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_focusDp", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_tooltipMoveDp", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_tooltipPointerDp", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_statesHandled", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    });
  }
  _afterNew() {
    this.setPrivateRaw("visible", !0), super._afterNew();
  }
  _markDirtyKey(e) {
    super._markDirtyKey(e), (e == "x" || e == "y" || e == "dx" || e == "dy") && (this.markDirtyBounds(), this._addPercentagePositionChildren(), this.markDirtyPosition());
  }
  _markDirtyPrivateKey(e) {
    super._markDirtyPrivateKey(e), (e == "x" || e == "y") && this.markDirtyPosition();
  }
  _removeTemplateField() {
    this._templateField && this._templateField._removeObjectTemplate(this);
  }
  _createEvents() {
    return new so(this);
  }
  _processTemplateField() {
    let e;
    const t = this.get("templateField");
    if (t) {
      const s = this.dataItem;
      if (s) {
        const r = s.dataContext;
        r && (e = r[t], !(e instanceof ge) && e && (e = ge.new(e)));
      }
    }
    this._templateField !== e && (this._removeTemplateField(), this._templateField = e, e && e._setObjectTemplate(this), this._applyTemplates());
  }
  // TODO change this to run before the element is added to the parent, so that way
  //      it doesn't need to apply the themes twice
  _setDataItem(e) {
    const t = this._dataItem;
    this._dataItem = e, this._processTemplateField();
    const s = "dataitemchanged";
    e != t && this.events.isEnabled(s) && this.events.dispatch(s, {
      type: s,
      target: this,
      oldDataItem: t,
      newDataItem: e
    });
  }
  /**
   * A [[DataItem]] used for this element.
   *
   * NOTE: data item is being assigned automatically in most cases where it
   * matters. Use this accessor to set data item only if you know what you're
   * doing.
   *
   * @param  value  Data item
   */
  set dataItem(e) {
    this._setDataItem(e);
  }
  /**
   * @return DataItem
   */
  get dataItem() {
    if (this._dataItem)
      return this._dataItem;
    {
      let e = this._parent;
      for (; e; ) {
        if (e._dataItem)
          return e._dataItem;
        e = e._parent;
      }
    }
  }
  _addPercentageSizeChildren() {
    let e = this.parent;
    e && (this.get("width") instanceof ne || this.get("height") instanceof ne ? Us(e._percentageSizeChildren, this) : ot(e._percentageSizeChildren, this));
  }
  _addPercentagePositionChildren() {
    let e = this.parent;
    e && (this.get("x") instanceof ne || this.get("y") instanceof ne ? Us(e._percentagePositionChildren, this) : ot(e._percentagePositionChildren, this));
  }
  /**
   * @ignore
   */
  markDirtyPosition() {
    this._root._addDirtyPosition(this);
  }
  updatePivotPoint() {
    const e = this._localBounds;
    if (e) {
      const t = this.get("centerX");
      t != null && (this._display.pivot.x = e.left + we(t, e.right - e.left));
      const s = this.get("centerY");
      s != null && (this._display.pivot.y = e.top + we(s, e.bottom - e.top));
    }
  }
  _beforeChanged() {
    if (super._beforeChanged(), this._handleStates(), this.isDirty("tooltip")) {
      const e = this._prevSettings.tooltip;
      e && e.dispose();
    }
    if ((this.isDirty("layer") || this.isDirty("layerMargin")) && (this._display.setLayer(this.get("layer"), this.get("layerMargin")), this.markDirtyLayer()), this.isDirty("tooltipPosition")) {
      const e = this._tooltipMoveDp;
      e && (e.dispose(), this._tooltipMoveDp = void 0);
      const t = this._tooltipPointerDp;
      t && (t.dispose(), this._tooltipPointerDp = void 0), this.get("tooltipPosition") == "pointer" && (this._tooltipPointerDp = new nt([
        this.events.on("pointerover", () => {
          this._tooltipMoveDp = this.events.on("globalpointermove", (s) => {
            this.showTooltip(s.point);
          });
        }),
        this.events.on("pointerout", () => {
          const s = this._tooltipMoveDp;
          s && (s.dispose(), this._tooltipMoveDp = void 0);
        })
      ]));
    }
  }
  _handleStates() {
    this._statesHandled || (this.isDirty("active") && (this.get("active") ? (this.states.applyAnimate("active"), this.set("ariaChecked", !0)) : (this.isHidden() || this.states.applyAnimate("default"), this.set("ariaChecked", !1)), this.markDirtyAccessibility()), this.isDirty("disabled") && (this.get("disabled") ? (this.states.applyAnimate("disabled"), this.set("ariaChecked", !1)) : (this.isHidden() || this.states.applyAnimate("default"), this.set("ariaChecked", !0)), this.markDirtyAccessibility()), this._statesHandled = !0);
  }
  _changed() {
    super._changed();
    const e = this._display, t = this.events;
    if (this.isDirty("draggable")) {
      const s = this.get("draggable");
      s ? (this.set("interactive", !0), this._dragDp = new nt([
        t.on("pointerdown", (r) => {
          this.dragStart(r);
        }),
        t.on("globalpointermove", (r) => {
          this.dragMove(r);
        }),
        t.on("globalpointerup", (r) => {
          this.dragStop(r);
        })
      ])) : this._dragDp && (this._dragDp.dispose(), this._dragDp = void 0), e.cancelTouch = !!s;
    }
    if (this.isDirty("tooltipText") || this.isDirty("tooltipHTML") || this.isDirty("showTooltipOn")) {
      const s = this.get("tooltipText"), r = this.get("tooltipHTML"), n = this.get("showTooltipOn", "hover");
      this._tooltipDp && (this._tooltipDp.dispose(), this._tooltipDp = void 0), (s || r) && (n == "click" ? this._tooltipDp = new nt([
        t.on("click", () => {
          this.setTimeout(() => this.showTooltip(), 10);
        }),
        Ie(document, "click", (a) => {
          this.hideTooltip();
        })
      ]) : n == "always" || (this._tooltipDp = new nt([
        t.on("pointerover", () => {
          this.showTooltip();
        }),
        t.on("pointerout", () => {
          this.hideTooltip();
        })
      ])));
    }
    if (this.isDirty("toggleKey")) {
      let s = this.get("toggleKey");
      s && s != "none" ? this._toggleDp = t.on("click", () => {
        this._isDragging || this.set(s, !this.get(s));
      }) : this._toggleDp && (this._toggleDp.dispose(), this._toggleDp = void 0);
    }
    if (this.isDirty("opacity") && (e.alpha = Math.max(0, this.get("opacity", 1))), this.isDirty("rotation") && (this.markDirtyBounds(), e.angle = this.get("rotation", 0)), this.isDirty("scale") && (this.markDirtyBounds(), e.scale = this.get("scale", 0)), (this.isDirty("centerX") || this.isDirty("centerY")) && (this.markDirtyBounds(), this.updatePivotPoint()), (this.isDirty("visible") || this.isPrivateDirty("visible") || this.isDirty("forceHidden")) && (!this.get("visible") || !this.getPrivate("visible") || this.get("forceHidden") ? (e.visible = !1, this.hideTooltip()) : e.visible = !0, this.markDirtyBounds(), this.get("focusable") && this.markDirtyAccessibility()), this.isDirty("width") || this.isDirty("height")) {
      this.markDirtyBounds(), this._addPercentageSizeChildren();
      const s = this.parent;
      s && (this.isDirty("width") && this.get("width") instanceof ne || this.isDirty("height") && this.get("height") instanceof ne) && (s.markDirty(), s._prevWidth = 0), this._sizeDirty = !0;
    }
    if ((this.isDirty("maxWidth") || this.isDirty("maxHeight") || this.isPrivateDirty("width") || this.isPrivateDirty("height") || this.isDirty("minWidth") || this.isDirty("minHeight") || this.isPrivateDirty("maxWidth") || this.isPrivateDirty("maxHeight") || this.isPrivateDirty("minWidth") || this.isPrivateDirty("minHeight")) && (this.markDirtyBounds(), this._sizeDirty = !0), this._sizeDirty && this._updateSize(), this.isDirty("wheelable")) {
      const s = this.get("wheelable");
      s && this.set("interactive", !0), e.wheelable = !!s;
    }
    if ((this.isDirty("tabindexOrder") || this.isDirty("focusableGroup")) && (this.get("focusable") ? this._root._registerTabindexOrder(this) : this._root._unregisterTabindexOrder(this)), this.isDirty("filter") && (e.filter = this.get("filter")), this.isDirty("cursorOverStyle") && (e.cursorOverStyle = this.get("cursorOverStyle")), this.isDirty("hoverOnFocus") && (this.get("hoverOnFocus") ? this._focusDp = new nt([
      t.on("focus", () => {
        this.showTooltip();
      }),
      t.on("blur", () => {
        this.hideTooltip();
      })
    ]) : this._focusDp && (this._focusDp.dispose(), this._focusDp = void 0)), this.isDirty("focusable") && (this.get("focusable") ? this._root._registerTabindexOrder(this) : this._root._unregisterTabindexOrder(this), this.markDirtyAccessibility()), (this.isDirty("role") || this.isDirty("ariaLive") || this.isDirty("ariaChecked") || this.isDirty("ariaHidden") || this.isDirty("ariaOrientation") || this.isDirty("ariaValueNow") || this.isDirty("ariaValueMin") || this.isDirty("ariaValueMax") || this.isDirty("ariaValueText") || this.isDirty("ariaLabel") || this.isDirty("ariaControls")) && this.markDirtyAccessibility(), this.isDirty("exportable") && (e.exportable = this.get("exportable")), this.isDirty("interactive")) {
      const s = this.events;
      this.get("interactive") ? this._hoverDp = new nt([
        s.on("click", (r) => {
          ra(r.originalEvent) && (this.getPrivate("touchHovering") || this.setTimeout(() => {
            this._handleOver(), (this.get("tooltipText") || this.get("tooltipHTML")) && this.showTooltip(), this.setPrivateRaw("touchHovering", !0), this.events.dispatch("pointerover", {
              type: "pointerover",
              target: r.target,
              originalEvent: r.originalEvent,
              point: r.point,
              simulated: r.simulated
            });
          }, 10));
        }),
        s.on("globalpointerup", (r) => {
          ra(r.originalEvent) && (this.getPrivate("touchHovering") && (this._handleOut(), (this.get("tooltipText") || this.get("tooltipHTML")) && this.hideTooltip()), this.setPrivateRaw("touchHovering", !1), this.events.dispatch("pointerout", {
            type: "pointerout",
            target: r.target,
            originalEvent: r.originalEvent,
            point: r.point,
            simulated: r.simulated
          })), this._isDown && this._handleUp(r);
        }),
        s.on("pointerover", () => {
          this._handleOver();
        }),
        s.on("pointerout", () => {
          this._handleOut();
        }),
        s.on("pointerdown", (r) => {
          this._handleDown(r);
        })
      ]) : (this._display.interactive = !1, this._hoverDp && (this._hoverDp.dispose(), this._hoverDp = void 0));
    }
    this.isDirty("forceInactive") && (this._display.inactive = this.get("forceInactive", !1)), this.get("showTooltipOn") == "always" && this._display.visible && this.showTooltip();
  }
  /**
   * @ignore
   * @todo should this be user-accessible?
   */
  dragStart(e) {
    this._dragEvent = e, this.events.stopParentDispatch();
  }
  /**
   * @ignore
   * @todo should this be user-accessible?
   */
  dragStop(e) {
    if (this._dragEvent = void 0, this._dragPoint = void 0, this.events.stopParentDispatch(), this._isDragging) {
      this._isDragging = !1;
      const t = "dragstop";
      this.events.isEnabled(t) && this.events.dispatch(t, {
        type: t,
        target: this,
        originalEvent: e.originalEvent,
        point: e.point,
        simulated: e.simulated
      });
    }
  }
  _handleOver() {
    this.isHidden() || (this.get("active") && this.states.lookup("hoverActive") ? this.states.applyAnimate("hoverActive") : this.get("disabled") && this.states.lookup("hoverDisabled") ? this.states.applyAnimate("hoverDisabled") : this.states.applyAnimate("hover"), this.get("draggable") && this._isDown && this.states.lookup("down") && this.states.applyAnimate("down"));
  }
  _handleOut() {
    this.isHidden() || (this.get("active") && this.states.lookup("active") ? this.states.applyAnimate("active") : this.get("disabled") && this.states.lookup("disabled") ? this.states.applyAnimate("disabled") : (this.states.lookup("hover") || this.states.lookup("hoverActive")) && this.states.applyAnimate("default"), this.get("draggable") && this._isDown && this.states.lookup("down") && this.states.applyAnimate("down"));
  }
  _handleUp(e) {
    if (!this.isHidden()) {
      this.get("active") && this.states.lookup("active") ? this.states.applyAnimate("active") : this.get("disabled") && this.states.lookup("disabled") ? this.states.applyAnimate("disabled") : this.states.lookup("down") && (this.isHover() ? this.states.applyAnimate("hover") : this.states.applyAnimate("default")), this._downPoint = void 0;
      const t = En(e.originalEvent);
      delete this._downPoints[t], Be(this._downPoints).length == 0 && (this._isDown = !1);
    }
  }
  _hasMoved(e) {
    const t = En(e.originalEvent), s = this._downPoints[t];
    if (s) {
      const r = Math.abs(s.x - e.point.x), n = Math.abs(s.y - e.point.y);
      return r > 5 || n > 5;
    }
    return !1;
  }
  _hasDown() {
    return Be(this._downPoints).length > 0;
  }
  _handleDown(e) {
    const t = this.parent;
    if (t && !this.get("draggable") && t._handleDown(e), this.get("interactive") && !this.isHidden()) {
      this.states.lookup("down") && this.states.applyAnimate("down"), this._downPoint = {
        x: e.point.x,
        y: e.point.y
      }, this._isDown = !0;
      const s = En(e.originalEvent);
      this._downPoints[s] = {
        x: e.point.x,
        y: e.point.y
      };
    }
  }
  /**
   * @ignore
   * @todo should this be user-accessible?
   */
  dragMove(e) {
    let t = this._dragEvent;
    if (t) {
      if (t.simulated && !e.simulated)
        return !0;
      let s = 0, r = this.parent;
      for (; r != null; )
        s += r.get("rotation", 0), r = r.parent;
      let n = e.point.x - t.point.x, a = e.point.y - t.point.y;
      const o = this.events;
      if (t.simulated && !this._isDragging) {
        this._isDragging = !0, this._dragEvent = e, this._dragPoint = {
          x: this.x(),
          y: this.y()
        };
        const l = "dragstart";
        o.isEnabled(l) && o.dispatch(l, {
          type: l,
          target: this,
          originalEvent: e.originalEvent,
          point: e.point,
          simulated: e.simulated
        });
      }
      if (this._isDragging) {
        let l = this._dragPoint;
        this.set("x", l.x + n * ht(s) + a * qe(s)), this.set("y", l.y + a * ht(s) - n * qe(s));
        const u = "dragged";
        o.isEnabled(u) && o.dispatch(u, {
          type: u,
          target: this,
          originalEvent: e.originalEvent,
          point: e.point,
          simulated: e.simulated
        });
      } else if (Math.hypot(n, a) > 5) {
        this._isDragging = !0, this._dragEvent = e, this._dragPoint = {
          x: this.x(),
          y: this.y()
        };
        const l = "dragstart";
        o.isEnabled(l) && o.dispatch(l, {
          type: l,
          target: this,
          originalEvent: e.originalEvent,
          point: e.point,
          simulated: e.simulated
        });
      }
    }
  }
  _updateSize() {
  }
  _getBounds() {
    this._localBounds = this._display.getLocalBounds();
  }
  /**
   * Returns depth (how deep in the hierachy of the content tree) of this
   * element.
   *
   * @return Depth
   */
  depth() {
    let e = this.parent, t = 0;
    for (; ; )
      if (e)
        ++t, e = e.parent;
      else
        return t;
  }
  /**
   * @ignore
   */
  markDirtySize() {
    this._sizeDirty = !0, this.markDirty();
  }
  /**
   * @ignore
   */
  markDirtyBounds() {
    const e = this._display;
    if (this.get("isMeasured")) {
      this._root._addDirtyBounds(this), e.isMeasured = !0, e.invalidateBounds();
      const t = this.parent;
      t && this.get("position") != "absolute" && (t.get("width") == null || t.get("height") == null || t.get("layout")) && t.markDirtyBounds(), this.get("focusable") && this.isFocus() && this.markDirtyAccessibility();
    }
  }
  /**
   * @ignore
   */
  markDirtyAccessibility() {
    this._root._invalidateAccessibility(this);
  }
  /**
   * @ignore
   */
  markDirtyLayer() {
    this._display.markDirtyLayer(!0);
  }
  /**
   * @ignore
   */
  markDirty() {
    super.markDirty(), this.markDirtyLayer();
  }
  _updateBounds() {
    const e = this._adjustedLocalBounds;
    let t;
    if (!this.get("visible") || !this.getPrivate("visible") || this.get("forceHidden") ? (t = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, this._localBounds = t, this._adjustedLocalBounds = t) : (this._getBounds(), this._fixMinBounds(this._localBounds), this.updatePivotPoint(), this._adjustedLocalBounds = this._display.getAdjustedBounds(this._localBounds), t = this._adjustedLocalBounds), !e || e.left !== t.left || e.top !== t.top || e.right !== t.right || e.bottom !== t.bottom) {
      const s = "boundschanged";
      this.events.isEnabled(s) && this.events.dispatch(s, { type: s, target: this }), this.parent && (this.parent.markDirty(), this.parent.markDirtyBounds());
    }
  }
  _fixMinBounds(e) {
    let t = this.get("minWidth", this.getPrivate("minWidth")), s = this.get("minHeight", this.getPrivate("minHeight"));
    S(t) && e.right - e.left < t && (e.right = e.left + t), S(s) && e.bottom - e.top < s && (e.bottom = e.top + s);
    let r = this.getPrivate("width"), n = this.getPrivate("height");
    S(r) && (e.right = e.left + r), S(n) && (e.bottom = e.top + n);
  }
  _removeParent(e) {
    e && (e.children.removeValue(this), ot(e._percentageSizeChildren, this), ot(e._percentagePositionChildren, this));
  }
  _clearDirty() {
    super._clearDirty(), this._sizeDirty = !1, this._statesHandled = !1;
  }
  /**
   * Simulate hover over element.
   */
  hover() {
    this.showTooltip(), this._handleOver();
  }
  /**
   * Simulate unhover over element.
   */
  unhover() {
    this.hideTooltip(), this._handleOut();
  }
  /**
   * Shows element's [[Tooltip]].
   */
  showTooltip(e) {
    const t = this.getTooltip(), s = this.get("tooltipText"), r = this.get("tooltipHTML");
    if ((s || r) && t) {
      const n = this.get("tooltipPosition"), a = this.getPrivate("tooltipTarget", this);
      (n == "fixed" || !e) && (this._display._setMatrix(), e = this.toGlobal(a._getTooltipPoint())), t.set("pointTo", e), t.set("tooltipTarget", a), t.get("x") || t.set("x", e.x), t.get("y") || t.set("y", e.y), s && t.label.set("text", s), r && t.label.set("html", r);
      const o = this.dataItem;
      if (o && t.label._setDataItem(o), this.get("showTooltipOn") == "always" && (e.x < 0 || e.x > this._root.width() || e.y < 0 || e.y > this._root.height())) {
        this.hideTooltip();
        return;
      }
      t.label.text.markDirtyText();
      const l = t.show();
      return this.setPrivateRaw("showingTooltip", !0), l;
    }
  }
  /**
   * Hides element's [[Tooltip]].
   */
  hideTooltip() {
    const e = this.getTooltip();
    if (e && e.get("tooltipTarget") == this.getPrivate("tooltipTarget", this)) {
      let t = e.get("keepTargetHover") && e.get("stateAnimationDuration", 0) == 0 ? 400 : void 0;
      const s = e.hide(t);
      return this.setPrivateRaw("showingTooltip", !1), s;
    }
  }
  _getTooltipPoint() {
    const e = this._localBounds;
    if (e) {
      let t = 0, s = 0;
      return this.get("isMeasured") ? (t = e.left + we(this.get("tooltipX", 0), e.right - e.left), s = e.top + we(this.get("tooltipY", 0), e.bottom - e.top)) : (t = we(this.get("tooltipX", 0), this.width()), s = we(this.get("tooltipY", 0), this.height())), { x: t, y: s };
    }
    return { x: 0, y: 0 };
  }
  /**
   * Returns [[Tooltip]] used for this element.
   *
   * @return Tooltip
   */
  getTooltip() {
    let e = this.get("tooltip");
    if (e)
      return e;
    {
      let t = this.parent;
      if (t)
        return t.getTooltip();
    }
  }
  _updatePosition() {
    const e = this.parent;
    let t = this.get("dx", 0), s = this.get("dy", 0), r = this.get("x"), n = this.getPrivate("x"), a = 0, o = 0;
    const l = this.get("position");
    r instanceof ne && (e ? r = e.innerWidth() * r.value + e.get("paddingLeft", 0) : r = 0), S(r) ? a = r + t : n != null ? a = n : e && l == "relative" && (a = e.get("paddingLeft", 0) + t);
    let u = this.get("y"), h = this.getPrivate("y");
    u instanceof ne && (e ? u = e.innerHeight() * u.value + e.get("paddingTop", 0) : u = 0), S(u) ? o = u + s : h != null ? o = h : e && l == "relative" && (o = e.get("paddingTop", 0) + s);
    const c = this._display;
    if (c.x != a || c.y != o) {
      c.invalidateBounds(), c.x = a, c.y = o;
      const d = "positionchanged";
      this.events.isEnabled(d) && this.events.dispatch(d, { type: d, target: this });
    }
    this.getPrivate("showingTooltip") && this.showTooltip();
  }
  /**
   * Returns element's actual X position in pixels.
   *
   * @return X (px)
   */
  x() {
    let e = this.get("x"), t = this.getPrivate("x");
    const s = this.parent;
    return s ? e instanceof ne ? we(e, s.innerWidth()) + s.get("paddingLeft", 0) : S(e) ? e : t ?? s.get("paddingLeft", this._display.x) : this._display.x;
  }
  /**
   * Returns element's actual Y position in pixels.
   *
   * @return Y (px)
   */
  y() {
    let e = this.getPrivate("y");
    if (e != null)
      return e;
    let t = this.get("y");
    const s = this.parent;
    return s ? t instanceof ne ? we(t, s.innerHeight()) + s.get("paddingTop", 0) : S(t) ? t : e ?? s.get("paddingTop", this._display.y) : this._display.y;
  }
  _dispose() {
    super._dispose(), this._display.dispose(), this._removeTemplateField(), this._removeParent(this.parent), this._root._removeFocusElement(this);
    const e = this.get("tooltip");
    e && e.dispose(), this.markDirty();
  }
  /**
   * @ignore
   */
  adjustedLocalBounds() {
    return this._fixMinBounds(this._adjustedLocalBounds), this._adjustedLocalBounds;
  }
  /**
   * Returns local coordinates of the element's bounds.
   *
   * @ignore
   * @return Global bounds
   */
  localBounds() {
    return this._localBounds;
  }
  /**
   * Returns adjusted local coordinates of the element's bounds.
   *
   * @ignore
   * @return Global bounds
   */
  bounds() {
    const e = this._adjustedLocalBounds, t = this.x(), s = this.y();
    return { left: e.left + t, right: e.right + t, top: e.top + s, bottom: e.bottom + s };
  }
  /**
   * Returns global coordinates of the element's bounds.
   *
   * @ignore
   * @return Global bounds
   */
  globalBounds() {
    const e = this.localBounds(), t = this.toGlobal({ x: e.left, y: e.top }), s = this.toGlobal({ x: e.right, y: e.top }), r = this.toGlobal({ x: e.right, y: e.bottom }), n = this.toGlobal({ x: e.left, y: e.bottom });
    return {
      left: Math.min(t.x, s.x, r.x, n.x),
      top: Math.min(t.y, s.y, r.y, n.y),
      right: Math.max(t.x, s.x, r.x, n.x),
      bottom: Math.max(t.y, s.y, r.y, n.y)
    };
  }
  _onShow(e) {
  }
  _onHide(e) {
  }
  /**
   * Plays initial reveal animation regardless if element is currently hidden
   * or visible.
   *
   * @param   duration  Duration of the animation in milliseconds
   * @param   delay     Delay showing of the element by X milliseconds
   * @return            Promise
   */
  appear(e, t) {
    return Ue(this, void 0, void 0, function* () {
      return yield this.hide(0), t ? new Promise((s, r) => {
        this.setTimeout(() => {
          s(this.show(e));
        }, t);
      }) : this.show(e);
    });
  }
  /**
   * Shows currently hidden element and returns a `Promise` which completes
   * when all showing animations are finished.
   *
   * ```TypeScript
   * series.show().then(function(ev) {
   *   console.log("Series is now fully visible");
   * })
   * ```
   * ```JavaScript
   * series.show().then(function(ev) {
   *   console.log("Series is now fully visible");
   * })
   * ```
   *
   * @return Promise
   */
  show(e) {
    return Ue(this, void 0, void 0, function* () {
      if (!this._isShowing) {
        this._isHidden = !1, this._isShowing = !0, this._isHiding = !1, this.states.lookup("default").get("visible") && this.set("visible", !0), this._onShow(e);
        const t = this.states.applyAnimate("default", e);
        yield Zu(t), this._isShowing = !1;
      }
    });
  }
  /**
   * Hides the element and returns a `Promise` which completes when all hiding
   * animations are finished.
   *
   * ```TypeScript
   * series.hide().then(function(ev) {
   *   console.log("Series finished hiding");
   * })
   * ```
   * ```JavaScript
   * series.hide().then(function(ev) {
   *   console.log("Series finished hiding");
   * })
   * ```
   *
   * @return Promise
   */
  hide(e) {
    return Ue(this, void 0, void 0, function* () {
      if (!this._isHiding && !this._isHidden) {
        this._isHiding = !0, this._isShowing = !1;
        let t = this.states.lookup("hidden");
        t || (t = this.states.create("hidden", {
          opacity: 0,
          visible: !1
        })), this._isHidden = !0, this._onHide(e);
        const s = this.states.applyAnimate("hidden", e);
        yield Zu(s), this._isHiding = !1;
      }
    });
  }
  /**
   * Returns `true` if this element is currently hidden.
   *
   * @return Is hidden?
   */
  isHidden() {
    return this._isHidden;
  }
  /**
   * Returns `true` if this element is currently animating to a default state.
   *
   * @return Is showing?
   */
  isShowing() {
    return this._isShowing;
  }
  /**
   * Returns `true` if this element is currently animating to a hidden state.
   *
   * @return Is hiding?
   */
  isHiding() {
    return this._isHiding;
  }
  /**
   * Returns `true` if this element is currently hovered by a pointer.
   *
   * @return Is hovered?
   */
  isHover() {
    return this._display.hovering();
  }
  /**
   * Returns `true` if this element does currently have focus.
   *
   * @return Is focused?
   */
  isFocus() {
    return this._root.focused(this);
  }
  /**
   * Returns `true` if this element is currently being dragged.
   *
   * @return Is dragged?
   */
  isDragging() {
    return this._isDragging;
  }
  /**
   * Returns `false` if if either public or private setting `visible` is set
   * to `false`, or `forceHidden` is set to `true`.
   *
   * @return Visible?
   */
  isVisible() {
    return !!(this.get("visible") && this.getPrivate("visible") && !this.get("forceHidden"));
  }
  /**
   * Same as `isVisible()`, except it checks all ascendants, too.
   *
   * @since 5.2.7
   * @return Visible?
   */
  isVisibleDeep() {
    return this._parent ? this._parent.isVisibleDeep() && this.isVisible() : this.isVisible();
  }
  /**
   * Returns an actual opacity of the element, taking into account all parents.
   *
   * @return Opacity
   * @since 5.2.11
   */
  compositeOpacity() {
    const e = this.get("opacity", 1);
    return this._parent ? this._parent.compositeOpacity() * e : e;
  }
  /**
   * Returns width of this element in pixels.
   *
   * @return Width (px)
   */
  width() {
    let e = this.get("width"), t = this.get("maxWidth", this.getPrivate("maxWidth")), s = this.get("minWidth", this.getPrivate("minWidth")), r = this.getPrivate("width"), n = 0;
    if (S(r))
      n = r;
    else if (e == null)
      this._adjustedLocalBounds && (n = this._adjustedLocalBounds.right - this._adjustedLocalBounds.left);
    else if (e instanceof ne) {
      const a = this.parent;
      a ? n = a.innerWidth() * e.value : n = this._root.width() * e.value;
    } else
      S(e) && (n = e);
    return S(s) && (n = Math.max(s, n)), S(t) && (n = Math.min(t, n)), n;
  }
  /**
   * Returns maximum allowed width of this element in pixels.
   *
   * @return Maximum width (px)
   */
  maxWidth() {
    let e = this.get("maxWidth", this.getPrivate("maxWidth"));
    if (S(e))
      return e;
    {
      let s = this.get("width");
      if (S(s))
        return s;
    }
    const t = this.parent;
    return t ? t.innerWidth() : this._root.width();
  }
  /**
   * Returns maximum allowed height of this element in pixels.
   *
   * @return Maximum height (px)
   */
  maxHeight() {
    let e = this.get("maxHeight", this.getPrivate("maxHeight"));
    if (S(e))
      return e;
    {
      let s = this.get("height");
      if (S(s))
        return s;
    }
    const t = this.parent;
    return t ? t.innerHeight() : this._root.height();
  }
  /**
   * Returns height of this element in pixels.
   *
   * @return Height (px)
   */
  height() {
    let e = this.get("height"), t = this.get("maxHeight", this.getPrivate("maxHeight")), s = this.get("minHeight", this.getPrivate("minHeight")), r = this.getPrivate("height"), n = 0;
    if (S(r))
      n = r;
    else if (e == null)
      this._adjustedLocalBounds && (n = this._adjustedLocalBounds.bottom - this._adjustedLocalBounds.top);
    else if (e instanceof ne) {
      const a = this.parent;
      a ? n = a.innerHeight() * e.value : n = this._root.height() * e.value;
    } else
      S(e) && (n = e);
    return S(s) && (n = Math.max(s, n)), S(t) && (n = Math.min(t, n)), n;
  }
  _findStaticTemplate(e) {
    return this._templateField && e(this._templateField) ? this._templateField : super._findStaticTemplate(e);
  }
  _walkParents(e) {
    this._parent && this._walkParent(e);
  }
  _walkParent(e) {
    this._parent && this._parent._walkParent(e), e(this);
  }
  /**
   * Parent [[Container]] of this element.
   *
   * @return Parent container
   */
  get parent() {
    return this._parent;
  }
  _setParent(e, t = !1) {
    const s = this._parent;
    e !== s && (this.markDirtyBounds(), e.markDirty(), this._parent = e, t && (this._removeParent(s), e && (this._addPercentageSizeChildren(), this._addPercentagePositionChildren())), this.markDirtyPosition(), this._applyThemes());
  }
  /**
   * Returns an instance of [[NumberFormatter]] used in this element.
   *
   * If this element does not have it set, global one form [[Root]] is used.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/using-formatters/} for more info
   * @return NumberFormatter instace
   */
  getNumberFormatter() {
    return this.get("numberFormatter", this._root.numberFormatter);
  }
  /**
   * Returns an instance of [[DateFormatter]] used in this element.
   *
   * If this element does not have it set, global one form [[Root]] is used.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/using-formatters/} for more info
   * @return DateFormatter instace
   */
  getDateFormatter() {
    return this.get("dateFormatter", this._root.dateFormatter);
  }
  /**
   * Returns an instance of [[DurationFormatter]] used in this element.
   *
   * If this element does not have it set, global one form [[Root]] is used.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/using-formatters/} for more info
   * @return DurationFormatter instace
   */
  getDurationFormatter() {
    return this.get("durationFormatter", this._root.durationFormatter);
  }
  /**
   * Converts X/Y coordinate within this element to a global coordinate.
   *
   * @param  point  Local coordinate
   * @return        Global coordinate
   */
  toGlobal(e) {
    return this._display.toGlobal(e);
  }
  /**
   * Converts global X/Y coordinate to a coordinate within this element.
   *
   * @param  point  Global coordinate
   * @return        Local coordinate
   */
  toLocal(e) {
    return this._display.toLocal(e);
  }
  _getDownPoint() {
    const e = this._getDownPointId();
    if (e)
      return this._downPoints[e];
  }
  _getDownPointId() {
    if (this._downPoints)
      return yu(this._downPoints, (e, t) => e > t ? 1 : e < t ? -1 : 0)[0];
  }
  /**
   * Moves sprite to the end of the parent's children array.
   *
   * Depending on `layout` setting of the parten container, it may effect the
   * positioning or overlapping order of the elements.
   */
  toFront() {
    const e = this.parent;
    e && e.children.moveValue(this, e.children.length - 1);
  }
  /**
   * Moves sprite to the beginning of the parent's children array.
   *
   * Depending on `layout` setting of the parten container, it may effect the
   * positioning or overlapping order of the elements.
   */
  toBack() {
    const e = this.parent;
    e && e.children.moveValue(this, 0);
  }
}
Object.defineProperty(wt, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Sprite"
});
Object.defineProperty(wt, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: De.classNames.concat([wt.className])
});
class St extends De {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_display", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._root._renderer.makeGraphics()
    }), Object.defineProperty(this, "_backgroundDisplay", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._root._renderer.makeGraphics()
    }), Object.defineProperty(this, "_clear", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_pattern", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  _afterNew() {
    super._afterNewApplyThemes();
  }
  get pattern() {
    return this._pattern;
  }
  _draw() {
  }
  _beforeChanged() {
    super._beforeChanged(), (this.isDirty("repetition") || this.isDirty("width") || this.isDirty("height") || this.isDirty("rotation") || this.isDirty("color") || this.isDirty("strokeWidth") || this.isDirty("strokeDasharray") || this.isDirty("strokeDashoffset") || this.isDirty("colorOpacity") || this.isDirty("fill") || this.isDirty("fillOpacity")) && (this._clear = !0);
  }
  _changed() {
    if (super._changed(), this._clear) {
      const e = this.get("repetition", ""), t = this.get("width", 100), s = this.get("height", 100), r = this.get("fill"), n = this.get("fillOpacity", 1);
      this._display.clear(), this._backgroundDisplay.clear(), r && n > 0 && (this._backgroundDisplay.beginFill(r, n), this._backgroundDisplay.drawRect(0, 0, t, s), this._backgroundDisplay.endFill()), this._display.angle = this.get("rotation", 0), this._draw(), this._pattern = this._root._renderer.createPattern(this._display, this._backgroundDisplay, e, t, s);
    }
  }
}
Object.defineProperty(St, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Pattern"
});
Object.defineProperty(St, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: De.classNames.concat([St.className])
});
class Zs extends St {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_image", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  _beforeChanged() {
    super._beforeChanged(), this._clear = !0, this.isDirty("src") && this._load();
  }
  _draw() {
    super._draw();
    const e = this._image;
    if (e) {
      const t = this.get("width", 100), s = this.get("height", 100), r = this.get("fit", "image");
      let n = 0, a = 0;
      r == "pattern" ? (n = t, a = s) : (n = e.width, a = e.height, r == "image" && (this.set("width", n), this.set("height", a)));
      const o = this.get("centered", !0);
      let l = 0, u = 0;
      o && (l = t / 2 - n / 2, u = s / 2 - a / 2), this._display.image(e, n, a, l, u);
    }
  }
  _load() {
    const e = this.get("src");
    if (e) {
      const t = new Image();
      t.src = e, t.decode().then(() => {
        this._image = t, this._draw(), this.events.isEnabled("loaded") && this.events.dispatch("loaded", { type: "loaded", target: this });
      }).catch((s) => {
      });
    }
  }
}
Object.defineProperty(Zs, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "PicturePattern"
});
Object.defineProperty(Zs, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: St.classNames.concat([Zs.className])
});
var oa;
(function(i) {
  i.ADD = "lighter", i.COLOR = "color", i.COLOR_BURN = "color-burn", i.COLOR_DODGE = "color-dodge", i.DARKEN = "darken", i.DIFFERENCE = "difference", i.DST_OVER = "destination-over", i.EXCLUSION = "exclusion", i.HARD_LIGHT = "hard-light", i.HUE = "hue", i.LIGHTEN = "lighten", i.LUMINOSITY = "luminosity", i.MULTIPLY = "multiply", i.NORMAL = "source-over", i.OVERLAY = "overlay", i.SATURATION = "saturation", i.SCREEN = "screen", i.SOFT_LIGHT = "soft-light", i.SRC_ATOP = "source-atop", i.XOR = "xor";
})(oa || (oa = {}));
const Od = ["fill", "fillOpacity", "stroke", "strokeWidth", "strokeOpacity", "fillPattern", "strokePattern", "fillGradient", "strokeGradient", "strokeDasharray", "strokeDashoffset"];
class he extends wt {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_display", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._root._renderer.makeGraphics()
    }), Object.defineProperty(this, "_clear", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    });
  }
  _beforeChanged() {
    if (super._beforeChanged(), (this.isDirty("draw") || this.isDirty("svgPath")) && this.markDirtyBounds(), (this.isDirty("fill") || this.isDirty("stroke") || this.isDirty("visible") || this.isDirty("forceHidden") || this.isDirty("scale") || this.isDirty("fillGradient") || this.isDirty("strokeGradient") || this.isDirty("fillPattern") || this.isDirty("strokePattern") || this.isDirty("fillOpacity") || this.isDirty("strokeOpacity") || this.isDirty("strokeWidth") || this.isDirty("draw") || this.isDirty("blendMode") || this.isDirty("strokeDasharray") || this.isDirty("strokeDashoffset") || this.isDirty("svgPath") || this.isDirty("lineJoin") || this.isDirty("shadowColor") || this.isDirty("shadowBlur") || this.isDirty("shadowOffsetX") || this.isDirty("shadowOffsetY")) && (this._clear = !0), this._display.crisp = this.get("crisp", !1), this.isDirty("fillGradient")) {
      const e = this.get("fillGradient");
      if (e) {
        this._display.isMeasured = !0;
        const t = e.get("target");
        t && (this._disposers.push(t.events.on("boundschanged", () => {
          this._markDirtyKey("fill");
        })), this._disposers.push(t.events.on("positionchanged", () => {
          this._markDirtyKey("fill");
        })));
      }
    }
    if (this.isDirty("strokeGradient")) {
      const e = this.get("strokeGradient");
      if (e) {
        this._display.isMeasured = !0;
        const t = e.get("target");
        t && (this._disposers.push(t.events.on("boundschanged", () => {
          this._markDirtyKey("stroke");
        })), this._disposers.push(t.events.on("positionchanged", () => {
          this._markDirtyKey("stroke");
        })));
      }
    }
  }
  _changed() {
    if (super._changed(), this._clear) {
      this.markDirtyBounds(), this.markDirtyLayer(), this._display.clear();
      let e = this.get("strokeDasharray");
      S(e) && (e < 0.5 ? e = [0] : e = [e]), this._display.setLineDash(e);
      const t = this.get("strokeDashoffset");
      t && this._display.setLineDashOffset(t);
      const s = this.get("blendMode", oa.NORMAL);
      this._display.blendMode = s;
      const r = this.get("draw");
      r && r(this._display, this);
      const n = this.get("svgPath");
      n != null && this._display.svgPath(n);
    }
  }
  _afterChanged() {
    if (super._afterChanged(), this._clear) {
      const e = this.get("fill"), t = this.get("fillGradient"), s = this.get("fillPattern"), r = this.get("fillOpacity"), n = this.get("stroke"), a = this.get("strokeGradient"), o = this.get("strokePattern"), l = this.get("shadowColor"), u = this.get("shadowBlur"), h = this.get("shadowOffsetX"), c = this.get("shadowOffsetY"), d = this.get("shadowOpacity");
      if (l && (u || h || c) && this._display.shadow(l, u, h, c, d), s) {
        let f = !1;
        e && (!s.get("fill") || s.get("fillInherited")) && (s.set("fill", e), s.set("fillInherited", !0), f = !0), n && (!s.get("color") || s.get("colorInherited")) && (s.set("color", n), s.set("colorInherited", !0), f = !0), f && s._changed();
        const g = s.pattern;
        g && (this._display.beginFill(g, r), this._display.endFill(), s instanceof Zs && s.events.once("loaded", () => {
          this._clear = !0, this.markDirty();
        }));
      } else if (t) {
        if (e) {
          const g = t.get("stops", []);
          g.length && x(g, (p) => {
            (!p.color || p.colorInherited) && e && (p.color = e, p.colorInherited = !0), (p.opacity == null || p.opacityInherited) && (p.opacity = r, p.opacityInherited = !0);
          });
        }
        const f = t.getFill(this);
        f && (this._display.beginFill(f, r), this._display.endFill());
      } else
        e && (this._display.beginFill(e, r), this._display.endFill());
      if (n || a || o) {
        const f = this.get("strokeOpacity");
        let g = this.get("strokeWidth", 1);
        this.get("nonScalingStroke") && (g = g / this.get("scale", 1)), this.get("crisp") && (g /= this._root._renderer.resolution);
        const p = this.get("lineJoin");
        if (o) {
          let m = !1;
          n && (!o.get("color") || o.get("colorInherited")) && (o.set("color", n), o.set("colorInherited", !0), m = !0), m && o._changed();
          const _ = o.pattern;
          _ && (this._display.lineStyle(g, _, f, p), this._display.endStroke(), o instanceof Zs && o.events.once("loaded", () => {
            this._clear = !0, this.markDirty();
          }));
        } else if (a) {
          const m = a.get("stops", []);
          m.length && x(m, (v) => {
            (!v.color || v.colorInherited) && n && (v.color = n, v.colorInherited = !0), (v.opacity == null || v.opacityInherited) && (v.opacity = f, v.opacityInherited = !0);
          });
          const _ = a.getFill(this);
          _ && (this._display.lineStyle(g, _, f, p), this._display.endStroke());
        } else
          n && (this._display.lineStyle(g, n, f, p), this._display.endStroke());
      }
    }
    this._clear = !1;
  }
}
Object.defineProperty(he, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Graphics"
});
Object.defineProperty(he, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: wt.classNames.concat([he.className])
});
class mt extends he {
  _beforeChanged() {
    super._beforeChanged(), (this.isDirty("width") || this.isDirty("height") || this.isPrivateDirty("width") || this.isPrivateDirty("height")) && (this._clear = !0);
  }
  _changed() {
    super._changed(), this._clear && !this.get("draw") && this._draw();
  }
  _draw() {
    this._display.drawRect(0, 0, this.width(), this.height());
  }
  _updateSize() {
    this.markDirty(), this._clear = !0;
  }
}
Object.defineProperty(mt, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Rectangle"
});
Object.defineProperty(mt, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: he.classNames.concat([mt.className])
});
function pi(i, e) {
  i.get("reverseChildren", !1) ? i.children.eachReverse(e) : i.children.each(e);
}
class ni extends De {
}
Object.defineProperty(ni, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Layout"
});
Object.defineProperty(ni, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: De.classNames.concat([ni.className])
});
class bs extends ni {
  /**
   * @ignore
   */
  updateContainer(e) {
    let t = e.get("paddingLeft", 0), s = e.innerWidth(), r = 0;
    pi(e, (a) => {
      if (a.isVisible() && a.get("position") == "relative") {
        let o = a.get("width");
        if (o instanceof ne) {
          r += o.value;
          let l = s * o.value, u = a.get("minWidth", a.getPrivate("minWidth", -1 / 0));
          u > l && (s -= u, r -= o.value);
          let h = a.get("maxWidth", a.getPrivate("maxWidth", 1 / 0));
          l > h && (s -= h, r -= o.value);
        } else
          S(o) || (o = a.width()), s -= o + a.get("marginLeft", 0) + a.get("marginRight", 0);
      }
    }), (s <= 0 || s == 1 / 0) && (s = 0.1), pi(e, (a) => {
      if (a.isVisible() && a.get("position") == "relative") {
        let o = a.get("width");
        if (o instanceof ne) {
          let l = s * o.value / r - a.get("marginLeft", 0) - a.get("marginRight", 0), u = a.get("minWidth", a.getPrivate("minWidth", -1 / 0)), h = a.get("maxWidth", a.getPrivate("maxWidth", 1 / 0));
          l = Math.min(Math.max(u, l), h), a.setPrivate("width", l);
        }
      }
    });
    let n = t;
    pi(e, (a) => {
      if (a.get("position") == "relative")
        if (a.isVisible()) {
          let o = a.adjustedLocalBounds(), l = a.get("marginLeft", 0), u = a.get("marginRight", 0), h = a.get("maxWidth"), c = o.left, d = o.right;
          h && d - c > h && (d = c + h);
          let f = n + l - c;
          a.setPrivate("x", f), n = f + d + u;
        } else
          a.setPrivate("x", void 0);
    });
  }
}
Object.defineProperty(bs, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "HorizontalLayout"
});
Object.defineProperty(bs, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: ni.classNames.concat([bs.className])
});
class ys extends ni {
  /**
   * @ignore
   */
  updateContainer(e) {
    let t = e.get("paddingTop", 0), s = e.innerHeight(), r = 0;
    pi(e, (a) => {
      if (a.isVisible() && a.get("position") == "relative") {
        let o = a.get("height");
        if (o instanceof ne) {
          r += o.value;
          let l = s * o.value, u = a.get("minHeight", a.getPrivate("minHeight", -1 / 0));
          u > l && (s -= u, r -= o.value);
          let h = a.get("maxHeight", a.getPrivate("maxHeight", 1 / 0));
          l > h && (s -= h, r -= o.value);
        } else
          S(o) || (o = a.height()), s -= o + a.get("marginTop", 0) + a.get("marginBottom", 0);
      }
    }), (s <= 0 || s == 1 / 0) && (s = 0.1), pi(e, (a) => {
      if (a.isVisible() && a.get("position") == "relative") {
        let o = a.get("height");
        if (o instanceof ne) {
          let l = s * o.value / r - a.get("marginTop", 0) - a.get("marginBottom", 0), u = a.get("minHeight", a.getPrivate("minHeight", -1 / 0)), h = a.get("maxHeight", a.getPrivate("maxHeight", 1 / 0));
          l = Math.min(Math.max(u, l), h), a.setPrivate("height", l);
        }
      }
    });
    let n = t;
    pi(e, (a) => {
      if (a.get("position") == "relative")
        if (a.isVisible()) {
          let o = a.adjustedLocalBounds(), l = a.get("marginTop", 0), u = o.top, h = o.bottom, c = a.get("maxHeight");
          c && h - u > c && (h = u + c);
          let d = a.get("marginBottom", 0), f = n + l - u;
          a.setPrivate("y", f), n = f + h + d;
        } else
          a.setPrivate("y", void 0);
    });
  }
}
Object.defineProperty(ys, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "VerticalLayout"
});
Object.defineProperty(ys, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: ni.classNames.concat([ys.className])
});
class bi extends ni {
  _afterNew() {
    this._setRawDefault("maxColumns", Number.MAX_VALUE), super._afterNew();
  }
  /**
   * @ignore
   */
  updateContainer(e) {
    let t = e.get("paddingLeft", 0), s = e.get("paddingRight", 0), r = e.get("paddingTop", 0), n = e.maxWidth() - t - s, a = n, o = 1;
    pi(e, (g) => {
      if (g.get("visible") && g.getPrivate("visible") && !g.get("forceHidden") && g.get("position") != "absolute") {
        let p = g.width();
        p < a && (a = p), p > o && (o = p);
      }
    }), a = Ne(a, 1, n), o = Ne(o, 1, n);
    let l = 1;
    this.get("fixedWidthGrid") ? l = n / o : l = n / a, l = Math.max(1, Math.floor(l)), l = Math.min(this.get("maxColumns", Number.MAX_VALUE), l);
    let u = this.getColumnWidths(e, l, o, n), h = r, c = 0, d = 0;
    l = u.length;
    let f = t;
    pi(e, (g) => {
      if (g.get("position") == "relative" && g.isVisible()) {
        const p = g.get("marginTop", 0), m = g.get("marginBottom", 0);
        let _ = g.adjustedLocalBounds(), v = g.get("marginLeft", 0), b = g.get("marginRight", 0), y = f + v - _.left, w = h + p - _.top;
        g.setPrivate("x", y), g.setPrivate("y", w), f += u[c] + b, d = Math.max(d, g.height() + p + m), c++, c >= l && (c = 0, f = t, h += d);
      }
    });
  }
  /**
   * @ignore
   */
  getColumnWidths(e, t, s, r) {
    let n = 0, a = [], o = 0;
    return pi(e, (l) => {
      let u = l.adjustedLocalBounds();
      l.get("position") != "absolute" && l.isVisible() && (this.get("fixedWidthGrid") ? a[o] = s : a[o] = Math.max(a[o] | 0, u.right - u.left + l.get("marginLeft", 0) + l.get("marginRight", 0)), o < e.children.length - 1 && (o++, o == t && (o = 0)));
    }), x(a, (l) => {
      n += l;
    }), n > r ? t > 2 ? (t -= 1, this.getColumnWidths(e, t, s, r)) : [r] : a;
  }
}
Object.defineProperty(bi, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "GridLayout"
});
Object.defineProperty(bi, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: ni.classNames.concat([bi.className])
});
class Nt {
  /**
   * Replaces brackets with temporary placeholders.
   *
   * @ignore Exclude from docs
   * @param text  Input text
   * @return Escaped text
   */
  static escape(e) {
    return e.replace(/\[\[/g, this.prefix + "1").replace(/([^\/\]]{1})\]\]/g, "$1" + this.prefix + "2").replace(/\]\]/g, this.prefix + "2").replace(/\{\{/g, this.prefix + "3").replace(/\}\}/g, this.prefix + "4").replace(/\'\'/g, this.prefix + "5");
  }
  /**
   * Replaces placeholders back to brackets.
   *
   * @ignore Exclude from docs
   * @param text  Escaped text
   * @return Unescaped text
   */
  static unescape(e) {
    return e.replace(new RegExp(this.prefix + "1", "g"), "[[").replace(new RegExp(this.prefix + "2", "g"), "]]").replace(new RegExp(this.prefix + "3", "g"), "{{").replace(new RegExp(this.prefix + "4", "g"), "}}").replace(new RegExp(this.prefix + "5", "g"), "''");
  }
  /**
   * Cleans up the text text for leftover double square brackets.
   *
   * @ignore Exclude from docs
   * @param text  Input text
   * @return Cleaned up text
   */
  static cleanUp(e) {
    return e.replace(/\[\[/g, "[").replace(/\]\]/g, "]").replace(/\{\{/g, "{").replace(/\}\}/g, "}").replace(/\'\'/g, "'");
  }
  /**
   * Splits string into chunks. (style blocks, quoted blocks, regular blocks)
   *
   * If the second parameter `quotedBlocks` is set to `true` this method will
   * also single out text blocks enclosed within single quotes that no
   * formatting should be applied to, and they should be displayed as is.
   *
   * Default for the above is `false`, so that you can use single quote in text
   * without escaping it.
   *
   * If enabled, single quotes can be escaped by doubling it - adding two
   * single quotes, which will be replaced by a one single quote in the final
   * output.
   *
   * @ignore Exclude from docs
   * @param text          Text to chunk
   * @param quotedBlocks  Use quoted blocks
   * @param noFormatting  Formatting blocks will be treated as regular text
   * @return Array of string chunks
   */
  static chunk(e, t = !1, s = !1) {
    let r = [];
    e = this.escape(e);
    let n = t ? e.split("'") : [e];
    for (let a = 0; a < n.length; a++) {
      let o = n[a];
      if (o !== "")
        if (a % 2 === 0) {
          o = o.replace(/\]\[/g, "]" + _i + "["), o = o.replace(/\[\]/g, "[ ]");
          let l = o.split(/[\[\]]+/);
          for (let u = 0; u < l.length; u++) {
            let h = this.cleanUp(this.unescape(l[u]));
            h !== _i && h !== "" && (u % 2 === 0 ? r.push({
              type: "value",
              text: h
            }) : r.push({
              type: s ? "value" : "format",
              text: "[" + h + "]"
            }));
          }
        } else {
          let l = o.split(/[\[\]]+/);
          for (let u = 0; u < l.length; u++) {
            let h = this.cleanUp(this.unescape(l[u]));
            h !== "" && (u % 2 === 0 ? r.push({
              type: "text",
              text: h
            }) : this.isImage(h) ? r.push({
              type: "image",
              text: "[" + h + "]"
            }) : r.push({
              type: "format",
              text: "[" + h + "]"
            }));
          }
        }
    }
    return r;
  }
  /**
   * Checks if supplied format contains image information and should be
   * formatted as such.
   * I.e.: `[img: myImage.png]`
   *
   * @ignore
   * @param  text  Format
   * @return true if it is an image
   */
  static isImage(e) {
    return !!e.match(/img[ ]?:/);
  }
  static getTextStyle(e) {
    let t = {};
    if (e == "" || e == "[ ]")
      return {};
    const s = e.match(/('[^']*')|("[^"]*")/gi);
    if (s)
      for (let n = 0; n < s.length; n++)
        e = e.replace(s[n], s[n].replace(/['"]*/g, "").replace(/[ ]+/g, "+"));
    let r = e.match(/([\w\-]*:[\s]?[^;\s\]]*)|(\#[\w]{1,6})|([\w\-]+)|(\/)/gi);
    if (!r)
      return {};
    for (let n = 0; n < r.length; n++)
      if (r[n].match(/^(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900)$/i))
        t.fontWeight = r[n];
      else if (r[n].match(/^(underline|line-through)$/i))
        t.textDecoration = r[n];
      else if (r[n] != "/")
        if (!r[n].match(/:/))
          t.fill = X.fromString(r[n]);
        else {
          const a = r[n].replace("+", " ").split(/:[ ]*/);
          t[a[0]] = a[1];
        }
    return t;
  }
}
Object.defineProperty(Nt, "prefix", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "__amcharts__"
});
function zr(i, e) {
  if (e != null) {
    e = "" + e, e = Nt.escape(e);
    let t = e.match(/\{([^}]+)\}/g), s;
    if (t)
      for (s = 0; s < t.length; s++) {
        let r = t[s].replace(/\{([^}]+)\}/, "$1"), n = hl(i, r);
        n == null && (n = ""), e = e.split(t[s]).join(n);
      }
    e = Nt.unescape(e);
  } else
    e = "";
  return e;
}
function hl(i, e, t) {
  let s;
  const r = i.dataItem;
  let n = [], a = /([^.]+)\(([^)]*)\)|([^.]+)/g, o;
  for (; o = a.exec(e), o !== null; )
    if (o[3]) {
      n.push({
        prop: o[3]
      });
      const l = i.getDateFormatter().get("dateFields", []), u = i.getNumberFormatter().get("numericFields", []), h = i.getDurationFormatter().get("durationFields", []);
      l.indexOf(o[3]) !== -1 ? n.push({
        method: "formatDate",
        params: []
      }) : u.indexOf(o[3]) !== -1 ? n.push({
        method: "formatNumber",
        params: []
      }) : h.indexOf(o[3]) !== -1 && n.push({
        method: "formatDuration",
        params: []
      });
    } else {
      let l = [];
      if (jr(o[2]) != "") {
        let u = /'([^']*)'|"([^"]*)"|([0-9\-]+)/g, h;
        for (; h = u.exec(o[2]), h !== null; )
          l.push(h[1] || h[2] || h[3]);
      }
      n.push({
        method: o[1],
        params: l
      });
    }
  if (r) {
    s = ns(i, n, r._settings), (s == null || Ps(s)) && (s = ns(i, n, r));
    let l = r.dataContext;
    s == null && l && (s = ns(i, n, l), s == null && (s = ns(i, [{
      prop: e
    }], l)), s == null && l.dataContext && (s = ns(i, n, l.dataContext))), s == null && r.component && r.component.dataItem !== r && (s = hl(r.component, e));
  }
  return s == null && (s = ns(i, n, i)), s == null && i.parent && (s = hl(i.parent, e)), s;
}
function V0(i, e) {
  const t = i.getPrivate("customData");
  if (Ps(t))
    return t[e];
}
function ns(i, e, t, s) {
  let r = t, n = !1;
  for (let a = 0, o = e.length; a < o; a++) {
    let l = e[a];
    if (l.prop) {
      if (r instanceof wt) {
        let u = r.get(l.prop);
        u == null && (u = r.getPrivate(l.prop)), u == null && (u = V0(r, l.prop)), u == null && (u = r[l.prop]), r = u;
      } else if (r.get) {
        let u = r.get(l.prop);
        u == null && (u = r[l.prop]), r = u;
      } else
        r = r[l.prop];
      if (r == null)
        return;
    } else
      switch (l.method) {
        case "formatNumber":
          let u = pt(r);
          u != null && (r = i.getNumberFormatter().format(u, s || l.params[0] || void 0), n = !0);
          break;
        case "formatDate":
          let h = Bc(r);
          if (!Qn(h) || $t(h.getTime()))
            return;
          h != null && (r = i.getDateFormatter().format(h, s || l.params[0] || void 0), n = !0);
          break;
        case "formatDuration":
          let c = pt(r);
          c != null && (r = i.getDurationFormatter().format(c, s || l.params[0] || void 0, l.params[1] || void 0), n = !0);
          break;
        case "urlEncode":
        case "encodeURIComponent":
          r = encodeURIComponent(r);
          break;
        default:
          r[l.method] && r[l.method].apply(t, l.params);
          break;
      }
  }
  if (!n) {
    let a = [{
      method: "",
      params: s
    }];
    if (s == null)
      S(r) ? (a[0].method = "formatNumber", a[0].params = "") : Qn(r) && (a[0].method = "formatDate", a[0].params = "");
    else {
      let o = hd(s);
      o === "number" ? a[0].method = "formatNumber" : o === "date" ? a[0].method = "formatDate" : o === "duration" && (a[0].method = "formatDuration");
    }
    a[0].method && (r = ns(i, a, r));
  }
  return r;
}
class Z extends wt {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_display", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._root._renderer.makeContainer()
    }), Object.defineProperty(this, "_childrenDisplay", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._root._renderer.makeContainer()
    }), Object.defineProperty(this, "children", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new Fx(this)
    }), Object.defineProperty(this, "_percentageSizeChildren", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_percentagePositionChildren", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_prevWidth", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_prevHeight", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_contentWidth", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_contentHeight", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_contentMask", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_vsbd0", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_vsbd1", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  _afterNew() {
    super._afterNew(), this._display.addChild(this._childrenDisplay);
  }
  _dispose() {
    zs(this.allChildren(), (e) => {
      e.dispose();
    }), this.getPrivate("htmlElement") && this._root._removeHTMLContent(this), super._dispose();
  }
  _changed() {
    if (super._changed(), this.isDirty("interactiveChildren") && (this._display.interactiveChildren = this.get("interactiveChildren", !1)), this.isDirty("layout") && (this._prevWidth = 0, this._prevHeight = 0, this.markDirtyBounds(), this._prevSettings.layout && this.children.each((e) => {
      e.removePrivate("x"), e.removePrivate("y");
    })), (this.isDirty("paddingTop") || this.isDirty("paddingBottom") || this.isDirty("paddingLeft") || this.isDirty("paddingRight")) && this.children.each((e) => {
      e.markDirtyPosition();
    }), this.isDirty("maskContent")) {
      const e = this._childrenDisplay;
      let t = this._contentMask;
      this.get("maskContent") ? t || (t = mt.new(this._root, {
        x: -0.5,
        y: -0.5,
        width: this.width() + 1,
        height: this.height() + 1
      }), this._contentMask = t, e.addChildAt(t._display, 0), e.mask = t._display) : t && (e.removeChild(t._display), e.mask = null, t.dispose(), this._contentMask = void 0);
    }
  }
  _updateSize() {
    super._updateSize(), x(this._percentageSizeChildren, (e) => {
      e._updateSize();
    }), x(this._percentagePositionChildren, (e) => {
      e.markDirtyPosition(), e._updateSize();
    }), this.updateBackground();
  }
  updateBackground() {
    const e = this.get("background");
    let t = this._localBounds;
    if (t && !this.isHidden()) {
      let s = t.left, r = t.top, n = t.right - s, a = t.bottom - r, o = this.get("maxWidth"), l = this.get("maxHeight");
      l && a > l && (a = l), o && n > o && (n = o);
      let u = this.width(), h = this.height();
      e && (e.setAll({ width: n, height: a, x: s, y: r }), this._display.interactive && (e._display.interactive = !0));
      const c = this._contentMask;
      c && c.setAll({ width: u + 1, height: h + 1 });
      const d = this.get("verticalScrollbar");
      if (d) {
        d.set("height", h), d.set("x", u - d.width() - d.get("marginRight", 0)), d.set("end", d.get("start", 0) + h / this._contentHeight);
        const f = d.get("background");
        f && f.setAll({ width: d.width(), height: h });
        let g = !0;
        this._contentHeight <= h && (g = !1), d.setPrivate("visible", g);
      }
    }
  }
  _applyThemes() {
    return super._applyThemes() ? (this.eachChildren((e) => {
      e._applyThemes();
    }), !0) : !1;
  }
  _applyState(e) {
    super._applyState(e), this.get("setStateOnChildren") && this.eachChildren((t) => {
      t.states.apply(e);
    });
  }
  _applyStateAnimated(e, t) {
    super._applyStateAnimated(e, t), this.get("setStateOnChildren") && this.eachChildren((s) => {
      s.states.applyAnimate(e, t);
    });
  }
  /**
   * Returns container's inner width (width without padding) in pixels.
   *
   * @return Inner width (px)
   */
  innerWidth() {
    return this.width() - this.get("paddingRight", 0) - this.get("paddingLeft", 0);
  }
  /**
   * Returns container's inner height (height without padding) in pixels.
   *
   * @return Inner height (px)
   */
  innerHeight() {
    return this.height() - this.get("paddingTop", 0) - this.get("paddingBottom", 0);
  }
  _getBounds() {
    let e = this.get("width"), t = this.get("height"), s = this.getPrivate("width"), r = this.getPrivate("height"), n = {
      left: 0,
      top: 0,
      right: this.width(),
      bottom: this.height()
    }, a = this.get("layout"), o = !1, l = !1;
    if ((a instanceof bs || a instanceof bi) && (o = !0), a instanceof ys && (l = !0), !((e != null || s != null) && (t != null || r != null) && !this.get("verticalScrollbar"))) {
      let u = Number.MAX_VALUE, h = u, c = -u, d = u, f = -u;
      const g = this.get("paddingLeft", 0), p = this.get("paddingTop", 0), m = this.get("paddingRight", 0), _ = this.get("paddingBottom", 0);
      this.children.each((v) => {
        if (v.get("position") != "absolute" && v.get("isMeasured")) {
          let b = v.adjustedLocalBounds(), y = v.x(), w = v.y(), D = y + b.left, A = y + b.right, T = w + b.top, j = w + b.bottom;
          o && (D -= v.get("marginLeft", 0), A += v.get("marginRight", 0)), l && (T -= v.get("marginTop", 0), j += v.get("marginBottom", 0)), D < h && (h = D), A > c && (c = A), T < d && (d = T), j > f && (f = j);
        }
      }), h == u && (h = 0), c == -u && (c = 0), d == u && (d = 0), f == -u && (f = 0), n.left = h - g, n.top = d - p, n.right = c + m, n.bottom = f + _;
    }
    this._contentWidth = n.right - n.left, this._contentHeight = n.bottom - n.top, S(e) && (n.left = 0, n.right = e), S(s) && (n.left = 0, n.right = s), S(t) && (n.top = 0, n.bottom = t), S(r) && (n.top = 0, n.bottom = r), this._localBounds = n;
  }
  _updateBounds() {
    const e = this.get("layout");
    e && e.updateContainer(this), super._updateBounds(), this.updateBackground();
  }
  /**
   * @ignore
   */
  markDirty() {
    super.markDirty(), this._root._addDirtyParent(this);
  }
  _prepareChildren() {
    const e = this.innerWidth(), t = this.innerHeight();
    if (e != this._prevWidth || t != this._prevHeight) {
      let s = this.get("layout"), r = !1, n = !1;
      s && ((s instanceof bs || s instanceof bi) && (r = !0), s instanceof ys && (n = !0)), x(this._percentageSizeChildren, (a) => {
        if (!r) {
          let o = a.get("width");
          o instanceof ne && a.setPrivate("width", o.value * e);
        }
        if (!n) {
          let o = a.get("height");
          o instanceof ne && a.setPrivate("height", o.value * t);
        }
      }), x(this._percentagePositionChildren, (a) => {
        a.markDirtyPosition(), a.markDirtyBounds();
      }), this._prevWidth = e, this._prevHeight = t, this._sizeDirty = !0, this.updateBackground();
    }
    this._handleStates();
  }
  _updateChildren() {
    if (this.isDirty("html")) {
      const t = this.get("html");
      t && t !== "" ? this._root._setHTMLContent(this, zr(this, this.get("html", ""))) : this._root._removeHTMLContent(this), this._root._positionHTMLElement(this);
    }
    if (this.isDirty("verticalScrollbar")) {
      const t = this.get("verticalScrollbar");
      if (t) {
        t._setParent(this), t.children.removeValue(t.startGrip), t.children.removeValue(t.endGrip), this.set("maskContent", !0), this.set("paddingRight", t.width() + t.get("marginRight", 0) + t.get("marginLeft", 0));
        let s = this.get("background");
        s || (s = this.set("background", mt.new(this._root, {
          themeTags: ["background"],
          fillOpacity: 0,
          fill: this._root.interfaceColors.get("alternativeBackground")
        }))), this._vsbd0 = this.events.on("wheel", (r) => {
          const n = r.originalEvent;
          if (eo(n, this))
            n.preventDefault();
          else
            return;
          let a = n.deltaY / 5e3;
          const o = t.get("start", 0), l = t.get("end", 1);
          o + a <= 0 && (a = -o), l + a >= 1 && (a = 1 - l), o + a >= 0 && l + a <= 1 && (t.set("start", o + a), t.set("end", l + a));
        }), this._disposers.push(this._vsbd0), this._vsbd1 = t.events.on("rangechanged", () => {
          let r = this._contentHeight;
          const n = this._childrenDisplay, a = this._contentMask;
          n.y = -t.get("start") * r, n.markDirtyLayer(), a && (a._display.y = -n.y, n.mask = a._display);
        }), this._disposers.push(this._vsbd1), this._display.addChild(t._display);
      } else {
        const s = this._prevSettings.verticalScrollbar;
        if (s) {
          this._display.removeChild(s._display), this._vsbd0 && this._vsbd0.dispose(), this._vsbd1 && this._vsbd1.dispose();
          const r = this._childrenDisplay;
          r.y = 0, this.setPrivate("height", void 0), this.set("maskContent", !1), this.set("paddingRight", void 0);
        }
      }
    }
    if (this.isDirty("background")) {
      const t = this._prevSettings.background;
      t && this._display.removeChild(t._display);
      const s = this.get("background");
      s instanceof wt && (s.set("isMeasured", !1), s._setParent(this), this._display.addChildAt(s._display, 0));
    }
    if (this.isDirty("mask")) {
      const t = this.get("mask"), s = this._prevSettings.mask;
      if (s && (this._display.removeChild(s._display), s != t && s.dispose()), t) {
        var e = t.parent;
        e && e.children.removeValue(t), t._setParent(this), this._display.addChildAt(t._display, 0), this._childrenDisplay.mask = t._display;
      }
    }
  }
  _processTemplateField() {
    super._processTemplateField(), this.children.each((e) => {
      e._processTemplateField();
    });
  }
  /**
   * @ignore
   */
  walkChildren(e) {
    this.children.each((t) => {
      t instanceof Z && t.walkChildren(e), e(t);
    });
  }
  eachChildren(e) {
    const t = this.get("background");
    t && e(t);
    const s = this.get("verticalScrollbar");
    s && e(s);
    const r = this.get("mask");
    r && e(r), this.children.values.forEach((n) => {
      e(n);
    });
  }
  allChildren() {
    const e = [];
    return this.eachChildren((t) => {
      e.push(t);
    }), e;
  }
  _setDataItem(e) {
    const t = e !== this._dataItem;
    super._setDataItem(e);
    const s = this.get("html", "");
    s && s !== "" && t && this._root._setHTMLContent(this, zr(this, s));
  }
}
Object.defineProperty(Z, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Container"
});
Object.defineProperty(Z, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: wt.classNames.concat([Z.className])
});
class Ni extends wt {
  constructor() {
    super(...arguments), Object.defineProperty(this, "textStyle", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._root._renderer.makeTextStyle()
    }), Object.defineProperty(this, "_display", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._root._renderer.makeText("", this.textStyle)
    }), Object.defineProperty(this, "_textStyles", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: [
        "textAlign",
        "fontFamily",
        "fontSize",
        "fontStyle",
        "fontWeight",
        "fontStyle",
        "fontVariant",
        "textDecoration",
        "shadowColor",
        "shadowBlur",
        "shadowOffsetX",
        "shadowOffsetY",
        "shadowOpacity",
        // "leading",
        // "letterSpacing",
        "lineHeight",
        "baselineRatio",
        //"padding",
        // "stroke",
        // "strokeThickness",
        // "trim",
        // "wordWrap",
        "direction",
        "textBaseline",
        "oversizedBehavior",
        "breakWords",
        "ellipsis",
        "minScale"
      ]
    }), Object.defineProperty(this, "_originalScale", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  _updateBounds() {
    if (this.get("text"))
      super._updateBounds();
    else {
      let e = {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
      };
      this._adjustedLocalBounds = e;
    }
  }
  _changed() {
    super._changed(), this._display.clear();
    let e = this.textStyle;
    if (this.isDirty("opacity")) {
      let t = this.get("opacity", 1);
      this._display.alpha = t;
    }
    if ((this.isDirty("text") || this.isDirty("populateText")) && (this._display.text = this._getText(), this.markDirtyBounds(), this.get("role") == "tooltip" && this._root.updateTooltip(this)), this.isPrivateDirty("tooltipElement") && this.getPrivate("tooltipElement") && this._disposers.push(new Ve(() => {
      this._root._removeTooltipElement(this);
    })), this.isDirty("width") && (e.wordWrapWidth = this.width(), this.markDirtyBounds()), this.isDirty("oversizedBehavior") && (e.oversizedBehavior = this.get("oversizedBehavior", "none"), this.markDirtyBounds()), this.isDirty("breakWords") && (e.breakWords = this.get("breakWords", !1), this.markDirtyBounds()), this.isDirty("ellipsis") && (e.ellipsis = this.get("ellipsis"), this.markDirtyBounds()), this.isDirty("ignoreFormatting") && (e.ignoreFormatting = this.get("ignoreFormatting", !1), this.markDirtyBounds()), this.isDirty("minScale") && (e.minScale = this.get("minScale", 0), this.markDirtyBounds()), this.isDirty("fill")) {
      let t = this.get("fill");
      t && (e.fill = t);
    }
    if (this.isDirty("fillOpacity")) {
      let t = this.get("fillOpacity", 1);
      t && (e.fillOpacity = t);
    }
    (this.isDirty("maxWidth") || this.isPrivateDirty("maxWidth")) && (e.maxWidth = this.get("maxWidth", this.getPrivate("maxWidth")), this.markDirtyBounds()), (this.isDirty("maxHeight") || this.isPrivateDirty("maxHeight")) && (e.maxHeight = this.get("maxHeight", this.getPrivate("maxHeight")), this.markDirtyBounds()), x(this._textStyles, (t) => {
      this._dirty[t] && (e[t] = this.get(t), this.markDirtyBounds());
    }), e.fontSize = this.get("fontSize"), e.fontFamily = this.get("fontFamily"), this._display.style = e, this.isDirty("role") && this.get("role") == "tooltip" && this._root.updateTooltip(this);
  }
  _getText() {
    const e = this.get("text", "");
    return this.get("populateText") ? zr(this, e) : e;
  }
  markDirtyText() {
    this._display.text = this._getText(), this.get("role") == "tooltip" && this._root.updateTooltip(this), this.markDirtyBounds(), this.markDirty();
  }
  _setDataItem(e) {
    super._setDataItem(e), this.get("populateText") && this.markDirtyText();
  }
  getNumberFormatter() {
    return this.parent ? this.parent.getNumberFormatter() : super.getNumberFormatter();
  }
  getDateFormatter() {
    return this.parent ? this.parent.getDateFormatter() : super.getDateFormatter();
  }
  getDurationFormatter() {
    return this.parent ? this.parent.getDurationFormatter() : super.getDurationFormatter();
  }
}
Object.defineProperty(Ni, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Text"
});
Object.defineProperty(Ni, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: wt.classNames.concat([Ni.className])
});
class W0 {
  constructor() {
    Object.defineProperty(this, "_observer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_targets", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), this._observer = new ResizeObserver((e) => {
      x(e, (t) => {
        x(this._targets, (s) => {
          s.target === t.target && s.callback();
        });
      });
    });
  }
  addTarget(e, t) {
    this._observer.observe(e, { box: "border-box" }), this._targets.push({ target: e, callback: t });
  }
  removeTarget(e) {
    this._observer.unobserve(e), ln(this._targets, (t) => t.target !== e);
  }
}
class ro {
  constructor() {
    Object.defineProperty(this, "_timer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "_targets", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    });
  }
  addTarget(e, t) {
    if (this._timer === null) {
      let r = null;
      const n = () => {
        const a = Date.now();
        (r === null || a > r + ro.delay) && (r = a, x(this._targets, (o) => {
          let l = o.target.getBoundingClientRect();
          (l.width !== o.size.width || l.height !== o.size.height) && (o.size = l, o.callback());
        })), this._targets.length === 0 ? this._timer = null : this._timer = requestAnimationFrame(n);
      };
      this._timer = requestAnimationFrame(n);
    }
    let s = { width: 0, height: 0, left: 0, right: 0, top: 0, bottom: 0, x: 0, y: 0 };
    this._targets.push({ target: e, callback: t, size: s });
  }
  removeTarget(e) {
    ln(this._targets, (t) => t.target !== e), this._targets.length === 0 && this._timer !== null && (cancelAnimationFrame(this._timer), this._timer = null);
  }
}
Object.defineProperty(ro, "delay", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 200
});
let vn = null;
function U0() {
  return vn === null && (typeof ResizeObserver < "u" ? vn = new W0() : vn = new ro()), vn;
}
class G0 {
  constructor(e, t) {
    Object.defineProperty(this, "_sensor", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_element", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_listener", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_disposed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), this._sensor = U0(), this._element = e, this._listener = vu(t), this._sensor.addTarget(e, t);
  }
  isDisposed() {
    return this._disposed;
  }
  dispose() {
    this._disposed || (this._disposed = !0, this._sensor.removeTarget(this._element), this._listener.dispose());
  }
  get sensor() {
    return this._sensor;
  }
}
class Xr extends De {
}
Object.defineProperty(Xr, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "InterfaceColors"
});
Object.defineProperty(Xr, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: De.classNames.concat([Xr.className])
});
class We extends Z {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_text", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_textKeys", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: [
        "text",
        "fill",
        "fillOpacity",
        "textAlign",
        "fontFamily",
        "fontSize",
        "fontStyle",
        "fontWeight",
        "fontStyle",
        "fontVariant",
        "textDecoration",
        "shadowColor",
        "shadowBlur",
        "shadowOffsetX",
        "shadowOffsetY",
        "shadowOpacity",
        // "leading",
        // "letterSpacing",
        "lineHeight",
        "baselineRatio",
        //"padding",
        // "stroke",
        // "strokeThickness",
        // "trim",
        // "wordWrap",
        "direction",
        "textBaseline",
        "oversizedBehavior",
        "breakWords",
        "ellipsis",
        "minScale",
        "populateText",
        "role",
        "ignoreFormatting"
      ]
    });
  }
  /**
   * @ignore Text is not to be used directly
   */
  get text() {
    return this._text;
  }
  _afterNew() {
    super._afterNew(), this._makeText(), x(this._textKeys, (e) => {
      const t = this.get(e);
      t != null && this._text.set(e, t);
    }), this.get("html", "") !== "" && this._text.set("text", ""), this.onPrivate("maxWidth", () => {
      this._setMaxDimentions();
    }), this.onPrivate("maxHeight", () => {
      this._setMaxDimentions();
    });
  }
  _makeText() {
    this._text = this.children.push(Ni.new(this._root, {}));
  }
  _updateChildren() {
    if (super._updateChildren(), x(this._textKeys, (e) => {
      this._text.set(e, this.get(e));
    }), this.isDirty("maxWidth") && this._setMaxDimentions(), this.isDirty("maxHeight") && this._setMaxDimentions(), this.isDirty("rotation") && this._setMaxDimentions(), this.get("html", "") !== "" ? this._text.set("text", "") : this._text.set("text", this.get("text")), this.isDirty("textAlign") || this.isDirty("width")) {
      const e = this.get("textAlign");
      let t;
      this.get("width") != null ? e == "right" ? t = R : e == "center" ? t = ie : t = 0 : e == "left" || e == "start" ? t = this.get("paddingLeft") : (e == "right" || e == "end") && (t = -this.get("paddingRight")), this.text.set("x", t);
    }
  }
  _setMaxDimentions() {
    const e = this.get("rotation"), t = e == 90 || e == 270 || e == -90, s = this.get("maxWidth", this.getPrivate("maxWidth", 1 / 0));
    S(s) ? this.text.set(t ? "maxHeight" : "maxWidth", s - this.get("paddingLeft", 0) - this.get("paddingRight", 0)) : this.text.set(t ? "maxHeight" : "maxWidth", void 0);
    const r = this.get("maxHeight", this.getPrivate("maxHeight", 1 / 0));
    S(r) ? this.text.set(t ? "maxWidth" : "maxHeight", r - this.get("paddingTop", 0) - this.get("paddingBottom", 0)) : this.text.set(t ? "maxWidth" : "maxHeight", void 0);
  }
  _setDataItem(e) {
    super._setDataItem(e), this._markDirtyKey("text"), this.text.get("populateText") && this.text.markDirtyText();
  }
  /**
   * Returns text with populated placeholders and formatting if `populateText` is
   * set to `true`.
   *
   * @return Populated text
   */
  getText() {
    return this._text._getText();
  }
}
Object.defineProperty(We, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Label"
});
Object.defineProperty(We, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Z.classNames.concat([We.className])
});
class ps extends he {
  _beforeChanged() {
    super._beforeChanged(), (this.isDirty("pointerBaseWidth") || this.isDirty("cornerRadius") || this.isDirty("pointerLength") || this.isDirty("pointerX") || this.isDirty("pointerY") || this.isDirty("width") || this.isDirty("height")) && (this._clear = !0);
  }
  _changed() {
    if (super._changed(), this._clear) {
      this.markDirtyBounds();
      let e = this.width(), t = this.height();
      if (e > 0 && t > 0) {
        let s = this.get("cornerRadius", 8);
        s = Ne(s, 0, Math.min(e / 2, t / 2));
        let r = this.get("pointerX", 0), n = this.get("pointerY", 0), a = this.get("pointerBaseWidth", 15) / 2, o = 0, l = 0, u = e, h = 0, c = e, d = t, f = 0, g = t, p = (r - o) * (d - l) - (n - l) * (c - o), m = (r - f) * (h - g) - (n - g) * (u - f);
        const _ = this._display;
        if (_.moveTo(s, 0), p > 0 && m > 0) {
          let v = Math.round(Ne(r, s + a, e - a - s));
          n = Ne(n, -1 / 0, 0), _.lineTo(v - a, 0), _.lineTo(r, n), _.lineTo(v + a, 0);
        }
        if (_.lineTo(e - s, 0), _.arcTo(e, 0, e, s, s), p > 0 && m < 0) {
          let v = Math.round(Ne(n, s + a, t - a - s));
          r = Ne(r, e, 1 / 0), _.lineTo(e, s), _.lineTo(e, Math.max(v - a, s)), _.lineTo(r, n), _.lineTo(e, v + a);
        }
        if (_.lineTo(e, t - s), _.arcTo(e, t, e - s, t, s), p < 0 && m < 0) {
          let v = Math.round(Ne(r, s + a, e - a - s));
          n = Ne(n, t, 1 / 0), _.lineTo(e - s, t), _.lineTo(v + a, t), _.lineTo(r, n), _.lineTo(v - a, t);
        }
        if (_.lineTo(s, t), _.arcTo(0, t, 0, t - s, s), p < 0 && m > 0) {
          let v = Math.round(Ne(n, s + a, t - s - a));
          r = Ne(r, -1 / 0, 0), _.lineTo(0, t - s), _.lineTo(0, v + a), _.lineTo(r, n), _.lineTo(0, Math.max(v - a, s));
        }
        _.lineTo(0, s), _.arcTo(0, 0, s, 0, s), _.closePath();
      }
    }
  }
}
Object.defineProperty(ps, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "PointedRectangle"
});
Object.defineProperty(ps, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: he.classNames.concat([ps.className])
});
class At extends Z {
  constructor(e, t, s, r = []) {
    super(e, t, s, r), Object.defineProperty(this, "_fx", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_fy", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_label", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_fillDp", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_strokeDp", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_labelDp", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_w", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_h", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_keepHoverDp", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  _afterNew() {
    this._settings.themeTags = se(this._settings.themeTags, ["tooltip"]), super._afterNew(), this.set("background", ps.new(this._root, {
      themeTags: ["tooltip", "background"]
    })), this._label = this.children.push(We.new(this._root, {})), this._disposers.push(this._label.events.on("boundschanged", () => {
      this._updateBackground();
    })), this._disposers.push(this.on("bounds", () => {
      this._updateBackground();
    })), this._updateTextColor(), this._root.tooltipContainer.children.push(this), this.hide(0), this._root._tooltips.push(this);
  }
  /**
   * A [[Label]] element for the tooltip.
   *
   * @readonly
   * @return Label
   */
  get label() {
    return this._label;
  }
  /**
   * Permanently disposes the tooltip.
   */
  dispose() {
    super.dispose(), vt(this._root._tooltips, this);
  }
  _updateChildren() {
    super._updateChildren(), this.get("labelText") != null && this.label.set("text", this.get("labelText")), this.get("labelHTML") != null && this.label.set("html", this.get("labelHTML"));
  }
  _changed() {
    if (super._changed(), this.isDirty("pointTo") && this._updateBackground(), this.isDirty("tooltipTarget") && this.updateBackgroundColor(), this.isDirty("keepTargetHover"))
      if (this.get("keepTargetHover")) {
        const t = this.get("background");
        this._keepHoverDp = new nt([
          t.events.on("pointerover", (s) => {
            let r = this.get("tooltipTarget");
            r && (r.parent && r.parent.getPrivate("tooltipTarget") == r && (r = r.parent), r.hover());
          }),
          t.events.on("pointerout", (s) => {
            let r = this.get("tooltipTarget");
            r && (r.parent && r.parent.getPrivate("tooltipTarget") == r && (r = r.parent), r.unhover());
          })
        ]);
      } else
        this._keepHoverDp && (this._keepHoverDp.dispose(), this._keepHoverDp = void 0);
  }
  _onShow() {
    super._onShow(), this.updateBackgroundColor();
  }
  updateBackgroundColor() {
    let e = this.get("tooltipTarget");
    const t = this.get("background");
    let s, r;
    e && t && (s = e.get("fill"), r = e.get("stroke"), s == null && (s = r), this.get("getFillFromSprite") && (this._fillDp && this._fillDp.dispose(), s != null && t.set("fill", s), this._fillDp = e.on("fill", (n) => {
      n != null && (t.set("fill", n), this._updateTextColor(n));
    }), this._disposers.push(this._fillDp)), this.get("getStrokeFromSprite") && (this._strokeDp && this._strokeDp.dispose(), s != null && t.set("stroke", s), this._strokeDp = e.on("fill", (n) => {
      n != null && t.set("stroke", n);
    }), this._disposers.push(this._strokeDp)), this.get("getLabelFillFromSprite") && (this._labelDp && this._labelDp.dispose(), s != null && this.label.set("fill", s), this._labelDp = e.on("fill", (n) => {
      n != null && this.label.set("fill", n);
    }), this._disposers.push(this._labelDp))), this._updateTextColor(s);
  }
  _updateTextColor(e) {
    this.get("autoTextColor") && (e == null && (e = this.get("background").get("fill")), e == null && (e = this._root.interfaceColors.get("background")), e instanceof X && this.label.set("fill", X.alternative(e, this._root.interfaceColors.get("alternativeText"), this._root.interfaceColors.get("text"))));
  }
  _setDataItem(e) {
    super._setDataItem(e), this.label._setDataItem(e);
  }
  _updateBackground() {
    super.updateBackground();
    const e = this._root.container;
    if (e) {
      let t = 0.5, s = 0.5, r = this.get("centerX");
      r instanceof ne && (t = r.value);
      let n = this.get("centerY");
      n instanceof ne && (s = n.value);
      let a = e.width(), o = e.height(), l = this.parent, u = 0, h = 0;
      if (l) {
        u = l.x(), h = l.y();
        const L = l.get("layerMargin");
        L && (u += L.left || 0, h += L.top || 0, a += (L.left || 0) + (L.right || 0), o += (L.top || 0) + (L.bottom || 0));
      }
      const c = this.get("bounds", { left: -u, top: -h, right: a - u, bottom: o - h });
      this._updateBounds();
      let d = this.width(), f = this.height();
      d === 0 && (d = this._w), f === 0 && (f = this._h);
      let g = this.get("pointTo", { x: a / 2, y: o / 2 }), p = g.x, m = g.y, _ = this.get("pointerOrientation"), v = this.get("background"), b = 0, y = 0, w = 0;
      v instanceof ps && (b = v.get("pointerLength", 0), y = v.get("strokeWidth", 0) / 2, w = y);
      let D = 0, A = 0, T = c.right - c.left, j = c.bottom - c.top;
      _ == "horizontal" || _ == "left" || _ == "right" ? (y = 0, _ == "horizontal" ? p > c.left + T / 2 ? (p -= d * (1 - t) + b, w *= -1) : p += d * t + b : _ == "left" ? p += d * (1 - t) + b : (p -= d * t + b, w *= -1)) : (w = 0, _ == "vertical" ? m > c.top + f / 2 + b ? m -= f * (1 - s) + b : (m += f * s + b, y *= -1) : _ == "down" ? m -= f * (1 - s) + b : (m += f * s + b, y *= -1)), p = Ne(p, c.left + d * t, c.left + T - d * (1 - t)) + w, m = Ne(m, c.top + f * s, c.top + j - f * (1 - s)) - y, D = g.x - p + d * t + w, A = g.y - m + f * s - y, this._fx = p, this._fy = m;
      const C = this.get("animationDuration", 0);
      if (C > 0 && this.get("visible") && this.get("opacity") > 0.1) {
        const L = this.get("animationEasing");
        this.animate({ key: "x", to: p, duration: C, easing: L }), this.animate({ key: "y", to: m, duration: C, easing: L });
      } else
        this.set("x", p), this.set("y", m);
      v instanceof ps && (v.set("pointerX", D), v.set("pointerY", A)), d > 0 && (this._w = d), f > 0 && (this._h = f);
    }
  }
}
Object.defineProperty(At, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Tooltip"
});
Object.defineProperty(At, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Z.classNames.concat([At.className])
});
class Ad extends De {
  _setDefaults() {
    this._setDefault("negativeBase", 0), this._setDefault("numberFormat", "#,###.#####"), this._setDefault("smallNumberThreshold", 1);
    const e = "_big_number_suffix_", t = "_small_number_suffix_", s = "_byte_suffix_";
    this._setDefault("bigNumberPrefixes", [
      { number: 1e3, suffix: this._t(e + "3") },
      { number: 1e6, suffix: this._t(e + "6") },
      { number: 1e9, suffix: this._t(e + "9") },
      { number: 1e12, suffix: this._t(e + "12") },
      { number: 1e15, suffix: this._t(e + "15") },
      { number: 1e18, suffix: this._t(e + "18") },
      { number: 1e21, suffix: this._t(e + "21") },
      { number: 1e24, suffix: this._t(e + "24") }
    ]), this._setDefault("smallNumberPrefixes", [
      { number: 1e-24, suffix: this._t(t + "24") },
      { number: 1e-21, suffix: this._t(t + "21") },
      { number: 1e-18, suffix: this._t(t + "18") },
      { number: 1e-15, suffix: this._t(t + "15") },
      { number: 1e-12, suffix: this._t(t + "12") },
      { number: 1e-9, suffix: this._t(t + "9") },
      { number: 1e-6, suffix: this._t(t + "6") },
      { number: 1e-3, suffix: this._t(t + "3") }
    ]), this._setDefault("bytePrefixes", [
      { number: 1, suffix: this._t(s + "B") },
      { number: 1024, suffix: this._t(s + "KB") },
      { number: 1048576, suffix: this._t(s + "MB") },
      { number: 1073741824, suffix: this._t(s + "GB") },
      { number: 1099511627776, suffix: this._t(s + "TB") },
      { number: 1125899906842624, suffix: this._t(s + "PB") }
    ]), super._setDefaults();
  }
  _beforeChanged() {
    super._beforeChanged();
  }
  /**
   * Formats the number according to specific format.
   *
   * @param value   Value to format
   * @param format  Format to apply
   * @return Formatted number
   */
  format(e, t, s) {
    (t == null || Ri(t) && t.toLowerCase() === "number") && (t = this.get("numberFormat", ""));
    let r, n = Number(e);
    if (Ps(t))
      try {
        return this.get("intlLocales") ? new Intl.NumberFormat(this.get("intlLocales"), t).format(n) : new Intl.NumberFormat(void 0, t).format(n);
      } catch {
        return "Invalid";
      }
    else {
      t = to(t);
      let a = this.parseFormat(t, this._root.language), o;
      n > this.get("negativeBase") ? o = a.positive : n < this.get("negativeBase") ? o = a.negative : o = a.zero, s != null && !o.mod && (o = Mi(o), o.decimals.active = n == 0 ? 0 : s), r = o.template.split(_i).join(this.applyFormat(n, o));
    }
    return r;
  }
  /**
   * Parses supplied format into structured object which can be used to format
   * the number.
   *
   * @param format Format string, i.e. "#,###.00"
   * @param language Language
   * @ignore
   */
  parseFormat(e, t) {
    const s = t.translateEmpty("_thousandSeparator"), r = t.translateEmpty("_decimalSeparator");
    let n = {
      positive: {
        thousands: {
          active: -1,
          passive: -1,
          interval: -1,
          separator: s
        },
        decimals: {
          active: -1,
          passive: -1,
          separator: r
        },
        template: "",
        source: "",
        parsed: !1
      },
      negative: {
        thousands: {
          active: -1,
          passive: -1,
          interval: -1,
          separator: s
        },
        decimals: {
          active: -1,
          passive: -1,
          separator: r
        },
        template: "",
        source: "",
        parsed: !1
      },
      zero: {
        thousands: {
          active: -1,
          passive: -1,
          interval: -1,
          separator: s
        },
        decimals: {
          active: -1,
          passive: -1,
          separator: r
        },
        template: "",
        source: "",
        parsed: !1
      }
    };
    e = e.replace("||", hs);
    let a = e.split("|");
    return n.positive.source = a[0], typeof a[2] > "u" ? n.zero = n.positive : n.zero.source = a[2], typeof a[1] > "u" ? n.negative = n.positive : n.negative.source = a[1], _e(n, (o, l) => {
      if (l.parsed)
        return;
      let u = l.source;
      u.toLowerCase() === "number" && (u = this.get("numberFormat", "#,###.#####"));
      let h = Nt.chunk(u, !0);
      for (let c = 0; c < h.length; c++) {
        let d = h[c];
        if (d.text = d.text.replace(hs, "|"), d.type === "value") {
          let f = d.text.match(/[#0.,]+[ ]?[abespABESP%!]?[abespABESP‰!]?/);
          if (f)
            if (f === null || f[0] === "")
              l.template += d.text;
            else {
              let g = f[0].match(/[abespABESP%‰!]{2}|[abespABESP%‰]{1}$/);
              g && (l.mod = g[0].toLowerCase(), l.modSpacing = !!f[0].match(/[ ]{1}[abespABESP%‰!]{1}$/));
              let p = f[0].split(".");
              if (p[0] !== "") {
                l.thousands.active = (p[0].match(/0/g) || []).length, l.thousands.passive = (p[0].match(/\#/g) || []).length + l.thousands.active;
                let m = p[0].split(",");
                m.length === 1 || (l.thousands.interval = (m.pop() || "").length, l.thousands.interval === 0 && (l.thousands.interval = -1));
              }
              typeof p[1] > "u" || (l.decimals.active = (p[1].match(/0/g) || []).length, l.decimals.passive = (p[1].match(/\#/g) || []).length + l.decimals.active), l.template += d.text.split(f[0]).join(_i);
            }
        } else
          l.template += d.text;
      }
      l.parsed = !0;
    }), n;
  }
  /**
   * Applies parsed format to a numeric value.
   *
   * @param value    Value
   * @param details  Parsed format as returned by parseFormat()
   * @return Formatted number
   * @ignore
   */
  applyFormat(e, t) {
    let s = e < 0;
    e = Math.abs(e);
    let r = "", n = "", a = t.mod ? t.mod.split("") : [];
    if (a.indexOf("b") !== -1) {
      let c = this.applyPrefix(e, this.get("bytePrefixes"), a.indexOf("!") !== -1);
      e = c[0], r = c[1], n = c[2], t.modSpacing && (n = " " + n);
    } else if (a.indexOf("a") !== -1) {
      let c = this.applyPrefix(e, e < this.get("smallNumberThreshold") ? this.get("smallNumberPrefixes") : this.get("bigNumberPrefixes"), a.indexOf("!") !== -1);
      e = c[0], r = c[1], n = c[2], t.modSpacing && (n = " " + n);
    } else if (a.indexOf("p") !== -1) {
      let c = Math.min(e.toString().length + 2, 21);
      e = parseFloat(e.toPrecision(c)), r = this._root.language.translate("_percentPrefix"), n = this._root.language.translate("_percentSuffix"), r == "" && n == "" && (n = "%");
    } else if (a.indexOf("%") !== -1) {
      let c = Math.min(e.toString().length + 2, 21);
      e *= 100, e = parseFloat(e.toPrecision(c)), n = "%";
    } else if (a.indexOf("‰") !== -1) {
      let c = Math.min(e.toString().length + 3, 21);
      e *= 1e3, e = parseFloat(e.toPrecision(c)), n = "‰";
    }
    if (a.indexOf("e") !== -1) {
      let c;
      t.decimals.passive >= 0 ? c = e.toExponential(t.decimals.passive).split("e") : c = e.toExponential().split("e"), e = Number(c[0]), n = "e" + c[1], t.modSpacing && (n = " " + n);
    } else if (t.decimals.passive === 0)
      e = Math.round(e);
    else if (t.decimals.passive > 0) {
      let c = Math.pow(10, t.decimals.passive);
      e = Math.round(e * c) / c;
    }
    let o = "", l = Hc(e).split("."), u = l[0];
    if (u.length < t.thousands.active && (u = Array(t.thousands.active - u.length + 1).join("0") + u), t.thousands.interval > 0) {
      let c = [], d = u.split("").reverse().join("");
      for (let f = 0, g = u.length; f <= g; f += t.thousands.interval) {
        let p = d.substr(f, t.thousands.interval).split("").reverse().join("");
        p !== "" && c.unshift(p);
      }
      u = c.join(t.thousands.separator);
    }
    o += u, l.length === 1 && l.push("");
    let h = l[1];
    return h.length < t.decimals.active && (h += Array(t.decimals.active - h.length + 1).join("0")), h !== "" && (o += t.decimals.separator + h), o === "" && (o = "0"), e !== 0 && s && a.indexOf("s") === -1 && (o = "-" + o), r && (o = r + o), n && (o += n), o;
  }
  applyPrefix(e, t, s = !1) {
    let r = e, n = "", a = "", o = !1, l = 1;
    for (let u = 0, h = t.length; u < h; u++)
      t[u].number <= e && (t[u].number === 0 ? r = 0 : (r = e / t[u].number, l = t[u].number), n = t[u].prefix, a = t[u].suffix, o = !0);
    return !o && s && t.length && e != 0 && (r = e / t[0].number, n = t[0].prefix, a = t[0].suffix, o = !0), o && (r = parseFloat(r.toPrecision(Math.min(l.toString().length + Math.floor(r).toString().replace(/[^0-9]*/g, "").length, 21)))), [r, n, a];
  }
  /**
   * Replaces brackets with temporary placeholders.
   *
   * @ignore Exclude from docs
   * @param text  Input text
   * @return Escaped text
   */
  escape(e) {
    return e.replace("||", hs);
  }
  /**
   * Replaces placeholders back to brackets.
   *
   * @ignore Exclude from docs
   * @param text  Escaped text
   * @return Unescaped text
   */
  unescape(e) {
    return e.replace(hs, "|");
  }
}
function Ld(i, e) {
  let t = 0, s = 0, r = 1, n = 0, a = 0, o = 0, l = 0, u = 0;
  return i.formatToParts(e).forEach((h) => {
    switch (h.type) {
      case "year":
        t = +h.value;
        break;
      case "month":
        s = +h.value - 1;
        break;
      case "day":
        r = +h.value;
        break;
      case "hour":
        n = +h.value;
        break;
      case "minute":
        a = +h.value;
        break;
      case "second":
        o = +h.value;
        break;
      case "fractionalSecond":
        l = +h.value;
        break;
      case "weekday":
        switch (h.value) {
          case "Sun":
            u = 0;
            break;
          case "Mon":
            u = 1;
            break;
          case "Tue":
            u = 2;
            break;
          case "Wed":
            u = 3;
            break;
          case "Thu":
            u = 4;
            break;
          case "Fri":
            u = 5;
            break;
          case "Sat":
            u = 6;
            break;
        }
    }
  }), n === 24 && (n = 0), { year: t, month: s, day: r, hour: n, minute: a, second: o, millisecond: l, weekday: u };
}
function Qu(i, e) {
  const { year: t, month: s, day: r, hour: n, minute: a, second: o, millisecond: l } = Ld(i, e);
  return Date.UTC(t, s, r, n, a, o, l);
}
class jd {
  constructor(e, t) {
    if (Object.defineProperty(this, "_utc", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_dtf", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), !t)
      throw new Error("You cannot use `new Class()`, instead use `Class.new()`");
    this.name = e, this._utc = new Intl.DateTimeFormat("UTC", {
      hour12: !1,
      timeZone: "UTC",
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
      weekday: "short",
      fractionalSecondDigits: 3
    }), this._dtf = new Intl.DateTimeFormat("UTC", {
      hour12: !1,
      timeZone: e,
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
      weekday: "short",
      fractionalSecondDigits: 3
    });
  }
  /**
   * Use this method to create an instance of this class.
   *
   * @see {@link https://www.amcharts.com/docs/v5/getting-started/#New_element_syntax} for more info
   * @param   timezone  IANA timezone
   * @return            Instantiated object
   */
  static new(e) {
    return new this(e, !0);
  }
  convertLocal(e) {
    const t = this.offsetUTC(e), s = e.getTimezoneOffset(), r = new Date(e);
    r.setUTCMinutes(r.getUTCMinutes() - (t - s));
    const n = r.getTimezoneOffset();
    return s != n && r.setUTCMinutes(r.getUTCMinutes() + n - s), r;
  }
  offsetUTC(e) {
    const t = Qu(this._utc, e), s = Qu(this._dtf, e);
    return (t - s) / 6e4;
  }
  parseDate(e) {
    return Ld(this._dtf, e);
  }
}
class Ed extends De {
  _setDefaults() {
    this._setDefault("capitalize", !0), this._setDefault("dateFormat", "yyyy-MM-dd"), super._setDefaults();
  }
  _beforeChanged() {
    super._beforeChanged();
  }
  format(e, t) {
    (typeof t > "u" || t === "") && (t = this.get("dateFormat", "yyyy-MM-dd"));
    let s, r = e;
    if (Ps(t))
      try {
        const o = this.get("intlLocales");
        return o ? new Intl.DateTimeFormat(o, t).format(r) : new Intl.DateTimeFormat(void 0, t).format(r);
      } catch {
        return "Invalid";
      }
    let n = this.parseFormat(t);
    const a = this._root.timezone;
    return a && !this._root.utc && (r = a.convertLocal(r)), S(r.getTime()) ? (s = this.applyFormat(r, n), this.get("capitalize") && (s = s.replace(/^.{1}/, s.substr(0, 1).toUpperCase())), s) : "Invalid date";
  }
  /**
   * Applies format to Date.
   *
   * @param date      Date object
   * @param info      Parsed format information
   * @return Formatted date string
   */
  applyFormat(e, t) {
    let s = t.template, r, n, a, o, l, u, h, c, d = e.getTime();
    this._root.utc ? (r = e.getUTCFullYear(), n = e.getUTCMonth(), a = e.getUTCDay(), o = e.getUTCDate(), l = e.getUTCHours(), u = e.getUTCMinutes(), h = e.getUTCSeconds(), c = e.getUTCMilliseconds()) : (r = e.getFullYear(), n = e.getMonth(), a = e.getDay(), o = e.getDate(), l = e.getHours(), u = e.getMinutes(), h = e.getSeconds(), c = e.getMilliseconds());
    for (let f = 0, g = t.parts.length; f < g; f++) {
      let p = "";
      switch (t.parts[f]) {
        case "G":
          p = this._t(r < 0 ? "_era_bc" : "_era_ad");
          break;
        case "yyyy":
          p = Math.abs(r).toString(), r < 0 && (p += this._t("_era_bc"));
          break;
        case "yyy":
        case "yy":
        case "y":
          p = Math.abs(r).toString().substr(-t.parts[f].length), r < 0 && (p += this._t("_era_bc"));
          break;
        case "YYYY":
        case "YYY":
        case "YY":
        case "Y":
          let m = cd(e, this._root.utc);
          t.parts[f] == "YYYY" ? p = Math.abs(m).toString() : p = Math.abs(m).toString().substr(-t.parts[f].length), m < 0 && (p += this._t("_era_bc"));
          break;
        case "u":
          break;
        case "q":
          p = "" + Math.ceil((e.getMonth() + 1) / 3);
          break;
        case "MMMMM":
          p = this._t(this._getMonth(n)).substr(0, 1);
          break;
        case "MMMM":
          p = this._t(this._getMonth(n));
          break;
        case "MMM":
          p = this._t(this._getShortMonth(n));
          break;
        case "MM":
          p = je(n + 1, 2, "0");
          break;
        case "M":
          p = (n + 1).toString();
          break;
        case "ww":
          p = je(Gs(e, this._root.utc), 2, "0");
          break;
        case "w":
          p = Gs(e, this._root.utc).toString();
          break;
        case "W":
          p = dd(e, this._root.utc).toString();
          break;
        case "dd":
          p = je(o, 2, "0");
          break;
        case "d":
          p = o.toString();
          break;
        case "DD":
        case "DDD":
          p = je(nl(e, this._root.utc).toString(), t.parts[f].length, "0");
          break;
        case "D":
          p = nl(e, this._root.utc).toString();
          break;
        case "F":
          break;
        case "g":
          break;
        case "t":
          p = this._root.language.translateFunc("_dateOrd").call(this, o);
          break;
        case "E":
          p = (a || 7).toString();
          break;
        case "EE":
          p = je((a || 7).toString(), 2, "0");
          break;
        case "EEE":
        case "eee":
          p = this._t(this._getShortWeekday(a));
          break;
        case "EEEE":
        case "eeee":
          p = this._t(this._getWeekday(a));
          break;
        case "EEEEE":
        case "eeeee":
          p = this._t(this._getShortWeekday(a)).substr(0, 1);
          break;
        case "e":
        case "ee":
          p = (a - (this._root.locale.firstDayOfWeek || 1) + 1).toString(), t.parts[f] == "ee" && (p = je(p, 2, "0"));
          break;
        case "a":
          l >= 12 ? p = this._t("PM") : p = this._t("AM");
          break;
        case "aa":
          l >= 12 ? p = this._t("P.M.") : p = this._t("A.M.");
          break;
        case "aaa":
          l >= 12 ? p = this._t("P") : p = this._t("A");
          break;
        case "h":
          p = xr(l).toString();
          break;
        case "hh":
          p = je(xr(l), 2, "0");
          break;
        case "H":
          p = l.toString();
          break;
        case "HH":
          p = je(l, 2, "0");
          break;
        case "K":
          p = xr(l, 0).toString();
          break;
        case "KK":
          p = je(xr(l, 0), 2, "0");
          break;
        case "k":
          p = (l + 1).toString();
          break;
        case "kk":
          p = je(l + 1, 2, "0");
          break;
        case "m":
          p = u.toString();
          break;
        case "mm":
          p = je(u, 2, "0");
          break;
        case "s":
          p = h.toString();
          break;
        case "ss":
          p = je(h, 2, "0");
          break;
        case "S":
        case "SS":
        case "SSS":
          p = Math.round(c / 1e3 * Math.pow(10, t.parts[f].length)).toString();
          break;
        case "x":
          p = d.toString();
          break;
        case "n":
        case "nn":
        case "nnn":
          p = je(c, t.parts[f].length, "0");
          break;
        case "z":
          p = wr(e, !1, !1, this._root.utc);
          break;
        case "zz":
          p = wr(e, !0, !1, this._root.utc);
          break;
        case "zzz":
          p = wr(e, !1, !0, this._root.utc);
          break;
        case "zzzz":
          p = wr(e, !0, !0, this._root.utc);
          break;
        case "Z":
        case "ZZ":
          let _ = this._root.utc ? "UTC" : this._root.timezone;
          _ instanceof jd && (_ = _.name);
          const v = _ ? pd(_) : e.getTimezoneOffset();
          let b = Math.abs(v) / 60, y = Math.floor(b), w = b * 60 - y * 60;
          this._root.utc && (y = 0, w = 0), t.parts[f] == "Z" ? (p = "GMT", p += v > 0 ? "-" : "+", p += je(y, 2) + ":" + je(w, 2)) : (p = v > 0 ? "-" : "+", p += je(y, 2) + je(w, 2));
          break;
        case "i":
          p = e.toISOString();
          break;
        case "I":
          p = e.toUTCString();
          break;
      }
      s = s.replace(_i, p);
    }
    return s;
  }
  /**
   * Parses format into structured infromation.
   *
   * @param format Format template
   */
  parseFormat(e) {
    let t = {
      template: "",
      parts: []
    }, s = Nt.chunk(e, !0);
    for (let r = 0; r < s.length; r++) {
      let n = s[r];
      if (n.type === "value") {
        if (n.text.match(/^date$/i)) {
          let o = this.get("dateFormat", "yyyy-MM-dd");
          Ri(o) || (o = "yyyy-MM-dd"), n.text = o;
        }
        let a = n.text.match(/G|yyyy|yyy|yy|y|YYYY|YYY|YY|Y|u|q|MMMMM|MMMM|MMM|MM|M|ww|w|W|dd|d|DDD|DD|D|F|g|EEEEE|EEEE|EEE|EE|E|eeeee|eeee|eee|ee|e|aaa|aa|a|hh|h|HH|H|KK|K|kk|k|mm|m|ss|s|SSS|SS|S|A|zzzz|zzz|zz|z|ZZ|Z|t|x|nnn|nn|n|i|I/g);
        if (a)
          for (let o = 0; o < a.length; o++)
            t.parts.push(a[o]), n.text = n.text.replace(a[o], _i);
      }
      t.template += n.text;
    }
    return t;
  }
  _months() {
    return ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
  }
  _getMonth(e) {
    return this._months()[e];
  }
  _shortMonths() {
    return ["Jan", "Feb", "Mar", "Apr", "May(short)", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
  }
  _getShortMonth(e) {
    return this._shortMonths()[e];
  }
  _weekdays() {
    return ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
  }
  _getWeekday(e) {
    return this._weekdays()[e];
  }
  _shortWeekdays() {
    return ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
  }
  _getShortWeekday(e) {
    return this._shortWeekdays()[e];
  }
  parse(e, t) {
    if (e instanceof Date)
      return e;
    if (S(e))
      return new Date(e);
    Ri(e) || (e = e.toString());
    let s, r = "";
    t = to(t), t = t.substr(0, e.length);
    let n = this.parseFormat(t), a = {
      year: -1,
      year3: -1,
      year2: -1,
      year1: -1,
      month: -1,
      monthShort: -1,
      monthLong: -1,
      weekdayShort: -1,
      weekdayLong: -1,
      day: -1,
      yearDay: -1,
      week: -1,
      hourBase0: -1,
      hour12Base0: -1,
      hourBase1: -1,
      hour12Base1: -1,
      minute: -1,
      second: -1,
      millisecond: -1,
      millisecondDigits: -1,
      am: -1,
      zone: -1,
      timestamp: -1,
      iso: -1
    }, o = {
      year: 1970,
      month: 0,
      day: 1,
      hour: 0,
      minute: 0,
      second: 0,
      millisecond: 0,
      timestamp: null,
      offset: 0,
      utc: this._root.utc
    }, l = 0, u = 0;
    for (let d = 0; d < n.parts.length; d++) {
      switch (u = d + l + 1, n.parts[d]) {
        case "yyyy":
        case "YYYY":
          r += "([0-9]{4})", a.year = u;
          break;
        case "yyy":
        case "YYY":
          r += "([0-9]{3})", a.year3 = u;
          break;
        case "yy":
        case "YY":
          r += "([0-9]{2})", a.year2 = u;
          break;
        case "y":
        case "Y":
          r += "([0-9]{1})", a.year1 = u;
          break;
        case "MMMM":
          r += "(" + this.getStringList(this._months()).join("|") + ")", a.monthLong = u;
          break;
        case "MMM":
          r += "(" + this.getStringList(this._shortMonths()).join("|") + ")", a.monthShort = u;
          break;
        case "MM":
        case "M":
          r += "([0-9]{2}|[0-9]{1})", a.month = u;
          break;
        case "ww":
        case "w":
          r += "([0-9]{2}|[0-9]{1})", a.week = u;
          break;
        case "dd":
        case "d":
          r += "([0-9]{2}|[0-9]{1})", a.day = u;
          break;
        case "DDD":
        case "DD":
        case "D":
          r += "([0-9]{3}|[0-9]{2}|[0-9]{1})", a.yearDay = u;
          break;
        case "dddd":
          r += "(" + this.getStringList(this._weekdays()).join("|") + ")", a.weekdayLong = u;
          break;
        case "ddd":
          r += "(" + this.getStringList(this._shortWeekdays()).join("|") + ")", a.weekdayShort = u;
          break;
        case "aaa":
        case "aa":
        case "a":
          r += "(" + this.getStringList(["AM", "PM", "A.M.", "P.M.", "A", "P"]).join("|") + ")", a.am = u;
          break;
        case "hh":
        case "h":
          r += "([0-9]{2}|[0-9]{1})", a.hour12Base1 = u;
          break;
        case "HH":
        case "H":
          r += "([0-9]{2}|[0-9]{1})", a.hourBase0 = u;
          break;
        case "KK":
        case "K":
          r += "([0-9]{2}|[0-9]{1})", a.hour12Base0 = u;
          break;
        case "kk":
        case "k":
          r += "([0-9]{2}|[0-9]{1})", a.hourBase1 = u;
          break;
        case "mm":
        case "m":
          r += "([0-9]{2}|[0-9]{1})", a.minute = u;
          break;
        case "ss":
        case "s":
          r += "([0-9]{2}|[0-9]{1})", a.second = u;
          break;
        case "SSS":
        case "SS":
        case "S":
          r += "([0-9]{3}|[0-9]{2}|[0-9]{1})", a.millisecond = u, a.millisecondDigits = n.parts[d].length;
          break;
        case "nnn":
        case "nn":
        case "n":
          r += "([0-9]{3}|[0-9]{2}|[0-9]{1})", a.millisecond = u;
          break;
        case "x":
          r += "([0-9]{1,})", a.timestamp = u;
          break;
        case "Z":
          r += "GMT([-+]+[0-9]{2}:[0-9]{2})", a.zone = u;
          break;
        case "ZZ":
          r += "([\\-+]+[0-9]{2}[0-9]{2})", a.zone = u;
          break;
        case "i":
          r += "([0-9]{4})-?([0-9]{2})-?([0-9]{2})T?([0-9]{2}):?([0-9]{2}):?([0-9]{2})\\.?([0-9]{0,3})([zZ]|[+\\-][0-9]{2}:?[0-9]{2}|$)", a.iso = u, l += 7;
          break;
        case "G":
        case "YYYY":
        case "YYY":
        case "YY":
        case "Y":
        case "MMMMM":
        case "W":
        case "EEEEE":
        case "EEEE":
        case "EEE":
        case "EE":
        case "E":
        case "eeeee":
        case "eeee":
        case "eee":
        case "ee":
        case "e":
        case "zzzz":
        case "zzz":
        case "zz":
        case "z":
        case "t":
          l--;
          break;
      }
      r += "[^0-9]*";
    }
    let h = new RegExp(r), c = e.match(h);
    if (c) {
      if (a.year > -1 && (o.year = parseInt(c[a.year])), a.year3 > -1) {
        let d = parseInt(c[a.year3]);
        d += 1e3, o.year = d;
      }
      if (a.year2 > -1) {
        let d = parseInt(c[a.year2]);
        d > 50 ? d += 1e3 : d += 2e3, o.year = d;
      }
      if (a.year1 > -1) {
        let d = parseInt(c[a.year1]);
        d = Math.floor(new Date().getFullYear() / 10) * 10 + d, o.year = d;
      }
      if (a.monthLong > -1 && (o.month = this.resolveMonth(c[a.monthLong])), a.monthShort > -1 && (o.month = this.resolveShortMonth(c[a.monthShort])), a.month > -1 && (o.month = parseInt(c[a.month]) - 1), a.week > -1 && a.day === -1 && (o.month = 0, o.day = fd(parseInt(c[a.week]), o.year, 1, this._root.utc)), a.day > -1 && (o.day = parseInt(c[a.day])), a.yearDay > -1 && (o.month = 0, o.day = parseInt(c[a.yearDay])), a.hourBase0 > -1 && (o.hour = parseInt(c[a.hourBase0])), a.hourBase1 > -1 && (o.hour = parseInt(c[a.hourBase1]) - 1), a.hour12Base0 > -1) {
        let d = parseInt(c[a.hour12Base0]);
        d == 11 && (d = 0), a.am > -1 && !this.isAm(c[a.am]) && (d += 12), o.hour = d;
      }
      if (a.hour12Base1 > -1) {
        let d = parseInt(c[a.hour12Base1]);
        d == 12 && (d = 0), a.am > -1 && !this.isAm(c[a.am]) && (d += 12), o.hour = d;
      }
      if (a.minute > -1 && (o.minute = parseInt(c[a.minute])), a.second > -1 && (o.second = parseInt(c[a.second])), a.millisecond > -1) {
        let d = parseInt(c[a.millisecond]);
        a.millisecondDigits == 2 ? d *= 10 : a.millisecondDigits == 1 && (d *= 100), o.millisecond = d;
      }
      if (a.timestamp > -1) {
        o.timestamp = parseInt(c[a.timestamp]);
        const d = new Date(o.timestamp);
        o.year = d.getUTCFullYear(), o.month = d.getUTCMonth(), o.day = d.getUTCDate(), o.hour = d.getUTCHours(), o.minute = d.getUTCMinutes(), o.second = d.getUTCSeconds(), o.millisecond = d.getUTCMilliseconds();
      }
      a.zone > -1 && (o.offset = this.resolveTimezoneOffset(new Date(o.year, o.month, o.day), c[a.zone])), a.iso > -1 && (o.year = pt(c[a.iso + 0]), o.month = pt(c[a.iso + 1]) - 1, o.day = pt(c[a.iso + 2]), o.hour = pt(c[a.iso + 3]), o.minute = pt(c[a.iso + 4]), o.second = pt(c[a.iso + 5]), o.millisecond = pt(c[a.iso + 6]), c[a.iso + 7] == "Z" || c[a.iso + 7] == "z" ? o.utc = !0 : c[a.iso + 7] != "" && (o.offset = this.resolveTimezoneOffset(new Date(o.year, o.month, o.day), c[a.iso + 7]))), o.utc ? s = new Date(Date.UTC(o.year, o.month, o.day, o.hour, o.minute, o.second, o.millisecond)) : s = new Date(o.year, o.month, o.day, o.hour, o.minute + o.offset, o.second, o.millisecond);
    } else
      s = new Date(e);
    return s;
  }
  resolveTimezoneOffset(e, t) {
    if (t.match(/([+\-]?)([0-9]{2}):?([0-9]{2})/)) {
      let r = t.match(/([+\-]?)([0-9]{2}):?([0-9]{2})/), n = r[1], a = r[2], o = r[3], l = parseInt(a) * 60 + parseInt(o);
      n == "+" && (l *= -1);
      let u = (e || new Date()).getTimezoneOffset();
      return l - u;
    }
    return 0;
  }
  /**
   * Resolves month name (i.e. "December") into a month number (11).
   *
   * @param value  Month name
   * @return Month number
   */
  resolveMonth(e) {
    let t = this._months().indexOf(e);
    return t > -1 || !this._root.language.isDefault() && (t = this._root.language.translateAll(this._months()).indexOf(e), t > -1) ? t : 0;
  }
  /**
   * Resolves short month name (i.e. "Dec") into a month number.
   *
   * @param value  Short month name
   * @return Month number
   */
  resolveShortMonth(e) {
    let t = this._shortMonths().indexOf(e);
    return t > -1 || (t = this._months().indexOf(e), t > -1) || this._root.language && !this._root.language.isDefault() && (t = this._root.language.translateAll(this._shortMonths()).indexOf(e), t > -1) ? t : 0;
  }
  /**
   * Checks if passed in string represents AM/PM notation in many of its
   * versions.
   *
   * @param value  Source string
   * @return Is it AM/PM?
   */
  isAm(e) {
    return this.getStringList(["AM", "A.M.", "A"]).indexOf(e.toUpperCase()) > -1;
  }
  /**
   * Translates list of strings.
   *
   * @param list  Source strings
   * @return Translated strings
   */
  getStringList(e) {
    let t = [];
    for (let s = 0; s < e.length; s++)
      this._root.language ? t.push(rl(this._t(e[s]))) : t.push(rl(e[s]));
    return t;
  }
}
class Id extends De {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_unitAliases", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {
        Y: "y",
        D: "d",
        H: "h",
        K: "h",
        k: "h",
        n: "S"
      }
    });
  }
  _setDefaults() {
    const e = "_duration_millisecond", t = "_duration_second", s = "_duration_minute", r = "_duration_hour", n = "_duration_day", a = "_duration_week", o = "_duration_month", l = "_duration_year", u = "_second", h = "_minute", c = "_hour", d = "_day", f = "_week", g = "_week", p = "_year";
    this._setDefault("negativeBase", 0), this._setDefault("baseUnit", "second"), this._setDefault("durationFormats", {
      millisecond: {
        millisecond: this._t(e),
        second: this._t(e + u),
        minute: this._t(e + h),
        hour: this._t(e + c),
        day: this._t(e + d),
        week: this._t(e + f),
        month: this._t(e + g),
        year: this._t(e + p)
      },
      second: {
        second: this._t(t),
        minute: this._t(t + h),
        hour: this._t(t + c),
        day: this._t(t + d),
        week: this._t(t + f),
        month: this._t(t + g),
        year: this._t(t + p)
      },
      minute: {
        minute: this._t(s),
        hour: this._t(s + c),
        day: this._t(s + d),
        week: this._t(s + f),
        month: this._t(s + g),
        year: this._t(s + p)
      },
      hour: {
        hour: this._t(r),
        day: this._t(r + d),
        week: this._t(r + f),
        month: this._t(r + g),
        year: this._t(r + p)
      },
      day: {
        day: this._t(n),
        week: this._t(n + f),
        month: this._t(n + g),
        year: this._t(n + p)
      },
      week: {
        week: this._t(a),
        month: this._t(a + g),
        year: this._t(a + p)
      },
      month: {
        month: this._t(o),
        year: this._t(o + p)
      },
      year: {
        year: this._t(l)
      }
    }), super._setDefaults();
  }
  _beforeChanged() {
    super._beforeChanged();
  }
  /**
   * Formats the number as duration.
   *
   * For example `1000` (base unit seconds) would be converted to `16:40` as in
   * 16 minutes and 40 seconds.
   *
   * @param value   Value to format
   * @param format  Format to apply
   * @param base    Override base unit
   * @return Formatted number
   */
  format(e, t, s) {
    let r = s || this.get("baseUnit");
    (typeof t > "u" || t === "") && (this.get("durationFormat") != null ? t = this.get("durationFormat") : t = this.getFormat(pt(e), void 0, r)), t = to(t);
    let n = this.parseFormat(t, r), a = Number(e), o;
    a > this.get("negativeBase") ? o = n.positive : a < this.get("negativeBase") ? o = n.negative : o = n.zero;
    let l = this.applyFormat(a, o);
    return o.color !== "" && (l = "[" + o.color + "]" + l + "[/]"), l;
  }
  /**
   * Parses supplied format into structured object which can be used to format
   * the number.
   *
   * @param format  Format string, i.e. "#,###.00"
   * @param base    Override base unit
   * @return Parsed information
   */
  parseFormat(e, t) {
    let s = t || this.get("baseUnit"), r = {
      positive: {
        color: "",
        template: "",
        parts: [],
        source: "",
        baseUnit: s,
        parsed: !1,
        absolute: !1
      },
      negative: {
        color: "",
        template: "",
        parts: [],
        source: "",
        baseUnit: s,
        parsed: !1,
        absolute: !1
      },
      zero: {
        color: "",
        template: "",
        parts: [],
        source: "",
        baseUnit: s,
        parsed: !1,
        absolute: !1
      }
    };
    e = e.replace("||", hs);
    let n = e.split("|");
    return r.positive.source = n[0], typeof n[2] > "u" ? r.zero = r.positive : r.zero.source = n[2], typeof n[1] > "u" ? r.negative = r.positive : r.negative.source = n[1], _e(r, (a, o) => {
      if (o.parsed)
        return;
      let l = o.source, u = [];
      u = o.source.match(/^\[([^\]]*)\]/), u && u.length && u[0] !== "" && (l = o.source.substr(u[0].length), o.color = u[1]);
      let h = Nt.chunk(l, !0);
      for (let c = 0; c < h.length; c++) {
        let d = h[c];
        if (d.text = d.text.replace(hs, "|"), d.type === "value") {
          d.text.match(/[yYMdDwhHKkmsSn]+a/) && (o.absolute = !0, d.text = d.text.replace(/([yYMdDwhHKkmsSn]+)a/, "$1"));
          let f = d.text.match(/y+|Y+|M+|d+|D+|w+|h+|H+|K+|k+|m+|s+|S+|n+/g);
          if (f)
            for (let g = 0; g < f.length; g++)
              f[g] == null && (f[g] = this._unitAliases[f[g]]), o.parts.push(f[g]), d.text = d.text.replace(f[g], _i);
        }
        o.template += d.text;
      }
      o.parsed = !0;
    }), r;
  }
  /**
   * Applies parsed format to a numeric value.
   *
   * @param value    Value
   * @param details  Parsed format as returned by {parseFormat}
   * @return Formatted duration
   */
  applyFormat(e, t) {
    let s = !t.absolute && e < this.get("negativeBase");
    e = Math.abs(e);
    let r = this.toTimeStamp(e, t.baseUnit), n = t.template;
    for (let a = 0, o = t.parts.length; a < o; a++) {
      let l = t.parts[a], u = this._toTimeUnit(l.substr(0, 1)), h = l.length, c = Math.floor(r / this._getUnitValue(u));
      n = n.replace(_i, je(c, h, "0")), r -= c * this._getUnitValue(u);
    }
    return s && (n = "-" + n), n;
  }
  /**
   * Converts numeric value to timestamp in milliseconds.
   *
   * @param value     A source value
   * @param baseUnit  Base unit the source value is in: "q", "s", "i", "h", "d", "w", "m", "y"
   * @return Value representation as a timestamp in milliseconds
   */
  toTimeStamp(e, t) {
    return e * this._getUnitValue(t);
  }
  _toTimeUnit(e) {
    switch (e) {
      case "S":
        return "millisecond";
      case "s":
        return "second";
      case "m":
        return "minute";
      case "h":
        return "hour";
      case "d":
        return "day";
      case "w":
        return "week";
      case "M":
        return "month";
      case "y":
        return "year";
    }
  }
  /**
   * Returns appropriate default format for the value.
   *
   * If `maxValue` is sepcified, it will use that value to determine the time
   * unit for the format.
   *
   * For example if your `baseUnit` is `"second"` and you pass in `10`, you
   * will get `"10"`.
   *
   * However, you might want it to be formatted in the context of bigger scale,
   * say 10 minutes (600 seconds). If you pass in `600` as `maxValue`, all
   * values, including small ones will use format with minutes, e.g.:
   * `00:10`, `00:50`, `12: 30`, etc.
   *
   * @param value     Value to format
   * @param maxValue  Maximum value to be used to determine format
   * @param baseUnit  Base unit of the value
   * @return Format
   */
  getFormat(e, t, s) {
    if (this.get("durationFormat") != null)
      return this.get("durationFormat");
    if (s || (s = this.get("baseUnit")), t != null && e != t) {
      e = Math.abs(e), t = Math.abs(t);
      let r = this.getValueUnit(Math.max(e, t), s);
      return this.get("durationFormats")[s][r];
    } else {
      let r = this.getValueUnit(e, s);
      return this.get("durationFormats")[s][r];
    }
  }
  /**
   * Returns value's closest denominator time unit, e.g 100 seconds is
   * `"minute"`, while 59 seconds would still be `second`.
   *
   * @param value     Source duration value
   * @param baseUnit  Base unit
   * @return Denominator
   */
  getValueUnit(e, t) {
    t || (t = this.get("baseUnit"));
    let s, r = this.getMilliseconds(e, t);
    return Kc(this._getUnitValues(), (n, a) => {
      if (n == t || s) {
        if (r / a <= 1)
          return s || (s = n), !1;
        s = n;
      }
      return !0;
    }), s;
  }
  /**
   * Converts value to milliseconds according to `baseUnit`.
   *
   * @param value     Source duration value
   * @param baseUnit  Base unit
   * @return Value in milliseconds
   */
  getMilliseconds(e, t) {
    return t || (t = this.get("baseUnit")), e * this._getUnitValue(t);
  }
  _getUnitValue(e) {
    return this._getUnitValues()[e];
  }
  _getUnitValues() {
    return {
      millisecond: 1,
      second: 1e3,
      minute: 6e4,
      hour: 36e5,
      day: 864e5,
      week: 6048e5,
      month: 2592e6,
      year: 31536e6
    };
  }
}
const Rd = {
  firstDayOfWeek: 1,
  // Number formatting options.
  // 
  // Please check with the local standards which separator is accepted to be
  // used for separating decimals, and which for thousands.
  _decimalSeparator: ".",
  _thousandSeparator: ",",
  // Position of the percent sign in numbers
  _percentPrefix: null,
  _percentSuffix: "%",
  // Suffixes for numbers
  // When formatting numbers, big or small numers might be reformatted to
  // shorter version, by applying a suffix.
  // 
  // For example, 1000000 might become "1m".
  // Or 1024 might become "1KB" if we're formatting byte numbers.
  // 
  // This section defines such suffixes for all such cases.
  _big_number_suffix_3: "k",
  _big_number_suffix_6: "M",
  _big_number_suffix_9: "G",
  _big_number_suffix_12: "T",
  _big_number_suffix_15: "P",
  _big_number_suffix_18: "E",
  _big_number_suffix_21: "Z",
  _big_number_suffix_24: "Y",
  _small_number_suffix_3: "m",
  _small_number_suffix_6: "μ",
  _small_number_suffix_9: "n",
  _small_number_suffix_12: "p",
  _small_number_suffix_15: "f",
  _small_number_suffix_18: "a",
  _small_number_suffix_21: "z",
  _small_number_suffix_24: "y",
  _byte_suffix_B: "B",
  _byte_suffix_KB: "KB",
  _byte_suffix_MB: "MB",
  _byte_suffix_GB: "GB",
  _byte_suffix_TB: "TB",
  _byte_suffix_PB: "PB",
  // Default date formats for various periods.
  // 
  // This should reflect official or de facto formatting universally accepted
  // in the country translation is being made for
  // Available format codes here:
  // https://www.amcharts.com/docs/v5/concepts/formatters/formatting-dates/#Format_codes
  // 
  // This will be used when formatting date/time for particular granularity,
  // e.g. "_date_hour" will be shown whenever we need to show time as hours.
  // 
  // "date" is used as in default date format when showing standalone dates.
  _date: "yyyy-MM-dd",
  _date_millisecond: "mm:ss SSS",
  _date_millisecond_full: "HH:mm:ss SSS",
  _date_second: "HH:mm:ss",
  _date_second_full: "HH:mm:ss",
  _date_minute: "HH:mm",
  _date_minute_full: "HH:mm - MMM dd, yyyy",
  _date_hour: "HH:mm",
  _date_hour_full: "HH:mm - MMM dd, yyyy",
  _date_day: "MMM dd",
  _date_day_full: "MMM dd, yyyy",
  _date_week: "ww",
  _date_week_full: "MMM dd, yyyy",
  _date_month: "MMM",
  _date_month_full: "MMM, yyyy",
  _date_year: "yyyy",
  // Default duration formats for various base units.
  // 
  // This will be used by DurationFormatter to format numeric values into
  // duration.
  // 
  // Notice how each duration unit comes in several versions. This is to ensure
  // that each base unit is shown correctly.
  // 
  // For example, if we have baseUnit set to "second", meaning our duration is
  // in seconds.
  // 
  // If we pass in `50` to formatter, it will know that we have just 50 seconds
  // (less than a minute) so it will use format in `"_duration_second"` ("ss"),
  // and the formatted result will be in like `"50"`.
  // 
  // If we pass in `70`, which is more than a minute, the formatter will switch
  // to `"_duration_second_minute"` ("mm:ss"), resulting in "01:10" formatted
  // text.
  // 
  // Available codes here:
  // https://www.amcharts.com/docs/v4/concepts/formatters/formatting-duration/#Available_Codes
  _duration_millisecond: "SSS",
  _duration_millisecond_second: "ss.SSS",
  _duration_millisecond_minute: "mm:ss SSS",
  _duration_millisecond_hour: "hh:mm:ss SSS",
  _duration_millisecond_day: "d'd' mm:ss SSS",
  _duration_millisecond_week: "d'd' mm:ss SSS",
  _duration_millisecond_month: "M'm' dd'd' mm:ss SSS",
  _duration_millisecond_year: "y'y' MM'm' dd'd' mm:ss SSS",
  _duration_second: "ss",
  _duration_second_minute: "mm:ss",
  _duration_second_hour: "hh:mm:ss",
  _duration_second_day: "d'd' hh:mm:ss",
  _duration_second_week: "d'd' hh:mm:ss",
  _duration_second_month: "M'm' dd'd' hh:mm:ss",
  _duration_second_year: "y'y' MM'm' dd'd' hh:mm:ss",
  _duration_minute: "mm",
  _duration_minute_hour: "hh:mm",
  _duration_minute_day: "d'd' hh:mm",
  _duration_minute_week: "d'd' hh:mm",
  _duration_minute_month: "M'm' dd'd' hh:mm",
  _duration_minute_year: "y'y' MM'm' dd'd' hh:mm",
  _duration_hour: "hh'h'",
  _duration_hour_day: "d'd' hh'h'",
  _duration_hour_week: "d'd' hh'h'",
  _duration_hour_month: "M'm' dd'd' hh'h'",
  _duration_hour_year: "y'y' MM'm' dd'd' hh'h'",
  _duration_day: "d'd'",
  _duration_day_week: "d'd'",
  _duration_day_month: "M'm' dd'd'",
  _duration_day_year: "y'y' MM'm' dd'd'",
  _duration_week: "w'w'",
  _duration_week_month: "w'w'",
  _duration_week_year: "w'w'",
  _duration_month: "M'm'",
  _duration_month_year: "y'y' MM'm'",
  _duration_year: "y'y'",
  // Era translations
  _era_ad: "AD",
  _era_bc: "BC",
  // Day part, used in 12-hour formats, e.g. 5 P.M.
  // Please note that these come in 3 variants:
  // * one letter (e.g. "A")
  // * two letters (e.g. "AM")
  // * two letters with dots (e.g. "A.M.")
  // 
  // All three need to to be translated even if they are all the same. Some
  // users might use one, some the other.
  A: "",
  P: "",
  AM: "",
  PM: "",
  "A.M.": "",
  "P.M.": "",
  // Date-related stuff.
  // 
  // When translating months, if there's a difference, use the form which is
  // best for a full date, e.g. as you would use it in "2018 January 1".
  // 
  // Note that May is listed twice. This is because in English May is the same
  // in both long and short forms, while in other languages it may not be the
  // case. Translate "May" to full word, while "May(short)" to shortened
  // version.
  // 
  // Should month names and weekdays be capitalized or not?
  // 
  // Rule of thumb is this: if the names should always be capitalized,
  // regardless of name position within date ("January", "21st January 2018",
  // etc.) use capitalized names. Otherwise enter all lowercase.
  // 
  // The date formatter will automatically capitalize names if they are the
  // first (or only) word in resulting date.
  January: "",
  February: "",
  March: "",
  April: "",
  May: "",
  June: "",
  July: "",
  August: "",
  September: "",
  October: "",
  November: "",
  December: "",
  Jan: "",
  Feb: "",
  Mar: "",
  Apr: "",
  "May(short)": "May",
  Jun: "",
  Jul: "",
  Aug: "",
  Sep: "",
  Oct: "",
  Nov: "",
  Dec: "",
  // Weekdays.
  Sunday: "",
  Monday: "",
  Tuesday: "",
  Wednesday: "",
  Thursday: "",
  Friday: "",
  Saturday: "",
  Sun: "",
  Mon: "",
  Tue: "",
  Wed: "",
  Thu: "",
  Fri: "",
  Sat: "",
  // Date ordinal function.
  // 
  // This is used when adding number ordinal when formatting days in dates.
  // 
  // E.g. "January 1st", "February 2nd".
  // 
  // The function accepts day number, and returns a string to be added to the
  // day, like in default English translation, if we pass in 2, we will receive
  // "nd" back.
  _dateOrd: function(i) {
    let e = "th";
    if (i < 11 || i > 13)
      switch (i % 10) {
        case 1:
          e = "st";
          break;
        case 2:
          e = "nd";
          break;
        case 3:
          e = "rd";
          break;
      }
    return e;
  },
  // Various chart controls.
  // Shown as a tooltip on zoom out button.
  "Zoom Out": "",
  // Timeline buttons
  Play: "",
  Stop: "",
  // Chart's Legend screen reader title.
  Legend: "",
  // Legend's item screen reader indicator.
  "Press ENTER to toggle": "",
  // Shown when the chart is busy loading something.
  Loading: "",
  // Shown as the first button in the breadcrumb navigation, e.g.:
  // Home > First level > ...
  Home: "",
  // Chart types.
  // Those are used as default screen reader titles for the main chart element
  // unless developer has set some more descriptive title.
  Chart: "",
  "Serial chart": "",
  "X/Y chart": "",
  "Pie chart": "",
  "Gauge chart": "",
  "Radar chart": "",
  "Sankey diagram": "",
  "Flow diagram": "",
  "Chord diagram": "",
  "TreeMap chart": "",
  "Force directed tree": "",
  "Sliced chart": "",
  // Series types.
  // Used to name series by type for screen readers if they do not have their
  // name set.
  Series: "",
  "Candlestick Series": "",
  "OHLC Series": "",
  "Column Series": "",
  "Line Series": "",
  "Pie Slice Series": "",
  "Funnel Series": "",
  "Pyramid Series": "",
  "X/Y Series": "",
  // Map-related stuff.
  Map: "",
  "Press ENTER to zoom in": "",
  "Press ENTER to zoom out": "",
  "Use arrow keys to zoom in and out": "",
  "Use plus and minus keys on your keyboard to zoom in and out": "",
  // Export-related stuff.
  // These prompts are used in Export menu labels.
  // 
  // "Export" is the top-level menu item.
  // 
  // "Image", "Data", "Print" as second-level indicating type of export
  // operation.
  // 
  // Leave actual format untranslated, unless you absolutely know that they
  // would convey more meaning in some other way.
  Export: "",
  Image: "",
  Data: "",
  Print: "",
  "Press ENTER or use arrow keys to navigate": "",
  "Press ENTER to open": "",
  "Press ENTER to print.": "",
  "Press ENTER to export as %1.": "",
  "(Press ESC to close this message)": "",
  "Image Export Complete": "",
  "Export operation took longer than expected. Something might have gone wrong.": "",
  "Saved from": "",
  PNG: "",
  JPG: "",
  GIF: "",
  SVG: "",
  PDF: "",
  JSON: "",
  CSV: "",
  XLSX: "",
  HTML: "",
  // Scrollbar-related stuff.
  // 
  // Scrollbar is a control which can zoom and pan the axes on the chart.
  // 
  // Each scrollbar has two grips: left or right (for horizontal scrollbar) or
  // upper and lower (for vertical one).
  // 
  // Prompts change in relation to whether Scrollbar is vertical or horizontal.
  // 
  // The final section is used to indicate the current range of selection.
  "Use TAB to select grip buttons or left and right arrows to change selection": "",
  "Use left and right arrows to move selection": "",
  "Use left and right arrows to move left selection": "",
  "Use left and right arrows to move right selection": "",
  "Use TAB select grip buttons or up and down arrows to change selection": "",
  "Use up and down arrows to move selection": "",
  "Use up and down arrows to move lower selection": "",
  "Use up and down arrows to move upper selection": "",
  "From %1 to %2": "",
  "From %1": "",
  "To %1": "",
  // Data loader-related.
  "No parser available for file: %1": "",
  "Error parsing file: %1": "",
  "Unable to load file: %1": "",
  "Invalid date": "",
  // Common actions
  Close: "",
  Minimize: ""
};
class Z0 extends De {
  _setDefaults() {
    this.setPrivate("defaultLocale", Rd), super._setDefaults();
  }
  /**
   * Returns a prompt translation.
   *
   * @param   prompt   Prompt to translate
   * @param   locale   Target locale
   * @param   ...rest  Parameters
   * @return           Translation
   */
  translate(e, t, ...s) {
    t || (t = this._root.locale || this.getPrivate("defaultLocale"));
    let r = e, n = t[e];
    if (n === null)
      r = "";
    else if (n != null)
      n && (r = n);
    else if (t !== this.getPrivate("defaultLocale"))
      return this.translate(e, this.getPrivate("defaultLocale"), ...s);
    if (s.length)
      for (let a = s.length, o = 0; o < a; ++o)
        r = r.split("%" + (o + 1)).join(s[o]);
    return r;
  }
  /**
   * Returns a prompt translation, including custom prompts.
   *
   * @param   prompt   Prompt to translate
   * @param   locale   Target locale
   * @param   ...rest  Parameters
   * @return           Translation
   */
  translateAny(e, t, ...s) {
    return this.translate(e, t, ...s);
  }
  /**
   * Add a custom prompt to locale.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/locales/creating-translations/#Extending_locale_with_custom_prompts}
   * @param  prompt       Source prompt
   * @param  translation  Tanslation
   * @param  locale       Target locale
   */
  setTranslationAny(e, t, s) {
    const r = s || this._root.locale;
    r[e] = t;
  }
  /**
   * Add a batch of custom prompts.
   *
   * @since 5.3.3
   * @see {@link https://www.amcharts.com/docs/v5/concepts/locales/creating-translations/#Extending_locale_with_custom_prompts}
   * @param  translations  Translations
   * @param  locale        Target locale
   */
  setTranslationsAny(e, t) {
    _e(e, (s, r) => {
      this.setTranslationAny(s, r, t);
    });
  }
  translateEmpty(e, t, ...s) {
    let r = this.translate(e, t, ...s);
    return r == e ? "" : r;
  }
  translateFunc(e, t) {
    return this._root.locale[e] ? this._root.locale[e] : t !== this.getPrivate("defaultLocale") ? this.translateFunc(e, this.getPrivate("defaultLocale")) : () => "";
  }
  /**
   * Translates a btach of prompts.
   *
   * @param  list    Array of prompts to translate
   * @param  locale  Target locale
   * @return         Array of translations
   */
  translateAll(e, t) {
    return this.isDefault() ? e : qn(e, (s) => this.translate(s, t));
  }
  /**
   * Returns `true` if the currently selected locale is a default locale.
   *
   * @return `true` if locale is default; `false` if it is not.
   */
  isDefault() {
    return this.getPrivate("defaultLocale") === this._root.locale;
  }
}
class dr {
  constructor(e, t) {
    if (Object.defineProperty(this, "_root", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_rules", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), this._root = e, !t)
      throw new Error("You cannot use `new Class()`, instead use `Class.new()`");
  }
  /**
   * Use this method to create an instance of this class.
   *
   * @see {@link https://www.amcharts.com/docs/v5/getting-started/#New_element_syntax} for more info
   * @param   root      Root element
   * @param   settings  Settings
   * @param   template  Template
   * @return            Instantiated object
   */
  static new(e) {
    const t = new this(e, !0);
    return t.setupDefaultRules(), t;
  }
  setupDefaultRules() {
  }
  /**
   * Looks up the rules for a specific theme class.
   *
   * @see {@link https://www.amcharts.com/docs/v5/themes/} for more info
   * @param   themeClass Theme class
   * @return             Array<IRule<A>>
   */
  _lookupRules(e) {
    return this._rules[e];
  }
  /**
   * Creates a [[Template]] for specific theme class and tags.
   *
   * NOTE: the difference from `rule()` is that `ruleRaw()` does not do any
   * type checks.
   *
   * @see {@link https://www.amcharts.com/docs/v5/themes/} for more info
   * @param   themeClass Theme class
   * @param   themeTags  Theme tags
   * @return             Template
   */
  ruleRaw(e, t = []) {
    let s = this._rules[e];
    s || (s = this._rules[e] = []), t.sort(Et);
    const { index: r, found: n } = Ei(s, (a) => {
      const o = Et(a.tags.length, t.length);
      return o === 0 ? Cd(a.tags, t, Et) : o;
    });
    if (n)
      return s[r].template;
    {
      const a = ge.new({});
      return s.splice(r, 0, {
        tags: t,
        template: a
      }), a;
    }
  }
  /**
   * Creates a [[Template]] for specific theme class and tags.
   *
   * @see {@link https://www.amcharts.com/docs/v5/themes/} for more info
   * @param   themeClass Theme class
   * @param   themeTags  Theme tags
   * @return             Template
   */
  rule(e, t = []) {
    return this.ruleRaw(e, t);
  }
}
function K(i, e, t, s) {
  i.set(e, t.get(s)), t.on(s, (r) => {
    i.set(e, r);
  });
}
class K0 extends dr {
  setupDefaultRules() {
    super.setupDefaultRules();
    const e = this._root.language, t = this._root.interfaceColors, s = this._root.horizontalLayout, r = this._root.verticalLayout, n = this.rule.bind(this);
    n("InterfaceColors").setAll({
      stroke: X.fromHex(15066597),
      fill: X.fromHex(15987699),
      primaryButton: X.fromHex(6788316),
      primaryButtonHover: X.fromHex(6779356),
      primaryButtonDown: X.fromHex(6872182),
      primaryButtonActive: X.fromHex(6872182),
      primaryButtonText: X.fromHex(16777215),
      primaryButtonStroke: X.fromHex(16777215),
      secondaryButton: X.fromHex(14277081),
      secondaryButtonHover: X.fromHex(10724259),
      secondaryButtonDown: X.fromHex(9276813),
      secondaryButtonActive: X.fromHex(15132390),
      secondaryButtonText: X.fromHex(0),
      secondaryButtonStroke: X.fromHex(16777215),
      grid: X.fromHex(0),
      background: X.fromHex(16777215),
      alternativeBackground: X.fromHex(0),
      text: X.fromHex(0),
      alternativeText: X.fromHex(16777215),
      disabled: X.fromHex(11382189),
      positive: X.fromHex(5288704),
      negative: X.fromHex(11730944)
    });
    {
      const a = n("ColorSet");
      a.setAll({
        passOptions: {
          hue: 0.05,
          saturation: 0,
          lightness: 0
        },
        colors: [
          X.fromHex(6797276)
        ],
        step: 1,
        //baseColor: Color.fromRGB(103, 183, 220),
        //count: 20,
        reuse: !1,
        startIndex: 0
      }), a.setPrivate("currentStep", 0), a.setPrivate("currentPass", 0);
    }
    n("Entity").setAll({
      stateAnimationDuration: 0,
      stateAnimationEasing: Sr(Ys)
    }), n("Component").setAll({
      interpolationDuration: 0,
      interpolationEasing: Sr(Ys)
    }), n("Sprite").setAll({
      visible: !0,
      scale: 1,
      opacity: 1,
      rotation: 0,
      position: "relative",
      tooltipX: ie,
      tooltipY: ie,
      tooltipPosition: "fixed",
      isMeasured: !0
    }), n("Sprite").states.create("default", { visible: !0, opacity: 1 }), n("Container").setAll({
      interactiveChildren: !0,
      setStateOnChildren: !1
    }), n("Graphics").setAll({
      strokeWidth: 1
    }), n("Chart").setAll({
      width: R,
      height: R,
      interactiveChildren: !1
    }), n("Sprite", ["horizontal", "center"]).setAll({
      centerX: ie,
      x: ie
    }), n("Sprite", ["vertical", "center"]).setAll({
      centerY: ie,
      y: ie
    }), n("Container", ["horizontal", "layout"]).setAll({
      layout: s
    }), n("Container", ["vertical", "layout"]).setAll({
      layout: r
    }), n("Pattern").setAll({
      repetition: "repeat",
      width: 50,
      height: 50,
      rotation: 0,
      fillOpacity: 1
    }), n("LinePattern").setAll({
      gap: 6,
      colorOpacity: 1,
      width: 49,
      height: 49
    }), n("RectanglePattern").setAll({
      gap: 6,
      checkered: !1,
      centered: !0,
      maxWidth: 5,
      maxHeight: 5,
      width: 48,
      height: 48,
      strokeWidth: 0
    }), n("CirclePattern").setAll({
      gap: 5,
      checkered: !1,
      centered: !1,
      radius: 3,
      strokeWidth: 0,
      width: 45,
      height: 45
    }), n("LinearGradient").setAll({
      rotation: 90
    }), n("Legend").setAll({
      fillField: "fill",
      strokeField: "stroke",
      nameField: "name",
      layout: bi.new(this._root, {}),
      layer: 30,
      clickTarget: "itemContainer"
    }), n("Container", ["legend", "item", "itemcontainer"]).setAll({
      paddingLeft: 5,
      paddingRight: 5,
      paddingBottom: 5,
      paddingTop: 5,
      layout: s,
      setStateOnChildren: !0,
      interactiveChildren: !1,
      ariaChecked: !0,
      focusable: !0,
      ariaLabel: e.translate("Press ENTER to toggle"),
      role: "checkbox"
    });
    {
      const a = n("Rectangle", ["legend", "item", "background"]);
      a.setAll({
        fillOpacity: 0
      }), K(a, "fill", t, "background");
    }
    n("Container", ["legend", "marker"]).setAll({
      setStateOnChildren: !0,
      centerY: ie,
      paddingLeft: 0,
      paddingRight: 0,
      paddingBottom: 0,
      paddingTop: 0,
      width: 18,
      height: 18
    }), n("RoundedRectangle", ["legend", "marker", "rectangle"]).setAll({
      width: R,
      height: R,
      cornerRadiusBL: 3,
      cornerRadiusTL: 3,
      cornerRadiusBR: 3,
      cornerRadiusTR: 3
    });
    {
      const a = n("RoundedRectangle", ["legend", "marker", "rectangle"]).states.create("disabled", {});
      K(a, "fill", t, "disabled"), K(a, "stroke", t, "disabled");
    }
    n("Label", ["legend", "label"]).setAll({
      centerY: ie,
      marginLeft: 5,
      paddingRight: 0,
      paddingLeft: 0,
      paddingTop: 0,
      paddingBottom: 0,
      populateText: !0
    });
    {
      const a = n("Label", ["legend", "label"]).states.create("disabled", {});
      K(a, "fill", t, "disabled");
    }
    n("Label", ["legend", "value", "label"]).setAll({
      centerY: ie,
      marginLeft: 5,
      paddingRight: 0,
      paddingLeft: 0,
      paddingTop: 0,
      paddingBottom: 0,
      width: 50,
      centerX: R,
      populateText: !0
    });
    {
      const a = n("Label", ["legend", "value", "label"]).states.create("disabled", {});
      K(a, "fill", t, "disabled");
    }
    n("HeatLegend").setAll({
      stepCount: 1
    }), n("RoundedRectangle", ["heatlegend", "marker"]).setAll({
      cornerRadiusTR: 0,
      cornerRadiusBR: 0,
      cornerRadiusTL: 0,
      cornerRadiusBL: 0
    }), n("RoundedRectangle", ["vertical", "heatlegend", "marker"]).setAll({
      height: R,
      width: 15
    }), n("RoundedRectangle", ["horizontal", "heatlegend", "marker"]).setAll({
      width: R,
      height: 15
    }), n("HeatLegend", ["vertical"]).setAll({
      height: R
    }), n("HeatLegend", ["horizontal"]).setAll({
      width: R
    }), n("Label", ["heatlegend", "start"]).setAll({
      paddingLeft: 5,
      paddingRight: 5,
      paddingTop: 5,
      paddingBottom: 5
    }), n("Label", ["heatlegend", "end"]).setAll({
      paddingLeft: 5,
      paddingRight: 5,
      paddingTop: 5,
      paddingBottom: 5
    });
    {
      const a = n("Label");
      a.setAll({
        paddingTop: 8,
        paddingBottom: 8,
        paddingLeft: 10,
        paddingRight: 10,
        fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"',
        fontSize: "1em",
        populateText: !1
      }), K(a, "fill", t, "text");
    }
    n("RadialLabel").setAll({
      textType: "regular",
      centerY: ie,
      centerX: ie,
      inside: !1,
      radius: 0,
      baseRadius: R,
      orientation: "auto",
      textAlign: "center"
    }), n("RoundedRectangle").setAll({
      cornerRadiusTL: 8,
      cornerRadiusBL: 8,
      cornerRadiusTR: 8,
      cornerRadiusBR: 8
    }), n("PointedRectangle").setAll({
      pointerBaseWidth: 15,
      pointerLength: 10,
      cornerRadius: 8
    }), n("Slice").setAll({
      shiftRadius: 0,
      dRadius: 0,
      dInnerRadius: 0
    });
    {
      const a = n("Tick");
      a.setAll({
        strokeOpacity: 0.15,
        isMeasured: !1,
        length: 4.5,
        position: "absolute",
        crisp: !0
      }), K(a, "stroke", t, "grid");
    }
    n("Bullet").setAll({
      locationX: 0.5,
      locationY: 0.5
    }), n("Tooltip").setAll({
      position: "absolute",
      getFillFromSprite: !0,
      getStrokeFromSprite: !1,
      autoTextColor: !0,
      paddingTop: 9,
      paddingBottom: 8,
      paddingLeft: 10,
      paddingRight: 10,
      marginBottom: 5,
      pointerOrientation: "vertical",
      centerX: ie,
      centerY: ie,
      animationEasing: Sr(Ys),
      exportable: !1
      //layer: 100
    }), n("PointedRectangle", ["tooltip", "background"]).setAll({
      strokeOpacity: 0.9,
      cornerRadius: 4,
      pointerLength: 4,
      pointerBaseWidth: 8,
      fillOpacity: 0.9,
      stroke: X.fromHex(16777215)
    });
    {
      const a = n("Label", ["tooltip"]);
      a.setAll({
        role: "tooltip",
        populateText: !0,
        paddingRight: 0,
        paddingTop: 0,
        paddingLeft: 0,
        paddingBottom: 0
      }), K(a, "fill", t, "alternativeText");
    }
    n("Button").setAll({
      paddingTop: 8,
      paddingBottom: 8,
      paddingLeft: 10,
      paddingRight: 10,
      interactive: !0,
      layout: s,
      interactiveChildren: !1,
      setStateOnChildren: !0,
      focusable: !0
    }), n("Button").states.create("hover", {}), n("Button").states.create("down", { stateAnimationDuration: 0 }), n("Button").states.create("active", {});
    {
      const a = n("RoundedRectangle", ["button", "background"]);
      K(a, "fill", t, "primaryButton"), K(a, "stroke", t, "primaryButtonStroke");
    }
    {
      const a = n("RoundedRectangle", ["button", "background"]).states.create("hover", {});
      K(a, "fill", t, "primaryButtonHover");
    }
    {
      const a = n("RoundedRectangle", ["button", "background"]).states.create("down", { stateAnimationDuration: 0 });
      K(a, "fill", t, "primaryButtonDown");
    }
    {
      const a = n("RoundedRectangle", ["button", "background"]).states.create("active", {});
      K(a, "fill", t, "primaryButtonActive");
    }
    {
      const a = n("Graphics", ["button", "icon"]);
      K(a, "stroke", t, "primaryButtonText");
    }
    {
      const a = n("Label", ["button"]);
      K(a, "fill", t, "primaryButtonText");
    }
    n("Button", ["zoom"]).setAll({
      paddingTop: 18,
      paddingBottom: 18,
      paddingLeft: 12,
      paddingRight: 12,
      centerX: 46,
      centerY: -10,
      y: 0,
      x: R,
      role: "button",
      ariaLabel: e.translate("Zoom Out"),
      layer: 30
    });
    {
      const a = n("RoundedRectangle", ["background", "button", "zoom"]);
      a.setAll({
        cornerRadiusBL: 40,
        cornerRadiusBR: 40,
        cornerRadiusTL: 40,
        cornerRadiusTR: 40
      }), K(a, "fill", t, "primaryButton");
    }
    {
      const a = n("RoundedRectangle", ["background", "button", "zoom"]).states.create("hover", {});
      K(a, "fill", t, "primaryButtonHover");
    }
    {
      const a = n("RoundedRectangle", ["background", "button", "zoom"]).states.create("down", { stateAnimationDuration: 0 });
      K(a, "fill", t, "primaryButtonDown");
    }
    {
      const a = n("Graphics", ["icon", "button", "zoom"]);
      a.setAll({
        crisp: !0,
        strokeOpacity: 0.7,
        draw: (o) => {
          o.moveTo(0, 0), o.lineTo(12, 0);
        }
      }), K(a, "stroke", t, "primaryButtonText");
    }
    n("Button", ["resize"]).setAll({
      paddingTop: 9,
      paddingBottom: 9,
      paddingLeft: 13,
      paddingRight: 13,
      draggable: !0,
      centerX: ie,
      centerY: ie,
      position: "absolute",
      role: "slider",
      ariaValueMin: "0",
      ariaValueMax: "100",
      ariaLabel: e.translate("Use up and down arrows to move selection")
    });
    {
      const a = n("RoundedRectangle", ["background", "resize", "button"]);
      a.setAll({
        cornerRadiusBL: 40,
        cornerRadiusBR: 40,
        cornerRadiusTL: 40,
        cornerRadiusTR: 40
      }), K(a, "fill", t, "secondaryButton"), K(a, "stroke", t, "secondaryButtonStroke");
    }
    {
      const a = n("RoundedRectangle", ["background", "resize", "button"]).states.create("hover", {});
      K(a, "fill", t, "secondaryButtonHover");
    }
    {
      const a = n("RoundedRectangle", ["background", "resize", "button"]).states.create("down", { stateAnimationDuration: 0 });
      K(a, "fill", t, "secondaryButtonDown");
    }
    {
      const a = n("Graphics", ["resize", "button", "icon"]);
      a.setAll({
        interactive: !1,
        crisp: !0,
        strokeOpacity: 0.5,
        draw: (o) => {
          o.moveTo(0, 0.5), o.lineTo(0, 12.5), o.moveTo(4, 0.5), o.lineTo(4, 12.5);
        }
      }), K(a, "stroke", t, "secondaryButtonText");
    }
    n("Button", ["resize", "vertical"]).setAll({
      rotation: 90,
      cursorOverStyle: "ns-resize"
    }), n("Button", ["resize", "horizontal"]).setAll({
      cursorOverStyle: "ew-resize"
    }), n("Button", ["play"]).setAll({
      paddingTop: 13,
      paddingBottom: 13,
      paddingLeft: 14,
      paddingRight: 14,
      ariaLabel: e.translate("Play"),
      toggleKey: "active"
    });
    {
      const a = n("RoundedRectangle", ["play", "background"]);
      a.setAll({
        strokeOpacity: 0.5,
        cornerRadiusBL: 100,
        cornerRadiusBR: 100,
        cornerRadiusTL: 100,
        cornerRadiusTR: 100
      }), K(a, "fill", t, "primaryButton");
    }
    {
      const a = n("Graphics", ["play", "icon"]);
      a.setAll({
        stateAnimationDuration: 0,
        dx: 1,
        draw: (o) => {
          o.moveTo(0, -5), o.lineTo(8, 0), o.lineTo(0, 5), o.lineTo(0, -5);
        }
      }), K(a, "fill", t, "primaryButtonText");
    }
    n("Graphics", ["play", "icon"]).states.create("default", {
      stateAnimationDuration: 0
    }), n("Graphics", ["play", "icon"]).states.create("active", {
      stateAnimationDuration: 0,
      draw: (a) => {
        a.moveTo(-4, -5), a.lineTo(-1, -5), a.lineTo(-1, 5), a.lineTo(-4, 5), a.lineTo(-4, -5), a.moveTo(4, -5), a.lineTo(1, -5), a.lineTo(1, 5), a.lineTo(4, 5), a.lineTo(4, -5);
      }
    }), n("Button", ["switch"]).setAll({
      paddingTop: 4,
      paddingBottom: 4,
      paddingLeft: 4,
      paddingRight: 4,
      ariaLabel: e.translate("Press ENTER to toggle"),
      toggleKey: "active",
      width: 40,
      height: 24,
      layout: null
    });
    {
      const a = n("RoundedRectangle", ["switch", "background"]);
      a.setAll({
        strokeOpacity: 0.5,
        cornerRadiusBL: 100,
        cornerRadiusBR: 100,
        cornerRadiusTL: 100,
        cornerRadiusTR: 100
      }), K(a, "fill", t, "primaryButton");
    }
    {
      const a = n("Circle", ["switch", "icon"]);
      a.setAll({
        radius: 8,
        centerY: 0,
        centerX: 0,
        dx: 0
      }), K(a, "fill", t, "primaryButtonText");
    }
    n("Graphics", ["switch", "icon"]).states.create("active", {
      dx: 16
    }), n("Scrollbar").setAll({
      start: 0,
      end: 1,
      layer: 30,
      animationEasing: Sr(Ys)
    }), n("Scrollbar", ["vertical"]).setAll({
      marginRight: 13,
      marginLeft: 13,
      minWidth: 12,
      height: R
    }), n("Scrollbar", ["horizontal"]).setAll({
      marginTop: 13,
      marginBottom: 13,
      minHeight: 12,
      width: R
    }), this.rule("Button", ["scrollbar"]).setAll({
      exportable: !1
    });
    {
      const a = n("RoundedRectangle", ["scrollbar", "main", "background"]);
      a.setAll({
        cornerRadiusTL: 8,
        cornerRadiusBL: 8,
        cornerRadiusTR: 8,
        cornerRadiusBR: 8,
        fillOpacity: 0.8
      }), K(a, "fill", t, "fill");
    }
    {
      const a = n("RoundedRectangle", ["scrollbar", "thumb"]);
      a.setAll({
        role: "slider",
        ariaLive: "polite",
        position: "absolute",
        draggable: !0
      }), K(a, "fill", t, "secondaryButton");
    }
    {
      const a = n("RoundedRectangle", ["scrollbar", "thumb"]).states.create("hover", {});
      K(a, "fill", t, "secondaryButtonHover");
    }
    {
      const a = n("RoundedRectangle", ["scrollbar", "thumb"]).states.create("down", { stateAnimationDuration: 0 });
      K(a, "fill", t, "secondaryButtonDown");
    }
    n("RoundedRectangle", ["scrollbar", "thumb", "vertical"]).setAll({
      x: ie,
      width: R,
      centerX: ie,
      ariaLabel: e.translate("Use up and down arrows to move selection")
    }), n("RoundedRectangle", ["scrollbar", "thumb", "horizontal"]).setAll({
      y: ie,
      centerY: ie,
      height: R,
      ariaLabel: e.translate("Use left and right arrows to move selection")
    });
    {
      const a = n("PointedRectangle", ["axis", "tooltip", "background"]);
      a.setAll({
        cornerRadius: 0
      }), K(a, "fill", t, "alternativeBackground");
    }
    n("Label", ["axis", "tooltip"]).setAll({
      role: void 0
    }), n("Label", ["axis", "tooltip", "y"]).setAll({
      textAlign: "right"
    }), n("Label", ["axis", "tooltip", "y", "opposite"]).setAll({
      textAlign: "left"
    }), n("Label", ["axis", "tooltip", "x"]).setAll({
      textAlign: "center"
    }), n("Tooltip", ["categoryaxis"]).setAll({
      labelText: "{category}"
    }), n("Star").setAll({
      spikes: 5,
      innerRadius: 5,
      radius: 10
    }), n("Tooltip", ["stock"]).setAll({
      paddingTop: 6,
      paddingBottom: 5,
      paddingLeft: 7,
      paddingRight: 7
    }), n("PointedRectangle", ["tooltip", "stock", "axis"]).setAll({
      pointerLength: 0,
      pointerBaseWidth: 0,
      cornerRadius: 3
    }), n("Label", ["tooltip", "stock"]).setAll({
      fontSize: "0.8em"
    }), n("SpriteResizer").setAll({
      rotationStep: 10
    }), n("Container", ["resizer", "grip"]).states.create("hover", {});
    {
      const a = n("RoundedRectangle", ["resizer", "grip"]);
      a.setAll({
        strokeOpacity: 0.7,
        strokeWidth: 1,
        fillOpacity: 1,
        width: 12,
        height: 12
      }), K(a, "fill", t, "background"), K(a, "stroke", t, "alternativeBackground");
    }
    {
      const a = n("RoundedRectangle", ["resizer", "grip", "outline"]);
      a.setAll({
        strokeOpacity: 0,
        fillOpacity: 0,
        width: 20,
        height: 20
      }), a.states.create("hover", {
        fillOpacity: 0.3
      }), K(a, "fill", t, "alternativeBackground");
    }
    n("RoundedRectangle", ["resizer", "grip", "left"]).setAll({
      cornerRadiusBL: 0,
      cornerRadiusBR: 0,
      cornerRadiusTL: 0,
      cornerRadiusTR: 0
    }), n("RoundedRectangle", ["resizer", "grip", "right"]).setAll({
      cornerRadiusBL: 0,
      cornerRadiusBR: 0,
      cornerRadiusTL: 0,
      cornerRadiusTR: 0
    });
    {
      const a = n("Rectangle", ["resizer", "rectangle"]);
      a.setAll({
        strokeDasharray: [2, 2],
        strokeOpacity: 0.5,
        strokeWidth: 1
      }), K(a, "stroke", t, "alternativeBackground");
    }
  }
}
class yo {
  constructor(e = 1, t = 0, s = 0, r = 1, n = 0, a = 0) {
    Object.defineProperty(this, "a", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "b", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "c", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "d", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tx", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "ty", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.a = e, this.b = t, this.c = s, this.d = r, this.tx = n, this.ty = a;
  }
  /**
   * Sets the matrix based on all the available properties
   */
  setTransform(e, t, s, r, n, a = 1) {
    this.a = Math.cos(n) * a, this.b = Math.sin(n) * a, this.c = -Math.sin(n) * a, this.d = Math.cos(n) * a, this.tx = e - (s * this.a + r * this.c), this.ty = t - (s * this.b + r * this.d);
  }
  /**
   * Get a new position with the current transformation applied.
   * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)
   */
  apply(e) {
    return {
      x: this.a * e.x + this.c * e.y + this.tx,
      y: this.b * e.x + this.d * e.y + this.ty
    };
  }
  /**
   * Get a new position with the inverse of the current transformation applied.
   * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)
   */
  applyInverse(e) {
    const t = 1 / (this.a * this.d + this.c * -this.b);
    return {
      x: this.d * t * e.x + -this.c * t * e.y + (this.ty * this.c - this.tx * this.d) * t,
      y: this.a * t * e.y + -this.b * t * e.x + (-this.ty * this.a + this.tx * this.b) * t
    };
  }
  /**
   * Appends the given Matrix to this Matrix.
   */
  append(e) {
    const t = this.a, s = this.b, r = this.c, n = this.d;
    this.a = e.a * t + e.b * r, this.b = e.a * s + e.b * n, this.c = e.c * t + e.d * r, this.d = e.c * s + e.d * n, this.tx = e.tx * t + e.ty * r + this.tx, this.ty = e.tx * s + e.ty * n + this.ty;
  }
  /**
   * Prepends the given Matrix to this Matrix.
   */
  prepend(e) {
    const t = this.tx;
    if (e.a !== 1 || e.b !== 0 || e.c !== 0 || e.d !== 1) {
      const s = this.a, r = this.c;
      this.a = s * e.a + this.b * e.c, this.b = s * e.b + this.b * e.d, this.c = r * e.a + this.d * e.c, this.d = r * e.b + this.d * e.d;
    }
    this.tx = t * e.a + this.ty * e.c + e.tx, this.ty = t * e.b + this.ty * e.d + e.ty;
  }
  /**
   * Copies the other matrix's properties into this matrix
   */
  copyFrom(e) {
    this.a = e.a, this.b = e.b, this.c = e.c, this.d = e.d, this.tx = e.tx, this.ty = e.ty;
  }
}
var Q0 = function() {
  function i(e, t) {
    var s = [], r = !0, n = !1, a = void 0;
    try {
      for (var o = e[Symbol.iterator](), l; !(r = (l = o.next()).done) && (s.push(l.value), !(t && s.length === t)); r = !0)
        ;
    } catch (u) {
      n = !0, a = u;
    } finally {
      try {
        !r && o.return && o.return();
      } finally {
        if (n)
          throw a;
      }
    }
    return s;
  }
  return function(e, t) {
    if (Array.isArray(e))
      return e;
    if (Symbol.iterator in Object(e))
      return i(e, t);
    throw new TypeError("Invalid attempt to destructure non-iterable instance");
  };
}(), Ir = Math.PI * 2, vo = function(e, t, s, r, n, a, o) {
  var l = e.x, u = e.y;
  l *= t, u *= s;
  var h = r * l - n * u, c = n * l + r * u;
  return {
    x: h + a,
    y: c + o
  };
}, J0 = function(e, t) {
  var s = t === 1.5707963267948966 ? 0.551915024494 : t === -1.5707963267948966 ? -0.551915024494 : 1.3333333333333333 * Math.tan(t / 4), r = Math.cos(e), n = Math.sin(e), a = Math.cos(e + t), o = Math.sin(e + t);
  return [{
    x: r - n * s,
    y: n + r * s
  }, {
    x: a + o * s,
    y: o - a * s
  }, {
    x: a,
    y: o
  }];
}, Ju = function(e, t, s, r) {
  var n = e * r - t * s < 0 ? -1 : 1, a = e * s + t * r;
  return a > 1 && (a = 1), a < -1 && (a = -1), n * Math.acos(a);
}, q0 = function(e, t, s, r, n, a, o, l, u, h, c, d) {
  var f = Math.pow(n, 2), g = Math.pow(a, 2), p = Math.pow(c, 2), m = Math.pow(d, 2), _ = f * g - f * m - g * p;
  _ < 0 && (_ = 0), _ /= f * m + g * p, _ = Math.sqrt(_) * (o === l ? -1 : 1);
  var v = _ * n / a * d, b = _ * -a / n * c, y = h * v - u * b + (e + s) / 2, w = u * v + h * b + (t + r) / 2, D = (c - v) / n, A = (d - b) / a, T = (-c - v) / n, j = (-d - b) / a, C = Ju(1, 0, D, A), L = Ju(D, A, T, j);
  return l === 0 && L > 0 && (L -= Ir), l === 1 && L < 0 && (L += Ir), [y, w, C, L];
}, ew = function(e) {
  var t = e.px, s = e.py, r = e.cx, n = e.cy, a = e.rx, o = e.ry, l = e.xAxisRotation, u = l === void 0 ? 0 : l, h = e.largeArcFlag, c = h === void 0 ? 0 : h, d = e.sweepFlag, f = d === void 0 ? 0 : d, g = [];
  if (a === 0 || o === 0)
    return [];
  var p = Math.sin(u * Ir / 360), m = Math.cos(u * Ir / 360), _ = m * (t - r) / 2 + p * (s - n) / 2, v = -p * (t - r) / 2 + m * (s - n) / 2;
  if (_ === 0 && v === 0)
    return [];
  a = Math.abs(a), o = Math.abs(o);
  var b = Math.pow(_, 2) / Math.pow(a, 2) + Math.pow(v, 2) / Math.pow(o, 2);
  b > 1 && (a *= Math.sqrt(b), o *= Math.sqrt(b));
  var y = q0(t, s, r, n, a, o, c, f, p, m, _, v), w = Q0(y, 4), D = w[0], A = w[1], T = w[2], j = w[3], C = Math.abs(j) / (Ir / 4);
  Math.abs(1 - C) < 1e-7 && (C = 1);
  var L = Math.max(Math.ceil(C), 1);
  j /= L;
  for (var E = 0; E < L; E++)
    g.push(J0(T, j)), T += j;
  return g.map(function(N) {
    var J = vo(N[0], a, o, m, p, D, A), z = J.x, H = J.y, Y = vo(N[1], a, o, m, p, D, A), U = Y.x, B = Y.y, ue = vo(N[2], a, o, m, p, D, A), O = ue.x, k = ue.y;
    return { x1: z, y1: H, x2: U, y2: B, x: O, y: k };
  });
};
function tw(i, e, t) {
  if (e !== t)
    throw new Error("Required " + t + " arguments for " + i + " but got " + e);
}
function Dr(i, e, t) {
  if (e < t)
    throw new Error("Required at least " + t + " arguments for " + i + " but got " + e);
}
function Pt(i, e, t) {
  if (Dr(i, e, t), e % t !== 0)
    throw new Error("Arguments for " + i + " must be in pairs of " + t);
}
function iw(i) {
  for (let e = 0; e < i.length; e += 7) {
    let t = e + 3, s = i[t];
    if (s.length > 1) {
      const r = /^([01])([01])(.*)$/.exec(s);
      r !== null && (i.splice(t, 0, r[1]), ++t, i.splice(t, 0, r[2]), ++t, r[3].length > 0 ? i[t] = r[3] : i.splice(t, 1));
    }
    if (++t, s = i[t], s.length > 1) {
      const r = /^([01])(.+)$/.exec(s);
      r !== null && (i.splice(t, 0, r[1]), ++t, i[t] = r[2]);
    }
  }
}
function qu(i) {
  if (i === 0 || i === 1)
    return i;
  throw new Error("Flag must be 0 or 1");
}
function sw(i) {
  const e = [0, 0, 0];
  for (let t = 0; t < 24; t++)
    e[t % 3] <<= 1, e[t % 3] |= i & 1, i >>= 1;
  return (e[2] | 0) + (e[1] << 8) + (e[0] << 16);
}
function xn(i, e) {
  for (; !(i.interactive && !e(i)); )
    if (i._parent)
      i = i._parent;
    else
      break;
}
function rw(i, e, t) {
  return Ie(i, sa(e), (s) => {
    let r = s.touches;
    r ? (r.length == 0 && (r = s.changedTouches), t(ea(r))) : t([s]);
  });
}
function eh(i) {
  const e = document.createElement("canvas");
  e.width = 1, e.height = 1;
  const t = e.getContext("2d", { willReadFrequently: !0 });
  t.drawImage(i, 0, 0, 1, 1);
  try {
    return t.getImageData(0, 0, 1, 1), !1;
  } catch {
    return console.warn('Image "' + i.src + '" is loaded from different host and is not covered by CORS policy. For more information about the implications read here: https://www.amcharts.com/docs/v5/concepts/cors'), !0;
  }
}
function Pr(i) {
  i.width = 0, i.height = 0, i.style.width = "0px", i.style.height = "0px";
}
class nw {
  constructor() {
    Object.defineProperty(this, "_x", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_y", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    });
  }
  get x() {
    return this._x;
  }
  get y() {
    return this._y;
  }
  set x(e) {
    this._x = e;
  }
  set y(e) {
    this._y = e;
  }
}
class no extends ur {
  constructor(e) {
    super(), Object.defineProperty(this, "_layer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "mask", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "visible", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "exportable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "interactive", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "inactive", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "wheelable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "cancelTouch", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "isMeasured", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "buttonMode", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "alpha", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), Object.defineProperty(this, "compoundAlpha", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), Object.defineProperty(this, "angle", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "scale", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), Object.defineProperty(this, "x", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "y", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "crisp", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "pivot", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new nw()
    }), Object.defineProperty(this, "filter", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "cursorOverStyle", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_replacedCursorStyle", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_localMatrix", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new yo()
    }), Object.defineProperty(this, "_matrix", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new yo()
    }), Object.defineProperty(this, "_uMatrix", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new yo()
    }), Object.defineProperty(this, "_renderer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_parent", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_localBounds", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_bounds", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_colorId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._renderer = e;
  }
  _dispose() {
    this._renderer._removeObject(this), this.getLayer().dirty = !0;
  }
  getCanvas() {
    return this.getLayer().view;
  }
  getLayer() {
    let e = this;
    for (; ; ) {
      if (e._layer)
        return e._layer;
      if (e._parent)
        e = e._parent;
      else
        return this._renderer.defaultLayer;
    }
  }
  setLayer(e, t) {
    e == null ? this._layer = void 0 : (this._layer = this._renderer.getLayer(e, !0), this._layer.visible = !0, this._layer.margin = t, t && Rs(this._layer.view, !1), this._renderer._ghostLayer.setMargin(this._renderer.layers), this._parent && this._parent.registerChildLayer(this._layer), this._layer.dirty = !0, this._renderer.resizeLayer(this._layer), this._renderer.resizeGhost());
  }
  markDirtyLayer() {
    this.getLayer().dirty = !0;
  }
  clear() {
    this.invalidateBounds();
  }
  invalidateBounds() {
    this._localBounds = void 0;
  }
  _addBounds(e) {
  }
  _getColorId() {
    return this._colorId === void 0 && (this._colorId = this._renderer.paintId(this)), this._colorId;
  }
  _isInteractive() {
    return this.inactive == !1 && (this.interactive || this._renderer._forceInteractive > 0);
  }
  _isInteractiveMask() {
    return this._isInteractive();
  }
  contains(e) {
    for (; ; ) {
      if (e === this)
        return !0;
      if (e._parent)
        e = e._parent;
      else
        return !1;
    }
  }
  toGlobal(e) {
    return this._matrix.apply(e);
  }
  toLocal(e) {
    return this._matrix.applyInverse(e);
  }
  getLocalMatrix() {
    return this._uMatrix.setTransform(0, 0, this.pivot.x, this.pivot.y, this.angle * Math.PI / 180, this.scale), this._uMatrix;
  }
  getLocalBounds() {
    return this._localBounds || (this._localBounds = {
      left: 1e7,
      top: 1e7,
      right: -1e7,
      bottom: -1e7
    }, this._addBounds(this._localBounds)), this._localBounds;
  }
  getAdjustedBounds(e) {
    this._setMatrix();
    const t = this.getLocalMatrix(), s = t.apply({ x: e.left, y: e.top }), r = t.apply({ x: e.right, y: e.top }), n = t.apply({ x: e.right, y: e.bottom }), a = t.apply({ x: e.left, y: e.bottom });
    return {
      left: Math.min(s.x, r.x, n.x, a.x),
      top: Math.min(s.y, r.y, n.y, a.y),
      right: Math.max(s.x, r.x, n.x, a.x),
      bottom: Math.max(s.y, r.y, n.y, a.y)
    };
  }
  on(e, t, s) {
    return this.interactive ? this._renderer._addEvent(this, e, t, s) : new Ve(() => {
    });
  }
  _setMatrix() {
    this._localMatrix.setTransform(
      this.x,
      this.y,
      this.pivot.x,
      this.pivot.y,
      // Converts degrees to radians
      this.angle * Math.PI / 180,
      this.scale
    ), this._matrix.copyFrom(this._localMatrix), this._parent && this._matrix.prepend(this._parent._matrix);
  }
  _transform(e, t) {
    const s = this._matrix;
    let r = s.tx * t, n = s.ty * t;
    this.crisp && (r = Math.floor(r) + 0.5, n = Math.floor(n) + 0.5), e.setTransform(s.a * t, s.b * t, s.c * t, s.d * t, r, n);
  }
  _transformMargin(e, t, s) {
    const r = this._matrix;
    e.setTransform(r.a * t, r.b * t, r.c * t, r.d * t, (r.tx + s.left) * t, (r.ty + s.top) * t);
  }
  _transformLayer(e, t, s) {
    s.margin ? this._transformMargin(e, s.scale || t, s.margin) : this._transform(e, s.scale || t);
  }
  render(e) {
    if (this.visible && (this.exportable !== !1 || !this._renderer._omitTainted)) {
      this._setMatrix();
      const t = this._renderer.resolution, s = this._renderer.layers, r = this._renderer._ghostLayer, n = r.context, a = this.mask;
      a && a._setMatrix(), x(s, (o) => {
        if (o) {
          const l = o.context;
          l.save(), a && (a._transformLayer(l, t, o), a._runPath(l), l.clip()), l.globalAlpha = this.compoundAlpha * this.alpha, this._transformLayer(l, t, o), this.filter && (l.filter = this.filter);
        }
      }), n.save(), a && this._isInteractiveMask() && (a._transformMargin(n, t, r.margin), a._runPath(n), n.clip()), this._transformMargin(n, t, r.margin), this._render(e), n.restore(), x(s, (o) => {
        o && o.context.restore();
      });
    }
  }
  _render(e) {
    if (this.exportable === !1) {
      const t = this._layer || e;
      t.tainted = !0;
    }
  }
  hovering() {
    return this._renderer._hovering.has(this);
  }
  dragging() {
    return this._renderer._dragging.some((e) => e.value === this);
  }
  shouldCancelTouch() {
    const e = this._renderer;
    return e.tapToActivate && !e._touchActive ? !1 : this.cancelTouch ? !0 : this._parent ? this._parent.shouldCancelTouch() : !1;
  }
}
class aw extends no {
  constructor() {
    super(...arguments), Object.defineProperty(this, "interactiveChildren", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "_childLayers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_children", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    });
  }
  _isInteractiveMask() {
    return this.interactiveChildren || super._isInteractiveMask();
  }
  addChild(e) {
    e._parent = this, this._children.push(e), e._layer && this.registerChildLayer(e._layer);
  }
  addChildAt(e, t) {
    e._parent = this, this._children.splice(t, 0, e), e._layer && this.registerChildLayer(e._layer);
  }
  removeChild(e) {
    e._parent = void 0, ot(this._children, e);
  }
  _render(e) {
    super._render(e);
    const t = this._renderer;
    this.interactive && this.interactiveChildren && ++t._forceInteractive;
    const s = this._layer || e;
    x(this._children, (r) => {
      r.compoundAlpha = this.compoundAlpha * this.alpha, r.render(s);
    }), this.interactive && this.interactiveChildren && --t._forceInteractive;
  }
  registerChildLayer(e) {
    this._childLayers || (this._childLayers = []), Us(this._childLayers, e), this._parent && this._parent.registerChildLayer(e);
  }
  markDirtyLayer(e = !1) {
    super.markDirtyLayer(), e && this._childLayers && x(this._childLayers, (t) => t.dirty = !0);
  }
  _dispose() {
    super._dispose(), this._childLayers && x(this._childLayers, (e) => {
      e.dirty = !0;
    });
  }
}
function He(i, e) {
  i.left = Math.min(i.left, e.x), i.top = Math.min(i.top, e.y), i.right = Math.max(i.right, e.x), i.bottom = Math.max(i.bottom, e.y);
}
class Qe {
  colorize(e, t) {
  }
  path(e) {
  }
  addBounds(e) {
  }
}
class ow extends Qe {
  colorize(e, t) {
    e.beginPath();
  }
}
class xo extends Qe {
  constructor(e) {
    super(), Object.defineProperty(this, "color", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
    });
  }
  colorize(e, t) {
    t !== void 0 ? e.fillStyle = t : e.fillStyle = this.color;
  }
}
class lw extends Qe {
  constructor(e) {
    super(), Object.defineProperty(this, "clearShadow", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
    });
  }
  colorize(e, t) {
    e.fill(), this.clearShadow && (e.shadowColor = "", e.shadowBlur = 0, e.shadowOffsetX = 0, e.shadowOffsetY = 0);
  }
}
class uw extends Qe {
  colorize(e, t) {
    e.stroke();
  }
}
class wo extends Qe {
  constructor(e, t, s) {
    super(), Object.defineProperty(this, "width", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
    }), Object.defineProperty(this, "color", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
    }), Object.defineProperty(this, "lineJoin", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: s
    });
  }
  colorize(e, t) {
    t !== void 0 ? e.strokeStyle = t : e.strokeStyle = this.color, e.lineWidth = this.width, this.lineJoin && (e.lineJoin = this.lineJoin);
  }
}
class hw extends Qe {
  constructor(e) {
    super(), Object.defineProperty(this, "dash", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
    });
  }
  colorize(e, t) {
    e.setLineDash(this.dash);
  }
}
class cw extends Qe {
  constructor(e) {
    super(), Object.defineProperty(this, "dashOffset", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
    });
  }
  colorize(e, t) {
    e.lineDashOffset = this.dashOffset;
  }
}
class dw extends Qe {
  constructor(e, t, s, r) {
    super(), Object.defineProperty(this, "x", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
    }), Object.defineProperty(this, "y", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
    }), Object.defineProperty(this, "width", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: s
    }), Object.defineProperty(this, "height", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: r
    });
  }
  path(e) {
    e.rect(this.x, this.y, this.width, this.height);
  }
  addBounds(e) {
    const t = this.x, s = this.y, r = t + this.width, n = s + this.height;
    He(e, { x: t, y: s }), He(e, { x: r, y: s }), He(e, { x: t, y: n }), He(e, { x: r, y: n });
  }
}
class fw extends Qe {
  constructor(e, t, s) {
    super(), Object.defineProperty(this, "x", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
    }), Object.defineProperty(this, "y", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
    }), Object.defineProperty(this, "radius", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: s
    });
  }
  path(e) {
    e.moveTo(this.x + this.radius, this.y), e.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
  }
  // TODO handle skewing and rotation
  addBounds(e) {
    He(e, { x: this.x - this.radius, y: this.y - this.radius }), He(e, { x: this.x + this.radius, y: this.y + this.radius });
  }
}
class pw extends Qe {
  constructor(e, t, s, r) {
    super(), Object.defineProperty(this, "x", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
    }), Object.defineProperty(this, "y", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
    }), Object.defineProperty(this, "radiusX", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: s
    }), Object.defineProperty(this, "radiusY", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: r
    });
  }
  path(e) {
    e.ellipse(0, 0, this.radiusX, this.radiusY, 0, 0, Math.PI * 2);
  }
  // TODO handle skewing and rotation
  addBounds(e) {
    He(e, { x: this.x - this.radiusX, y: this.y - this.radiusY }), He(e, { x: this.x + this.radiusX, y: this.y + this.radiusY });
  }
}
class gw extends Qe {
  constructor(e, t, s, r, n, a) {
    super(), Object.defineProperty(this, "cx", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
    }), Object.defineProperty(this, "cy", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
    }), Object.defineProperty(this, "radius", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: s
    }), Object.defineProperty(this, "startAngle", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: r
    }), Object.defineProperty(this, "endAngle", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: n
    }), Object.defineProperty(this, "anticlockwise", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: a
    });
  }
  path(e) {
    this.radius > 0 && e.arc(this.cx, this.cy, this.radius, this.startAngle, this.endAngle, this.anticlockwise);
  }
  addBounds(e) {
    let t = aa(this.cx, this.cy, this.startAngle * fs, this.endAngle * fs, this.radius);
    He(e, { x: t.left, y: t.top }), He(e, { x: t.right, y: t.bottom });
  }
}
class mw extends Qe {
  constructor(e, t, s, r, n) {
    super(), Object.defineProperty(this, "x1", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
    }), Object.defineProperty(this, "y1", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
    }), Object.defineProperty(this, "x2", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: s
    }), Object.defineProperty(this, "y2", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: r
    }), Object.defineProperty(this, "radius", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: n
    });
  }
  path(e) {
    this.radius > 0 && e.arcTo(this.x1, this.y1, this.x2, this.y2, this.radius);
  }
  // TODO: add points
  addBounds(e) {
  }
}
class _w extends Qe {
  constructor(e, t) {
    super(), Object.defineProperty(this, "x", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
    }), Object.defineProperty(this, "y", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
    });
  }
  path(e) {
    e.lineTo(this.x, this.y);
  }
  addBounds(e) {
    He(e, { x: this.x, y: this.y });
  }
}
class bw extends Qe {
  constructor(e, t) {
    super(), Object.defineProperty(this, "x", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
    }), Object.defineProperty(this, "y", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
    });
  }
  path(e) {
    e.moveTo(this.x, this.y);
  }
  addBounds(e) {
    He(e, { x: this.x, y: this.y });
  }
}
class yw extends Qe {
  path(e) {
    e.closePath();
  }
}
class vw extends Qe {
  constructor(e, t, s, r, n, a) {
    super(), Object.defineProperty(this, "cpX", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
    }), Object.defineProperty(this, "cpY", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
    }), Object.defineProperty(this, "cpX2", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: s
    }), Object.defineProperty(this, "cpY2", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: r
    }), Object.defineProperty(this, "toX", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: n
    }), Object.defineProperty(this, "toY", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: a
    });
  }
  path(e) {
    e.bezierCurveTo(this.cpX, this.cpY, this.cpX2, this.cpY2, this.toX, this.toY);
  }
  // TODO: OK?
  addBounds(e) {
    He(e, { x: this.cpX, y: this.cpY }), He(e, { x: this.cpX2, y: this.cpY2 }), He(e, { x: this.toX, y: this.toY });
  }
}
class xw extends Qe {
  constructor(e, t, s, r) {
    super(), Object.defineProperty(this, "cpX", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
    }), Object.defineProperty(this, "cpY", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
    }), Object.defineProperty(this, "toX", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: s
    }), Object.defineProperty(this, "toY", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: r
    });
  }
  path(e) {
    e.quadraticCurveTo(this.cpX, this.cpY, this.toX, this.toY);
  }
  // TODO: OK?
  addBounds(e) {
    He(e, { x: this.cpX, y: this.cpY }), He(e, { x: this.toX, y: this.toY });
  }
}
class ww extends Qe {
  constructor(e, t, s, r, n) {
    super(), Object.defineProperty(this, "color", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
    }), Object.defineProperty(this, "blur", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
    }), Object.defineProperty(this, "offsetX", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: s
    }), Object.defineProperty(this, "offsetY", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: r
    }), Object.defineProperty(this, "opacity", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: n
    });
  }
  colorize(e, t) {
    this.opacity && (e.fillStyle = this.color), e.shadowColor = this.color, e.shadowBlur = this.blur, e.shadowOffsetX = this.offsetX, e.shadowOffsetY = this.offsetY;
  }
}
class Sw extends Qe {
  constructor(e, t, s, r, n) {
    super(), Object.defineProperty(this, "image", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
    }), Object.defineProperty(this, "width", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
    }), Object.defineProperty(this, "height", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: s
    }), Object.defineProperty(this, "x", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: r
    }), Object.defineProperty(this, "y", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: n
    });
  }
  path(e) {
    e.drawImage(this.image, this.x, this.y, this.width, this.height);
  }
  // TODO: OK?
  addBounds(e) {
    He(e, { x: this.x, y: this.y }), He(e, { x: this.width, y: this.height });
  }
}
class Dw extends no {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_operations", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "blendMode", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: oa.NORMAL
    }), Object.defineProperty(this, "_hasShadows", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_fillAlpha", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_strokeAlpha", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  clear() {
    super.clear(), this._operations.length = 0;
  }
  _pushOp(e) {
    this._operations.push(e);
  }
  beginFill(e, t = 1) {
    this._fillAlpha = t, e ? e instanceof X ? this._pushOp(new xo(e.toCSS(t))) : (this.isMeasured = !0, this._pushOp(new xo(e))) : this._pushOp(new xo("rgba(0, 0, 0, " + t + ")"));
  }
  endFill() {
    this._pushOp(new lw(this._hasShadows));
  }
  endStroke() {
    this._pushOp(new uw());
  }
  beginPath() {
    this._pushOp(new ow());
  }
  lineStyle(e = 0, t, s = 1, r) {
    this._strokeAlpha = s, t ? t instanceof X ? this._pushOp(new wo(e, t.toCSS(s), r)) : this._pushOp(new wo(e, t, r)) : this._pushOp(new wo(e, "rgba(0, 0, 0, " + s + ")", r));
  }
  setLineDash(e) {
    this._pushOp(new hw(e || []));
  }
  setLineDashOffset(e = 0) {
    this._pushOp(new cw(e));
  }
  drawRect(e, t, s, r) {
    this._pushOp(new dw(e, t, s, r));
  }
  drawCircle(e, t, s) {
    this._pushOp(new fw(e, t, s));
  }
  drawEllipse(e, t, s, r) {
    this._pushOp(new pw(e, t, s, r));
  }
  arc(e, t, s, r, n, a = !1) {
    this._pushOp(new gw(e, t, s, r, n, a));
  }
  arcTo(e, t, s, r, n) {
    this._pushOp(new mw(e, t, s, r, n));
  }
  lineTo(e, t) {
    this._pushOp(new _w(e, t));
  }
  moveTo(e, t) {
    this._pushOp(new bw(e, t));
  }
  bezierCurveTo(e, t, s, r, n, a) {
    this._pushOp(new vw(e, t, s, r, n, a));
  }
  quadraticCurveTo(e, t, s, r) {
    this._pushOp(new xw(e, t, s, r));
  }
  closePath() {
    this._pushOp(new yw());
  }
  shadow(e, t = 0, s = 0, r = 0, n) {
    this._hasShadows = !0, this._pushOp(new ww(n ? e.toCSS(n) : e.toCSS(this._fillAlpha || this._strokeAlpha), t, s, r));
  }
  image(e, t, s, r, n) {
    this._pushOp(new Sw(e, t, s, r, n));
  }
  // https://svgwg.org/svg2-draft/paths.html#DProperty
  // TODO better error checking
  svgPath(e) {
    let t = 0, s = 0, r = null, n = null, a = null, o = null;
    const l = /([MmZzLlHhVvCcSsQqTtAa])([^MmZzLlHhVvCcSsQqTtAa]*)/g, u = /[\u0009\u0020\u000A\u000C\u000D]*([\+\-]?[0-9]*\.?[0-9]+(?:[eE][\+\-]?[0-9]+)?)[\u0009\u0020\u000A\u000C\u000D]*,?/g;
    let h;
    for (; (h = l.exec(e)) !== null; ) {
      const c = h[1], d = h[2], f = [];
      for (; (h = u.exec(d)) !== null; )
        f.push(h[1]);
      switch (c !== "S" && c !== "s" && c !== "C" && c !== "c" && (r = null, n = null), c !== "Q" && c !== "q" && c !== "T" && c !== "t" && (a = null, o = null), c) {
        case "M":
          Pt(c, f.length, 2), t = +f[0], s = +f[1], this.moveTo(t, s);
          for (let p = 2; p < f.length; p += 2)
            t = +f[p], s = +f[p + 1], this.lineTo(t, s);
          break;
        case "m":
          Pt(c, f.length, 2), t += +f[0], s += +f[1], this.moveTo(t, s);
          for (let p = 2; p < f.length; p += 2)
            t += +f[p], s += +f[p + 1], this.lineTo(t, s);
          break;
        case "L":
          Pt(c, f.length, 2);
          for (let p = 0; p < f.length; p += 2)
            t = +f[p], s = +f[p + 1], this.lineTo(t, s);
          break;
        case "l":
          Pt(c, f.length, 2);
          for (let p = 0; p < f.length; p += 2)
            t += +f[p], s += +f[p + 1], this.lineTo(t, s);
          break;
        case "H":
          Dr(c, f.length, 1);
          for (let p = 0; p < f.length; ++p)
            t = +f[p], this.lineTo(t, s);
          break;
        case "h":
          Dr(c, f.length, 1);
          for (let p = 0; p < f.length; ++p)
            t += +f[p], this.lineTo(t, s);
          break;
        case "V":
          Dr(c, f.length, 1);
          for (let p = 0; p < f.length; ++p)
            s = +f[p], this.lineTo(t, s);
          break;
        case "v":
          Dr(c, f.length, 1);
          for (let p = 0; p < f.length; ++p)
            s += +f[p], this.lineTo(t, s);
          break;
        case "C":
          Pt(c, f.length, 6);
          for (let p = 0; p < f.length; p += 6) {
            const m = +f[p], _ = +f[p + 1];
            r = +f[p + 2], n = +f[p + 3], t = +f[p + 4], s = +f[p + 5], this.bezierCurveTo(m, _, r, n, t, s);
          }
          break;
        case "c":
          Pt(c, f.length, 6);
          for (let p = 0; p < f.length; p += 6) {
            const m = +f[p] + t, _ = +f[p + 1] + s;
            r = +f[p + 2] + t, n = +f[p + 3] + s, t += +f[p + 4], s += +f[p + 5], this.bezierCurveTo(m, _, r, n, t, s);
          }
          break;
        case "S":
          Pt(c, f.length, 4), (r === null || n === null) && (r = t, n = s);
          for (let p = 0; p < f.length; p += 4) {
            const m = 2 * t - r, _ = 2 * s - n;
            r = +f[p], n = +f[p + 1], t = +f[p + 2], s = +f[p + 3], this.bezierCurveTo(m, _, r, n, t, s);
          }
          break;
        case "s":
          Pt(c, f.length, 4), (r === null || n === null) && (r = t, n = s);
          for (let p = 0; p < f.length; p += 4) {
            const m = 2 * t - r, _ = 2 * s - n;
            r = +f[p] + t, n = +f[p + 1] + s, t += +f[p + 2], s += +f[p + 3], this.bezierCurveTo(m, _, r, n, t, s);
          }
          break;
        case "Q":
          Pt(c, f.length, 4);
          for (let p = 0; p < f.length; p += 4)
            a = +f[p], o = +f[p + 1], t = +f[p + 2], s = +f[p + 3], this.quadraticCurveTo(a, o, t, s);
          break;
        case "q":
          Pt(c, f.length, 4);
          for (let p = 0; p < f.length; p += 4)
            a = +f[p] + t, o = +f[p + 1] + s, t += +f[p + 2], s += +f[p + 3], this.quadraticCurveTo(a, o, t, s);
          break;
        case "T":
          Pt(c, f.length, 2), (a === null || o === null) && (a = t, o = s);
          for (let p = 0; p < f.length; p += 2)
            a = 2 * t - a, o = 2 * s - o, t = +f[p], s = +f[p + 1], this.quadraticCurveTo(a, o, t, s);
          break;
        case "t":
          Pt(c, f.length, 2), (a === null || o === null) && (a = t, o = s);
          for (let p = 0; p < f.length; p += 2)
            a = 2 * t - a, o = 2 * s - o, t += +f[p], s += +f[p + 1], this.quadraticCurveTo(a, o, t, s);
          break;
        case "A":
        case "a":
          const g = c === "a";
          iw(f), Pt(c, f.length, 7);
          for (let p = 0; p < f.length; p += 7) {
            let m = +f[p + 5], _ = +f[p + 6];
            g && (m += t, _ += s);
            const v = ew({
              px: t,
              py: s,
              rx: +f[p],
              ry: +f[p + 1],
              xAxisRotation: +f[p + 2],
              largeArcFlag: qu(+f[p + 3]),
              sweepFlag: qu(+f[p + 4]),
              cx: m,
              cy: _
            });
            x(v, (b) => {
              this.bezierCurveTo(b.x1, b.y1, b.x2, b.y2, b.x, b.y), t = b.x, s = b.y;
            });
          }
          break;
        case "Z":
        case "z":
          tw(c, f.length, 0), this.closePath();
          break;
      }
    }
  }
  _runPath(e) {
    e.beginPath(), x(this._operations, (t) => {
      t.path(e);
    });
  }
  _render(e) {
    super._render(e);
    const t = this._layer || e, s = t.dirty, r = this._isInteractive();
    if (s || r) {
      const n = t.context, a = this._renderer._ghostLayer.context;
      s && (n.globalCompositeOperation = this.blendMode, n.beginPath());
      let o;
      r && (a.beginPath(), o = this._getColorId()), x(this._operations, (l) => {
        s && (l.path(n), l.colorize(n, void 0)), r && (l.path(a), l.colorize(a, o));
      });
    }
  }
  renderDetached(e) {
    if (this.visible) {
      this._setMatrix(), e.save();
      const t = this.mask;
      t && (t._setMatrix(), t._transform(e, 1), t._runPath(e), e.clip()), e.globalAlpha = this.compoundAlpha * this.alpha, this._transform(e, 1), this.filter && (e.filter = this.filter), e.globalCompositeOperation = this.blendMode, e.beginPath(), x(this._operations, (s) => {
        s.path(e), s.colorize(e, void 0);
      }), e.restore();
    }
  }
  _addBounds(e) {
    this.visible && this.isMeasured && x(this._operations, (t) => {
      t.addBounds(e);
    });
  }
}
class Yd extends no {
  constructor(e, t, s) {
    super(e), Object.defineProperty(this, "text", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "style", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "resolution", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), Object.defineProperty(this, "_textInfo", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_textVisible", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "_originalScale", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), this.text = t, this.style = s;
  }
  invalidateBounds() {
    super.invalidateBounds(), this._textInfo = void 0;
  }
  _shared(e) {
    this.style.textAlign && (e.textAlign = this.style.textAlign), this.style.direction && (e.direction = this.style.direction), this.style.textBaseline && (e.textBaseline = this.style.textBaseline);
  }
  _prerender(e, t = !1, s = !1) {
    super._render(e);
    const r = e.context, n = this._renderer._ghostLayer.context, a = this.style;
    let o = this._getFontStyle(void 0, s);
    r.font = o, this._isInteractive() && !t && (n.font = o), a.fill && (a.fill instanceof X ? r.fillStyle = a.fill.toCSS(a.fillOpacity != null ? a.fillOpacity : 1) : r.fillStyle = a.fill), a.shadowColor && (e.context.shadowColor = a.shadowColor.toCSS(a.shadowOpacity || 1)), a.shadowBlur && (e.context.shadowBlur = a.shadowBlur), a.shadowOffsetX && (e.context.shadowOffsetX = a.shadowOffsetX), a.shadowOffsetY && (e.context.shadowOffsetY = a.shadowOffsetY), this._shared(r), this._isInteractive() && !t && (n.fillStyle = this._getColorId(), this._shared(n));
  }
  _getFontStyle(e, t = !1) {
    const s = this.style;
    let r = [];
    return e && e.fontVariant ? r.push(e.fontVariant) : s.fontVariant && r.push(s.fontVariant), t || (e && e.fontWeight ? r.push(e.fontWeight) : s.fontWeight && r.push(s.fontWeight)), e && e.fontStyle ? r.push(e.fontStyle) : s.fontStyle && r.push(s.fontStyle), e && e.fontSize ? (S(e.fontSize) && (e.fontSize = e.fontSize + "px"), r.push(e.fontSize)) : s.fontSize && (S(s.fontSize) && (s.fontSize = s.fontSize + "px"), r.push(s.fontSize)), e && e.fontFamily ? r.push(e.fontFamily) : s.fontFamily ? r.push(s.fontFamily) : r.length && r.push("Arial"), r.join(" ");
  }
  _render(e) {
    const t = this._layer || e;
    if (this._textInfo || this._measure(t), this._textVisible) {
      const s = this._isInteractive(), r = t.context, n = t.dirty, a = this._renderer._ghostLayer.context;
      r.save(), a.save(), this._prerender(t), x(this._textInfo, (o, l) => {
        x(o.textChunks, (u, h) => {
          if (u.style && (r.save(), a.save(), r.font = u.style, this._isInteractive() && (a.font = u.style)), u.fill && (r.save(), r.fillStyle = u.fill.toCSS()), n && r.fillText(u.text, u.offsetX, o.offsetY + u.offsetY), u.textDecoration == "underline" || u.textDecoration == "line-through") {
            let c = 1, d = 1, f = u.height, g = u.offsetX;
            switch (this.style.textAlign) {
              case "right":
              case "end":
                g -= u.width;
                break;
              case "center":
                g -= u.width / 2;
                break;
            }
            if (u.style)
              switch (Nt.getTextStyle(u.style).fontWeight) {
                case "bolder":
                case "bold":
                case "700":
                case "800":
                case "900":
                  c = 2;
                  break;
              }
            f && (d = f / 20);
            let p;
            u.textDecoration == "line-through" ? p = c + o.offsetY + u.offsetY - u.height / 2 : p = c + d * 1.5 + o.offsetY + u.offsetY, r.save(), r.beginPath(), u.fill ? r.strokeStyle = u.fill.toCSS() : this.style.fill && this.style.fill instanceof X && (r.strokeStyle = this.style.fill.toCSS()), r.lineWidth = c * d, r.moveTo(g, p), r.lineTo(g + u.width, p), r.stroke(), r.restore();
          }
          s && this.interactive && a.fillText(u.text, u.offsetX, o.offsetY + u.offsetY), u.fill && r.restore(), u.style && (r.restore(), a.restore());
        });
      }), r.restore(), a.restore();
    }
  }
  _addBounds(e) {
    if (this.visible && this.isMeasured) {
      const t = this._measure(this.getLayer());
      He(e, { x: t.left, y: t.top }), He(e, { x: t.right, y: t.bottom });
    }
  }
  _ignoreFontWeight() {
    return /apple/i.test(navigator.vendor);
  }
  _measure(e) {
    const t = e.context, s = this._renderer._ghostLayer.context, r = this.style.direction == "rtl";
    this._textInfo = [];
    const n = this.style.oversizedBehavior, a = this.style.maxWidth, o = S(a) && n == "truncate", l = S(a) && (n == "wrap" || n == "wrap-no-break");
    t.save(), s.save(), this._prerender(e, !0, this._ignoreFontWeight());
    const u = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ", h = this.text.toString().replace(/\r/g, "").split(/\n/);
    let c = !0, d = 0, f = 0, g = 0, p;
    x(h, (_, v) => {
      let b;
      for (_ == "" ? b = [{
        type: "value",
        text: ""
      }] : b = Nt.chunk(_, !1, this.style.ignoreFormatting); b.length > 0; ) {
        let y = {
          offsetY: g,
          ascent: 0,
          width: 0,
          height: 0,
          left: 0,
          right: 0,
          textChunks: []
        };
        const w = this._measureText(u, t), D = w.actualBoundingBoxAscent + w.actualBoundingBoxDescent;
        y.height = D, y.ascent = w.actualBoundingBoxAscent;
        let A, T = this.style.textDecoration, j, C, L = !1, E = !0, N = [], J;
        mu(b, (z, H) => {
          if (z.type == "format")
            if (z.text == "[/]")
              c || (t.restore(), s.restore(), c = !0), j = void 0, p = void 0, C = void 0, T = this.style.textDecoration, J = void 0, A = z.text;
            else {
              c || (t.restore(), s.restore());
              let Y = Nt.getTextStyle(z.text);
              const U = this._getFontStyle(Y);
              t.save(), s.save(), t.font = U, p = U, A = z.text, Y.textDecoration && (T = Y.textDecoration), Y.fill && (j = Y.fill), Y.width && (C = pt(Y.width)), Y.verticalAlign && (J = Y.verticalAlign), c = !1;
              const B = this._measureText(u, t), ue = B.actualBoundingBoxAscent + B.actualBoundingBoxDescent;
              ue > y.height && (y.height = ue), B.actualBoundingBoxAscent > y.ascent && (y.ascent = B.actualBoundingBoxAscent);
            }
          else if (z.type == "value" && !L) {
            const Y = this._measureText(z.text, t);
            let U = Y.actualBoundingBoxLeft + Y.actualBoundingBoxRight;
            if (o) {
              let k = E || this.style.breakWords || !1;
              const M = this.style.ellipsis || "", $ = this._measureText(M, t), q = $.actualBoundingBoxLeft + $.actualBoundingBoxRight;
              if (y.width + U > a) {
                const W = a - y.width - q;
                z.text = this._truncateText(t, z.text, W, k), z.text += M, L = !0;
              }
            } else if (l && y.width + U > a) {
              const k = a - y.width, M = this._truncateText(t, z.text, k, !1, E && this.style.oversizedBehavior != "wrap-no-break");
              if (M == "")
                return this._textVisible = !0, !1;
              N = b.slice(H + 1), jr(M) != jr(z.text) && (N.unshift({
                type: "value",
                text: z.text.substr(M.length)
              }), A && N.unshift({
                type: "format",
                text: A
              })), z.text = jr(M), b = [], L = !0;
            }
            let B = 1, ue = 1;
            if (p && C && C > U) {
              const k = U / C;
              switch (this.style.textAlign) {
                case "right":
                case "end":
                  B = k;
                  break;
                case "center":
                  B = k, ue = k;
                  break;
                default:
                  ue = k;
              }
              U = C;
            }
            const O = Y.actualBoundingBoxAscent + Y.actualBoundingBoxDescent;
            O > y.height && (y.height = O), Y.actualBoundingBoxAscent > y.ascent && (y.ascent = Y.actualBoundingBoxAscent), y.width += U, y.left += Y.actualBoundingBoxLeft / B, y.right += Y.actualBoundingBoxRight / ue, y.textChunks.push({
              style: p,
              fill: j,
              text: z.text,
              width: U,
              height: O,
              left: Y.actualBoundingBoxLeft,
              right: Y.actualBoundingBoxRight,
              ascent: Y.actualBoundingBoxAscent,
              offsetX: 0,
              offsetY: 0,
              textDecoration: T,
              verticalAlign: J
            }), E = !1;
          }
          return !0;
        }), this.style.lineHeight instanceof ne ? (y.height *= this.style.lineHeight.value, y.ascent *= this.style.lineHeight.value) : (y.height *= this.style.lineHeight || 1.2, y.ascent *= this.style.lineHeight || 1.2), d < y.left && (d = y.left), f < y.right && (f = y.right), this._textInfo.push(y), g += y.height, b = N || [];
      }
    }), c || (t.restore(), s.restore()), x(this._textInfo, (_, v) => {
      let b = 0;
      x(_.textChunks, (y) => {
        if (y.offsetX = b + y.left - _.left, y.offsetY += _.height - _.height * (this.style.baselineRatio || 0.19), b += y.width, y.verticalAlign)
          switch (y.verticalAlign) {
            case "super":
              y.offsetY -= _.height / 2 - y.height / 2;
              break;
            case "sub":
              y.offsetY += y.height / 2;
              break;
          }
      });
    });
    const m = {
      left: r ? -f : -d,
      top: 0,
      right: r ? d : f,
      bottom: g
    };
    if (n !== "none") {
      const _ = this._fitRatio(m);
      if (_ < 1)
        if (n == "fit")
          S(this.style.minScale) && _ < this.style.minScale ? this._textVisible = !1 : ((!this._originalScale || this._originalScale == 1) && (this._originalScale = this.scale), this.scale = _, this._textVisible = !0);
        else if (n == "hide")
          this._textVisible = !1;
        else {
          switch (this.style.textAlign) {
            case "right":
            case "end":
              m.left = -a, m.right = 0;
              break;
            case "center":
              m.left = -a / 2, m.right = a / 2;
              break;
            default:
              m.left = 0, m.right = a;
          }
          this.scale = this._originalScale || 1, this._originalScale = void 0, this._textVisible = !0;
        }
      else
        this.scale = this._originalScale || 1, this._originalScale = void 0, this._textVisible = !0;
    }
    return t.restore(), s.restore(), m;
  }
  _fitRatio(e) {
    const t = this.style.maxWidth, s = this.style.maxHeight;
    if (!S(t) && !S(s))
      return 1;
    const r = e.right - e.left, n = e.bottom - e.top;
    return Math.min(t / r || 1, s / n || 1);
  }
  _truncateText(e, t, s, r = !1, n = !0) {
    let a;
    do {
      if (r)
        t = t.slice(0, -1);
      else {
        let l = t.replace(/[^,;:!?\\\/\s]+[,;:!?\\\/\s]*$/g, "");
        if (l == "" && n)
          r = !0;
        else {
          if (l == "")
            return t;
          t = l;
        }
      }
      const o = this._measureText(t, e);
      a = o.actualBoundingBoxLeft + o.actualBoundingBoxRight;
    } while (a > s && t != "");
    return t;
  }
  _measureText(e, t) {
    let s = t.measureText(e), r = {};
    if (s.actualBoundingBoxAscent == null) {
      const a = document.createElement("div");
      a.innerText = e, a.style.visibility = "hidden", a.style.position = "absolute", a.style.top = "-1000000px;", a.style.fontFamily = this.style.fontFamily || "", a.style.fontSize = this.style.fontSize + "", document.body.appendChild(a);
      const o = a.getBoundingClientRect();
      document.body.removeChild(a);
      const l = o.height, u = s.width;
      r = {
        actualBoundingBoxAscent: l,
        actualBoundingBoxDescent: 0,
        actualBoundingBoxLeft: 0,
        actualBoundingBoxRight: u,
        fontBoundingBoxAscent: l,
        fontBoundingBoxDescent: 0,
        width: u
      };
    } else
      r = {
        actualBoundingBoxAscent: s.actualBoundingBoxAscent,
        actualBoundingBoxDescent: s.actualBoundingBoxDescent,
        actualBoundingBoxLeft: s.actualBoundingBoxLeft,
        actualBoundingBoxRight: s.actualBoundingBoxRight,
        fontBoundingBoxAscent: s.actualBoundingBoxAscent,
        fontBoundingBoxDescent: s.actualBoundingBoxDescent,
        width: s.width
      };
    const n = s.width;
    switch (this.style.textAlign) {
      case "right":
      case "end":
        r.actualBoundingBoxLeft = n, r.actualBoundingBoxRight = 0;
        break;
      case "center":
        r.actualBoundingBoxLeft = n / 2, r.actualBoundingBoxRight = n / 2;
        break;
      default:
        r.actualBoundingBoxLeft = 0, r.actualBoundingBoxRight = n;
    }
    return r;
  }
}
class Pw {
  constructor() {
    Object.defineProperty(this, "fill", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "fillOpacity", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "textAlign", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "fontFamily", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "fontSize", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "fontWeight", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "fontStyle", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "fontVariant", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "textDecoration", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shadowColor", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shadowBlur", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shadowOffsetX", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shadowOffsetY", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shadowOpacity", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "lineHeight", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Ce(120)
    }), Object.defineProperty(this, "baselineRatio", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0.19
    }), Object.defineProperty(this, "direction", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "textBaseline", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "oversizedBehavior", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "none"
    }), Object.defineProperty(this, "breakWords", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "ellipsis", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "…"
    }), Object.defineProperty(this, "maxWidth", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "maxHeight", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "minScale", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "ignoreFormatting", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    });
  }
}
class Tw extends Yd {
  constructor() {
    super(...arguments), Object.defineProperty(this, "textType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "circular"
    }), Object.defineProperty(this, "radius", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "startAngle", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "inside", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "orientation", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "auto"
    }), Object.defineProperty(this, "kerning", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_textReversed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    });
  }
  _render(e) {
    switch (this.textType) {
      case "circular":
        this._renderCircular(e);
        break;
      default:
        super._render(e);
        break;
    }
  }
  _renderCircular(e) {
    if (this._textVisible) {
      const t = this._layer || e;
      this._prerender(t);
      const s = this._isInteractive(), r = t.context, n = t.dirty, a = this._renderer._ghostLayer.context;
      r.save(), s && a.save(), this._textInfo || this._measure(t);
      let o = this.radius || 0, l = this.startAngle || 0, u = 0, h = this.orientation, c = h == "auto" ? "auto" : h == "inward";
      const d = this.inside, f = this.style.textAlign || "left", g = this.kerning || 0;
      let p = f == "left" ? 1 : -1;
      const m = !this._textReversed;
      if (c == "auto") {
        let _ = 0, v = 0;
        x(this._textInfo, (b, y) => {
          const w = l + b.width / (o - b.height) / 2 * -p;
          w > _ && (_ = w);
        }), f == "left" ? v = (_ + u / 2) * fs : f == "right" ? v = (_ - u / 2) * fs : v = l * fs, v = _s(v), c = v >= 270 || v <= 90;
      }
      c == !0 && m && (this._textInfo.reverse(), this._textReversed = !0), x(this._textInfo, (_, v) => {
        const b = _.height;
        d || (o += b), (p == -1 && c || p == 1 && !c) && m && _.textChunks.reverse();
        let y = l;
        u = 0, f == "center" && (y += _.width / (o - b) / 2 * -p, u = y - l), y += Math.PI * (c ? 0 : 1), r.save(), s && a.save(), r.rotate(y), s && a.rotate(y);
        let w = 0;
        x(_.textChunks, (D, A) => {
          const T = D.text, j = D.width;
          w = j / 2 / (o - b) * p, r.rotate(w), s && a.rotate(w), D.style && (r.save(), a.save(), r.font = D.style, s && (a.font = D.style)), D.fill && (r.save(), r.fillStyle = D.fill.toCSS()), r.textBaseline = "middle", r.textAlign = "center", s && (a.textBaseline = "middle", a.textAlign = "center"), n && r.fillText(T, 0, (c ? 1 : -1) * (0 - o + b / 2)), s && a.fillText(T, 0, (c ? 1 : -1) * (0 - o + b / 2)), D.fill && r.restore(), D.style && (r.restore(), a.restore()), w = (j / 2 + g) / (o - b) * p, r.rotate(w), s && a.rotate(w);
        }), r.restore(), s && a.restore(), d && (o -= b);
      }), r.restore(), s && a.restore();
    }
  }
  _measure(e) {
    switch (this.textType) {
      case "circular":
        return this._measureCircular(e);
      default:
        return super._measure(e);
    }
  }
  _measureCircular(e) {
    const t = e.context, s = this._renderer._ghostLayer.context, r = this.style.direction == "rtl", n = this.style.oversizedBehavior, a = this.style.maxWidth, o = S(a) && n == "truncate", l = this.style.ellipsis || "";
    let u;
    this._textVisible = !0, this._textInfo = [], this._textReversed = !1, t.save(), s.save(), this._prerender(e, !0);
    const h = this.text.toString().replace(/\r/g, "").split(/\n/);
    let c = !0, d = 0, f = 0;
    return x(h, (g, p) => {
      let m = Nt.chunk(g, !1, this.style.ignoreFormatting), _ = {
        offsetY: f,
        ascent: 0,
        width: 0,
        height: 0,
        left: 0,
        right: 0,
        textChunks: []
      }, v, b, y;
      x(m, (w, D) => {
        if (w.type == "format") {
          if (w.text == "[/]")
            c || (t.restore(), s.restore(), c = !0), b = void 0, v = void 0, y = void 0;
          else {
            let A = Nt.getTextStyle(w.text);
            const T = this._getFontStyle(A);
            t.save(), s.save(), t.font = T, v = T, A.fill && (b = A.fill), A.width && (y = pt(A.width)), c = !1;
          }
          o && (u = this._measureText(l, t));
        } else if (w.type == "value") {
          const A = w.text.match(/./ug) || [];
          r && A.reverse();
          for (let T = 0; T < A.length; T++) {
            const j = A[T], C = this._measureText(j, t);
            let L = C.width;
            v && y && y > L && (L = y);
            const E = C.actualBoundingBoxAscent + C.actualBoundingBoxDescent;
            if (E > _.height && (_.height = E), C.actualBoundingBoxAscent > _.ascent && (_.ascent = C.actualBoundingBoxAscent), _.width += L, _.left += C.actualBoundingBoxLeft, _.right += C.actualBoundingBoxRight, _.textChunks.push({
              style: v,
              fill: b,
              text: j,
              width: L,
              height: E + C.actualBoundingBoxDescent,
              left: C.actualBoundingBoxLeft,
              right: C.actualBoundingBoxRight,
              ascent: C.actualBoundingBoxAscent,
              offsetX: 0,
              offsetY: E,
              textDecoration: void 0
            }), d += L, o) {
              u || (u = this._measureText(l, t));
              const N = u.actualBoundingBoxLeft + u.actualBoundingBoxRight;
              if (d += N, d + N > a) {
                _.textChunks.length == 1 ? this._textVisible = !1 : (_.width += N, _.left += u.actualBoundingBoxLeft, _.right += u.actualBoundingBoxRight, _.textChunks.push({
                  style: v,
                  fill: b,
                  text: l,
                  width: N,
                  height: E + u.actualBoundingBoxDescent,
                  left: u.actualBoundingBoxLeft,
                  right: u.actualBoundingBoxRight,
                  ascent: u.actualBoundingBoxAscent,
                  offsetX: 0,
                  offsetY: E,
                  textDecoration: void 0
                }));
                break;
              }
            }
            if (r)
              break;
          }
        }
      }), this.style.lineHeight instanceof ne ? _.height *= this.style.lineHeight.value : _.height *= this.style.lineHeight || 1.2, this._textInfo.push(_), f += _.height;
    }), c || (t.restore(), s.restore()), n == "hide" && d > a && (this._textVisible = !1), x(this._textInfo, (g) => {
      x(g.textChunks, (p) => {
        p.offsetY += Math.round((g.height - p.height + (g.ascent - p.ascent)) / 2);
      });
    }), t.restore(), s.restore(), {
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
  }
}
class kw extends no {
  constructor(e, t) {
    super(e), Object.defineProperty(this, "width", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "height", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "image", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tainted", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shadowColor", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shadowBlur", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shadowOffsetX", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shadowOffsetY", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shadowOpacity", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_imageMask", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.image = t;
  }
  _dispose() {
    super._dispose(), this._imageMask && Pr(this._imageMask);
  }
  getLocalBounds() {
    if (!this._localBounds) {
      let e = 0, t = 0;
      this.width && (e = this.width), this.height && (t = this.height), this._localBounds = {
        left: 0,
        top: 0,
        right: e,
        bottom: t
      }, this._addBounds(this._localBounds);
    }
    return this._localBounds;
  }
  _render(e) {
    if (super._render(e), this.image) {
      const t = this._layer || e;
      if (this.tainted === void 0 && (this.tainted = eh(this.image), t.tainted = !0), this.tainted && this._renderer._omitTainted)
        return;
      if (t.dirty) {
        this.shadowColor && (t.context.shadowColor = this.shadowColor.toCSS(this.shadowOpacity || 1)), this.shadowBlur && (t.context.shadowBlur = this.shadowBlur), this.shadowOffsetX && (t.context.shadowOffsetX = this.shadowOffsetX), this.shadowOffsetY && (t.context.shadowOffsetY = this.shadowOffsetY);
        const s = this.width || this.image.naturalWidth, r = this.height || this.image.naturalHeight;
        t.context.drawImage(this.image, 0, 0, s, r);
      }
      if (this.interactive && this._isInteractive()) {
        const s = this._getMask(this.image);
        this._renderer._ghostLayer.context.drawImage(s, 0, 0);
      }
    }
  }
  clear() {
    super.clear(), this.image = void 0, this._imageMask = void 0;
  }
  _getMask(e) {
    if (this._imageMask === void 0) {
      const t = this.width || e.naturalWidth, s = this.height || e.naturalHeight, r = document.createElement("canvas");
      r.width = t, r.height = s;
      const n = r.getContext("2d");
      n.imageSmoothingEnabled = !1, n.fillStyle = this._getColorId(), n.fillRect(0, 0, t, s), eh(e) || (n.globalCompositeOperation = "destination-in", n.drawImage(e, 0, 0, t, s)), this._imageMask = r;
    }
    return this._imageMask;
  }
}
class Cw {
  constructor(e, t, s, r) {
    Object.defineProperty(this, "event", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
    }), Object.defineProperty(this, "originalPoint", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
    }), Object.defineProperty(this, "point", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: s
    }), Object.defineProperty(this, "bbox", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: r
    }), Object.defineProperty(this, "id", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "simulated", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "native", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Ut("touchevents") && e instanceof Touch ? this.id = e.identifier : this.id = null;
  }
}
class Mw extends Zc {
  /*protected _mouseMoveThrottler: Throttler = new Throttler(() => {
      this._dispatchGlobalMousemove(this._lastPointerMoveEvent.event, this._lastPointerMoveEvent.native);
  });
  */
  constructor(e) {
    if (super(), Object.defineProperty(this, "view", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: document.createElement("div")
    }), Object.defineProperty(this, "_layerDom", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: document.createElement("div")
    }), Object.defineProperty(this, "layers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_dirtyLayers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "defaultLayer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.getLayer(0)
    }), Object.defineProperty(this, "_ghostLayer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new Ow()
    }), Object.defineProperty(this, "_patternCanvas", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: document.createElement("canvas")
    }), Object.defineProperty(this, "_patternContext", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._patternCanvas.getContext("2d")
    }), Object.defineProperty(this, "_domWidth", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_domHeight", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_canvasWidth", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_canvasHeight", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "resolution", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "interactionsEnabled", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "_listeners", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_events", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_colorId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_colorMap", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_forceInteractive", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_omitTainted", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_hovering", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Set()
    }), Object.defineProperty(this, "_dragging", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_mousedown", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_lastPointerMoveEvent", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tapToActivate", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "tapToActivateTimeout", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 3e3
    }), Object.defineProperty(this, "_touchActive", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_touchActiveTimeout", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), e == null ? this.resolution = window.devicePixelRatio : this.resolution = e, this.view.style.position = "absolute", this.view.appendChild(this._layerDom), this._disposers.push(new Ve(() => {
      _e(this._events, (t, s) => {
        s.disposer.dispose();
      }), x(this.layers, (t) => {
        Pr(t.view), t.exportableView && Pr(t.exportableView);
      }), Pr(this._ghostLayer.view), Pr(this._patternCanvas);
    })), this._disposers.push(vu(() => {
      e == null && (this.resolution = window.devicePixelRatio);
    })), Ut("touchevents")) {
      const t = (s) => {
        this._dragging.length !== 0 && mu(this._dragging, (r) => r.value.shouldCancelTouch() ? (s.preventDefault(), !1) : !0), this._touchActiveTimeout && this._delayTouchDeactivate();
      };
      this._disposers.push(Ie(window, "touchstart", t, { passive: !1 })), this._disposers.push(Ie(this.view, "touchstart", t, { passive: !1 })), this._disposers.push(Ie(this.view, "touchmove", () => {
        this._touchActiveTimeout && this._delayTouchDeactivate();
      }, { passive: !0 })), this._disposers.push(Ie(window, "click", (s) => {
        this._touchActive = !1;
      }, { passive: !0 })), this._disposers.push(Ie(this.view, "click", (s) => {
        window.setTimeout(() => {
          this._touchActive = !0, this._delayTouchDeactivate();
        }, 100);
      }, { passive: !0 }));
    }
    Ut("wheelevents") && this._disposers.push(Ie(this.view, "wheel", (t) => {
      let s = !1;
      this._hovering.forEach((r) => {
        if (r.wheelable)
          return s = !0, !1;
      }), s && t.preventDefault();
    }, { passive: !1 }));
  }
  _delayTouchDeactivate() {
    this._touchActiveTimeout && clearTimeout(this._touchActiveTimeout), this.tapToActivateTimeout > 0 && (this._touchActiveTimeout = window.setTimeout(() => {
      this._touchActive = !1;
    }, this.tapToActivateTimeout));
  }
  get debugGhostView() {
    return !!this._ghostLayer.view.parentNode;
  }
  set debugGhostView(e) {
    e ? this._ghostLayer.view.parentNode || this.view.appendChild(this._ghostLayer.view) : this._ghostLayer.view.parentNode && this._ghostLayer.view.parentNode.removeChild(this._ghostLayer.view);
  }
  createLinearGradient(e, t, s, r) {
    return this.defaultLayer.context.createLinearGradient(e, t, s, r);
  }
  createRadialGradient(e, t, s, r, n, a) {
    return this.defaultLayer.context.createRadialGradient(e, t, s, r, n, a);
  }
  createPattern(e, t, s, r, n) {
    return this._patternCanvas.width = r, this._patternCanvas.height = n, this._patternContext.clearRect(0, 0, r, n), t.renderDetached(this._patternContext), e.renderDetached(this._patternContext), this._patternContext.createPattern(this._patternCanvas, s);
  }
  makeContainer() {
    return new aw(this);
  }
  makeGraphics() {
    return new Dw(this);
  }
  makeText(e, t) {
    return new Yd(this, e, t);
  }
  makeTextStyle() {
    return new Pw();
  }
  makeRadialText(e, t) {
    return new Tw(this, e, t);
  }
  makePicture(e) {
    return new kw(this, e);
  }
  resizeLayer(e) {
    e.resize(this._canvasWidth, this._canvasHeight, this._domWidth, this._domHeight, this.resolution);
  }
  resizeGhost() {
    this._ghostLayer.resize(this._canvasWidth, this._canvasHeight, this._domWidth, this._domHeight, this.resolution);
  }
  resize(e, t, s, r) {
    this._canvasWidth = e, this._canvasHeight = t, this._domWidth = s, this._domHeight = r, x(this.layers, (n) => {
      n && (n.dirty = !0, this.resizeLayer(n));
    }), this.resizeGhost(), this.view.style.width = s + "px", this.view.style.height = r + "px";
  }
  createDetachedLayer(e = !1) {
    const t = document.createElement("canvas"), s = t.getContext("2d", { willReadFrequently: e }), r = new Aw(t, s);
    return t.style.position = "absolute", t.style.top = "0px", t.style.left = "0px", r;
  }
  getLayerByOrder(e) {
    const t = this.layers, s = t.length;
    for (let r = 0; r < s; r++) {
      const n = t[r];
      if (n.order == e)
        return n;
    }
  }
  getLayer(e, t = !0) {
    let s = this.getLayerByOrder(e);
    if (s)
      return s;
    const r = this.createDetachedLayer(e == 99);
    r.order = e, r.visible = t, r.visible && this.resizeLayer(r);
    const n = this.layers;
    n.push(r), n.sort((u, h) => u.order > h.order ? 1 : u.order < h.order ? -1 : 0);
    const a = n.length, o = Yi(n, r);
    let l;
    for (let u = o + 1; u < a; u++)
      if (n[u].visible) {
        l = n[u];
        break;
      }
    return r.visible && (l === void 0 ? this._layerDom.appendChild(r.view) : this._layerDom.insertBefore(r.view, l.view)), r;
  }
  render(e) {
    if (this._dirtyLayers.length = 0, x(this.layers, (t) => {
      t && t.dirty && t.visible && (this._dirtyLayers.push(t), t.clear());
    }), this._ghostLayer.clear(), e.render(this.defaultLayer), this._ghostLayer.context.restore(), x(this.layers, (t) => {
      if (t) {
        const s = t.context;
        s.beginPath(), s.moveTo(0, 0), s.stroke();
      }
    }), x(this._dirtyLayers, (t) => {
      t.context.restore(), t.dirty = !1;
    }), this._hovering.size && this._lastPointerMoveEvent) {
      const t = this._lastPointerMoveEvent.native;
      x(this._lastPointerMoveEvent.events, (s) => {
        this._dispatchGlobalMousemove(s, t);
      });
    }
  }
  paintId(e) {
    const t = sw(++this._colorId), s = X.fromHex(t).toCSS();
    return this._colorMap[s] = e, s;
  }
  _removeObject(e) {
    e._colorId !== void 0 && delete this._colorMap[e._colorId];
  }
  // protected _identifyObjectByColor(colorId: number): CanvasDisplayObject | undefined {
  // 	return this._colorMap[colorId];
  // }
  _adjustBoundingBox(e) {
    const t = this._ghostLayer.margin;
    return new DOMRect(e.left - t.left, e.top - t.top, e.width + t.left + t.right, e.height + t.top + t.bottom);
  }
  getEvent(e, t = !0) {
    const s = this.view.getBoundingClientRect(), r = {
      x: e.clientX || 0,
      y: e.clientY || 0
    }, n = {
      x: r.x - (t ? s.left : 0),
      y: r.y - (t ? s.top : 0)
    };
    return new Cw(e, r, n, this._adjustBoundingBox(s));
  }
  _getHitTarget(e, t, s) {
    if (t.width === 0 || t.height === 0 || e.x < t.left || e.x > t.right || e.y < t.top || e.y > t.bottom || !this._layerDom.contains(s.target))
      return;
    const r = this._ghostLayer.getImageData(e, t);
    if (r.data[0] === 0 && r.data[1] === 0 && r.data[2] === 0)
      return !1;
    const n = X.fromRGB(r.data[0], r.data[1], r.data[2]).toCSS();
    return this._colorMap[n];
  }
  _withEvents(e, t) {
    const s = this._events[e];
    if (s !== void 0) {
      s.dispatching = !0;
      try {
        t(s);
      } finally {
        s.dispatching = !1, s.cleanup && (s.cleanup = !1, ln(s.callbacks, (r) => !r.disposed), s.callbacks.length === 0 && (s.disposer.dispose(), delete this._events[e]));
      }
    }
  }
  _dispatchEventAll(e, t) {
    this.interactionsEnabled && this._withEvents(e, (s) => {
      x(s.callbacks, (r) => {
        r.disposed || r.callback.call(r.context, t);
      });
    });
  }
  _dispatchEvent(e, t, s) {
    if (!this.interactionsEnabled)
      return !1;
    let r = !1;
    return this._withEvents(e, (n) => {
      x(n.callbacks, (a) => {
        !a.disposed && a.object === t && (a.callback.call(a.context, s), r = !0);
      });
    }), r;
  }
  _dispatchMousedown(e) {
    const t = e.button;
    if (t != 0 && t != 2 && t != 1 && t !== void 0)
      return;
    const s = this.getEvent(e), r = this._getHitTarget(s.originalPoint, s.bbox, e);
    if (r) {
      const n = s.id;
      let a = !1;
      xn(r, (o) => {
        const l = { id: n, value: o };
        return this._mousedown.push(l), !a && this._dispatchEvent("pointerdown", o, s) && (a = !0, this._dragging.some((h) => h.value === o && h.id === n) || this._dragging.push(l)), !0;
      });
    }
  }
  _dispatchGlobalMousemove(e, t) {
    const s = this.getEvent(e), r = this._getHitTarget(s.originalPoint, s.bbox, e);
    s.native = t, r ? (this._hovering.forEach((n) => {
      n.contains(r) || (this._hovering.delete(n), n.cursorOverStyle && In(document.body, "cursor", n._replacedCursorStyle), this._dispatchEvent("pointerout", n, s));
    }), s.native && xn(r, (n) => (this._hovering.has(n) || (this._hovering.add(n), n.cursorOverStyle && (n._replacedCursorStyle = id(document.body, "cursor"), In(document.body, "cursor", n.cursorOverStyle)), this._dispatchEvent("pointerover", n, s)), !0))) : (this._hovering.forEach((n) => {
      n.cursorOverStyle && In(document.body, "cursor", n._replacedCursorStyle), this._dispatchEvent("pointerout", n, s);
    }), this._hovering.clear()), this._dispatchEventAll("globalpointermove", s);
  }
  _dispatchGlobalMouseup(e, t) {
    const s = this.getEvent(e);
    s.native = t, this._dispatchEventAll("globalpointerup", s);
  }
  _dispatchDragMove(e) {
    if (this._dragging.length !== 0) {
      const t = this.getEvent(e), s = t.id;
      this._dragging.forEach((r) => {
        r.id === s && this._dispatchEvent("pointermove", r.value, t);
      });
    }
  }
  _dispatchDragEnd(e) {
    const t = e.button;
    let s;
    if (t == 0 || t === void 0)
      s = "click";
    else if (t == 2)
      s = "rightclick";
    else if (t == 1)
      s = "middleclick";
    else
      return;
    const r = this.getEvent(e), n = r.id;
    if (this._mousedown.length !== 0) {
      const a = this._getHitTarget(r.originalPoint, r.bbox, e);
      a && this._mousedown.forEach((o) => {
        o.id === n && o.value.contains(a) && this._dispatchEvent(s, o.value, r);
      }), this._mousedown.length = 0;
    }
    this._dragging.length !== 0 && (this._dragging.forEach((a) => {
      a.id === n && this._dispatchEvent("pointerup", a.value, r);
    }), this._dragging.length = 0);
  }
  _dispatchDoubleClick(e) {
    const t = this.getEvent(e), s = this._getHitTarget(t.originalPoint, t.bbox, e);
    s && xn(s, (r) => !this._dispatchEvent("dblclick", r, t));
  }
  _dispatchWheel(e) {
    const t = this.getEvent(e), s = this._getHitTarget(t.originalPoint, t.bbox, e);
    s && xn(s, (r) => !this._dispatchEvent("wheel", r, t));
  }
  _makeSharedEvent(e, t) {
    if (this._listeners[e] === void 0) {
      const s = t();
      this._listeners[e] = new qa(() => {
        delete this._listeners[e], s.dispose();
      });
    }
    return this._listeners[e].increment();
  }
  _onPointerEvent(e, t) {
    let s = !1, r = null;
    function n() {
      r = null, s = !1;
    }
    return new nt([
      new Ve(() => {
        r !== null && clearTimeout(r), n();
      }),
      Ie(this.view, sa(e), (a) => {
        s = !0, r !== null && clearTimeout(r), r = window.setTimeout(n, 0);
      }),
      rw(window, e, (a) => {
        r !== null && (clearTimeout(r), r = null), t(a, s), s = !1;
      })
    ]);
  }
  // This ensures that only a single DOM event is added (e.g. only a single mousemove event listener)
  _initEvent(e) {
    switch (e) {
      case "globalpointermove":
      case "pointerover":
      case "pointerout":
        return this._makeSharedEvent("pointermove", () => {
          const t = (s, r) => {
            this._lastPointerMoveEvent = { events: s, native: r }, x(s, (n) => {
              this._dispatchGlobalMousemove(n, r);
            });
          };
          return new nt([
            this._onPointerEvent("pointerdown", t),
            this._onPointerEvent("pointermove", t)
          ]);
        });
      case "globalpointerup":
        return this._makeSharedEvent("pointerup", () => {
          var t = this._onPointerEvent("pointerup", (r, n) => {
            x(r, (a) => {
              this._dispatchGlobalMouseup(a, n);
            }), this._lastPointerMoveEvent = { events: r, native: n };
          }), s = this._onPointerEvent("pointercancel", (r, n) => {
            x(r, (a) => {
              this._dispatchGlobalMouseup(a, n);
            }), this._lastPointerMoveEvent = { events: r, native: n };
          });
          return new Ve(() => {
            t.dispose(), s.dispose();
          });
        });
      case "click":
      case "rightclick":
      case "middleclick":
      case "pointerdown":
      case "pointermove":
      case "pointerup":
        return this._makeSharedEvent("pointerdown", () => {
          const t = this._onPointerEvent("pointerdown", (a) => {
            x(a, (o) => {
              this._dispatchMousedown(o);
            });
          }), s = this._onPointerEvent("pointermove", (a) => {
            x(a, (o) => {
              this._dispatchDragMove(o);
            });
          }), r = this._onPointerEvent("pointerup", (a) => {
            x(a, (o) => {
              this._dispatchDragEnd(o);
            });
          }), n = this._onPointerEvent("pointercancel", (a) => {
            x(a, (o) => {
              this._dispatchDragEnd(o);
            });
          });
          return new Ve(() => {
            t.dispose(), s.dispose(), r.dispose(), n.dispose();
          });
        });
      case "dblclick":
        return this._makeSharedEvent("dblclick", () => this._onPointerEvent("dblclick", (t) => {
          x(t, (s) => {
            this._dispatchDoubleClick(s);
          });
        }));
      case "wheel":
        return this._makeSharedEvent("wheel", () => Ie(window, sa("wheel"), (t) => {
          this._dispatchWheel(t);
        }, { passive: !1 }));
    }
  }
  _addEvent(e, t, s, r) {
    let n = this._events[t];
    n === void 0 && (n = this._events[t] = {
      disposer: this._initEvent(t),
      callbacks: [],
      dispatching: !1,
      cleanup: !1
    });
    const a = { object: e, context: r, callback: s, disposed: !1 };
    return n.callbacks.push(a), new Ve(() => {
      a.disposed = !0, n.dispatching ? n.cleanup = !0 : (ot(n.callbacks, a), n.callbacks.length === 0 && (n.disposer.dispose(), delete this._events[t]));
    });
  }
  getCanvas(e, t) {
    this.render(e), t || (t = {});
    let s = this.resolution, r = Math.floor(this._canvasWidth * this.resolution), n = Math.floor(this._canvasHeight * this.resolution);
    if (t.minWidth && t.minWidth > r) {
      let f = t.minWidth / r;
      f > s && (s = f * this.resolution);
    }
    if (t.minHeight && t.minHeight > n) {
      let f = t.minHeight / n;
      f > s && (s = f * this.resolution);
    }
    if (t.maxWidth && t.maxWidth < r) {
      let f = t.maxWidth / r;
      f < s && (s = f * this.resolution);
    }
    if (t.maxHeight && t.maxHeight > n) {
      let f = t.maxHeight / n;
      f < s && (s = f * this.resolution);
    }
    t.maintainPixelRatio && (s /= this.resolution);
    const a = [];
    let o = !1;
    const l = document.createElement("canvas");
    s != this.resolution && (o = !0, r = r * s / this.resolution, n = n * s / this.resolution), l.width = r, l.height = n, l.style.position = "fixed", l.style.top = "-10000px", this.view.appendChild(l), a.push(l);
    const u = l.getContext("2d");
    let h = 0, c = 0, d = !1;
    return x(this.layers, (f) => {
      f && f.visible && (f.tainted || o) && (d = !0, f.exportableView = f.view, f.exportableContext = f.context, f.view = document.createElement("canvas"), f.view.style.position = "fixed", f.view.style.top = "-10000px", this.view.appendChild(f.view), a.push(f.view), f.view.width = r, f.view.height = n, f.context = f.view.getContext("2d"), f.dirty = !0, f.scale = s);
    }), d && (this._omitTainted = !0, this.render(e), this._omitTainted = !1), x(this.layers, (f) => {
      f && f.visible && (u.drawImage(f.view, 0, 0), f.exportableView && (f.view = f.exportableView, f.exportableView = void 0), f.exportableContext && (f.context = f.exportableContext, f.exportableContext = void 0), h < f.view.clientWidth && (h = f.view.clientWidth), c < f.view.clientHeight && (c = f.view.clientHeight), f.scale = void 0);
    }), l.style.width = h + "px", l.style.height = c + "px", x(a, (f) => {
      f.style.position = "", f.style.top = "", this.view.removeChild(f);
    }), l;
  }
}
class Ow {
  constructor() {
    Object.defineProperty(this, "view", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "context", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "margin", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
      }
    }), Object.defineProperty(this, "_width", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_height", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), this.view = document.createElement("canvas"), this.context = this.view.getContext("2d", { alpha: !1, willReadFrequently: !0 }), this.context.imageSmoothingEnabled = !1, this.view.style.position = "absolute", this.view.style.top = "0px", this.view.style.left = "0px";
  }
  resize(e, t, s, r, n) {
    e += this.margin.left + this.margin.right, t += this.margin.top + this.margin.bottom, s += this.margin.left + this.margin.right, r += this.margin.top + this.margin.bottom, this.view.style.left = -this.margin.left + "px", this.view.style.top = -this.margin.top + "px", this._width = Math.floor(e * n), this._height = Math.floor(t * n), this.view.width = this._width, this.view.style.width = s + "px", this.view.height = this._height, this.view.style.height = r + "px";
  }
  getImageData(e, t) {
    return this.context.getImageData(
      // TODO should this round ?
      Math.round((e.x - t.left) / t.width * this._width),
      Math.round((e.y - t.top) / t.height * this._height),
      1,
      1
    );
  }
  setMargin(e) {
    this.margin.left = 0, this.margin.right = 0, this.margin.top = 0, this.margin.bottom = 0, x(e, (t) => {
      t.margin && (this.margin.left = Math.max(this.margin.left, t.margin.left), this.margin.right = Math.max(this.margin.right, t.margin.right), this.margin.top = Math.max(this.margin.top, t.margin.top), this.margin.bottom = Math.max(this.margin.bottom, t.margin.bottom));
    });
  }
  clear() {
    this.context.save(), this.context.fillStyle = "#000", this.context.fillRect(0, 0, this._width, this._height);
  }
}
class Aw {
  constructor(e, t) {
    Object.defineProperty(this, "view", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "context", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tainted", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "margin", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "order", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "visible", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "width", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "height", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "scale", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "dirty", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "exportableView", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "exportableContext", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_width", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_height", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), this.view = e, this.context = t;
  }
  resize(e, t, s, r, n) {
    this.width != null && (e = this.width, s = this.width), this.height != null && (t = this.height, r = this.height), this.margin ? (e += this.margin.left + this.margin.right, t += this.margin.top + this.margin.bottom, s += this.margin.left + this.margin.right, r += this.margin.top + this.margin.bottom, this.view.style.left = -this.margin.left + "px", this.view.style.top = -this.margin.top + "px") : (this.view.style.left = "0px", this.view.style.top = "0px"), this._width = Math.floor(e * n), this._height = Math.floor(t * n), this.view.width = this._width, this.view.style.width = s + "px", this.view.height = this._height, this.view.style.height = r + "px";
  }
  clear() {
    this.context.save(), this.context.clearRect(0, 0, this._width, this._height);
  }
}
function th(i, e) {
  i == null ? requestAnimationFrame(e) : setTimeout(() => {
    requestAnimationFrame(e);
  }, 1e3 / i);
}
class un {
  constructor(e, t = {}, s) {
    if (Object.defineProperty(this, "dom", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_inner", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_settings", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_isDirty", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_isDirtyParents", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_dirty", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_dirtyParents", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_dirtyBounds", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_dirtyPositions", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_ticker", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "_tickers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_updateTick", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "events", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new hr()
    }), Object.defineProperty(this, "animationTime", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "_animations", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_renderer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_rootContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "container", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tooltipContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_tooltipContainerSettings", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_tooltip", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "language", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Z0.new(this, {})
    }), Object.defineProperty(this, "locale", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Rd
    }), Object.defineProperty(this, "utc", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "timezone", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "fps", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "numberFormatter", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Ad.new(this, {})
    }), Object.defineProperty(this, "dateFormatter", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Ed.new(this, {})
    }), Object.defineProperty(this, "durationFormatter", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Id.new(this, {})
    }), Object.defineProperty(this, "tabindex", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_tabindexes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_a11yD", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_focusElementDirty", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_focusElementContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_focusedSprite", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_isShift", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_keyboardDragPoint", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_tooltipElementContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_readerAlertElement", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_logo", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_tooltipDiv", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "nonce", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "interfaceColors", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "verticalLayout", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ys.new(this, {})
    }), Object.defineProperty(this, "horizontalLayout", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: bs.new(this, {})
    }), Object.defineProperty(this, "gridLayout", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: bi.new(this, {})
    }), Object.defineProperty(this, "autoResize", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "_fontHash", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ""
    }), Object.defineProperty(this, "_isDisposed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_disposers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_resizeSensorDisposer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_tooltips", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_htmlElementContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_htmlEnabledContainers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), !s)
      throw new Error("You cannot use `new Class()`, instead use `Class.new()`");
    this._settings = t, t.accessible == !1 && (this._a11yD = !0), t.useSafeResolution == null && (t.useSafeResolution = !0);
    let r;
    t.useSafeResolution && (r = ad()), this._renderer = new Mw(r);
    let n;
    if (e instanceof HTMLElement ? n = e : n = document.getElementById(e), x(Lt.rootElements, (l) => {
      if (l.dom === n)
        throw new Error("You cannot have multiple Roots on the same DOM node");
    }), this.interfaceColors = Xr.new(this, {}), n === null)
      throw new Error("Could not find HTML element with id `" + e + "`");
    this.dom = n;
    let a = document.createElement("div");
    a.style.position = "relative", a.style.height = "100%", n.appendChild(a);
    const o = t.tooltipContainerBounds;
    o && (this._tooltipContainerSettings = o), this._inner = a, this._updateComputedStyles(), Lt.rootElements.push(this);
  }
  static new(e, t) {
    const s = new un(e, t, !0);
    return s._init(), s;
  }
  moveDOM(e) {
    let t;
    if (e instanceof HTMLElement ? t = e : t = document.getElementById(e), t) {
      for (; this.dom.childNodes.length > 0; )
        t.appendChild(this.dom.childNodes[0]);
      this.dom = t, this._initResizeSensor(), this.resize();
    }
  }
  _handleLogo() {
    if (this._logo) {
      const e = this.dom.offsetWidth, t = this.dom.offsetHeight;
      e <= 150 || t <= 60 ? this._logo.hide() : this._logo.show();
    }
  }
  _showBranding() {
    if (!this._logo) {
      const e = this.tooltipContainer.children.push(Z.new(this, {
        interactive: !0,
        interactiveChildren: !1,
        position: "absolute",
        setStateOnChildren: !0,
        paddingTop: 9,
        paddingRight: 9,
        paddingBottom: 9,
        paddingLeft: 9,
        scale: 0.6,
        y: Ce(100),
        centerY: R,
        tooltipText: "Created using amCharts 5",
        tooltipX: R,
        cursorOverStyle: "pointer",
        background: mt.new(this, {
          fill: oe(4671320),
          fillOpacity: 0,
          tooltipY: 5
        })
      })), t = At.new(this, {
        pointerOrientation: "horizontal",
        paddingTop: 4,
        paddingRight: 7,
        paddingBottom: 4,
        paddingLeft: 7
      });
      t.label.setAll({
        fontSize: 12
      }), t.get("background").setAll({
        fill: this.interfaceColors.get("background"),
        stroke: this.interfaceColors.get("grid"),
        strokeOpacity: 0.3
      }), e.set("tooltip", t), e.events.on("click", () => {
        window.open("https://www.amcharts.com/", "_blank");
      }), e.states.create("hover", {}), e.children.push(he.new(this, {
        stroke: oe(13421772),
        strokeWidth: 3,
        svgPath: "M5 25 L13 25h13.6c3.4 0 6 0 10.3-4.3s5.2-12 8.6-12c3.4 0 4.3 8.6 7.7 8.6M83.4 25H79.8c-3.4 0-6 0-10.3-4.3s-5.2-12-8.6-12-4.3 8.6-7.7 8.6"
      })).states.create("hover", { stroke: oe(3976191) }), e.children.push(he.new(this, {
        stroke: oe(8947848),
        strokeWidth: 3,
        svgPath: "M83.4 25h-31C37 25 39.5 4.4 28.4 4.4S18.9 24.2 4.3 25H0"
      })).states.create("hover", { stroke: oe(4671320) }), this._logo = e, this._handleLogo();
    }
  }
  _getRealSize() {
    return this.dom.getBoundingClientRect();
  }
  _getCalculatedSize(e) {
    return this._settings.calculateSize ? this._settings.calculateSize(e) : {
      width: e.width,
      height: e.height
    };
  }
  _init() {
    const e = this._renderer, t = this._getRealSize(), s = this._getCalculatedSize(t), r = Math.floor(s.width), n = Math.floor(s.height), a = Math.floor(t.width), o = Math.floor(t.height), l = Z.new(this, {
      visible: !0,
      width: a,
      height: o
    });
    this._rootContainer = l, this._rootContainer._defaultThemes.push(K0.new(this));
    const u = l.children.push(Z.new(this, { visible: !0, width: R, height: R }));
    this.container = u, e.resize(a, o, r, n), this._inner.appendChild(e.view), this._initResizeSensor();
    const h = document.createElement("div");
    if (this._htmlElementContainer = h, h.className = "am5-html-container", h.style.position = "absolute", h.style.pointerEvents = "none", this._tooltipContainerSettings || (h.style.overflow = "hidden"), this._inner.appendChild(h), this._a11yD !== !0) {
      const c = document.createElement("div");
      c.className = "am5-reader-container", c.setAttribute("role", "alert"), c.style.zIndex = "-100000", c.style.opacity = "0", c.style.position = "absolute", c.style.top = "0", this._readerAlertElement = c, this._inner.appendChild(this._readerAlertElement);
      const d = document.createElement("div");
      d.className = "am5-focus-container", d.style.position = "absolute", d.style.pointerEvents = "none", d.style.top = "0px", d.style.left = "0px", d.style.overflow = "hidden", d.style.width = r + "px", d.style.height = n + "px", d.setAttribute("role", "application"), Rs(d, !1), this._focusElementContainer = d, this._inner.appendChild(this._focusElementContainer);
      const f = document.createElement("div");
      this._tooltipElementContainer = f, f.className = "am5-tooltip-container", this._inner.appendChild(f), Ut("keyboardevents") && (this._disposers.push(Ie(window, "keydown", (g) => {
        g.keyCode == 16 && (this._isShift = !0);
      })), this._disposers.push(Ie(window, "keyup", (g) => {
        g.keyCode == 16 && (this._isShift = !1);
      })), this._disposers.push(Ie(d, "keydown", (g) => {
        const p = this._focusedSprite;
        if (p) {
          g.keyCode == 27 && (ed(), this._focusedSprite = void 0);
          let m = 0, _ = 0;
          switch (g.keyCode) {
            case 13:
              g.preventDefault();
              const v = e.getEvent(new MouseEvent("click"));
              p.events.dispatch("click", {
                type: "click",
                originalEvent: v.event,
                point: v.point,
                simulated: !0,
                target: p
              });
              return;
            case 37:
              m = -6;
              break;
            case 39:
              m = 6;
              break;
            case 38:
              _ = -6;
              break;
            case 40:
              _ = 6;
              break;
            default:
              return;
          }
          if (m != 0 || _ != 0) {
            if (g.preventDefault(), !p.isDragging()) {
              this._keyboardDragPoint = {
                x: 0,
                y: 0
              };
              const y = e.getEvent(new MouseEvent("mousedown", {
                clientX: 0,
                clientY: 0
              }));
              p.events.isEnabled("pointerdown") && p.events.dispatch("pointerdown", {
                type: "pointerdown",
                originalEvent: y.event,
                point: y.point,
                simulated: !0,
                target: p
              });
            }
            const v = this._keyboardDragPoint;
            v.x += m, v.y += _;
            const b = e.getEvent(new MouseEvent("mousemove", {
              clientX: v.x,
              clientY: v.y
            }), !1);
            p.events.isEnabled("globalpointermove") && p.events.dispatch("globalpointermove", {
              type: "globalpointermove",
              originalEvent: b.event,
              point: b.point,
              simulated: !0,
              target: p
            });
          }
        }
      })), this._disposers.push(Ie(d, "keyup", (g) => {
        if (this._focusedSprite) {
          const p = this._focusedSprite, m = g.keyCode;
          switch (m) {
            case 37:
            case 39:
            case 38:
            case 40:
              if (p.isDragging()) {
                const _ = this._keyboardDragPoint, v = e.getEvent(new MouseEvent("mouseup", {
                  clientX: _.x,
                  clientY: _.y
                }));
                p.events.isEnabled("globalpointerup") && p.events.dispatch("globalpointerup", {
                  type: "globalpointerup",
                  originalEvent: v.event,
                  point: v.point,
                  simulated: !0,
                  target: p
                }), this._keyboardDragPoint = void 0;
                return;
              } else if (p.get("focusableGroup")) {
                const _ = p.get("focusableGroup"), v = this._tabindexes.filter((w) => w.get("focusableGroup") == _);
                let b = v.indexOf(p);
                const y = v.length - 1;
                b += m == 39 || m == 40 ? 1 : -1, b < 0 ? b = y : b > y && (b = 0), td(v[b].getPrivate("focusElement").dom);
              }
              break;
          }
        }
      })));
    }
    this._startTicker(), this.setThemes([]), this._addTooltip(), this._hasLicense() || this._showBranding();
  }
  _initResizeSensor() {
    this._resizeSensorDisposer && this._resizeSensorDisposer.dispose(), this._resizeSensorDisposer = new G0(this.dom, () => {
      this.autoResize && this.resize();
    }), this._disposers.push(this._resizeSensorDisposer);
  }
  /**
   * If automatic resizing of char is disabled (`root.autoResize = false`), it
   * can be resized manually by calling this method.
   */
  resize() {
    const e = this._getRealSize(), t = this._getCalculatedSize(e), s = Math.floor(t.width), r = Math.floor(t.height);
    if (s > 0 && r > 0) {
      const n = Math.floor(e.width), a = Math.floor(e.height), o = this._htmlElementContainer;
      if (o.style.width = s + "px", o.style.height = r + "px", this._a11yD !== !0) {
        const u = this._focusElementContainer;
        u.style.width = s + "px", u.style.height = r + "px";
      }
      this._renderer.resize(n, a, s, r);
      const l = this._rootContainer;
      l.setPrivate("width", n), l.setPrivate("height", a), this._render(), this._handleLogo();
    }
  }
  _render() {
    this._renderer.render(this._rootContainer._display), this._focusElementDirty && (this._updateCurrentFocus(), this._focusElementDirty = !1);
  }
  _runTickers(e) {
    x(this._tickers, (t) => {
      t(e);
    });
  }
  _runAnimations(e) {
    ln(this._animations, (t) => t._runAnimation(e));
  }
  _runDirties() {
    let e = {};
    for (; this._isDirtyParents; )
      this._isDirtyParents = !1, Be(this._dirtyParents).forEach((a) => {
        const o = this._dirtyParents[a];
        delete this._dirtyParents[a], o.isDisposed() || (e[o.uid] = o, o._prepareChildren());
      });
    Be(e).forEach((a) => {
      e[a]._updateChildren();
    });
    const t = [];
    Be(this._dirty).forEach((a) => {
      const o = this._dirty[a];
      o.isDisposed() ? delete this._dirty[o.uid] : (t.push(o), o._beforeChanged());
    }), t.forEach((a) => {
      a._changed(), delete this._dirty[a.uid], a._clearDirty();
    }), this._isDirty = !1;
    const s = {}, r = [];
    Be(this._dirtyBounds).forEach((a) => {
      const o = this._dirtyBounds[a];
      delete this._dirtyBounds[a], o.isDisposed() || (s[o.uid] = o.depth(), r.push(o));
    }), r.sort((a, o) => Et(s[o.uid], s[a.uid])), r.forEach((a) => {
      a._updateBounds();
    });
    const n = this._dirtyPositions;
    Be(n).forEach((a) => {
      const o = n[a];
      delete n[a], o.isDisposed() || o._updatePosition();
    }), t.forEach((a) => {
      a._afterChanged();
    });
  }
  _renderFrame(e) {
    return this._updateTick ? (this.events.isEnabled("framestarted") && this.events.dispatch("framestarted", {
      type: "framestarted",
      target: this,
      timestamp: e
    }), this._checkComputedStyles(), this._runTickers(e), this._runAnimations(e), this._runDirties(), this._render(), this._positionHTMLElements(), this.events.isEnabled("frameended") && this.events.dispatch("frameended", {
      type: "frameended",
      target: this,
      timestamp: e
    }), this._tickers.length === 0 && this._animations.length === 0 && !this._isDirty) : !0;
  }
  _runTicker(e) {
    this.isDisposed() || (this.animationTime = e, this._renderFrame(e) ? (this._ticker = null, this.animationTime = null) : th(this.fps, this._ticker));
  }
  _runTickerNow() {
    if (!this.isDisposed())
      for (; ; ) {
        const e = performance.now();
        if (this.animationTime = e, this._renderFrame(e)) {
          this.animationTime = null;
          break;
        }
      }
  }
  _startTicker() {
    this._ticker === null && (this.animationTime = null, this._ticker = (e) => {
      this._runTicker(e);
    }, th(this.fps, this._ticker));
  }
  /**
   * Returns whether the root is updating or not.
   */
  get updateTick() {
    return this._updateTick;
  }
  /**
   * Enables or disables the root updating.
   */
  set updateTick(e) {
    this._updateTick = e, e && this._startTicker();
  }
  _addDirtyEntity(e) {
    this._dirty[e.uid] === void 0 && (this._isDirty = !0, this._dirty[e.uid] = e, this._startTicker());
  }
  _addDirtyParent(e) {
    this._dirtyParents[e.uid] === void 0 && (this._isDirty = !0, this._isDirtyParents = !0, this._dirtyParents[e.uid] = e, this._startTicker());
  }
  _addDirtyBounds(e) {
    this._dirtyBounds[e.uid] === void 0 && (this._isDirty = !0, this._dirtyBounds[e.uid] = e, this._startTicker());
  }
  _addDirtyPosition(e) {
    this._dirtyPositions[e.uid] === void 0 && (this._isDirty = !0, this._dirtyPositions[e.uid] = e, this._startTicker());
  }
  _addAnimation(e) {
    this._animations.indexOf(e) === -1 && (this._animations.push(e), this._startTicker());
  }
  _markDirty() {
    this._isDirty = !0;
  }
  _markDirtyRedraw() {
    this.events.once("frameended", () => {
      this._isDirty = !0, this._startTicker();
    });
  }
  eachFrame(e) {
    return this._tickers.push(e), this._startTicker(), new Ve(() => {
      ot(this._tickers, e);
    });
  }
  markDirtyGlobal(e) {
    e || (e = this.container), e.walkChildren((t) => {
      t instanceof Z && this.markDirtyGlobal(t), t.markDirty(), t.markDirtyBounds();
    });
  }
  /**
   * Returns width of the target container, in pixels.
   *
   * @return Width
   */
  width() {
    return Math.floor(this._getCalculatedSize(this._getRealSize()).width);
  }
  /**
   * Returns height of the target container, in pixels.
   *
   * @return Height
   */
  height() {
    return Math.floor(this._getCalculatedSize(this._getRealSize()).height);
  }
  /**
   * Disposes root and all the content in it.
   */
  dispose() {
    this._isDisposed || (this._isDisposed = !0, this._rootContainer.dispose(), this._renderer.dispose(), this.horizontalLayout.dispose(), this.verticalLayout.dispose(), this.interfaceColors.dispose(), x(this._disposers, (e) => {
      e.dispose();
    }), this._inner && qc(this._inner), vt(Lt.rootElements, this));
  }
  /**
   * Returns `true` if root element is disposed.
   *
   * @return Disposed?
   */
  isDisposed() {
    return this._isDisposed;
  }
  /**
   * Triggers screen reader read out a message.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/accessibility/} for more info
   * @param  text  Alert text
   */
  readerAlert(e) {
    this._a11yD !== !0 && (this._readerAlertElement.innerHTML = na(e));
  }
  /**
   * Sets themes to be used for the chart.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/themes/} for more info
   * @param  themes  A list of themes
   */
  setThemes(e) {
    this._rootContainer.set("themes", e);
    const t = this.tooltipContainer;
    t && t._applyThemes();
    const s = this.interfaceColors;
    s && s._applyThemes();
  }
  _addTooltip() {
    if (!this.tooltipContainer) {
      const e = this._tooltipContainerSettings, t = this._rootContainer.children.push(Z.new(this, {
        position: "absolute",
        isMeasured: !1,
        width: R,
        height: R,
        layer: e ? 35 : 30,
        layerMargin: e || void 0
      }));
      this.tooltipContainer = t;
      const s = At.new(this, {});
      this.container.set("tooltip", s), s.hide(0), this._tooltip = s;
    }
  }
  /**
   * Accesibility
   */
  _registerTabindexOrder(e) {
    this._a11yD != !0 && (e.get("focusable") ? Us(this._tabindexes, e) : vt(this._tabindexes, e), this._invalidateTabindexes());
  }
  _unregisterTabindexOrder(e) {
    this._a11yD != !0 && (vt(this._tabindexes, e), this._invalidateTabindexes());
  }
  _invalidateTabindexes() {
    if (this._a11yD == !0)
      return;
    this._tabindexes.sort((t, s) => {
      const r = t.get("tabindexOrder", 0), n = s.get("tabindexOrder", 0);
      return r == n ? 0 : r > n ? 1 : -1;
    });
    const e = [];
    x(this._tabindexes, (t, s) => {
      t.getPrivate("focusElement") ? this._moveFocusElement(s, t) : this._makeFocusElement(s, t);
      const r = t.get("focusableGroup");
      r && (e.indexOf(r) !== -1 ? t.getPrivate("focusElement").dom.setAttribute("tabindex", "-1") : e.push(r));
    });
  }
  _updateCurrentFocus() {
    this._a11yD != !0 && this._focusedSprite && (this._decorateFocusElement(this._focusedSprite), this._positionFocusElement(this._focusedSprite));
  }
  _decorateFocusElement(e, t) {
    if (this._a11yD == !0 || (t || (t = e.getPrivate("focusElement").dom), !t))
      return;
    e.get("visible") && e.get("role") != "tooltip" && !e.isHidden() ? t.getAttribute("tabindex") != "-1" && t.setAttribute("tabindex", "" + this.tabindex) : t.removeAttribute("tabindex");
    const s = e.get("role");
    s ? t.setAttribute("role", s) : t.removeAttribute("role");
    const r = e.get("ariaLabel");
    if (r) {
      const f = zr(e, r);
      t.setAttribute("aria-label", f);
    } else
      t.removeAttribute("aria-label");
    const n = e.get("ariaLive");
    n ? t.setAttribute("aria-live", n) : t.removeAttribute("aria-live");
    const a = e.get("ariaChecked");
    a != null ? t.setAttribute("aria-checked", a ? "true" : "false") : t.removeAttribute("aria-checked"), e.get("ariaHidden") ? t.setAttribute("aria-hidden", "hidden") : t.removeAttribute("aria-hidden");
    const o = e.get("ariaOrientation");
    o ? t.setAttribute("aria-orientation", o) : t.removeAttribute("aria-orientation");
    const l = e.get("ariaValueNow");
    l ? t.setAttribute("aria-valuenow", l) : t.removeAttribute("aria-valuenow");
    const u = e.get("ariaValueMin");
    u ? t.setAttribute("aria-valuemin", u) : t.removeAttribute("aria-valuemin");
    const h = e.get("ariaValueMax");
    h ? t.setAttribute("aria-valuemax", h) : t.removeAttribute("aria-valuemax");
    const c = e.get("ariaValueText");
    c ? t.setAttribute("aria-valuetext", c) : t.removeAttribute("aria-valuetext");
    const d = e.get("ariaControls");
    d ? t.setAttribute("aria-controls", d) : t.removeAttribute("aria-controls");
  }
  _makeFocusElement(e, t) {
    if (t.getPrivate("focusElement") || this._a11yD == !0)
      return;
    const s = document.createElement("div");
    t.get("role") != "tooltip" && (s.tabIndex = this.tabindex), s.style.position = "absolute", Rs(s, !1);
    const r = [];
    t.setPrivate("focusElement", {
      dom: s,
      disposers: r
    }), this._decorateFocusElement(t), r.push(Ie(s, "focus", (n) => {
      this._handleFocus(n, e);
    })), r.push(Ie(s, "blur", (n) => {
      this._handleBlur(n, e);
    })), this._moveFocusElement(e, t);
  }
  _removeFocusElement(e) {
    if (this._a11yD == !0)
      return;
    vt(this._tabindexes, e);
    const t = e.getPrivate("focusElement");
    t && (this._focusElementContainer.removeChild(t.dom), x(t.disposers, (r) => {
      r.dispose();
    }));
  }
  _hideFocusElement(e) {
    if (this._a11yD == !0)
      return;
    const t = e.getPrivate("focusElement");
    t.dom.style.display = "none";
  }
  _moveFocusElement(e, t) {
    if (this._a11yD == !0)
      return;
    const s = this._focusElementContainer, r = t.getPrivate("focusElement").dom;
    if (r === this._focusElementContainer.children[e])
      return;
    const n = this._focusElementContainer.children[e + 1];
    n ? s.insertBefore(r, n) : s.append(r);
  }
  _positionFocusElement(e) {
    if (this._a11yD == !0)
      return;
    const t = e.globalBounds(), s = t.right == t.left ? e.width() : t.right - t.left, r = t.top == t.bottom ? e.height() : t.bottom - t.top, n = e.getPrivate("focusElement").dom;
    n.style.top = t.top - 2 + "px", n.style.left = t.left - 2 + "px", n.style.width = s + 4 + "px", n.style.height = r + 4 + "px";
  }
  _handleFocus(e, t) {
    if (this._a11yD == !0)
      return;
    const s = this._tabindexes[t];
    if (!s.isVisibleDeep()) {
      this._focusNext(e.target, this._isShift ? -1 : 1);
      return;
    }
    this._positionFocusElement(s), this._focusedSprite = s, s.events.isEnabled("focus") && s.events.dispatch("focus", {
      type: "focus",
      originalEvent: e,
      target: s
    });
  }
  _focusNext(e, t) {
    if (this._a11yD == !0)
      return;
    var s = Array.from(document.querySelectorAll([
      "a[href]",
      "area[href]",
      "button:not([disabled])",
      "details",
      "input:not([disabled])",
      "iframe:not([disabled])",
      "select:not([disabled])",
      "textarea:not([disabled])",
      '[contentEditable=""]',
      '[contentEditable="true"]',
      '[contentEditable="TRUE"]',
      '[tabindex]:not([tabindex^="-"])'
      //':not([disabled])'
    ].join(",")));
    let r = s.indexOf(e) + t;
    r < 0 ? r = s.length - 1 : r >= s.length && (r = 0), s[r].focus();
  }
  _handleBlur(e, t) {
    if (this._a11yD == !0)
      return;
    const s = this._focusedSprite;
    s && s.events.isEnabled("blur") && s.events.dispatch("blur", {
      type: "blur",
      originalEvent: e,
      target: s
    }), this._focusedSprite = void 0;
  }
  /**
   * @ignore
   */
  updateTooltip(e) {
    if (this._a11yD == !0)
      return;
    const t = na(e._getText());
    let s = e.getPrivate("tooltipElement");
    e.get("role") == "tooltip" && t != "" ? (s || (s = this._makeTooltipElement(e)), s.innerHTML != t && (s.innerHTML = t)) : s && (s.remove(), e.removePrivate("tooltipElement"));
  }
  _makeTooltipElement(e) {
    const t = this._tooltipElementContainer, s = document.createElement("div");
    return s.style.position = "absolute", s.style.top = "-1000000px", s.style.opacity = "0.0000001", Rs(s, !1), this._decorateFocusElement(e, s), t.append(s), e.setPrivate("tooltipElement", s), s;
  }
  _removeTooltipElement(e) {
    if (this._a11yD == !0)
      return;
    const t = e.getPrivate("tooltipElement");
    if (t) {
      const s = t.parentElement;
      s && s.removeChild(t);
    }
  }
  _invalidateAccessibility(e) {
    if (this._a11yD == !0)
      return;
    this._focusElementDirty = !0;
    const t = e.getPrivate("focusElement");
    e.get("focusable") ? t && (this._decorateFocusElement(e), this._positionFocusElement(e)) : t && this._removeFocusElement(e);
  }
  /**
   * Returns `true` if `target` is currently focused.
   *
   * @param   target  Target
   * @return          Focused?
   */
  focused(e) {
    return this._focusedSprite === e;
  }
  /**
   * Converts document coordinates to coordinates withing root element.
   *
   * @param   point  Document point
   * @return         Root point
   */
  documentPointToRoot(e) {
    const t = this.dom.getBoundingClientRect();
    return {
      x: e.x - t.left,
      y: e.y - t.top
    };
  }
  /**
   * Converts root coordinates to document
   *
   * @param   point  Document point
   * @return         Root point
   */
  rootPointToDocument(e) {
    const t = this.dom.getBoundingClientRect();
    return {
      x: e.x + t.left,
      y: e.y + t.top
    };
  }
  /**
   * @ignore
   */
  addDisposer(e) {
    return this._disposers.push(e), e;
  }
  _updateComputedStyles() {
    const e = window.getComputedStyle(this.dom);
    let t = "";
    _e(e, (r, n) => {
      Ri(r) && r.match(/^font/) && (t += n);
    });
    const s = t != this._fontHash;
    return s && (this._fontHash = t), s;
  }
  _checkComputedStyles() {
    this._updateComputedStyles() && this._invalidateLabelBounds(this.container);
  }
  _invalidateLabelBounds(e) {
    e instanceof Z ? e.children.each((t) => {
      this._invalidateLabelBounds(t);
    }) : e instanceof Ni && e.markDirtyBounds();
  }
  /**
   * To all the clever heads out there. Yes, we did not make any attempts to
   * scramble this.
   *
   * This is a part of a tool meant for our users to manage their commercial
   * licenses for removal of amCharts branding from charts.
   *
   * The only legit way to do so is to purchase a commercial license for amCharts:
   * https://www.amcharts.com/online-store/
   *
   * Removing or altering this code, or disabling amCharts branding in any other
   * way is against the license and thus illegal.
   */
  _hasLicense() {
    for (let e = 0; e < Lt.licenses.length; e++)
      if (Lt.licenses[e].match(/^AM5C.{5,}/i))
        return !0;
    return !1;
  }
  _licenseApplied() {
    this._logo && this._logo.set("forceHidden", !0);
  }
  /**
   * @ignore
   */
  get debugGhostView() {
    return this._renderer.debugGhostView;
  }
  /**
   * @ignore
   */
  set debugGhostView(e) {
    this._renderer.debugGhostView = e;
  }
  /**
   * Set this to `true` if you need chart to require first a tap onto it before
   * touch gesture related functionality like zoom/pan is turned on.
   *
   * @see {@link https://www.amcharts.com/docs/v5/getting-started/root-element/#Touch_related_options} for more info
   * @default false
   * @since 5.2.9
   * @param  value  Needs a tap to activate touch functions
   */
  set tapToActivate(e) {
    this._renderer.tapToActivate = e;
  }
  /**
   * @return Needs a tap to activate touch functions
   */
  get tapToActivate() {
    return this._renderer.tapToActivate;
  }
  /**
   * If `tapToActivate` is set to `true`, this setting will determine number
   * of milliseconds the chart will stay "active", before releasing the
   * controls back to the page.
   *
   * @see {@link https://www.amcharts.com/docs/v5/getting-started/root-element/#Touch_related_options} for more info
   * @default 3000
   * @since 5.2.9
   * @param  value  Timeout
   */
  set tapToActivateTimeout(e) {
    this._renderer.tapToActivateTimeout = e;
  }
  /**
   * @return Timeout
   */
  get tapToActivateTimeout() {
    return this._renderer.tapToActivateTimeout;
  }
  _makeHTMLElement(e) {
    const t = this._htmlElementContainer, s = document.createElement("div");
    return e.setPrivate("htmlElement", s), s.style.position = "absolute", s.style.overflow = "auto", s.style.boxSizing = "border-box", Rs(s, !0), e.events.isEnabled("click") && this._disposers.push(Ie(s, "click", (r) => {
      const n = this._renderer.getEvent(r);
      e.events.dispatch("click", {
        type: "click",
        originalEvent: n.event,
        point: n.point,
        simulated: !1,
        target: e
      });
    })), this._positionHTMLElement(e), t.append(s), Us(this._htmlEnabledContainers, e), s;
  }
  _positionHTMLElements() {
    x(this._htmlEnabledContainers, (e) => {
      this._positionHTMLElement(e);
    });
  }
  _positionHTMLElement(e) {
    const t = e.getPrivate("htmlElement");
    if (t) {
      x(["paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "minWidth", "minHeight", "maxWidth", "maxHeight"], (c) => {
        const d = e.get(c);
        d ? t.style[c] = d + "px" : t.style[c] = "";
      });
      const r = e.compositeOpacity();
      setTimeout(() => {
        t.style.opacity = r + "";
      }, 10);
      const n = e.isVisibleDeep();
      n && (t.style.display = "block");
      const a = e.globalBounds();
      t.style.top = a.top + "px", t.style.left = a.left + "px";
      const o = e.get("width"), l = e.get("height");
      let u = 0, h = 0;
      if (o && (u = e.width()), l && (h = e.height()), !o || !l) {
        t.style.position = "fixed", t.style.width = "", t.style.height = "";
        const c = t.getBoundingClientRect();
        t.style.position = "absolute", u = c.width, h = c.height, e._adjustedLocalBounds = { left: 0, right: 0, top: 0, bottom: 0 }, e.setPrivate("minWidth", u), e.setPrivate("minHeight", h);
      } else
        e.removePrivate("minWidth"), e.removePrivate("minHeight");
      u > 0 && (t.style.minWidth = u + "px"), h > 0 && (t.style.minHeight = h + "px"), (!n || r == 0) && (t.style.display = "none");
    }
  }
  _setHTMLContent(e, t) {
    let s = e.getPrivate("htmlElement");
    s || (s = this._makeHTMLElement(e)), s.innerHTML != t && (s.innerHTML = t);
  }
  _removeHTMLContent(e) {
    let t = e.getPrivate("htmlElement");
    t && this._htmlElementContainer.removeChild(t), vt(this._htmlEnabledContainers, e);
  }
}
let wn;
function Lw(i, e, t) {
  const s = e.interfaceColors, r = s.get("secondaryButton").toCSS(), n = s.get("text").toCSS(), a = s.get("alternativeBackground").toCSS(0.45);
  if (!wn) {
    const o = new nt([
      new Je(i, ".am5-modal", {
        width: "100%",
        height: "100%",
        position: "absolute",
        "z-index": "100000",
        top: "0",
        left: "0"
      }),
      new Je(i, ".am5-modal-curtain", {
        top: "0",
        left: "0",
        width: "100%",
        height: "100%",
        position: "absolute",
        background: s.get("background").toCSS(0.5),
        "z-index": "100"
      }),
      new Je(i, ".am5-modal-wrapper", {
        top: "0",
        left: "0",
        width: "100%",
        height: "100%",
        position: "absolute",
        "text-align": "center",
        "white-space": "nowrap",
        background: s.get("background").toCSS(0.5),
        "z-index": "101"
      }),
      new Je(i, ".am5-modal-wrapper:before", {
        content: "''",
        display: "inline-block",
        height: "100%",
        "vertical-align": "middle",
        "margin-right": "-0.25em"
      }),
      new Je(i, ".am5-modal-content", {
        display: "inline-block",
        padding: "1.2em",
        "vertical-align": "middle",
        "text-align": "left",
        "white-space": "normal",
        background: s.get("background").toCSS(),
        //"border": "1px solid " + ic.get("alternativeBackground")!.toCSS(),
        "border-radius": "4px",
        "-webkit-box-shadow": "0px 0px 36px 0px " + a,
        "box-shadow": "0px 0px 36px 0px " + a,
        color: n
      }),
      new Je(i, ".am5-modal-content h1", {
        "font-size": "1em",
        margin: "0 0 0.5em 0"
      }),
      new Je(i, ".am5-modal-table", {
        display: "table",
        margin: "1em 0"
      }),
      new Je(i, ".am5-modal-table-row", {
        display: "table-row"
      }),
      new Je(i, ".am5-modal-table-heading", {
        display: "table-heading",
        padding: "3px 10px 3px 0"
      }),
      new Je(i, ".am5-modal-table-cell", {
        display: "table-cell",
        padding: "3px 0 3px 0"
      }),
      new Je(i, ".am5-modal-table-cell > *", {
        "vertical-align": "middle"
      }),
      new Je(i, ".am5-modal-content input[type=text], .am5-modal-content input[type=number], .am5-modal-content select", {
        border: "1px solid " + r,
        "border-radius": "4px",
        padding: "3px 5px",
        margin: "2px"
      }),
      new Je(i, ".am5-modal-input-narrow", {
        width: "50px"
      }),
      new Je(i, ".am5-modal-button", {
        "font-weight": "400",
        color: s.get("secondaryButtonText").toCSS(),
        "line-height": "1.5",
        "text-align": "center",
        "text-decoration": "none",
        "vertical-align": "middle",
        cursor: "pointer",
        padding: "0.2em 0.8em",
        "font-size": "1em",
        "border-radius": "0.25em",
        margin: "0 0.25em 0 0",
        border: "1px solid " + s.get("secondaryButtonStroke").toCSS(),
        background: s.get("secondaryButton").toCSS()
      }),
      new Je(i, ".am5-modal-button:hover", {
        background: s.get("secondaryButtonHover").toCSS()
      }),
      new Je(i, ".am5-modal-button.am5-modal-primary", {
        color: s.get("primaryButtonText").toCSS(),
        border: "1px solid " + s.get("primaryButtonStroke").toCSS(),
        background: s.get("primaryButton").toCSS()
      }),
      new Je(i, ".am5-modal-button.am5-modal-primary:hover", {
        background: s.get("primaryButtonHover").toCSS()
      })
    ]);
    wn = new qa(() => {
      wn = void 0, o.dispose();
    });
  }
  return wn.increment();
}
class la extends De {
  //protected _currentPass: number = 0;
  _afterNew() {
    super._afterNewApplyThemes(), this._setRawDefault("deactivateRoot", !0), Lw(rd(this._root.dom), this._root);
    const e = document.createElement("div");
    e.className = "am5-modal", e.style.display = "none", this.root._inner.appendChild(e), this.setPrivate("container", e);
    const t = document.createElement("div");
    t.className = "am5-modal-curtain", e.appendChild(t), this.setPrivate("curtain", t), Ie(t, "click", () => {
      this.cancel();
    });
    const s = document.createElement("div");
    s.className = "am5-modal-wrapper", e.appendChild(s), this.setPrivate("wrapper", s);
    const r = document.createElement("div");
    r.className = "am5-modal-content", s.appendChild(r), this.setPrivate("content", r);
    const n = this.get("content");
    n && (r.innerHTML = n), Ut("keyboardevents") && this._disposers.push(Ie(document, "keydown", (a) => {
      this.isOpen() && a.keyCode == 27 && this.cancel();
    }));
  }
  _beforeChanged() {
    super._beforeChanged(), this.isDirty("content") && (this.getPrivate("content").innerHTML = this.get("content", ""));
  }
  /**
   * Returns `true` if modal is currently open.
   *
   * @return  Modal open?
   */
  isOpen() {
    return this.getPrivate("container").style.display != "none";
  }
  /**
   * Opens modal.
   */
  open() {
    this.getPrivate("container").style.display = "block", this.get("deactivateRoot") && this.setTimeout(() => {
      this._root._renderer.interactionsEnabled = !1;
    }, 10), this.events.dispatch("opened", {
      type: "opened",
      target: this
    });
  }
  /**
   * Closes modal.
   */
  close() {
    this.getPrivate("container").style.display = "none", this.get("deactivateRoot") && (this._root._renderer.interactionsEnabled = !0), this.events.dispatch("closed", {
      type: "closed",
      target: this
    });
  }
  /**
   * Closes modal and invokes `cancelled` event.
   */
  cancel() {
    this.getPrivate("container").style.display = "none", this.get("deactivateRoot") && (this._root._renderer.interactionsEnabled = !0), this.events.dispatch("cancelled", {
      type: "cancelled",
      target: this
    });
  }
  /**
   * Disposes modal.
   */
  dispose() {
    super.dispose(), this.root.dom.removeChild(this.getPrivate("container"));
  }
}
Object.defineProperty(la, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Modal"
});
Object.defineProperty(la, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: De.classNames.concat([la.className])
});
class qt extends De {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_index", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "series", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  _afterNew() {
    super._afterNewApplyThemes();
  }
  _beforeChanged() {
    if (super._beforeChanged(), this.isDirty("sprite")) {
      const e = this.get("sprite");
      e && (e.setAll({ position: "absolute", role: "figure" }), this._disposers.push(e));
    }
    (this.isDirty("locationX") || this.isDirty("locationY")) && this.series && this.series._positionBullet(this);
  }
}
Object.defineProperty(qt, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Bullet"
});
Object.defineProperty(qt, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: De.classNames.concat([qt.className])
});
class it extends mt {
  _beforeChanged() {
    super._beforeChanged(), (this.isDirty("cornerRadiusTL") || this.isDirty("cornerRadiusTR") || this.isDirty("cornerRadiusBR") || this.isDirty("cornerRadiusBL")) && (this._clear = !0);
  }
  _draw() {
    let e = this.width(), t = this.height(), s = e, r = t, n = s / Math.abs(e), a = r / Math.abs(t);
    if (S(s) && S(r)) {
      let o = Math.min(s, r) / 2, l = we(this.get("cornerRadiusTL", 8), o), u = we(this.get("cornerRadiusTR", 8), o), h = we(this.get("cornerRadiusBR", 8), o), c = we(this.get("cornerRadiusBL", 8), o), d = Math.min(Math.abs(s / 2), Math.abs(r / 2));
      l = Ne(l, 0, d), u = Ne(u, 0, d), h = Ne(h, 0, d), c = Ne(c, 0, d);
      const f = this._display;
      f.moveTo(l * n, 0), f.lineTo(s - u * n, 0), u > 0 && f.arcTo(s, 0, s, u * a, u), f.lineTo(s, r - h * a), h > 0 && f.arcTo(s, r, s - h * n, r, h), f.lineTo(c * n, r), c > 0 && f.arcTo(0, r, 0, r - c * a, c), f.lineTo(0, l * a), l > 0 && f.arcTo(0, 0, l * n, 0, l), f.closePath();
    }
  }
}
Object.defineProperty(it, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "RoundedRectangle"
});
Object.defineProperty(it, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: mt.classNames.concat([it.className])
});
class Ks extends Z {
  _afterNew() {
    this._settings.themeTags = se(this._settings.themeTags, ["button"]), super._afterNew(), this._settings.background || this.set("background", it.new(this._root, {
      themeTags: se(this._settings.themeTags, ["background"])
    }));
  }
  _prepareChildren() {
    if (super._prepareChildren(), this.isDirty("icon")) {
      const e = this._prevSettings.icon, t = this.get("icon");
      t !== e && (this._disposeProperty("icon"), e && e.dispose(), t && this.children.push(t), this._prevSettings.icon = t);
    }
    if (this.isDirty("label")) {
      const e = this._prevSettings.label, t = this.get("label");
      t !== e && (this._disposeProperty("label"), e && e.dispose(), t && this.children.push(t), this._prevSettings.label = t);
    }
  }
}
Object.defineProperty(Ks, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Button"
});
Object.defineProperty(Ks, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Z.classNames.concat([Ks.className])
});
class ei extends he {
  _beforeChanged() {
    super._beforeChanged(), this.isDirty("radius") && (this._clear = !0);
  }
  _changed() {
    super._changed(), this._clear && this._display.drawCircle(0, 0, this.get("radius", 10));
  }
}
Object.defineProperty(ei, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Circle"
});
Object.defineProperty(ei, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: he.classNames.concat([ei.className])
});
class ua extends he {
  _beforeChanged() {
    super._beforeChanged(), (this.isDirty("radiusX") || this.isDirty("radiusY") || this.isDirty("rotation")) && (this._clear = !0);
  }
  _changed() {
    super._changed(), this._clear && this._display.drawEllipse(0, 0, Math.abs(this.get("radiusX")), Math.abs(this.get("radiusY")));
  }
}
Object.defineProperty(ua, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Ellipse"
});
Object.defineProperty(ua, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: he.classNames.concat([ua.className])
});
class ha extends he {
  _beforeChanged() {
    super._beforeChanged(), (this.isDirty("radius") || this.isDirty("innerRadius") || this.isDirty("spikes")) && (this._clear = !0);
  }
  _changed() {
    if (super._changed(), this._clear) {
      const e = this._display, t = this.get("radius", 0), s = we(this.get("innerRadius", 0), t), r = this.get("spikes", 0), n = Math.PI / r;
      let a = Math.PI / 2 * 3;
      e.moveTo(0, -t);
      for (let o = 0; o < r; o++)
        e.lineTo(Math.cos(a) * t, Math.sin(a) * t), a += n, e.lineTo(Math.cos(a) * s, Math.sin(a) * s), a += n;
      e.lineTo(0, -t), e.closePath();
    }
  }
}
Object.defineProperty(ha, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Star"
});
Object.defineProperty(ha, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: he.classNames.concat([ha.className])
});
class Nd extends cr {
  constructor() {
    super(...arguments), Object.defineProperty(this, "processor", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  /**
   * @ignore
   */
  incrementRef() {
  }
  /**
   * @ignore
   */
  decrementRef() {
  }
  _onPush(e) {
    this.processor && this.processor.processRow(e), super._onPush(e);
  }
  _onInsertIndex(e, t) {
    this.processor && this.processor.processRow(t), super._onInsertIndex(e, t);
  }
  _onSetIndex(e, t, s) {
    this.processor && this.processor.processRow(s), super._onSetIndex(e, t, s);
  }
}
class jw {
  constructor(e) {
    Object.defineProperty(this, "processor", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_value", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._value = e;
  }
  incrementRef() {
  }
  decrementRef() {
  }
}
class Gt extends Md {
  constructor(e, t, s) {
    super(s), Object.defineProperty(this, "component", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "dataContext", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "bullets", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "open", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "close", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.dataContext = t, this.component = e, this._settings.visible = !0, this._checkDirty();
  }
  /**
   * @ignore
   */
  markDirty() {
    this.component.markDirtyValues(this);
  }
  _startAnimation() {
    this.component._root._addAnimation(this);
  }
  _animationTime() {
    return this.component._root.animationTime;
  }
  _dispose() {
    this.component && this.component.disposeDataItem(this), super._dispose();
  }
  /**
   * Shows a data item that's currently hidden.
   */
  show(e) {
    this.setRaw("visible", !0), this.component && this.component.showDataItem(this, e);
  }
  /**
   * Hides a data item that's currently visible.
   */
  hide(e) {
    this.setRaw("visible", !1), this.component && this.component.hideDataItem(this, e);
  }
  isHidden() {
    return !this.get("visible");
  }
}
class $i extends Z {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new Nd()
    }), Object.defineProperty(this, "_dataItems", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_mainDataItems", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._dataItems
    }), Object.defineProperty(this, "valueFields", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "fields", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["id"]
    }), Object.defineProperty(this, "_valueFields", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_valueFieldsF", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_fields", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_fieldsF", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_valuesDirty", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_dataChanged", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_dataGrouped", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "inited", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    });
  }
  /**
   * Component's data.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/data/} for more info
   */
  set data(e) {
    e.incrementRef(), this._data.decrementRef(), this._data = e;
  }
  /**
   * @return  Data
   */
  get data() {
    return this._data;
  }
  _dispose() {
    super._dispose(), this._data.decrementRef();
  }
  _onDataClear() {
  }
  _afterNew() {
    super._afterNew(), this._data.incrementRef(), this._updateFields(), this._disposers.push(this.data.events.onAll((e) => {
      const t = this._mainDataItems;
      if (this.markDirtyValues(), this._markDirtyGroup(), this._dataChanged = !0, e.type === "clear")
        x(t, (s) => {
          s.dispose();
        }), t.length = 0, this._onDataClear();
      else if (e.type === "push") {
        const s = new Gt(this, e.newValue, this._makeDataItem(e.newValue));
        t.push(s), this.processDataItem(s);
      } else if (e.type === "setIndex") {
        const s = t[e.index], r = this._makeDataItem(e.newValue);
        s.bullets = void 0, Be(r).forEach((n) => {
          s.animate({
            key: n,
            to: r[n],
            duration: this.get("interpolationDuration", 0),
            easing: this.get("interpolationEasing")
          });
        }), s.dataContext = e.newValue;
      } else if (e.type === "insertIndex") {
        const s = new Gt(this, e.newValue, this._makeDataItem(e.newValue));
        t.splice(e.index, 0, s), this.processDataItem(s);
      } else if (e.type === "removeIndex")
        t[e.index].dispose(), t.splice(e.index, 1);
      else if (e.type === "moveIndex") {
        const s = t[e.oldIndex];
        t.splice(e.oldIndex, 1), t.splice(e.newIndex, 0, s);
      } else
        throw new Error("Unknown IStreamEvent type");
      this._afterDataChange();
    }));
  }
  _updateFields() {
    this.valueFields && (this._valueFields = [], this._valueFieldsF = {}, x(this.valueFields, (e) => {
      this.get(e + "Field") && (this._valueFields.push(e), this._valueFieldsF[e] = { fieldKey: e + "Field", workingKey: e + "Working" });
    })), this.fields && (this._fields = [], this._fieldsF = {}, x(this.fields, (e) => {
      this.get(e + "Field") && (this._fields.push(e), this._fieldsF[e] = e + "Field");
    }));
  }
  /**
   * A list of component's data items.
   *
   * @return  Data items
   */
  get dataItems() {
    return this._dataItems;
  }
  processDataItem(e) {
  }
  _makeDataItem(e) {
    const t = {};
    return this._valueFields && x(this._valueFields, (s) => {
      const r = this.get(this._valueFieldsF[s].fieldKey);
      t[s] = e[r], t[this._valueFieldsF[s].workingKey] = t[s];
    }), this._fields && x(this._fields, (s) => {
      const r = this.get(this._fieldsF[s]);
      t[s] = e[r];
    }), t;
  }
  /**
   * @ignore
   */
  makeDataItem(e) {
    let t = new Gt(this, void 0, e);
    return this.processDataItem(t), t;
  }
  /**
   * @ignore
   */
  pushDataItem(e) {
    const t = this.makeDataItem(e);
    return this._mainDataItems.push(t), t;
  }
  /**
   * @ignore
   */
  disposeDataItem(e) {
  }
  /**
   * Shows component's data item.
   *
   * @param   dataItem   Data item
   * @param   _duration  Animation duration in milliseconds
   * @return             Promise
   */
  showDataItem(e, t) {
    return Ue(this, void 0, void 0, function* () {
      e.set("visible", !0);
    });
  }
  /**
   * Hides component's data item.
   *
   * @param   dataItem   Data item
   * @param   _duration  Animation duration in milliseconds
   * @return             Promise
   */
  hideDataItem(e, t) {
    return Ue(this, void 0, void 0, function* () {
      e.set("visible", !1);
    });
  }
  _clearDirty() {
    super._clearDirty(), this._valuesDirty = !1;
  }
  _afterDataChange() {
  }
  _afterChanged() {
    if (super._afterChanged(), this._dataChanged) {
      const e = "datavalidated";
      this.events.isEnabled(e) && this.events.dispatch(e, { type: e, target: this }), this._dataChanged = !1;
    }
    this.inited = !0;
  }
  /**
   * Forces a repaint of the element which relies on data.
   *
   * @since 5.0.21
   */
  markDirtyValues(e) {
    this.markDirty(), this._valuesDirty = !0;
  }
  _markDirtyGroup() {
    this._dataGrouped = !1;
  }
  /**
   * @ignore
   */
  markDirtySize() {
    this._sizeDirty = !0, this.markDirty();
  }
}
Object.defineProperty($i, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Component"
});
Object.defineProperty($i, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Z.classNames.concat([$i.className])
});
class Fi extends De {
  _afterNew() {
    super._afterNewApplyThemes();
  }
  /**
   * @ignore
   */
  getFill(e) {
    return {
      addColorStop: (t, s) => {
      }
    };
  }
  _changed() {
    super._changed();
  }
  /**
   * @ignore
   */
  getBounds(e) {
    const t = this.get("target");
    if (t) {
      let s = t.globalBounds();
      const r = e.toLocal({ x: s.left, y: s.top }), n = e.toLocal({ x: s.right, y: s.top }), a = e.toLocal({ x: s.right, y: s.bottom }), o = e.toLocal({ x: s.left, y: s.bottom });
      return {
        left: Math.min(r.x, n.x, a.x, o.x),
        top: Math.min(r.y, n.y, a.y, o.y),
        right: Math.max(r.x, n.x, a.x, o.x),
        bottom: Math.max(r.y, n.y, a.y, o.y)
      };
    }
    return e._display.getLocalBounds();
  }
}
Object.defineProperty(Fi, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Gradient"
});
Object.defineProperty(Fi, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: De.classNames.concat([Fi.className])
});
class Vr extends Fi {
  /**
   * @ignore
   */
  getFill(e) {
    const t = this.get("rotation", 0);
    let s = this.getBounds(e), r = s.left || 0, n = s.right || 0, a = s.top || 0, o = s.bottom || 0, l = ht(t), u = qe(t), h = l * (n - r), c = u * (o - a), d = Math.max(h, c);
    const f = this._root._renderer.createLinearGradient(r, a, r + d * l, a + d * u), g = this.get("stops");
    if (g) {
      let p = 0;
      x(g, (m) => {
        let _ = m.offset;
        S(_) || (_ = p / (g.length - 1));
        let v = m.opacity;
        S(v) || (v = 1);
        let b = m.color;
        if (b) {
          const y = m.lighten;
          y && (b = X.lighten(b, y));
          const w = m.brighten;
          w && (b = X.brighten(b, w)), f.addColorStop(_, "rgba(" + b.r + "," + b.g + "," + b.b + "," + v + ")");
        }
        p++;
      });
    }
    return f;
  }
}
Object.defineProperty(Vr, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "LinearGradient"
});
Object.defineProperty(Vr, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Fi.classNames.concat([Vr.className])
});
class ca extends Z {
  constructor() {
    super(...arguments), Object.defineProperty(this, "labelContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.children.push(Z.new(this._root, {}))
    }), Object.defineProperty(this, "markerContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.children.push(Z.new(this._root, {}))
    }), Object.defineProperty(this, "startLabel", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.labelContainer.children.push(We.new(this._root, { themeTags: ["start"] }))
    }), Object.defineProperty(this, "endLabel", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.labelContainer.children.push(We.new(this._root, { themeTags: ["end"] }))
    }), Object.defineProperty(this, "markers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new Ae(ge.new({}), () => it._new(this._root, {
        themeTags: se(this.markers.template.get("themeTags", []), [this.get("orientation"), "heatlegend", "marker"])
      }, [this.markers.template]))
    });
  }
  _afterNew() {
    this._settings.themeTags = se(this._settings.themeTags, ["heatlegend", this._settings.orientation]), super._afterNew(), this.set("tooltip", At.new(this._root, {
      themeTags: ["heatlegend"]
    }));
  }
  /**
   * @ignore
   */
  makeMarker() {
    const e = this.markers.make();
    return e.states.create("disabled", {}), e;
  }
  /**
   * Moves and shows tooltip at specific value.
   *
   * Can also specify optional text to show in tooltip, as well as the color.
   *
   * @param  value  Value
   * @param  text   Text
   * @param  color  Color
   */
  showValue(e, t, s) {
    const r = this.getTooltip();
    if (r && S(e)) {
      const n = this.get("startValue", 0), a = this.get("endValue", 1), o = (e - n) / (a - n), l = this.get("startColor"), u = this.get("endColor");
      t || (t = this.getNumberFormatter().format(e)), s || (s = X.interpolate(o, l, u)), r.label.set("text", t);
      let h;
      this.get("orientation") == "vertical" ? h = this.markerContainer.toGlobal({ x: 0, y: this.innerHeight() * (1 - o) }) : h = this.markerContainer.toGlobal({ x: this.innerWidth() * o, y: 0 });
      let c = r.get("background");
      c && c.set("fill", X.interpolate(o, l, u)), r.set("pointTo", h), r.show();
    }
  }
  _prepareChildren() {
    super._prepareChildren();
    const e = this.labelContainer, t = this.get("orientation"), s = this.startLabel, r = this.endLabel, n = this.getTooltip();
    if (this.isDirty("orientation") && (t == "vertical" ? (this.markerContainer.setAll({ layout: this._root.verticalLayout, height: R }), this.set("layout", this._root.horizontalLayout), s.setAll({ y: R, x: void 0, centerY: R, centerX: R }), r.setAll({ y: 0, x: void 0, centerY: 0, centerX: R }), e.setAll({ height: R, width: void 0 }), n && n.set("pointerOrientation", "horizontal")) : (this.markerContainer.setAll({ layout: this._root.horizontalLayout, width: R }), this.set("layout", this._root.verticalLayout), s.setAll({ x: 0, y: void 0, centerX: 0, centerY: 0 }), r.setAll({ x: R, y: void 0, centerX: R, centerY: 0 }), e.setAll({ width: R, height: void 0 }), n && n.set("pointerOrientation", "vertical"))), this.isDirty("stepCount")) {
      const a = this.get("stepCount", 1), o = this.get("startColor"), l = this.get("endColor");
      if (this.markerContainer.children.clear(), a > 1)
        for (let u = 0; u < a; u++) {
          const h = this.makeMarker();
          t == "vertical" ? this.markerContainer.children.moveValue(h, 0) : this.markerContainer.children.push(h), o && l && h.set("fill", X.interpolate(u / a, o, l));
        }
      else if (a == 1) {
        const u = this.makeMarker();
        this.markerContainer.children.push(u);
        const h = Vr.new(this._root, { stops: [{ color: o }, { color: l }] });
        if (t == "vertical") {
          h.set("rotation", 90);
          let c = h.get("stops");
          c && c.reverse();
        } else
          h.set("rotation", 0);
        o && l && u.set("fillGradient", h);
      }
    }
    (this.isDirty("startText") || this.isDirty("startValue")) && s.set("text", this.get("startText", this.getNumberFormatter().format(this.get("startValue", 0)))), (this.isDirty("endText") || this.isDirty("endValue")) && r.set("text", this.get("endText", this.getNumberFormatter().format(this.get("endValue", 1))));
  }
}
Object.defineProperty(ca, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "HeatLegend"
});
Object.defineProperty(ca, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Z.classNames.concat([ca.className])
});
function $d(i) {
  return new Promise((e, t) => {
    setTimeout(e, i);
  });
}
let ao = {
  millisecond: 1,
  second: 1e3,
  minute: 6e4,
  hour: 36e5,
  day: 864e5,
  week: 6048e5,
  month: 365.242 / 12 * 864e5,
  year: 31536e6
};
function hn(i) {
  switch (i) {
    case "year":
      return;
    case "month":
      return "year";
    case "week":
      return "month";
    case "day":
      return "month";
    case "hour":
      return "day";
    case "minute":
      return "hour";
    case "second":
      return "minute";
    case "millisecond":
      return "second";
  }
}
function xt(i, e) {
  return e == null && (e = 1), ao[i] * e;
}
function Mt(i) {
  return i ? ao[i.timeUnit] * i.count : 0;
}
function Yn(i, e, t, s, r) {
  const n = i.timeUnit, a = i.count;
  if (n == "hour" || n == "minute" || n == "second" || n == "millisecond")
    return ao[i.timeUnit] * i.count;
  {
    const o = Ge(new Date(e.getTime()), n, a, t, s, void 0, r).getTime();
    let l = o + a * xt(n) * 1.05;
    return l = Ge(new Date(l), n, 1, t, s, void 0, r).getTime(), l - o;
  }
}
function Fd() {
  return new Date();
}
function Ew() {
  return Fd().getTime();
}
function Iw(i) {
  return new Date(i.getTime());
}
function cn(i, e, t, s, r) {
  if (e - i > xt(t, 1.2))
    return !0;
  let n = new Date(i), a = new Date(e);
  r && (n = r.convertLocal(n), a = r.convertLocal(a));
  let o = 0, l = 0;
  !s && t != "millisecond" && (o = n.getTimezoneOffset(), n.setUTCMinutes(n.getUTCMinutes() - o), l = a.getTimezoneOffset(), a.setUTCMinutes(a.getUTCMinutes() - l));
  let u = !1;
  switch (t) {
    case "year":
      n.getUTCFullYear() != a.getUTCFullYear() && (u = !0);
      break;
    case "month":
      (n.getUTCFullYear() != a.getUTCFullYear() || n.getUTCMonth() != a.getUTCMonth()) && (u = !0);
      break;
    case "day":
      (n.getUTCMonth() != a.getUTCMonth() || n.getUTCDate() != a.getUTCDate()) && (u = !0);
      break;
    case "hour":
      n.getUTCHours() != a.getUTCHours() && (u = !0);
      break;
    case "minute":
      n.getUTCMinutes() != a.getUTCMinutes() && (u = !0);
      break;
    case "second":
      n.getUTCSeconds() != a.getUTCSeconds() && (u = !0);
      break;
    case "millisecond":
      n.getTime() != a.getTime() && (u = !0);
      break;
  }
  if (u)
    return u;
  let h = hn(t);
  return h ? cn(i, e, h, s, r) : !1;
}
function Bd(i, e, t, s, r) {
  let n = 0;
  switch (!s && e != "millisecond" && (n = i.getTimezoneOffset(), r && (n -= r.offsetUTC(i)), i.setUTCMinutes(i.getUTCMinutes() - n)), e) {
    case "day":
      let a = i.getUTCDate();
      i.setUTCDate(a + t);
      break;
    case "second":
      let o = i.getUTCSeconds();
      i.setUTCSeconds(o + t);
      break;
    case "millisecond":
      let l = i.getUTCMilliseconds();
      i.setUTCMilliseconds(l + t);
      break;
    case "hour":
      let u = i.getUTCHours();
      i.setUTCHours(u + t);
      break;
    case "minute":
      let h = i.getUTCMinutes();
      i.setUTCMinutes(h + t);
      break;
    case "year":
      let c = i.getUTCFullYear();
      i.setUTCFullYear(c + t);
      break;
    case "month":
      let d = i.getUTCMonth();
      i.setUTCMonth(d + t);
      break;
    case "week":
      let f = i.getUTCDate();
      i.setUTCDate(f + t * 7);
      break;
  }
  if (!s && e != "millisecond" && (i.setUTCMinutes(i.getUTCMinutes() + n), e == "day" || e == "week" || e == "month" || e == "year")) {
    let a = i.getTimezoneOffset();
    if (r && (a += r.offsetUTC(i)), a != n) {
      let o = a - n;
      i.setUTCMinutes(i.getUTCMinutes() + o), i.getTimezoneOffset() != a && i.setUTCMinutes(i.getUTCMinutes() - o);
    }
  }
  return i;
}
function Ge(i, e, t, s, r, n, a) {
  if (!a || r) {
    let o = 0;
    switch (!r && e != "millisecond" && (o = i.getTimezoneOffset(), i.setUTCMinutes(i.getUTCMinutes() - o)), e) {
      case "day":
        let l = i.getUTCDate();
        if (t > 1) {
          if (n) {
            n = Ge(n, "day", 1);
            let _ = i.getTime() - n.getTime(), v = Math.floor(_ / xt("day") / t), b = xt("day", v * t);
            i.setTime(n.getTime() + b - o * xt("minute"));
          }
        } else
          i.setUTCDate(l);
        i.setUTCHours(0, 0, 0, 0);
        break;
      case "second":
        let u = i.getUTCSeconds();
        t > 1 && (u = Math.floor(u / t) * t), i.setUTCSeconds(u, 0);
        break;
      case "millisecond":
        if (t == 1)
          return i;
        let h = i.getUTCMilliseconds();
        h = Math.floor(h / t) * t, i.setUTCMilliseconds(h);
        break;
      case "hour":
        let c = i.getUTCHours();
        t > 1 && (c = Math.floor(c / t) * t), i.setUTCHours(c, 0, 0, 0);
        break;
      case "minute":
        let d = i.getUTCMinutes();
        t > 1 && (d = Math.floor(d / t) * t), i.setUTCMinutes(d, 0, 0);
        break;
      case "month":
        let f = i.getUTCMonth();
        t > 1 && (f = Math.floor(f / t) * t), i.setUTCMonth(f, 1), i.setUTCHours(0, 0, 0, 0);
        break;
      case "year":
        let g = i.getUTCFullYear();
        t > 1 && (g = Math.floor(g / t) * t), i.setUTCFullYear(g, 0, 1), i.setUTCHours(0, 0, 0, 0);
        break;
      case "week":
        let p = i.getUTCDate(), m = i.getUTCDay();
        S(s) || (s = 1), m >= s ? p = p - m + s : p = p - (7 + m) + s, i.setUTCDate(p), i.setUTCHours(0, 0, 0, 0);
        break;
    }
    if (!r && e != "millisecond" && (i.setUTCMinutes(i.getUTCMinutes() + o), e == "day" || e == "week" || e == "month" || e == "year")) {
      let l = i.getTimezoneOffset();
      if (l != o) {
        let u = l - o;
        i.setUTCMinutes(i.getUTCMinutes() + u);
      }
    }
    return i;
  } else {
    if (isNaN(i.getTime()))
      return i;
    let o = a.offsetUTC(i), l = i.getTimezoneOffset(), u = a.parseDate(i), h = u.year, c = u.month, d = u.day, f = u.hour, g = u.minute, p = u.second, m = u.millisecond, _ = u.weekday;
    switch (e) {
      case "day":
        if (t > 1 && n) {
          n = Ge(n, "day", 1, s, r, void 0, a);
          let b = i.getTime() - n.getTime(), y = Math.floor(b / xt("day") / t), w = xt("day", y * t);
          i.setTime(n.getTime() + w), u = a.parseDate(i), h = u.year, c = u.month, d = u.day;
        }
        f = 0, g = o - l, p = 0, m = 0;
        break;
      case "second":
        g += o - l, t > 1 && (p = Math.floor(p / t) * t), m = 0;
        break;
      case "millisecond":
        g += o - l, t > 1 && (m = Math.floor(m / t) * t);
        break;
      case "hour":
        t > 1 && (f = Math.floor(f / t) * t), g = o - l, p = 0, m = 0;
        break;
      case "minute":
        t > 1 && (g = Math.floor(g / t) * t), g += o - l, p = 0, m = 0;
        break;
      case "month":
        t > 1 && (c = Math.floor(c / t) * t), d = 1, f = 0, g = o - l, p = 0, m = 0;
        break;
      case "year":
        t > 1 && (h = Math.floor(h / t) * t), c = 0, d = 1, f = 0, g = o - l, p = 0, m = 0;
        break;
      case "week":
        S(s) || (s = 1), _ >= s ? d = d - _ + s : d = d - (7 + _) + s, f = 0, g = o - l, p = 0, m = 0;
        break;
    }
    i = new Date(h, c, d, f, g, p, m);
    let v = i.getTimezoneOffset();
    return v != l && i.setTime(i.getTime() + (l - v) * 6e4), i;
  }
}
function Qs(i, e, t, s) {
  let r = s[i], n = Mt(r), a = s.length - 1;
  if (i >= a)
    return Object.assign({}, s[a]);
  let o = Math.ceil(e / n);
  return e < n && i > 0 ? Object.assign({}, s[i - 1]) : o <= t ? Object.assign({}, s[i]) : i + 1 < s.length ? Qs(i + 1, e, t, s) : Object.assign({}, s[i]);
}
function Hd(i, e) {
  switch (e) {
    case "day":
      return i.getDate();
    case "second":
      return i.getSeconds();
    case "millisecond":
      return i.getMilliseconds();
    case "hour":
      return i.getHours();
    case "minute":
      return i.getMinutes();
    case "month":
      return i.getMonth();
    case "year":
      return i.getFullYear();
    case "week":
      return Gs(i);
  }
}
const Rw = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  add: Bd,
  checkChange: cn,
  chooseInterval: Qs,
  copy: Iw,
  getDateIntervalDuration: Yn,
  getDuration: xt,
  getIntervalDuration: Mt,
  getNextUnit: hn,
  getTime: Ew,
  getUnitValue: Hd,
  now: Fd,
  round: Ge,
  sleep: $d,
  timeUnitDurations: ao
}, Symbol.toStringTag, { value: "Module" }));
class ai extends $i {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_aggregatesCalculated", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_selectionAggregatesCalculated", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_dataProcessed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_psi", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_pei", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "chart", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "bullets", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new cr()
    }), Object.defineProperty(this, "bulletsContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Z.new(this._root, { width: R, height: R, position: "absolute" })
    });
  }
  _afterNew() {
    this.valueFields.push("value"), super._afterNew(), this.setPrivate("customData", {}), this._disposers.push(this.bullets.events.onAll((e) => {
      if (e.type === "clear")
        this._handleBullets(this.dataItems);
      else if (e.type === "push")
        this._handleBullets(this.dataItems);
      else if (e.type === "setIndex")
        this._handleBullets(this.dataItems);
      else if (e.type === "insertIndex")
        this._handleBullets(this.dataItems);
      else if (e.type === "removeIndex")
        this._handleBullets(this.dataItems);
      else if (e.type === "moveIndex")
        this._handleBullets(this.dataItems);
      else
        throw new Error("Unknown IListEvent type");
    }));
  }
  _dispose() {
    this.bulletsContainer.dispose(), super._dispose();
  }
  startIndex() {
    let e = this.dataItems.length;
    return Math.min(this.getPrivate("startIndex", 0), e);
  }
  endIndex() {
    let e = this.dataItems.length;
    return Math.min(this.getPrivate("endIndex", e), e);
  }
  _handleBullets(e) {
    x(e, (t) => {
      const s = t.bullets;
      s && (x(s, (r) => {
        r.dispose();
      }), t.bullets = void 0);
    }), this.markDirtyValues();
  }
  /**
   * Looks up and returns a data item by its ID.
   *
   * @param   id  ID
   * @return      Data item
   */
  getDataItemById(e) {
    return bu(this.dataItems, (t) => t.get("id") == e);
  }
  _makeBullets(e) {
    this._shouldMakeBullet(e) && (e.bullets = [], this.bullets.each((t) => {
      this._makeBullet(e, t);
    }));
  }
  _shouldMakeBullet(e) {
    return !0;
  }
  _makeBullet(e, t, s) {
    const r = t(this._root, this, e);
    if (r) {
      let n = r.get("sprite");
      n && (n._setDataItem(e), n.setRaw("position", "absolute"), this.bulletsContainer.children.push(n)), r._index = s, r.series = this, e.bullets.push(r);
    }
    return r;
  }
  _clearDirty() {
    super._clearDirty(), this._aggregatesCalculated = !1, this._selectionAggregatesCalculated = !1;
  }
  _prepareChildren() {
    super._prepareChildren();
    let e = this.startIndex(), t = this.endIndex();
    if (this.isDirty("heatRules") && (this._valuesDirty = !0), this.isPrivateDirty("baseValueSeries")) {
      const r = this.getPrivate("baseValueSeries");
      r && this._disposers.push(r.onPrivate("startIndex", () => {
        this.markDirtyValues();
      }));
    }
    if (this.get("calculateAggregates") && (this._valuesDirty && !this._dataProcessed && (this._aggregatesCalculated || (this._calculateAggregates(0, this.dataItems.length), this._aggregatesCalculated = !0)), (this._psi != e || this._pei != t) && !this._selectionAggregatesCalculated && (e === 0 && t === this.dataItems.length && this._aggregatesCalculated || this._calculateAggregates(e, t), this._selectionAggregatesCalculated = !0)), this.isDirty("tooltip")) {
      let r = this.get("tooltip");
      r && (r.hide(0), r.set("tooltipTarget", this));
    }
    if (this.isDirty("fill") || this.isDirty("stroke")) {
      let r;
      const n = this.get("legendDataItem");
      if (n && (r = n.get("markerRectangle"), r && this.isVisible())) {
        if (this.isDirty("stroke")) {
          let a = this.get("stroke");
          r.set("stroke", a);
        }
        if (this.isDirty("fill")) {
          let a = this.get("fill");
          r.set("fill", a);
        }
      }
      this.updateLegendMarker(void 0);
    }
    if (this.bullets.length > 0) {
      let r = this.startIndex(), n = this.endIndex();
      n < this.dataItems.length && n++;
      for (let a = r; a < n; a++) {
        let o = this.dataItems[a];
        o.bullets || this._makeBullets(o);
      }
    }
  }
  _calculateAggregates(e, t) {
    let s = this._valueFields;
    if (!s)
      throw new Error("No value fields are set for the series.");
    const r = {}, n = {}, a = {}, o = {}, l = {}, u = {}, h = {}, c = {}, d = {};
    x(s, (f) => {
      r[f] = 0, n[f] = 0, a[f] = 0;
    }), x(s, (f) => {
      let g = f + "Change", p = f + "ChangePercent", m = f + "ChangePrevious", _ = f + "ChangePreviousPercent", v = f + "ChangeSelection", b = f + "ChangeSelectionPercent", y = "valueY";
      (f == "valueX" || f == "openValueX" || f == "lowValueX" || f == "highValueX") && (y = "valueX");
      const w = this.getPrivate("baseValueSeries");
      for (let D = e; D < t; D++) {
        const A = this.dataItems[D];
        let T = A.get(f);
        T != null && (a[f]++, r[f] += T, n[f] += Math.abs(T), c[f] = r[f] / a[f], (o[f] > T || o[f] == null) && (o[f] = T), (l[f] < T || l[f] == null) && (l[f] = T), h[f] = T, u[f] == null && (u[f] = T, d[f] = T, w && (u[y] = w._getBase(y))), e === 0 && (A.setRaw(g, T - u[y]), A.setRaw(p, (T - u[y]) / u[y] * 100)), A.setRaw(m, T - d[y]), A.setRaw(_, (T - d[y]) / d[y] * 100), A.setRaw(v, T - u[y]), A.setRaw(b, (T - u[y]) / u[y] * 100), d[f] = T);
      }
    }), x(s, (f) => {
      this.setPrivate(f + "AverageSelection", c[f]), this.setPrivate(f + "CountSelection", a[f]), this.setPrivate(f + "SumSelection", r[f]), this.setPrivate(f + "AbsoluteSumSelection", n[f]), this.setPrivate(f + "LowSelection", o[f]), this.setPrivate(f + "HighSelection", l[f]), this.setPrivate(f + "OpenSelection", u[f]), this.setPrivate(f + "CloseSelection", h[f]);
    }), e === 0 && t === this.dataItems.length && x(s, (f) => {
      this.setPrivate(f + "Average", c[f]), this.setPrivate(f + "Count", a[f]), this.setPrivate(f + "Sum", r[f]), this.setPrivate(f + "AbsoluteSum", n[f]), this.setPrivate(f + "Low", o[f]), this.setPrivate(f + "High", l[f]), this.setPrivate(f + "Open", u[f]), this.setPrivate(f + "Close", h[f]);
    });
  }
  _updateChildren() {
    super._updateChildren(), this._psi = this.startIndex(), this._pei = this.endIndex(), this.isDirty("visible") && this.bulletsContainer.set("visible", this.get("visible"));
    const e = this.get("heatRules");
    if (this._valuesDirty && e && e.length > 0 && x(e, (t) => {
      const s = t.minValue || this.getPrivate(t.dataField + "Low") || 0, r = t.maxValue || this.getPrivate(t.dataField + "High") || 0;
      x(t.target._entities, (n) => {
        const a = n.dataItem.get(t.dataField);
        if (!S(a)) {
          t.neutral && n.set(t.key, t.neutral);
          return;
        }
        let o;
        t.logarithmic ? o = (Math.log(a) * Math.LOG10E - Math.log(s) * Math.LOG10E) / (Math.log(r) * Math.LOG10E - Math.log(s) * Math.LOG10E) : o = (a - s) / (r - s), S(a) && (!S(o) || Math.abs(o) == 1 / 0) && (o = 0.5);
        let l;
        S(t.min) ? l = t.min + (t.max - t.min) * o : t.min instanceof X ? l = X.interpolate(o, t.min, t.max) : t.min instanceof ne && (l = vd(o, t.min, t.max)), t.customFunction ? t.customFunction.call(this, n, s, r, a) : n.set(t.key, l);
      });
    }), this.bullets.length > 0) {
      let t = this.dataItems.length, s = this.startIndex(), r = this.endIndex();
      r < t && r++, s > 0 && s--;
      for (let n = 0; n < s; n++)
        this._hideBullets(this.dataItems[n]);
      for (let n = s; n < r; n++)
        this._positionBullets(this.dataItems[n]);
      for (let n = r; n < t; n++)
        this._hideBullets(this.dataItems[n]);
    }
  }
  _positionBullets(e) {
    e.bullets && x(e.bullets, (t) => {
      this._positionBullet(t);
      const s = t.get("sprite");
      t.get("dynamic") && (s && (s._markDirtyKey("fill"), s.markDirtySize()), s instanceof Z && s.walkChildren((r) => {
        r._markDirtyKey("fill"), r.markDirtySize(), r instanceof We && r.text.markDirtyText();
      })), s instanceof We && s.get("populateText") && s.text.markDirtyText();
    });
  }
  _hideBullets(e) {
    e.bullets && x(e.bullets, (t) => {
      let s = t.get("sprite");
      s && s.setPrivate("visible", !1);
    });
  }
  _positionBullet(e) {
  }
  _placeBulletsContainer(e) {
    e.bulletsContainer.children.moveValue(this.bulletsContainer);
  }
  _removeBulletsContainer() {
    const e = this.bulletsContainer;
    e.parent && e.parent.children.removeValue(e);
  }
  /**
   * @ignore
   */
  disposeDataItem(e) {
    const t = e.bullets;
    t && x(t, (s) => {
      s.dispose();
    });
  }
  _getItemReaderLabel() {
    return "";
  }
  /**
   * Shows series's data item.
   *
   * @param   dataItem  Data item
   * @param   duration  Animation duration in milliseconds
   * @return            Promise
   */
  showDataItem(e, t) {
    const s = Object.create(null, {
      showDataItem: { get: () => super.showDataItem }
    });
    return Ue(this, void 0, void 0, function* () {
      const r = [s.showDataItem.call(this, e, t)], n = e.bullets;
      n && x(n, (a) => {
        r.push(a.get("sprite").show(t));
      }), yield Promise.all(r);
    });
  }
  /**
   * Hides series's data item.
   *
   * @param   dataItem  Data item
   * @param   duration  Animation duration in milliseconds
   * @return            Promise
   */
  hideDataItem(e, t) {
    const s = Object.create(null, {
      hideDataItem: { get: () => super.hideDataItem }
    });
    return Ue(this, void 0, void 0, function* () {
      const r = [s.hideDataItem.call(this, e, t)], n = e.bullets;
      n && x(n, (a) => {
        r.push(a.get("sprite").hide(t));
      }), yield Promise.all(r);
    });
  }
  _sequencedShowHide(e, t) {
    return Ue(this, void 0, void 0, function* () {
      if (this.get("sequencedInterpolation"))
        if (S(t) || (t = this.get("interpolationDuration", 0)), t > 0) {
          const s = this.startIndex(), r = this.endIndex();
          yield Promise.all(qn(this.dataItems, (n, a) => Ue(this, void 0, void 0, function* () {
            let o = t || 0;
            (a < s - 10 || a > r + 10) && (o = 0);
            let l = this.get("sequencedDelay", 0) + o / (r - s);
            yield $d(l * (a - s)), e ? yield this.showDataItem(n, o) : yield this.hideDataItem(n, o);
          })));
        } else
          yield Promise.all(qn(this.dataItems, (s) => e ? this.showDataItem(s, 0) : this.hideDataItem(s, 0)));
    });
  }
  /**
   * @ignore
   */
  updateLegendValue(e) {
    if (e) {
      const t = e.get("legendDataItem");
      if (t) {
        const s = t.get("valueLabel");
        if (s) {
          const n = s.text;
          let a = "";
          s._setDataItem(e), a = this.get("legendValueText", n.get("text", "")), s.set("text", a), n.markDirtyText();
        }
        const r = t.get("label");
        if (r) {
          const n = r.text;
          let a = "";
          r._setDataItem(e), a = this.get("legendLabelText", n.get("text", "")), r.set("text", a), n.markDirtyText();
        }
      }
    }
  }
  /**
   * @ignore
   */
  updateLegendMarker(e) {
  }
  _onHide() {
    super._onHide();
    const e = this.getTooltip();
    e && e.hide();
  }
  /**
   * @ignore
   */
  hoverDataItem(e) {
  }
  /**
   * @ignore
   */
  unhoverDataItem(e) {
  }
  /**
   * @ignore
   */
  _getBase(e) {
    const t = this.dataItems[this.startIndex()];
    return t ? t.get(e) : 0;
  }
}
Object.defineProperty(ai, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Series"
});
Object.defineProperty(ai, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: $i.classNames.concat([ai.className])
});
class Js extends ai {
  constructor() {
    super(...arguments), Object.defineProperty(this, "itemContainers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new Ae(ge.new({}), () => Z._new(this._root, {
        themeTags: se(this.itemContainers.template.get("themeTags", []), ["legend", "item"]),
        themeTagsSelf: se(this.itemContainers.template.get("themeTagsSelf", []), ["itemcontainer"]),
        background: it.new(this._root, {
          themeTags: se(this.itemContainers.template.get("themeTags", []), ["legend", "item", "background"]),
          themeTagsSelf: se(this.itemContainers.template.get("themeTagsSelf", []), ["itemcontainer"])
        })
      }, [this.itemContainers.template]))
    }), Object.defineProperty(this, "markers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new Ae(ge.new({}), () => Z._new(this._root, {
        themeTags: se(this.markers.template.get("themeTags", []), ["legend", "marker"])
      }, [this.markers.template]))
    }), Object.defineProperty(this, "labels", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new Ae(ge.new({}), () => We._new(this._root, {
        themeTags: se(this.labels.template.get("themeTags", []), ["legend", "label"])
      }, [this.labels.template]))
    }), Object.defineProperty(this, "valueLabels", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new Ae(ge.new({}), () => We._new(this._root, {
        themeTags: se(this.valueLabels.template.get("themeTags", []), ["legend", "label", "value"])
      }, [this.valueLabels.template]))
    }), Object.defineProperty(this, "markerRectangles", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new Ae(ge.new({}), () => it._new(this._root, {
        themeTags: se(this.markerRectangles.template.get("themeTags", []), ["legend", "marker", "rectangle"])
      }, [this.markerRectangles.template]))
    });
  }
  _afterNew() {
    this._settings.themeTags = se(this._settings.themeTags, ["legend"]), this.fields.push("name", "stroke", "fill"), super._afterNew();
  }
  /**
   * @ignore
   */
  makeItemContainer(e) {
    const t = this.children.push(this.itemContainers.make());
    return t._setDataItem(e), this.itemContainers.push(t), t.states.create("disabled", {}), t;
  }
  /**
   * @ignore
   */
  makeMarker() {
    const e = this.markers.make();
    return this.markers.push(e), e.states.create("disabled", {}), e;
  }
  /**
   * @ignore
   */
  makeLabel() {
    const e = this.labels.make();
    return e.states.create("disabled", {}), e;
  }
  /**
   * @ignore
   */
  makeValueLabel() {
    const e = this.valueLabels.make();
    return e.states.create("disabled", {}), e;
  }
  /**
   * @ignore
   */
  makeMarkerRectangle() {
    const e = this.markerRectangles.make();
    return e.states.create("disabled", {}), e;
  }
  processDataItem(e) {
    super.processDataItem(e);
    const t = this.makeItemContainer(e), s = this.get("nameField"), r = this.get("fillField"), n = this.get("strokeField");
    if (t) {
      const o = this.get("clickTarget", "itemContainer"), l = e.dataContext;
      l && l.set && l.set("legendDataItem", e), t._setDataItem(e), e.set("itemContainer", t);
      const u = this.makeMarker();
      if (u) {
        t.children.push(u), u._setDataItem(e), e.set("marker", u);
        const d = this.get("useDefaultMarker"), f = u.children.push(this.makeMarkerRectangle());
        let g = e.get("fill"), p = e.get("stroke");
        e.set("markerRectangle", f), l && l.get && (g = l.get(r, g), p = l.get(n, p)), p || (p = g), d ? l.on && (l.on(r, () => {
          f.set("fill", l.get(r));
        }), l.on(n, () => {
          f.set("stroke", l.get(n));
        })) : l && l.createLegendMarker && l.createLegendMarker(), f.setAll({ fill: g, stroke: p });
        const m = l.component;
        m && m.updateLegendMarker && m.updateLegendMarker(l);
      }
      const h = this.makeLabel();
      if (h) {
        t.children.push(h), h._setDataItem(e), e.set("label", h), h.text.on("text", () => {
          t.set("ariaLabel", h.text._getText() + "; " + this._t("Press ENTER to toggle"));
        }), l && l.get && e.set("name", l.get(s));
        let d = e.get("name");
        d && h.set("text", d);
      }
      const c = this.makeValueLabel();
      if (c && (t.children.push(c), c._setDataItem(e), e.set("valueLabel", c)), l && l.show && (this._disposers.push(l.on("visible", (d) => {
        t.set("disabled", !d);
      })), l.get("visible") || t.set("disabled", !0), o != "none")) {
        var a = t;
        o == "marker" && (a = u), this._addClickEvents(a, l, e);
      }
      this.children.values.sort((d, f) => {
        var g = d.dataItem.dataContext, p = f.dataItem.dataContext;
        if (g && p) {
          var m = this.data.indexOf(g), _ = this.data.indexOf(p);
          if (m > _)
            return 1;
          if (m < _)
            return -1;
        }
        return 0;
      }), l && l.updateLegendValue && l.updateLegendValue();
    }
  }
  _addClickEvents(e, t, s) {
    e.set("cursorOverStyle", "pointer"), e.events.on("pointerover", () => {
      const r = t.component;
      r && r.hoverDataItem && r.hoverDataItem(t);
    }), e.events.on("pointerout", () => {
      const r = t.component;
      r && r.hoverDataItem && r.unhoverDataItem(t);
    }), e.events.on("click", () => {
      const r = s.get("label").text._getText();
      t.show && t.isHidden && (t.isHidden() || t.get("visible") === !1) ? (t.show(), e.set("disabled", !1), this._root.readerAlert(this._t("%1 shown", this._root.locale, r))) : t.hide && (t.hide(), e.set("disabled", !0), this._root.readerAlert(this._t("%1 hidden", this._root.locale, r)));
    });
  }
  /**
   * @ignore
   */
  disposeDataItem(e) {
    super.disposeDataItem(e);
    const t = e.dataContext;
    t && t.get && t.get("legendDataItem") == e && t.set("legendDataItem", void 0);
    let s = e.get("itemContainer");
    s && (this.itemContainers.removeValue(s), s.dispose());
    let r = e.get("marker");
    r && (this.markers.removeValue(r), r.dispose());
    let n = e.get("markerRectangle");
    n && (this.markerRectangles.removeValue(n), n.dispose());
    let a = e.get("label");
    a && (this.labels.removeValue(a), a.dispose());
    let o = e.get("valueLabel");
    o && (this.valueLabels.removeValue(o), o.dispose());
  }
}
Object.defineProperty(Js, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Legend"
});
Object.defineProperty(Js, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: ai.classNames.concat([Js.className])
});
function ih(i, e) {
  for (let t = 0, s = e.length; t < s; t++) {
    const r = e[t];
    if (r.length > 0) {
      let n = r[0];
      if (n.length > 0) {
        let a = n[0];
        i.moveTo(a.x, a.y);
        for (let o = 0, l = r.length; o < l; o++)
          Yw(i, r[o]);
      }
    }
  }
}
function Yw(i, e) {
  for (let t = 0, s = e.length; t < s; t++) {
    const r = e[t];
    i.lineTo(r.x, r.y);
  }
}
class qs extends he {
  _beforeChanged() {
    super._beforeChanged(), (this.isDirty("points") || this.isDirty("segments") || this._sizeDirty || this.isPrivateDirty("width") || this.isPrivateDirty("height")) && (this._clear = !0);
  }
  _changed() {
    if (super._changed(), this._clear) {
      const e = this.get("points"), t = this.get("segments");
      if (e && e.length > 0) {
        let s = e[0];
        this._display.moveTo(s.x, s.y), ih(this._display, [[e]]);
      } else if (t)
        ih(this._display, t);
      else if (!this.get("draw")) {
        let s = this.width(), r = this.height();
        this._display.moveTo(0, 0), this._display.lineTo(s, r);
      }
    }
  }
}
Object.defineProperty(qs, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Line"
});
Object.defineProperty(qs, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: he.classNames.concat([qs.className])
});
class da extends wt {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_display", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._root._renderer.makePicture(void 0)
    });
  }
  _changed() {
    if (super._changed(), this.isDirty("width")) {
      const e = this.get("width");
      this._display.width = S(e) ? e : void 0;
    }
    if (this.isDirty("height")) {
      const e = this.get("height");
      this._display.height = S(e) ? e : void 0;
    }
    if (this.isDirty("shadowColor")) {
      this._display.clear();
      const e = this.get("shadowColor");
      this._display.shadowColor = e ?? void 0;
    }
    this.isDirty("shadowBlur") && (this._display.clear(), this._display.shadowBlur = this.get("shadowBlur")), this.isDirty("shadowOffsetX") && (this._display.clear(), this._display.shadowOffsetX = this.get("shadowOffsetX")), this.isDirty("shadowOffsetY") && (this._display.clear(), this._display.shadowOffsetY = this.get("shadowOffsetY")), this.isDirty("shadowOpacity") && (this._display.clear(), this._display.shadowOpacity = this.get("shadowOpacity")), (this.isDirty("src") || this.isDirty("cors")) && (this._display.clear(), this._load());
  }
  _load() {
    const e = this.get("src");
    if (e) {
      const t = new Image();
      t.crossOrigin = this.get("cors", "anonymous"), t.src = e, t.decode().then(() => {
        this._display.image = t, this._updateSize();
      }).catch((s) => {
      });
    }
  }
  _updateSize() {
    super._updateSize();
    const e = this._display.image;
    if (e) {
      let t = this.getPrivate("width", this.get("width")), s = this.getPrivate("height", this.get("height"));
      const r = e.width && e.height ? e.width / e.height : 0;
      S(t) && S(s) ? (this._display.width = t, this._display.height = s) : S(t) && r ? s = t / r : S(s) && r ? t = s * r : (t = e.width, s = e.height), S(t) && (this._display.width = t), S(s) && (this._display.height = s), this.markDirtyBounds(), this.markDirty();
    }
  }
}
Object.defineProperty(da, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Picture"
});
Object.defineProperty(da, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: wt.classNames.concat([da.className])
});
class Wr extends Ni {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_display", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._root._renderer.makeRadialText("", this.textStyle)
    });
  }
  _afterNew() {
    super._afterNew();
  }
  _beforeChanged() {
    super._beforeChanged(), this._display.clear(), this.isDirty("textType") && (this._display.textType = this.get("textType"), this.markDirtyBounds()), this.isDirty("radius") && (this._display.radius = this.get("radius"), this.markDirtyBounds()), this.isDirty("startAngle") && (this._display.startAngle = (this.get("startAngle", 0) + 90) * ms, this.markDirtyBounds()), this.isDirty("inside") && (this._display.inside = this.get("inside"), this.markDirtyBounds()), this.isDirty("orientation") && (this._display.orientation = this.get("orientation"), this.markDirtyBounds()), this.isDirty("kerning") && (this._display.kerning = this.get("kerning"), this.markDirtyBounds());
  }
}
Object.defineProperty(Wr, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "RadialText"
});
Object.defineProperty(Wr, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Ni.classNames.concat([Wr.className])
});
class vs extends We {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_flipped", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    });
  }
  _afterNew() {
    this._textKeys.push("textType", "kerning"), super._afterNew();
  }
  _makeText() {
    this._text = this.children.push(Wr.new(this._root, {}));
  }
  /**
   * Returns base radius in pixels.
   *
   * @return Base radius
   */
  baseRadius() {
    const e = this.getPrivate("radius", 0), t = this.getPrivate("innerRadius", 0), s = this.get("baseRadius", 0);
    return t + we(s, e - t);
  }
  /**
   * Returns radius adjustment in pixels.
   *
   * @return Radius
   */
  radius() {
    const e = this.get("inside", !1);
    return this.baseRadius() + this.get("radius", 0) * (e ? -1 : 1);
  }
  _updateChildren() {
    if (super._updateChildren(), this.isDirty("baseRadius") || this.isPrivateDirty("radius") || this.isPrivateDirty("innerRadius") || this.isDirty("labelAngle") || this.isDirty("radius") || this.isDirty("inside") || this.isDirty("orientation") || this.isDirty("textType")) {
      const e = this.get("textType", "adjusted"), t = this.get("inside", !1), s = this.get("orientation");
      let r = _s(this.get("labelAngle", 0));
      this._text.set("startAngle", this.get("labelAngle", 0)), this._text.set("inside", t);
      const n = qe(r), a = ht(r);
      let o = this.baseRadius(), l = this.radius();
      if (this._display.angle = 0, e == "circular")
        this.setAll({
          paddingTop: 0,
          paddingBottom: 0,
          paddingLeft: 0,
          paddingRight: 0
        }), this._text.set("orientation", s), this._text.set("radius", l);
      else {
        o == 0 && (r = 0, l = 0);
        let u = l * a, h = l * n;
        e == "radial" ? (this.setRaw("x", u), this.setRaw("y", h), r < 90 || r > 270 || s != "auto" ? (this._display.angle = r, this._flipped = !1) : (this._display.angle = r + 180, this._flipped = !0), this._dirty.rotation = !1) : e == "adjusted" ? (this.setRaw("centerX", ie), this.setRaw("centerY", ie), this.setRaw("x", u), this.setRaw("y", h)) : e == "regular" && (this.setRaw("x", u), this.setRaw("y", h));
      }
      this.markDirtyPosition(), this.markDirtyBounds();
    }
  }
  _updatePosition() {
    const e = this.get("textType", "regular"), t = this.get("inside", !1);
    let s = 0, r = 0, n = this.get("labelAngle", 0), a = this.localBounds(), o = a.right - a.left, l = a.bottom - a.top;
    if (e == "radial") {
      if (this._flipped) {
        let u = this.get("centerX");
        u instanceof ne && (o = o * (1 - u.value * 2)), s = o * ht(n), r = o * qe(n);
      }
    } else
      !t && e == "adjusted" && (s = o / 2 * ht(n), r = l / 2 * qe(n));
    this.setRaw("dx", s), this.setRaw("dy", r), super._updatePosition();
  }
  /**
   * @ignore
   */
  get text() {
    return this._text;
  }
}
Object.defineProperty(vs, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "RadialLabel"
});
Object.defineProperty(vs, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: We.classNames.concat([vs.className])
});
class fa extends he {
  _beforeChanged() {
    super._beforeChanged(), (this.isDirty("width") || this.isDirty("height") || this.isPrivateDirty("width") || this.isPrivateDirty("height")) && (this._clear = !0);
  }
  _changed() {
    super._changed(), this._clear && !this.get("draw") && this._draw();
  }
  _draw() {
    const e = this.width(), t = this.height(), s = this._display;
    s.moveTo(-e / 2, t / 2), s.lineTo(0, -t / 2), s.lineTo(e / 2, t / 2), s.lineTo(-e / 2, t / 2), s.closePath();
  }
  _updateSize() {
    this.markDirty(), this._clear = !0;
  }
}
Object.defineProperty(fa, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Triangle"
});
Object.defineProperty(fa, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: he.classNames.concat([fa.className])
});
class yi extends Z {
  constructor() {
    super(...arguments), Object.defineProperty(this, "thumb", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._makeThumb()
    }), Object.defineProperty(this, "startGrip", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._makeButton()
    }), Object.defineProperty(this, "endGrip", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._makeButton()
    }), Object.defineProperty(this, "_thumbBusy", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_startDown", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_endDown", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_thumbDown", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_gripDown", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  _addOrientationClass() {
    this._settings.themeTags = se(this._settings.themeTags, ["scrollbar", this._settings.orientation]), this._settings.background || (this._settings.background = it.new(this._root, {
      themeTags: se(this._settings.themeTags, ["main", "background"])
    }));
  }
  _makeButton() {
    return this.children.push(Ks.new(this._root, {
      themeTags: ["resize", "button", this.get("orientation")],
      icon: he.new(this._root, {
        themeTags: ["icon"]
      })
    }));
  }
  _makeThumb() {
    return this.children.push(it.new(this._root, {
      themeTags: ["thumb", this.get("orientation")]
    }));
  }
  _handleAnimation(e) {
    e && this._disposers.push(e.events.on("stopped", () => {
      this.setPrivateRaw("isBusy", !1), this._thumbBusy = !1;
    }));
  }
  _afterNew() {
    this._addOrientationClass(), super._afterNew();
    const e = this.startGrip, t = this.endGrip, s = this.thumb, r = this.get("background");
    r && this._disposers.push(r.events.on("click", (n) => {
      this.setPrivateRaw("isBusy", !0);
      const a = this._display.toLocal(n.point), o = this.width(), l = this.height(), u = this.get("orientation");
      let h;
      u == "vertical" ? h = (a.y - s.height() / 2) / l : h = (a.x - s.width() / 2) / o;
      let c, d;
      u == "vertical" ? (c = h * l, d = "y") : (c = h * o, d = "x");
      const f = this.get("animationDuration", 0);
      f > 0 ? (this._thumbBusy = !0, this._handleAnimation(this.thumb.animate({ key: d, to: c, duration: f, easing: this.get("animationEasing") }))) : (this.thumb.set(d, c), this._root.events.once("frameended", () => {
        this.setPrivateRaw("isBusy", !1);
      }));
    })), this._disposers.push(s.events.on("dblclick", (n) => {
      if (!eo(n.originalEvent, this))
        return;
      const a = this.get("animationDuration", 0), o = this.get("animationEasing");
      this.animate({ key: "start", to: 0, duration: a, easing: o }), this.animate({ key: "end", to: 1, duration: a, easing: o });
    })), this._disposers.push(e.events.on("pointerdown", () => {
      this.setPrivateRaw("isBusy", !0), this._startDown = !0, this._gripDown = "start";
    })), this._disposers.push(t.events.on("pointerdown", () => {
      this.setPrivateRaw("isBusy", !0), this._endDown = !0, this._gripDown = "end";
    })), this._disposers.push(s.events.on("pointerdown", () => {
      this.setPrivateRaw("isBusy", !0), this._thumbDown = !0, this._gripDown = void 0;
    })), this._disposers.push(e.events.on("globalpointerup", () => {
      this._startDown && this.setPrivateRaw("isBusy", !1), this._startDown = !1;
    })), this._disposers.push(t.events.on("globalpointerup", () => {
      this._endDown && this.setPrivateRaw("isBusy", !1), this._endDown = !1;
    })), this._disposers.push(s.events.on("globalpointerup", () => {
      this._thumbDown && this.setPrivateRaw("isBusy", !1), this._thumbDown = !1;
    })), this._disposers.push(e.on("x", () => {
      this._updateThumb();
    })), this._disposers.push(t.on("x", () => {
      this._updateThumb();
    })), this._disposers.push(e.on("y", () => {
      this._updateThumb();
    })), this._disposers.push(t.on("y", () => {
      this._updateThumb();
    })), this._disposers.push(s.events.on("positionchanged", () => {
      this._updateGripsByThumb();
    })), this.get("orientation") == "vertical" ? (e.set("x", 0), t.set("x", 0), this._disposers.push(s.adapters.add("y", (n) => Math.max(Math.min(Number(n), this.height() - s.height()), 0))), this._disposers.push(s.adapters.add("x", (n) => this.width() / 2)), this._disposers.push(e.adapters.add("x", (n) => this.width() / 2)), this._disposers.push(t.adapters.add("x", (n) => this.width() / 2)), this._disposers.push(e.adapters.add("y", (n) => Math.max(Math.min(Number(n), this.height()), 0))), this._disposers.push(t.adapters.add("y", (n) => Math.max(Math.min(Number(n), this.height()), 0)))) : (e.set("y", 0), t.set("y", 0), this._disposers.push(s.adapters.add("x", (n) => Math.max(Math.min(Number(n), this.width() - s.width()), 0))), this._disposers.push(s.adapters.add("y", (n) => this.height() / 2)), this._disposers.push(e.adapters.add("y", (n) => this.height() / 2)), this._disposers.push(t.adapters.add("y", (n) => this.height() / 2)), this._disposers.push(e.adapters.add("x", (n) => Math.max(Math.min(Number(n), this.width()), 0))), this._disposers.push(t.adapters.add("x", (n) => Math.max(Math.min(Number(n), this.width()), 0))));
  }
  _updateChildren() {
    super._updateChildren(), (this.isDirty("end") || this.isDirty("start") || this._sizeDirty) && this.updateGrips();
  }
  _changed() {
    if (super._changed(), this.isDirty("start") || this.isDirty("end")) {
      const e = "rangechanged";
      this.events.isEnabled(e) && this.events.dispatch(e, { type: e, target: this, start: this.get("start", 0), end: this.get("end", 1), grip: this._gripDown });
    }
  }
  /**
   * @ignore
   */
  updateGrips() {
    const e = this.startGrip, t = this.endGrip, s = this.get("orientation"), r = this.height(), n = this.width();
    s == "vertical" ? (e.set("y", r * this.get("start", 0)), t.set("y", r * this.get("end", 1))) : (e.set("x", n * this.get("start", 0)), t.set("x", n * this.get("end", 1)));
    const a = this.getPrivate("positionTextFunction"), o = Math.round(this.get("start", 0) * 100), l = Math.round(this.get("end", 0) * 100);
    let u, h;
    a ? (u = a.call(this, this.get("start", 0)), h = a.call(this, this.get("end", 0))) : (u = o + "%", h = l + "%"), e.set("ariaLabel", this._t("From %1", void 0, u)), e.set("ariaValueNow", "" + o), e.set("ariaValueText", o + "%"), e.set("ariaValueMin", "0"), e.set("ariaValueMax", "100"), t.set("ariaLabel", this._t("To %1", void 0, h)), t.set("ariaValueNow", "" + l), t.set("ariaValueText", l + "%"), t.set("ariaValueMin", "0"), t.set("ariaValueMax", "100");
  }
  _updateThumb() {
    const e = this.thumb, t = this.startGrip, s = this.endGrip, r = this.height(), n = this.width();
    let a = t.x(), o = s.x(), l = t.y(), u = s.y(), h = 0, c = 1;
    this.get("orientation") == "vertical" ? S(l) && S(u) && (!this._thumbBusy && !e.isDragging() && (e.set("height", u - l), e.set("y", l)), h = l / r, c = u / r) : S(a) && S(o) && (!this._thumbBusy && !e.isDragging() && (e.set("width", o - a), e.set("x", a)), h = a / n, c = o / n), this.getPrivate("isBusy") && (this.get("start") != h || this.get("end") != c) && (this.set("start", h), this.set("end", c));
    const d = this.getPrivate("positionTextFunction"), f = Math.round(this.get("start", 0) * 100), g = Math.round(this.get("end", 0) * 100);
    let p, m;
    d ? (p = d.call(this, this.get("start", 0)), m = d.call(this, this.get("end", 0))) : (p = f + "%", m = g + "%"), e.set("ariaLabel", this._t("From %1 to %2", void 0, p, m)), e.set("ariaValueNow", "" + f), e.set("ariaValueText", f + "%");
  }
  _updateGripsByThumb() {
    const e = this.thumb, t = this.startGrip, s = this.endGrip;
    if (this.get("orientation") == "vertical") {
      const r = e.height();
      t.set("y", e.y()), s.set("y", e.y() + r);
    } else {
      const r = e.width();
      t.set("x", e.x()), s.set("x", e.x() + r);
    }
  }
}
Object.defineProperty(yi, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Scrollbar"
});
Object.defineProperty(yi, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Z.classNames.concat([yi.className])
});
let pa = class extends yi {
  _afterNew() {
    this._addOrientationClass(), super._afterNew(), this.endGrip.setPrivate("visible", !1), this.thumb.setPrivate("visible", !1);
  }
  /**
   * @ignore
   */
  updateGrips() {
    super.updateGrips();
    const e = this.startGrip;
    this.endGrip.setAll({ x: e.x(), y: e.y() }), this.setRaw("end", this.get("start"));
  }
};
Object.defineProperty(pa, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Slider"
});
Object.defineProperty(pa, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: yi.classNames.concat([pa.className])
});
var cl = Math.PI, dl = 2 * cl, as = 1e-6, Nw = dl - as;
function fl() {
  this._x0 = this._y0 = // start of current subpath
  this._x1 = this._y1 = null, this._ = "";
}
function oo() {
  return new fl();
}
fl.prototype = oo.prototype = {
  constructor: fl,
  moveTo: function(i, e) {
    this._ += "M" + (this._x0 = this._x1 = +i) + "," + (this._y0 = this._y1 = +e);
  },
  closePath: function() {
    this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._ += "Z");
  },
  lineTo: function(i, e) {
    this._ += "L" + (this._x1 = +i) + "," + (this._y1 = +e);
  },
  quadraticCurveTo: function(i, e, t, s) {
    this._ += "Q" + +i + "," + +e + "," + (this._x1 = +t) + "," + (this._y1 = +s);
  },
  bezierCurveTo: function(i, e, t, s, r, n) {
    this._ += "C" + +i + "," + +e + "," + +t + "," + +s + "," + (this._x1 = +r) + "," + (this._y1 = +n);
  },
  arcTo: function(i, e, t, s, r) {
    i = +i, e = +e, t = +t, s = +s, r = +r;
    var n = this._x1, a = this._y1, o = t - i, l = s - e, u = n - i, h = a - e, c = u * u + h * h;
    if (r < 0)
      throw new Error("negative radius: " + r);
    if (this._x1 === null)
      this._ += "M" + (this._x1 = i) + "," + (this._y1 = e);
    else if (c > as)
      if (!(Math.abs(h * o - l * u) > as) || !r)
        this._ += "L" + (this._x1 = i) + "," + (this._y1 = e);
      else {
        var d = t - n, f = s - a, g = o * o + l * l, p = d * d + f * f, m = Math.sqrt(g), _ = Math.sqrt(c), v = r * Math.tan((cl - Math.acos((g + c - p) / (2 * m * _))) / 2), b = v / _, y = v / m;
        Math.abs(b - 1) > as && (this._ += "L" + (i + b * u) + "," + (e + b * h)), this._ += "A" + r + "," + r + ",0,0," + +(h * d > u * f) + "," + (this._x1 = i + y * o) + "," + (this._y1 = e + y * l);
      }
  },
  arc: function(i, e, t, s, r, n) {
    i = +i, e = +e, t = +t, n = !!n;
    var a = t * Math.cos(s), o = t * Math.sin(s), l = i + a, u = e + o, h = 1 ^ n, c = n ? s - r : r - s;
    if (t < 0)
      throw new Error("negative radius: " + t);
    this._x1 === null ? this._ += "M" + l + "," + u : (Math.abs(this._x1 - l) > as || Math.abs(this._y1 - u) > as) && (this._ += "L" + l + "," + u), t && (c < 0 && (c = c % dl + dl), c > Nw ? this._ += "A" + t + "," + t + ",0,1," + h + "," + (i - a) + "," + (e - o) + "A" + t + "," + t + ",0,1," + h + "," + (this._x1 = l) + "," + (this._y1 = u) : c > as && (this._ += "A" + t + "," + t + ",0," + +(c >= cl) + "," + h + "," + (this._x1 = i + t * Math.cos(r)) + "," + (this._y1 = e + t * Math.sin(r))));
  },
  rect: function(i, e, t, s) {
    this._ += "M" + (this._x0 = this._x1 = +i) + "," + (this._y0 = this._y1 = +e) + "h" + +t + "v" + +s + "h" + -t + "Z";
  },
  toString: function() {
    return this._;
  }
};
function $e(i) {
  return function() {
    return i;
  };
}
var sh = Math.abs, st = Math.atan2, es = Math.cos, $w = Math.max, So = Math.min, Jt = Math.sin, Ns = Math.sqrt, bt = 1e-12, Ur = Math.PI, ga = Ur / 2, Fw = 2 * Ur;
function Bw(i) {
  return i > 1 ? 0 : i < -1 ? Ur : Math.acos(i);
}
function rh(i) {
  return i >= 1 ? ga : i <= -1 ? -ga : Math.asin(i);
}
function Hw(i) {
  return i.innerRadius;
}
function zw(i) {
  return i.outerRadius;
}
function Xw(i) {
  return i.startAngle;
}
function Vw(i) {
  return i.endAngle;
}
function Ww(i) {
  return i && i.padAngle;
}
function Uw(i, e, t, s, r, n, a, o) {
  var l = t - i, u = s - e, h = a - r, c = o - n, d = c * l - h * u;
  if (!(d * d < bt))
    return d = (h * (e - n) - c * (i - r)) / d, [i + d * l, e + d * u];
}
function Sn(i, e, t, s, r, n, a) {
  var o = i - t, l = e - s, u = (a ? n : -n) / Ns(o * o + l * l), h = u * l, c = -u * o, d = i + h, f = e + c, g = t + h, p = s + c, m = (d + g) / 2, _ = (f + p) / 2, v = g - d, b = p - f, y = v * v + b * b, w = r - n, D = d * p - g * f, A = (b < 0 ? -1 : 1) * Ns($w(0, w * w * y - D * D)), T = (D * b - v * A) / y, j = (-D * v - b * A) / y, C = (D * b + v * A) / y, L = (-D * v + b * A) / y, E = T - m, N = j - _, J = C - m, z = L - _;
  return E * E + N * N > J * J + z * z && (T = C, j = L), {
    cx: T,
    cy: j,
    x01: -h,
    y01: -c,
    x11: T * (r / w - 1),
    y11: j * (r / w - 1)
  };
}
function Gw() {
  var i = Hw, e = zw, t = $e(0), s = null, r = Xw, n = Vw, a = Ww, o = null;
  function l() {
    var u, h, c = +i.apply(this, arguments), d = +e.apply(this, arguments), f = r.apply(this, arguments) - ga, g = n.apply(this, arguments) - ga, p = sh(g - f), m = g > f;
    if (o || (o = u = oo()), d < c && (h = d, d = c, c = h), !(d > bt))
      o.moveTo(0, 0);
    else if (p > Fw - bt)
      o.moveTo(d * es(f), d * Jt(f)), o.arc(0, 0, d, f, g, !m), c > bt && (o.moveTo(c * es(g), c * Jt(g)), o.arc(0, 0, c, g, f, m));
    else {
      var _ = f, v = g, b = f, y = g, w = p, D = p, A = a.apply(this, arguments) / 2, T = A > bt && (s ? +s.apply(this, arguments) : Ns(c * c + d * d)), j = So(sh(d - c) / 2, +t.apply(this, arguments)), C = j, L = j, E, N;
      if (T > bt) {
        var J = rh(T / c * Jt(A)), z = rh(T / d * Jt(A));
        (w -= J * 2) > bt ? (J *= m ? 1 : -1, b += J, y -= J) : (w = 0, b = y = (f + g) / 2), (D -= z * 2) > bt ? (z *= m ? 1 : -1, _ += z, v -= z) : (D = 0, _ = v = (f + g) / 2);
      }
      var H = d * es(_), Y = d * Jt(_), U = c * es(y), B = c * Jt(y);
      if (j > bt) {
        var ue = d * es(v), O = d * Jt(v), k = c * es(b), M = c * Jt(b), $;
        if (p < Ur && ($ = Uw(H, Y, k, M, ue, O, U, B))) {
          var q = H - $[0], W = Y - $[1], fe = ue - $[0], ve = O - $[1], Dt = 1 / Jt(Bw((q * fe + W * ve) / (Ns(q * q + W * W) * Ns(fe * fe + ve * ve))) / 2), Qi = Ns($[0] * $[0] + $[1] * $[1]);
          C = So(j, (c - Qi) / (Dt - 1)), L = So(j, (d - Qi) / (Dt + 1));
        }
      }
      D > bt ? L > bt ? (E = Sn(k, M, H, Y, d, L, m), N = Sn(ue, O, U, B, d, L, m), o.moveTo(E.cx + E.x01, E.cy + E.y01), L < j ? o.arc(E.cx, E.cy, L, st(E.y01, E.x01), st(N.y01, N.x01), !m) : (o.arc(E.cx, E.cy, L, st(E.y01, E.x01), st(E.y11, E.x11), !m), o.arc(0, 0, d, st(E.cy + E.y11, E.cx + E.x11), st(N.cy + N.y11, N.cx + N.x11), !m), o.arc(N.cx, N.cy, L, st(N.y11, N.x11), st(N.y01, N.x01), !m))) : (o.moveTo(H, Y), o.arc(0, 0, d, _, v, !m)) : o.moveTo(H, Y), !(c > bt) || !(w > bt) ? o.lineTo(U, B) : C > bt ? (E = Sn(U, B, ue, O, c, -C, m), N = Sn(H, Y, k, M, c, -C, m), o.lineTo(E.cx + E.x01, E.cy + E.y01), C < j ? o.arc(E.cx, E.cy, C, st(E.y01, E.x01), st(N.y01, N.x01), !m) : (o.arc(E.cx, E.cy, C, st(E.y01, E.x01), st(E.y11, E.x11), !m), o.arc(0, 0, c, st(E.cy + E.y11, E.cx + E.x11), st(N.cy + N.y11, N.cx + N.x11), m), o.arc(N.cx, N.cy, C, st(N.y11, N.x11), st(N.y01, N.x01), !m))) : o.arc(0, 0, c, y, b, m);
    }
    if (o.closePath(), u)
      return o = null, u + "" || null;
  }
  return l.centroid = function() {
    var u = (+i.apply(this, arguments) + +e.apply(this, arguments)) / 2, h = (+r.apply(this, arguments) + +n.apply(this, arguments)) / 2 - Ur / 2;
    return [es(h) * u, Jt(h) * u];
  }, l.innerRadius = function(u) {
    return arguments.length ? (i = typeof u == "function" ? u : $e(+u), l) : i;
  }, l.outerRadius = function(u) {
    return arguments.length ? (e = typeof u == "function" ? u : $e(+u), l) : e;
  }, l.cornerRadius = function(u) {
    return arguments.length ? (t = typeof u == "function" ? u : $e(+u), l) : t;
  }, l.padRadius = function(u) {
    return arguments.length ? (s = u == null ? null : typeof u == "function" ? u : $e(+u), l) : s;
  }, l.startAngle = function(u) {
    return arguments.length ? (r = typeof u == "function" ? u : $e(+u), l) : r;
  }, l.endAngle = function(u) {
    return arguments.length ? (n = typeof u == "function" ? u : $e(+u), l) : n;
  }, l.padAngle = function(u) {
    return arguments.length ? (a = typeof u == "function" ? u : $e(+u), l) : a;
  }, l.context = function(u) {
    return arguments.length ? (o = u ?? null, l) : o;
  }, l;
}
function zd(i) {
  this._context = i;
}
zd.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(i, e) {
    switch (i = +i, e = +e, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(i, e) : this._context.moveTo(i, e);
        break;
      case 1:
        this._point = 2;
      default:
        this._context.lineTo(i, e);
        break;
    }
  }
};
function Xd(i) {
  return new zd(i);
}
function Vd(i) {
  return i[0];
}
function Wd(i) {
  return i[1];
}
function Ud() {
  var i = Vd, e = Wd, t = $e(!0), s = null, r = Xd, n = null;
  function a(o) {
    var l, u = o.length, h, c = !1, d;
    for (s == null && (n = r(d = oo())), l = 0; l <= u; ++l)
      !(l < u && t(h = o[l], l, o)) === c && ((c = !c) ? n.lineStart() : n.lineEnd()), c && n.point(+i(h, l, o), +e(h, l, o));
    if (d)
      return n = null, d + "" || null;
  }
  return a.x = function(o) {
    return arguments.length ? (i = typeof o == "function" ? o : $e(+o), a) : i;
  }, a.y = function(o) {
    return arguments.length ? (e = typeof o == "function" ? o : $e(+o), a) : e;
  }, a.defined = function(o) {
    return arguments.length ? (t = typeof o == "function" ? o : $e(!!o), a) : t;
  }, a.curve = function(o) {
    return arguments.length ? (r = o, s != null && (n = r(s)), a) : r;
  }, a.context = function(o) {
    return arguments.length ? (o == null ? s = n = null : n = r(s = o), a) : s;
  }, a;
}
function Zw() {
  var i = Vd, e = null, t = $e(0), s = Wd, r = $e(!0), n = null, a = Xd, o = null;
  function l(h) {
    var c, d, f, g = h.length, p, m = !1, _, v = new Array(g), b = new Array(g);
    for (n == null && (o = a(_ = oo())), c = 0; c <= g; ++c) {
      if (!(c < g && r(p = h[c], c, h)) === m)
        if (m = !m)
          d = c, o.areaStart(), o.lineStart();
        else {
          for (o.lineEnd(), o.lineStart(), f = c - 1; f >= d; --f)
            o.point(v[f], b[f]);
          o.lineEnd(), o.areaEnd();
        }
      m && (v[c] = +i(p, c, h), b[c] = +t(p, c, h), o.point(e ? +e(p, c, h) : v[c], s ? +s(p, c, h) : b[c]));
    }
    if (_)
      return o = null, _ + "" || null;
  }
  function u() {
    return Ud().defined(r).curve(a).context(n);
  }
  return l.x = function(h) {
    return arguments.length ? (i = typeof h == "function" ? h : $e(+h), e = null, l) : i;
  }, l.x0 = function(h) {
    return arguments.length ? (i = typeof h == "function" ? h : $e(+h), l) : i;
  }, l.x1 = function(h) {
    return arguments.length ? (e = h == null ? null : typeof h == "function" ? h : $e(+h), l) : e;
  }, l.y = function(h) {
    return arguments.length ? (t = typeof h == "function" ? h : $e(+h), s = null, l) : t;
  }, l.y0 = function(h) {
    return arguments.length ? (t = typeof h == "function" ? h : $e(+h), l) : t;
  }, l.y1 = function(h) {
    return arguments.length ? (s = h == null ? null : typeof h == "function" ? h : $e(+h), l) : s;
  }, l.lineX0 = l.lineY0 = function() {
    return u().x(i).y(t);
  }, l.lineY1 = function() {
    return u().x(i).y(s);
  }, l.lineX1 = function() {
    return u().x(e).y(t);
  }, l.defined = function(h) {
    return arguments.length ? (r = typeof h == "function" ? h : $e(!!h), l) : r;
  }, l.curve = function(h) {
    return arguments.length ? (a = h, n != null && (o = a(n)), l) : a;
  }, l.context = function(h) {
    return arguments.length ? (h == null ? n = o = null : o = a(n = h), l) : n;
  }, l;
}
function nh(i, e, t) {
  i._context.bezierCurveTo(
    i._x1 + i._k * (i._x2 - i._x0),
    i._y1 + i._k * (i._y2 - i._y0),
    i._x2 + i._k * (i._x1 - e),
    i._y2 + i._k * (i._y1 - t),
    i._x2,
    i._y2
  );
}
function Gd(i, e) {
  this._context = i, this._k = (1 - e) / 6;
}
Gd.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        nh(this, this._x1, this._y1);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(i, e) {
    switch (i = +i, e = +e, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(i, e) : this._context.moveTo(i, e);
        break;
      case 1:
        this._point = 2, this._x1 = i, this._y1 = e;
        break;
      case 2:
        this._point = 3;
      default:
        nh(this, i, e);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = i, this._y0 = this._y1, this._y1 = this._y2, this._y2 = e;
  }
};
const ah = function i(e) {
  function t(s) {
    return new Gd(s, e);
  }
  return t.tension = function(s) {
    return i(+s);
  }, t;
}(0);
function Zd(i, e) {
  this._context = i, this._t = e;
}
Zd.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN, this._point = 0;
  },
  lineEnd: function() {
    0 < this._t && this._t < 1 && this._point === 2 && this._context.lineTo(this._x, this._y), (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line >= 0 && (this._t = 1 - this._t, this._line = 1 - this._line);
  },
  point: function(i, e) {
    switch (i = +i, e = +e, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(i, e) : this._context.moveTo(i, e);
        break;
      case 1:
        this._point = 2;
      default: {
        if (this._t <= 0)
          this._context.lineTo(this._x, e), this._context.lineTo(i, e);
        else {
          var t = this._x * (1 - this._t) + i * this._t;
          this._context.lineTo(t, this._y), this._context.lineTo(t, e);
        }
        break;
      }
    }
    this._x = i, this._y = e;
  }
};
function Kw(i) {
  return new Zd(i, 1);
}
class Gr extends he {
  constructor() {
    super(...arguments), Object.defineProperty(this, "ix", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "iy", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_generator", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Gw()
    });
  }
  _getTooltipPoint() {
    let e = this.get("tooltipX"), t = this.get("tooltipY"), s = 0, r = 0;
    S(e) && (s = e), S(t) && (r = t);
    let n = this.get("radius", 0), a = this.get("innerRadius", 0), o = this.get("dRadius", 0), l = this.get("dInnerRadius", 0);
    return n += o, a += l, a < 0 && (a = n + a), e instanceof ne && (s = this.ix * (a + (n - a) * e.value)), t instanceof ne && (r = this.iy * (a + (n - a) * t.value)), this.get("arc") >= 360 && a == 0 && (s = 0, r = 0), { x: s, y: r };
  }
  _beforeChanged() {
    super._beforeChanged(), (this.isDirty("radius") || this.isDirty("arc") || this.isDirty("innerRadius") || this.isDirty("startAngle") || this.isDirty("dRadius") || this.isDirty("dInnerRadius") || this.isDirty("cornerRadius")) && (this._clear = !0);
  }
  _changed() {
    if (super._changed(), this._clear) {
      let e = this.get("startAngle", 0), t = this.get("arc", 0);
      const s = this._generator;
      t < 0 && (e = e + t, t = t * -1), t > 0.1 && s.cornerRadius(this.get("cornerRadius", 0)), s.context(this._display);
      let r = this.get("radius", 0), n = this.get("innerRadius", 0), a = this.get("dRadius", 0), o = this.get("dInnerRadius", 0);
      r += a, n += o, n < 0 && (n = r + n), s({ innerRadius: n, outerRadius: r, startAngle: (e + 90) * ms, endAngle: (e + t + 90) * ms });
      let l = e + t / 2;
      this.ix = ht(l), this.iy = qe(l);
    }
    if (this.isDirty("shiftRadius")) {
      const e = this.get("shiftRadius", 0);
      this.setRaw("dx", this.ix * e), this.setRaw("dy", this.iy * e), this.markDirtyPosition();
    }
  }
}
Object.defineProperty(Gr, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Slice"
});
Object.defineProperty(Gr, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: he.classNames.concat([Gr.className])
});
class er extends Z {
  constructor() {
    super(...arguments), Object.defineProperty(this, "chartContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.children.push(Z.new(this._root, { width: R, height: R, interactiveChildren: !1 }))
    }), Object.defineProperty(this, "bulletsContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Z.new(this._root, { interactiveChildren: !1, isMeasured: !1, position: "absolute", width: R, height: R })
    });
  }
}
Object.defineProperty(er, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Chart"
});
Object.defineProperty(er, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Z.classNames.concat([er.className])
});
class Bi extends er {
  constructor() {
    super(...arguments), Object.defineProperty(this, "seriesContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Z.new(this._root, { width: R, height: R, isMeasured: !1 })
    }), Object.defineProperty(this, "series", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new ia()
    });
  }
  _afterNew() {
    super._afterNew(), this._disposers.push(this.series);
    const e = this.seriesContainer.children;
    this._disposers.push(this.series.events.onAll((t) => {
      if (t.type === "clear") {
        x(t.oldValues, (r) => {
          this._removeSeries(r);
        });
        const s = this.get("colors");
        s && s.reset();
      } else if (t.type === "push")
        e.moveValue(t.newValue), this._processSeries(t.newValue);
      else if (t.type === "setIndex")
        e.setIndex(t.index, t.newValue), this._processSeries(t.newValue);
      else if (t.type === "insertIndex")
        e.insertIndex(t.index, t.newValue), this._processSeries(t.newValue);
      else if (t.type === "removeIndex")
        this._removeSeries(t.oldValue);
      else if (t.type === "moveIndex")
        e.moveValue(t.value, t.newIndex), this._processSeries(t.value);
      else
        throw new Error("Unknown IListEvent type");
    }));
  }
  _processSeries(e) {
    e.chart = this, e._placeBulletsContainer(this);
  }
  _removeSeries(e) {
    e.isDisposed() || (this.seriesContainer.children.removeValue(e), e._removeBulletsContainer());
  }
}
Object.defineProperty(Bi, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "SerialChart"
});
Object.defineProperty(Bi, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: er.classNames.concat([Bi.className])
});
class xs extends qs {
}
Object.defineProperty(xs, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Tick"
});
Object.defineProperty(xs, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: qs.classNames.concat([xs.className])
});
class ma extends Fi {
  /**
   * @ignore
   */
  getFill(e) {
    const t = this.getBounds(e);
    let s = 0, r = 0, n = t.left || 0, a = t.right || 0, o = t.top || 0, l = t.bottom || 0;
    const u = a - n, h = l - o;
    let c = e.get("radius");
    S(c) ? (s = 0, r = 0) : (c = Math.min(u, h) / 2, s = u / 2, r = h / 2);
    let d = this.get("x"), f = this.get("y");
    d != null && (s = we(d, u)), f != null && (r = we(f, h));
    const g = this._root._renderer.createRadialGradient(s, r, 0, s, r, c), p = this.get("stops");
    if (p) {
      let m = 0;
      x(p, (_) => {
        let v = _.offset;
        S(v) || (v = m / (p.length - 1));
        let b = _.opacity;
        S(b) || (b = 1);
        let y = _.color;
        if (y) {
          const w = _.lighten;
          w && (y = X.lighten(y, w));
          const D = _.brighten;
          D && (y = X.brighten(y, D)), g.addColorStop(v, "rgba(" + y.r + "," + y.g + "," + y.b + "," + b + ")");
        }
        m++;
      });
    }
    return g;
  }
}
Object.defineProperty(ma, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "RadialGradient"
});
Object.defineProperty(ma, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Fi.classNames.concat([ma.className])
});
class _a extends St {
  _beforeChanged() {
    super._beforeChanged(), this.isDirty("gap") && (this._clear = !0);
  }
  _draw() {
    super._draw();
    const e = this.get("checkered", !1), t = this.get("centered", !0), s = this.get("gap", 0), r = this.get("rotation", 0);
    let n = this.get("width", 100), a = this.get("height", 100), o = this.get("radius", 3), l = o * 2 + s, u = o * 2 + s, h = Math.round(n / l), c = Math.round(a / u);
    l = n / h, u = a / c, r != 0 && (this._display.x = l * ht(r), this._display.y = u * qe(r));
    const d = this.get("color"), f = this.get("colorOpacity");
    (d || f) && this._display.beginFill(d, f);
    for (let g = r == 0 ? 0 : -c * 2; g < c * 2; g++)
      for (let p = r == 0 ? 0 : -h * 2; p < h * 2; p++)
        if (!e || (g & 1) != 1 && (p & 1) != 1 || (g & 1) == 1 && (p & 1) == 1) {
          let m = p * l, _ = g * u;
          t && (m += l + s / 2, _ += u + s / 2), this._display.drawCircle(m - o, _ - o, o);
        }
    e ? (n = n / 2 - s * 2, a = a / 2 - s * 2) : (n -= s, a -= s), (d || f) && this._display.endFill();
  }
}
Object.defineProperty(_a, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "CirclePattern"
});
Object.defineProperty(_a, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: St.classNames.concat([_a.className])
});
class ba extends St {
  _beforeChanged() {
    super._beforeChanged(), this.isDirty("gap") && (this._clear = !0);
  }
  _draw() {
    super._draw();
    const e = this.get("width", 100), t = this.get("height", 100), s = this.get("gap", 0), r = this.get("strokeWidth", 1);
    if (!s)
      this._display.moveTo(0, 0), this._display.lineTo(e, 0);
    else {
      let o = s + r, l = t / o;
      for (let u = -l; u < l * 2; u++) {
        const h = Math.round(u * o - o / 2) + 0.5;
        this._display.moveTo(-e, h), this._display.lineTo(e * 2, h);
      }
    }
    this._display.lineStyle(r, this.get("color"), this.get("colorOpacity"));
    let n = this.get("strokeDasharray");
    S(n) && (n < 0.5 ? n = [0] : n = [n]), this._display.setLineDash(n);
    const a = this.get("strokeDashoffset");
    a && this._display.setLineDashOffset(a), this._display.endStroke();
  }
}
Object.defineProperty(ba, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "LinePattern"
});
Object.defineProperty(ba, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: St.classNames.concat([ba.className])
});
class ya extends St {
  _beforeChanged() {
    super._beforeChanged(), this.isDirty("gap") && (this._clear = !0);
  }
  _draw() {
    super._draw();
    const e = this.get("checkered", !1), t = this.get("centered", !0), s = this.get("gap", 0), r = this.get("rotation", 0);
    let n = this.get("width", 100), a = this.get("height", 100), o = this.get("maxWidth", 5), l = this.get("maxHeight", 5), u = o + s, h = l + s, c = Math.round(n / u), d = Math.round(a / h);
    u = n / c, h = a / d, r != 0 && (this._display.x = u / 2 * ht(r), this._display.y = -h / 2 * qe(r));
    for (let p = r == 0 ? 0 : -d * 2; p < d * 2; p++)
      for (let m = r == 0 ? 0 : -c * 2; m < c * 2; m++)
        if (!e || (p & 1) != 1 && (m & 1) != 1 || (p & 1) == 1 && (m & 1) == 1) {
          let _ = m * u, v = p * h;
          t && (_ += (u - o) / 2, v += (h - l) / 2), this._display.drawRect(_, v, o, l);
        }
    e ? (n = n / 2 - s * 2, a = a / 2 - s * 2) : (n -= s, a -= s);
    const f = this.get("color"), g = this.get("colorOpacity");
    (f || g) && (this._display.beginFill(f, g), this._display.endFill());
  }
}
Object.defineProperty(ya, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "RectanglePattern"
});
Object.defineProperty(ya, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: St.classNames.concat([ya.className])
});
class va extends St {
  _beforeChanged() {
    super._beforeChanged(), this.isDirty("svgPath") && (this._clear = !0);
  }
  _draw() {
    super._draw();
    const e = this.get("svgPath");
    e != null && this._display.svgPath(e);
    const t = this.get("color"), s = this.get("colorOpacity");
    (t || s) && (this._display.beginFill(t, s), this._display.endFill());
  }
}
Object.defineProperty(va, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "PathPattern"
});
Object.defineProperty(va, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: St.classNames.concat([va.className])
});
class ws extends De {
  //protected _currentPass: number = 0;
  _afterNew() {
    super._afterNewApplyThemes(), this._dirty.colors = !1;
  }
  _beforeChanged() {
    this.isDirty("colors") && this.reset();
  }
  /**
   * @ignore
   */
  generateColors() {
    this.setPrivate("currentPass", this.getPrivate("currentPass", 0) + 1);
    const e = this.getPrivate("currentPass"), t = this.get("colors", [this.get("baseColor", X.fromHex(16711680))]);
    this.getPrivate("numColors") || this.setPrivate("numColors", t.length);
    const s = this.getPrivate("numColors"), r = 0, n = this.get("passOptions"), a = this.get("reuse");
    for (let o = r; o < s; o++)
      if (a)
        t.push(t[o]);
      else {
        const l = t[o].toHSL();
        let u = l.h + (n.hue || 0) * e;
        for (; u > 1; )
          u -= 1;
        let h = l.s + (n.saturation || 0) * e;
        h > 1 && (h = 1), h < 0 && (h = 0);
        let c = l.l + (n.lightness || 0) * e;
        for (; c > 1; )
          c -= 1;
        t.push(X.fromHSL(u, h, c));
      }
  }
  /**
   * Returns a [[Color]] at specific index.
   *
   * If there's no color at this index, a new color is generated.
   *
   * @param   index  Index
   * @return         Color
   */
  getIndex(e) {
    const t = this.get("colors", []), s = this.get("saturation");
    return e >= t.length ? (this.generateColors(), this.getIndex(e)) : s != null ? X.saturate(t[e], s) : t[e];
  }
  /**
   * Returns next [[Color]] in the list.
   *
   * If the list is out of colors, new ones are generated dynamically.
   */
  next() {
    let e = this.getPrivate("currentStep", this.get("startIndex", 0));
    return this.setPrivate("currentStep", e + this.get("step", 1)), this.getIndex(e);
  }
  /**
   * Resets counter to the start of the list, so the next call for `next()` will
   * return the first color.
   */
  reset() {
    this.setPrivate("currentStep", this.get("startIndex", 0)), this.setPrivate("currentPass", 0);
  }
}
Object.defineProperty(ws, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "ColorSet"
});
Object.defineProperty(ws, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: De.classNames.concat([ws.className])
});
class Qw {
  /**
   * Parses JSON string.
   *
   * @param   input    JSON
   * @param   options  Options
   * @return           Data
   */
  static parse(e, t) {
    t = this._applyDefaults(t);
    try {
      if (Ri(e)) {
        let s = JSON.parse(e);
        return t.reverse && Jn(s) && s.reverse(), s;
      } else {
        if (Jn(e) || Ps(e))
          return e;
        throw "Unable to parse JSON data";
      }
    } catch {
      return;
    }
  }
  static _applyDefaults(e) {
    const t = {}, s = {
      reverse: !1
    };
    return e || (e = {}), _e(s, (r, n) => {
      t[r] = e[r] || n;
    }), t;
  }
}
class Jw {
  /**
   * Parses CSV string.
   *
   * @param   input    CSV
   * @param   options  Options
   * @return           Data
   */
  static parse(e, t) {
    t = this._applyDefaults(t);
    let s = this.CSVToArray(e, t.delimiter), r = [], n = [], a, o;
    for (o = 0; o < t.skipRows; o++)
      s.shift();
    if (t.useColumnNames) {
      n = s.shift();
      for (let u = 0; u < n.length; u++)
        a = n[u] != null ? n[u].replace(/^\s+|\s+$/gm, "") : "", a === "" && (a = "col" + u), n[u] = a;
    }
    let l;
    for (; l = t.reverse ? s.pop() : s.shift(), !!l; ) {
      if (t.skipEmpty && l.length === 1 && l[0] === "")
        continue;
      let u = {};
      for (o = 0; o < l.length; o++)
        a = n[o] === void 0 ? "col" + o : n[o], u[a] = l[o];
      r.push(u);
    }
    return r;
  }
  /**
   * @ignore
   */
  static CSVToArray(e, t) {
    t = t || ",";
    let s = new RegExp(
      // Delimiters.
      "(\\" + t + '|\\r?\\n|\\r|^)(?:"([^"]*(?:""[^"]*)*)"|([^"\\' + t + "\\r\\n]*))",
      "gi"
    ), r = [
      []
    ], n = null;
    for (; n = s.exec(e), !!n; ) {
      let a = n[1];
      a.length && a !== t && r.push([]);
      let o;
      n[2] ? o = n[2].replace(new RegExp('""', "g"), '"') : o = n[3], r[r.length - 1].push(o);
    }
    return r;
  }
  static _applyDefaults(e) {
    const t = {}, s = {
      delimiter: ",",
      reverse: !1,
      skipRows: 0,
      skipEmpty: !0,
      useColumnNames: !1
    };
    return e || (e = {}), _e(s, (r, n) => {
      t[r] = e[r] || n;
    }), t;
  }
}
class qw extends De {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_checkDates", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_checkNumbers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_checkColors", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_checkEmpty", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_checkDeep", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    });
  }
  _afterNew() {
    super._afterNew(), this._checkFeatures(), this.on("dateFields", () => this._checkFeatures()), this.on("dateFormat", () => this._checkFeatures()), this.on("numericFields", () => this._checkFeatures()), this.on("colorFields", () => this._checkFeatures()), this.on("emptyAs", () => this._checkFeatures());
  }
  _checkFeatures() {
    (this.isDirty("dateFields") || this.isDirty("dateFormat")) && (this._checkDates = this.get("dateFields") && this.get("dateFields").length > 0), this.isDirty("numericFields") && (this._checkNumbers = this.get("numericFields") && this.get("numericFields").length > 0), this.isDirty("colorFields") && (this._checkColors = this.get("colorFields") && this.get("colorFields").length > 0), this.isDirty("emptyAs") && (this._checkEmpty = this.get("emptyAs") != null), this._checkDeepFeatures();
  }
  _checkDeepFeatures() {
    const e = [];
    x(["dateFields", "numericFields", "colorFields"], (t) => {
      x(this.get(t, []), (s) => {
        const r = s.split(".");
        for (r.pop(); r.length > 0; )
          e.push(r.join(".")), r.pop();
      });
    }), this._checkDeep = e.length > 0, this.setPrivate("deepFields", e);
  }
  /**
   * Processess entire array of data.
   *
   * NOTE: calling this will modify original array!
   */
  processMany(e) {
    Jn(e) && (this._checkDates || this._checkNumbers || this._checkColors || this._checkEmpty) && x(e, (t) => {
      this.processRow(t);
    });
  }
  /**
   * Processes a row (object) of data.
   *
   * NOTE: calling this will modify values of the original object!
   */
  processRow(e, t = "") {
    _e(e, (s, r) => {
      const n = t + s;
      this._checkEmpty && (e[s] = this._maybeToEmpty(e[s])), this._checkNumbers && (e[s] = this._maybeToNumber(n, e[s])), this._checkDates && (e[s] = this._maybeToDate(n, e[s])), this._checkColors && (e[s] = this._maybeToColor(n, e[s])), this._checkDeep && this.getPrivate("deepFields", []).indexOf(n) !== -1 && Ps(e[s]) && this.processRow(e[s], n + ".");
    });
  }
  _maybeToNumber(e, t) {
    return this.get("numericFields").indexOf(e) !== -1 ? pt(t) : t;
  }
  _maybeToDate(e, t) {
    return this.get("dateFields").indexOf(e) !== -1 ? this._root.dateFormatter.parse(t, this.get("dateFormat", "")).getTime() : t;
  }
  _maybeToEmpty(e) {
    return (e == null || e == "") && this.get("emptyAs") != null ? this.get("emptyAs") : e;
  }
  _maybeToColor(e, t) {
    return this.get("colorFields").indexOf(e) !== -1 ? X.fromAny(t) : t;
  }
}
class xa extends Z {
  constructor() {
    super(...arguments), Object.defineProperty(this, "rectangle", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.children.push(mt.new(this._root, { themeTags: ["rectangle"], fillOpacity: 0, fill: oe(16777215) }))
    }), Object.defineProperty(this, "gripL", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._createGrip("left")
    }), Object.defineProperty(this, "gripR", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._createGrip("right")
    }), Object.defineProperty(this, "gripT", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._createGrip("top")
    }), Object.defineProperty(this, "gripB", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._createGrip("bottom")
    }), Object.defineProperty(this, "_is", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), Object.defineProperty(this, "_ix", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_iw", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_positionDP", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_isHover", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    });
  }
  _afterNew() {
    super._afterNew(), this.addTag("resizer"), this.set("visible", !1), this.gripL.events.on("dragged", (e) => {
      this._resize(e.target, -1);
    }), this.gripR.events.on("dragged", (e) => {
      this._resize(e.target, 1);
    }), this.gripL.events.on("dragstart", (e) => {
      this._resizeStart(e.target);
    }), this.gripR.events.on("dragstart", (e) => {
      this._resizeStart(e.target);
    }), this.gripT.events.on("dragged", (e) => {
      this._rotate(e, 90);
    }), this.gripB.events.on("dragged", (e) => {
      this._rotate(e, -90);
    }), this.gripT.events.on("dragstart", (e) => {
      this._resizeStart(e.target);
    }), this.gripB.events.on("dragstart", (e) => {
      this._resizeStart(e.target);
    });
  }
  _resizeStart(e) {
    const t = this.get("sprite");
    t && (this._is = t.get("scale", 1), this._ix = e.x(), this._iw = this.width() / 2);
  }
  _resize(e, t) {
    const s = this.get("sprite"), r = this.get("spriteTemplate");
    if (s) {
      const n = Math.max(0.01, this._is * (1 + t * (e.x() - this._ix) / this._iw));
      r ? r.set("scale", n) : s.set("scale", n), s.states.lookup("default").set("scale", n), this._updatePositions();
    }
  }
  _rotate(e, t) {
    const s = this.get("sprite"), r = this.get("spriteTemplate");
    if (s) {
      const n = this.parent;
      if (n) {
        const a = this.get("rotationStep", 10);
        let o = Math.round((Dd({ x: this.x(), y: this.y() }, n.toLocal(e.point)) + t) / a) * a;
        r ? r.set("rotation", o) : s.set("rotation", o), s.states.lookup("default").set("rotation", o), this._updatePositions();
      }
    }
  }
  _createGrip(e) {
    const t = this.children.push(Z.new(this._root, {
      themeTags: ["grip", e],
      setStateOnChildren: !0,
      draggable: !0
    }));
    return t.children.push(it.new(this._root, {
      themeTags: ["outline"],
      centerX: ie,
      centerY: ie
    })), t.children.push(it.new(this._root, {
      centerX: ie,
      centerY: ie
    })), t;
  }
  _updateChildren() {
    if (super._updateChildren(), this.isDirty("sprite")) {
      const e = this.get("sprite");
      if (e) {
        this.show(0), this.setPrivate("visible", !0), this._updatePositions();
        const t = e.parent;
        t && t.children.moveValue(this, 0), this._positionDP = e.events.on("positionchanged", () => {
          this._updatePositions();
        });
      } else
        this.hide(0), this.setPrivate("visible", !1), this._positionDP && this._positionDP.dispose();
    }
    (this.isDirty("width") || this.isDirty("height") || this.isDirty("rotation")) && this._updatePositions();
  }
  _updatePositions() {
    const e = this.get("sprite");
    if (e) {
      let t = e.localBounds(), s = e.get("scale", 1), r = 20, n = (t.right - t.left) * s + r, a = (t.bottom - t.top) * s + r, o = e.get("rotation", 0);
      const l = this.rectangle;
      let u = e.get("centerX", ie), h = e.get("centerY", ie), c = 0;
      u instanceof ne && (c = u.value);
      let d = 0;
      h instanceof ne && (d = h.value), l.setAll({ centerX: u, centerY: h, width: n, height: a }), this.setAll({ x: e.x() + r * (c - 0.5) * ht(o) - r * (d - 0.5) * qe(o), y: e.y() + r * (d - 0.5) * ht(o) + r * (c - 0.5) * qe(o), width: n, height: a, rotation: o }), this.gripT.setAll({ x: (0.5 - c) * n, y: -d * a }), this.gripB.setAll({ x: (0.5 - c) * n, y: (1 - d) * a }), this.gripL.setAll({ x: -c * n, y: (0.5 - d) * a }), this.gripR.setAll({ x: (1 - c) * n, y: (0.5 - d) * a }), this.rectangle.setAll({ width: n, height: a });
    }
  }
}
Object.defineProperty(xa, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "SpriteResizer"
});
Object.defineProperty(xa, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Z.classNames.concat([xa.className])
});
function eS(i, e, t) {
  return new Promise((s, r) => {
    let n = t != null && t.responseType == "blob", a = new XMLHttpRequest();
    if (a.onload = () => {
      if (a.status === 200) {
        let o, l;
        if (n) {
          l = a.response, Kd(l).then((h) => {
            let c = {
              xhr: a,
              error: !1,
              response: h,
              blob: l,
              type: a.getResponseHeader("Content-Type"),
              target: e
            };
            s(c);
          });
          return;
        } else
          o = a.responseText || a.response;
        let u = {
          xhr: a,
          error: !1,
          response: o,
          blob: l,
          type: a.getResponseHeader("Content-Type"),
          target: e
        };
        s(u);
      } else
        r({
          xhr: a,
          error: !0,
          type: a.getResponseHeader("Content-Type"),
          target: e
        });
    }, a.onerror = () => {
      r({
        xhr: a,
        error: !0,
        type: a.getResponseHeader("Content-Type"),
        target: e
      });
    }, a.open("GET", i, !0), t && t.withCredentials && (a.withCredentials = !0), t != null) {
      if (t.requestHeaders != null)
        for (let o = 0; o < t.requestHeaders.length; o++) {
          let l = t.requestHeaders[o];
          a.setRequestHeader(l.key, l.value);
        }
      t.responseType != null && (a.responseType = t.responseType);
    }
    a.send();
  });
}
function Kd(i) {
  return new Promise((e, t) => {
    const s = new FileReader();
    s.onload = (r) => {
      e(s.result);
    }, s.onerror = (r) => {
      t(r);
    }, s.readAsText(i);
  });
}
const tS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  load: eS,
  readBlob: Kd
}, Symbol.toStringTag, { value: "Module" })), oh = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ArrayDisposer: Zc,
  Bullet: qt,
  Button: Ks,
  CSVParser: Jw,
  Chart: er,
  Circle: ei,
  CirclePattern: _a,
  Color: X,
  ColorSet: ws,
  Component: $i,
  Container: Z,
  CounterDisposer: qa,
  DataItem: Gt,
  DataProcessor: qw,
  DateFormatter: Ed,
  Disposer: Ve,
  DurationFormatter: Id,
  Ellipse: ua,
  Entity: De,
  Gradient: Fi,
  Graphics: he,
  GridLayout: bi,
  HeatLegend: ca,
  HorizontalLayout: bs,
  InterfaceColors: Xr,
  JSONParser: Qw,
  JsonData: jw,
  Label: We,
  Layout: ni,
  Legend: Js,
  Line: qs,
  LinePattern: ba,
  LinearGradient: Vr,
  ListData: Nd,
  Modal: la,
  MultiDisposer: nt,
  MutableValueDisposer: $x,
  NumberFormatter: Ad,
  PathPattern: va,
  Pattern: St,
  Percent: ne,
  Picture: da,
  PicturePattern: Zs,
  PointedRectangle: ps,
  RadialGradient: ma,
  RadialLabel: vs,
  RadialText: Wr,
  Rectangle: mt,
  RectanglePattern: ya,
  Root: un,
  RoundedRectangle: it,
  Scrollbar: yi,
  SerialChart: Bi,
  Series: ai,
  Slice: Gr,
  Slider: pa,
  Sprite: wt,
  SpriteResizer: xa,
  Star: ha,
  Template: ge,
  Text: Ni,
  TextFormatter: Nt,
  Theme: dr,
  Tick: xs,
  Timezone: jd,
  Tooltip: At,
  Triangle: fa,
  VerticalLayout: ys,
  addLicense: N0,
  array: Nx,
  color: oe,
  disposeAllRootElements: $0,
  ease: E0,
  math: f0,
  net: tS,
  object: Xx,
  p0: Bx,
  p100: R,
  p50: ie,
  percent: Ce,
  ready: Jc,
  registry: Lt,
  time: Rw,
  type: Px,
  utils: e0
}, Symbol.toStringTag, { value: "Module" }));
class Qd extends dr {
  setupDefaultRules() {
    super.setupDefaultRules();
    const e = this._root.interfaceColors, t = this._root.language, s = this.rule.bind(this);
    s("XYChart").setAll({
      colors: ws.new(this._root, {}),
      paddingLeft: 20,
      paddingRight: 20,
      paddingTop: 16,
      paddingBottom: 16,
      panX: !1,
      panY: !1,
      wheelStep: 0.25,
      arrangeTooltips: !0,
      pinchZoomX: !1,
      pinchZoomY: !1
    }), s("XYSeries").setAll({
      legendLabelText: "{name}"
    }), s("XYChart", ["scrollbar", "chart"]).setAll({
      paddingBottom: 0,
      paddingLeft: 0,
      paddingTop: 0,
      paddingRight: 0,
      colors: ws.new(this._root, {
        saturation: 0
      })
    });
    {
      const l = s("Graphics", ["scrollbar", "overlay"]);
      l.setAll({
        fillOpacity: 0.5
      }), K(l, "fill", e, "background");
    }
    s("RoundedRectangle", ["xy", "scrollbar", "thumb"]).setAll({
      cornerRadiusTR: 0,
      cornerRadiusTL: 0,
      cornerRadiusBR: 0,
      cornerRadiusBL: 0,
      fillOpacity: 0,
      focusable: !0
    }), s("RoundedRectangle", ["xy", "scrollbar", "thumb"]).states.create("hover", { fillOpacity: 0.4 }), s("RoundedRectangle", ["xy", "scrollbar", "chart", "background"]).setAll({
      cornerRadiusTL: 0,
      cornerRadiusBL: 0,
      cornerRadiusTR: 0,
      cornerRadiusBR: 0
    }), s("RoundedRectangle", ["xy", "scrollbar", "chart", "background", "resize", "button"]).setAll({
      cornerRadiusBL: 40,
      cornerRadiusBR: 40,
      cornerRadiusTL: 40,
      cornerRadiusTR: 40
    }), s("AxisRendererX", ["xy", "chart", "scrollbar"]).setAll({
      strokeOpacity: 0,
      inside: !0
    }), s("AxisRendererY", ["xy", "chart", "scrollbar"]).setAll({
      strokeOpacity: 0,
      inside: !0,
      minGridDistance: 5
    }), s("AxisLabel", ["xy", "scrollbar", "x"]).setAll({
      opacity: 0.5,
      centerY: R,
      minPosition: 0.01,
      maxPosition: 0.99,
      fontSize: "0.8em"
    }), s("AxisLabel", ["category"]).setAll({
      text: "{category}",
      populateText: !0
    }), s("AxisLabel", ["x"]).setAll({
      centerY: 0
    }), s("AxisLabel", ["x", "inside"]).setAll({
      centerY: R
    }), s("AxisLabel", ["x", "inside", "opposite"]).setAll({
      centerY: 0
    }), s("AxisLabel", ["x", "opposite"]).setAll({
      centerY: R
    }), s("AxisLabel", ["y"]).setAll({
      centerX: R
    }), s("AxisLabel", ["y", "inside"]).setAll({
      centerX: 0
    }), s("AxisLabel", ["y", "inside", "opposite"]).setAll({
      centerX: R
    }), s("AxisLabel", ["y", "opposite"]).setAll({
      centerX: 0
    }), s("AxisLabel", ["xy", "scrollbar", "y"]).setAll({
      visible: !1
    }), s("Grid", ["xy", "scrollbar", "y"]).setAll({
      visible: !1
    }), s("Grid", ["xy", "scrollbar", "x"]).setAll({
      opacity: 0.5
    }), s("XYCursor").setAll({
      behavior: "none",
      layer: 30,
      exportable: !1,
      snapToSeriesBy: "xy",
      moveThreshold: 1
    });
    {
      const l = s("Grid", ["cursor", "x"]);
      l.setAll({
        strokeOpacity: 0.8,
        strokeDasharray: [2, 2],
        ariaLabel: t.translate("Use left and right arrows to move selection")
      }), K(l, "stroke", e, "alternativeBackground");
    }
    {
      const l = s("Grid", ["cursor", "y"]);
      l.setAll({
        strokeOpacity: 0.8,
        strokeDasharray: [2, 2],
        ariaLabel: t.translate("Use up and down arrows to move selection")
      }), K(l, "stroke", e, "alternativeBackground");
    }
    {
      const l = s("Graphics", ["cursor", "selection"]);
      l.setAll({
        fillOpacity: 0.15
      }), K(l, "fill", e, "alternativeBackground");
    }
    s("Axis").setAll({
      start: 0,
      end: 1,
      minZoomCount: 1,
      maxZoomCount: 1 / 0,
      maxZoomFactor: 1e3,
      maxDeviation: 0.1,
      snapTooltip: !0,
      tooltipLocation: 0.5,
      panX: !0,
      panY: !0,
      zoomX: !0,
      zoomY: !0,
      fixAxisSize: !0
    }), s("AxisLabel").setAll({
      location: 0.5,
      multiLocation: 0,
      centerX: ie,
      centerY: ie,
      paddingTop: 3,
      paddingBottom: 3,
      paddingLeft: 5,
      paddingRight: 5
    }), s("Container", ["axis", "header"]).setAll({
      layer: 30
    }), s("Rectangle", ["axis", "header", "background"]).setAll({
      crisp: !0
    });
    {
      const l = s("AxisRenderer");
      l.setAll({
        crisp: !0,
        strokeOpacity: 0
      }), K(l, "stroke", e, "grid");
    }
    s("AxisRendererX").setAll({
      minGridDistance: 120,
      opposite: !1,
      inversed: !1,
      cellStartLocation: 0,
      cellEndLocation: 1,
      width: R
    }), s("AxisRendererY").setAll({
      minGridDistance: 40,
      opposite: !1,
      inversed: !1,
      cellStartLocation: 0,
      cellEndLocation: 1,
      height: R
    });
    {
      const l = s("Rectangle", ["axis", "thumb"]);
      l.setAll({
        fillOpacity: 0
      }), K(l, "fill", e, "alternativeBackground"), l.states.create("hover", { fillOpacity: 0.1 });
    }
    s("Rectangle", ["axis", "thumb", "x"]).setAll({
      cursorOverStyle: "ew-resize"
    }), s("Rectangle", ["axis", "thumb", "y"]).setAll({
      cursorOverStyle: "ns-resize"
    });
    {
      const l = s("Grid");
      l.setAll({
        location: 0,
        strokeOpacity: 0.15,
        crisp: !0
      }), K(l, "stroke", e, "grid");
    }
    s("Grid", ["base"]).setAll({
      strokeOpacity: 0.3
    });
    {
      const l = s("Graphics", ["axis", "fill"]);
      l.setAll({
        visible: !1,
        isMeasured: !1,
        position: "absolute",
        fillOpacity: 0.05
      }), K(l, "fill", e, "alternativeBackground");
    }
    s("Graphics", ["axis", "fill", "range"]).setAll({
      isMeasured: !0
    }), s("Graphics", ["series", "fill", "range"]).setAll({
      visible: !1,
      isMeasured: !0
    }), s("Grid", ["series", "range"]).setAll({
      visible: !1
    }), s("AxisTick", ["series", "range"]).setAll({
      visible: !1
    }), s("AxisLabel", ["series", "range"]).setAll({
      visible: !1
    });
    {
      const l = s("AxisTick");
      l.setAll({
        location: 0.5,
        multiLocation: 0,
        strokeOpacity: 1,
        isMeasured: !1,
        position: "absolute",
        visible: !1
      }), K(l, "stroke", e, "grid");
    }
    s("CategoryAxis").setAll({
      startLocation: 0,
      endLocation: 1,
      fillRule: (l, u) => {
        const h = l.get("axisFill");
        h && (!S(u) || u % 2 == 0 ? h.setPrivate("visible", !0) : h.setPrivate("visible", !1));
      }
    });
    const r = [
      { timeUnit: "millisecond", count: 1 },
      { timeUnit: "millisecond", count: 5 },
      { timeUnit: "millisecond", count: 10 },
      { timeUnit: "millisecond", count: 50 },
      { timeUnit: "millisecond", count: 100 },
      { timeUnit: "millisecond", count: 500 },
      { timeUnit: "second", count: 1 },
      { timeUnit: "second", count: 5 },
      { timeUnit: "second", count: 10 },
      { timeUnit: "second", count: 30 },
      { timeUnit: "minute", count: 1 },
      { timeUnit: "minute", count: 5 },
      { timeUnit: "minute", count: 10 },
      { timeUnit: "minute", count: 15 },
      { timeUnit: "minute", count: 30 },
      { timeUnit: "hour", count: 1 },
      { timeUnit: "hour", count: 3 },
      { timeUnit: "hour", count: 6 },
      { timeUnit: "hour", count: 12 },
      { timeUnit: "day", count: 1 },
      { timeUnit: "day", count: 2 },
      { timeUnit: "day", count: 3 },
      { timeUnit: "day", count: 4 },
      { timeUnit: "day", count: 5 },
      { timeUnit: "week", count: 1 },
      { timeUnit: "month", count: 1 },
      { timeUnit: "month", count: 2 },
      { timeUnit: "month", count: 3 },
      { timeUnit: "month", count: 6 },
      { timeUnit: "year", count: 1 },
      { timeUnit: "year", count: 2 },
      { timeUnit: "year", count: 5 },
      { timeUnit: "year", count: 10 },
      { timeUnit: "year", count: 50 },
      { timeUnit: "year", count: 100 },
      { timeUnit: "year", count: 200 },
      { timeUnit: "year", count: 500 },
      { timeUnit: "year", count: 1e3 },
      { timeUnit: "year", count: 2e3 },
      { timeUnit: "year", count: 5e3 },
      { timeUnit: "year", count: 1e4 },
      { timeUnit: "year", count: 1e5 }
    ], n = {
      millisecond: t.translate("_date_millisecond"),
      second: t.translate("_date_second"),
      minute: t.translate("_date_minute"),
      hour: t.translate("_date_hour"),
      day: t.translate("_date_day"),
      week: t.translate("_date_day"),
      month: t.translate("_date_month"),
      year: t.translate("_date_year")
    }, a = {
      millisecond: t.translate("_date_millisecond"),
      second: t.translate("_date_second"),
      minute: t.translate("_date_minute"),
      hour: t.translate("_date_day"),
      day: t.translate("_date_day"),
      week: t.translate("_date_day"),
      month: t.translate("_date_month") + " " + t.translate("_date_year"),
      year: t.translate("_date_year")
    }, o = {
      millisecond: t.translate("_date_millisecond_full"),
      second: t.translate("_date_second_full"),
      minute: t.translate("_date_minute_full"),
      hour: t.translate("_date_hour_full"),
      day: t.translate("_date_day_full"),
      week: t.translate("_date_week_full"),
      month: t.translate("_date_month_full"),
      year: t.translate("_date_year")
    };
    s("CategoryDateAxis").setAll({
      markUnitChange: !0,
      gridIntervals: ea(r),
      dateFormats: Mi(n),
      periodChangeDateFormats: Mi(a)
    }), s("DateAxis").setAll({
      maxZoomFactor: null,
      strictMinMax: !0,
      startLocation: 0,
      endLocation: 1,
      markUnitChange: !0,
      groupData: !1,
      groupCount: 500,
      gridIntervals: ea(r),
      dateFormats: Mi(n),
      periodChangeDateFormats: Mi(a),
      tooltipDateFormats: o,
      groupIntervals: [
        { timeUnit: "millisecond", count: 1 },
        { timeUnit: "millisecond", count: 10 },
        { timeUnit: "millisecond", count: 100 },
        { timeUnit: "second", count: 1 },
        { timeUnit: "second", count: 10 },
        { timeUnit: "minute", count: 1 },
        { timeUnit: "minute", count: 10 },
        { timeUnit: "hour", count: 1 },
        { timeUnit: "day", count: 1 },
        { timeUnit: "week", count: 1 },
        { timeUnit: "month", count: 1 },
        { timeUnit: "year", count: 1 }
      ],
      fillRule: (l) => {
        const u = l.get("axisFill");
        if (u) {
          const h = l.component, c = l.get("value"), d = l.get("endValue"), f = h.intervalDuration(), g = h.getPrivate("baseInterval"), p = h.getPrivate("gridInterval", g);
          let m = h.getPrivate("min", 0);
          if (m = Ge(new Date(m), p.timeUnit, p.count, this._root.locale.firstDayOfWeek, this._root.utc, void 0, this._root.timezone).getTime(), c != null && d != null) {
            const _ = Math.round(Math.round((c - m) / f)) / 2;
            _ == Math.round(_) ? u.setPrivate("visible", !0) : u.setPrivate("visible", !1);
          }
        }
      }
    }), s("GaplessDateAxis").setAll({
      fillRule: (l) => {
        const u = l.get("axisFill");
        if (u) {
          const h = l.get("index");
          let c = !1;
          (!S(h) || h % 2 == 0) && (c = !0), u.setPrivate("visible", c);
        }
      }
    }), s("ValueAxis").setAll({
      baseValue: 0,
      logarithmic: !1,
      strictMinMax: !1,
      autoZoom: !0,
      fillRule: (l) => {
        const u = l.get("axisFill");
        if (u) {
          const h = l.component, c = l.get("value"), d = h.getPrivate("step");
          S(c) && S(d) && (tt(c / d / 2, 5) == Math.round(c / d / 2) ? u.setPrivate("visible", !1) : u.setPrivate("visible", !0));
        }
      }
    }), s("DurationAxis").setAll({
      baseUnit: "second"
    }), s("XYSeries").setAll({
      maskBullets: !0,
      stackToNegative: !0,
      locationX: 0.5,
      locationY: 0.5,
      snapTooltip: !1,
      openValueXGrouped: "open",
      openValueYGrouped: "open",
      valueXGrouped: "close",
      valueYGrouped: "close",
      seriesTooltipTarget: "series"
    }), s("BaseColumnSeries").setAll({
      adjustBulletPosition: !0
    }), s("ColumnSeries").setAll({
      clustered: !0
    }), s("RoundedRectangle", ["series", "column"]).setAll({
      position: "absolute",
      isMeasured: !1,
      width: Ce(70),
      height: Ce(70),
      strokeWidth: 1,
      strokeOpacity: 1,
      cornerRadiusBL: 0,
      cornerRadiusTL: 0,
      cornerRadiusBR: 0,
      cornerRadiusTR: 0,
      fillOpacity: 1,
      role: "figure"
    }), s("LineSeries").setAll({
      connect: !0,
      autoGapCount: 1.1,
      stackToNegative: !1
    }), s("Graphics", ["series", "stroke"]).setAll({
      position: "absolute",
      strokeWidth: 1,
      strokeOpacity: 1,
      isMeasured: !1
    }), s("Graphics", ["series", "fill"]).setAll({
      visible: !1,
      fillOpacity: 0,
      position: "absolute",
      strokeWidth: 0,
      strokeOpacity: 0,
      isMeasured: !1
    }), s("Graphics", ["line", "series", "legend", "marker", "stroke"]).setAll({
      draw: (l, u) => {
        const h = u.parent;
        if (h) {
          const c = h.height(), d = h.width();
          l.moveTo(0, c / 2), l.lineTo(d, c / 2);
        }
      }
    });
    {
      const l = s("Graphics", ["line", "series", "legend", "marker", "stroke"]).states.create("disabled", {});
      K(l, "stroke", e, "disabled");
    }
    s("Graphics", ["line", "series", "legend", "marker", "fill"]).setAll({
      draw: (l, u) => {
        const h = u.parent;
        if (h) {
          const c = h.height(), d = h.width();
          l.moveTo(0, 0), l.lineTo(d, 0), l.lineTo(d, c), l.lineTo(0, c), l.lineTo(0, 0);
        }
      }
    });
    {
      const l = s("Graphics", ["line", "series", "legend", "marker", "fill"]).states.create("disabled", {});
      K(l, "stroke", e, "disabled");
    }
    s("SmoothedXYLineSeries").setAll({
      tension: 0.5
    }), s("SmoothedXLineSeries").setAll({
      tension: 0.5
    }), s("SmoothedYLineSeries").setAll({
      tension: 0.5
    }), s("Candlestick").setAll({
      position: "absolute",
      isMeasured: !1,
      width: Ce(50),
      height: Ce(50),
      strokeWidth: 1,
      strokeOpacity: 1,
      cornerRadiusBL: 0,
      cornerRadiusTL: 0,
      cornerRadiusBR: 0,
      cornerRadiusTR: 0,
      fillOpacity: 1,
      role: "figure"
    }), s("OHLC").setAll({
      width: Ce(80),
      height: Ce(80)
    }), s("CandlestickSeries").setAll({
      lowValueXGrouped: "low",
      lowValueYGrouped: "low",
      highValueXGrouped: "high",
      highValueYGrouped: "high",
      openValueXGrouped: "open",
      openValueYGrouped: "open",
      valueXGrouped: "close",
      valueYGrouped: "close"
    });
    {
      const l = s("Rectangle", ["column", "autocolor"]).states.create("riseFromOpen", {});
      K(l, "fill", e, "positive"), K(l, "stroke", e, "positive");
    }
    {
      const l = s("Rectangle", ["column", "autocolor"]).states.create("dropFromOpen", {});
      K(l, "fill", e, "negative"), K(l, "stroke", e, "negative");
    }
    s("Rectangle", ["column", "autocolor", "pro"]).states.create("riseFromOpen", { fillOpacity: 0 }), s("Rectangle", ["column", "autocolor", "pro"]).states.create("dropFromOpen", { fillOpacity: 1 });
    {
      const l = s("Rectangle", ["column", "autocolor", "pro"]).states.create("riseFromPrevious", {});
      K(l, "fill", e, "positive"), K(l, "stroke", e, "positive");
    }
    {
      const l = s("Rectangle", ["column", "autocolor", "pro"]).states.create("dropFromPrevious", {});
      K(l, "fill", e, "negative"), K(l, "stroke", e, "negative");
    }
  }
}
let tr = class extends Bi {
  constructor() {
    super(...arguments), Object.defineProperty(this, "xAxes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new ia()
    }), Object.defineProperty(this, "yAxes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new ia()
    }), Object.defineProperty(this, "topAxesContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.chartContainer.children.push(Z.new(this._root, { width: R, layout: this._root.verticalLayout }))
    }), Object.defineProperty(this, "yAxesAndPlotContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.chartContainer.children.push(Z.new(this._root, { width: R, height: R, layout: this._root.horizontalLayout }))
    }), Object.defineProperty(this, "bottomAxesContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.chartContainer.children.push(Z.new(this._root, { width: R, layout: this._root.verticalLayout }))
    }), Object.defineProperty(this, "leftAxesContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.yAxesAndPlotContainer.children.push(Z.new(this._root, { height: R, layout: this._root.horizontalLayout }))
    }), Object.defineProperty(this, "plotsContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.yAxesAndPlotContainer.children.push(Z.new(this._root, { width: R, height: R, maskContent: !1 }))
    }), Object.defineProperty(this, "plotContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.plotsContainer.children.push(Z.new(this._root, { width: R, height: R }))
    }), Object.defineProperty(this, "topPlotContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.plotsContainer.children.push(Z.new(this._root, { width: R, height: R }))
    }), Object.defineProperty(this, "gridContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.plotContainer.children.push(Z.new(this._root, { width: R, height: R, isMeasured: !1 }))
    }), Object.defineProperty(this, "topGridContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Z.new(this._root, { width: R, height: R, isMeasured: !1 })
    }), Object.defineProperty(this, "rightAxesContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.yAxesAndPlotContainer.children.push(Z.new(this._root, { height: R, layout: this._root.horizontalLayout }))
    }), Object.defineProperty(this, "axisHeadersContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.plotContainer.children.push(Z.new(this._root, {}))
    }), Object.defineProperty(this, "zoomOutButton", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.topPlotContainer.children.push(Ks.new(this._root, {
        themeTags: ["zoom"],
        icon: he.new(this._root, {
          themeTags: ["button", "icon"]
        })
      }))
    }), Object.defineProperty(this, "_movePoint", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: { x: 0, y: 0 }
    }), Object.defineProperty(this, "_wheelDp", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_otherCharts", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_movePoints", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_downStartX", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_downEndX", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_downStartY", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_downEndY", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  _afterNew() {
    this._defaultThemes.push(Qd.new(this._root)), super._afterNew(), this._disposers.push(this.xAxes), this._disposers.push(this.yAxes);
    const e = this._root;
    let t = this._root.verticalLayout;
    const s = this.zoomOutButton;
    s.events.on("click", () => {
      this.zoomOut();
    }), s.set("opacity", 0), s.states.lookup("default").set("opacity", 1), this.chartContainer.set("layout", t);
    const r = this.plotContainer;
    r.children.push(this.seriesContainer), this._disposers.push(this._processAxis(this.xAxes, this.bottomAxesContainer)), this._disposers.push(this._processAxis(this.yAxes, this.leftAxesContainer)), r.children.push(this.topGridContainer), r.children.push(this.bulletsContainer), r.set("interactive", !0), r.set("interactiveChildren", !1), r.set("background", mt.new(e, {
      themeTags: ["xy", "background"],
      fill: X.fromHex(0),
      fillOpacity: 0
    })), this._disposers.push(r.events.on("pointerdown", (n) => {
      this._handlePlotDown(n.originalEvent);
    })), this._disposers.push(r.events.on("globalpointerup", (n) => {
      this._handlePlotUp(n.originalEvent);
    })), this._disposers.push(r.events.on("globalpointermove", (n) => {
      this._handlePlotMove(n.originalEvent);
    })), this._maskGrid(), this._setUpTouch();
  }
  _beforeChanged() {
    super._beforeChanged(), (this.isDirty("pinchZoomX") || this.isDirty("pinchZoomY") || this.get("panX") || this.get("panY")) && this._setUpTouch();
  }
  _setUpTouch() {
    this.plotContainer._display.cancelTouch || (this.plotContainer._display.cancelTouch = !!(this.get("pinchZoomX") || this.get("pinchZoomY") || this.get("panX") || this.get("panY")));
  }
  _maskGrid() {
    this.gridContainer.set("maskContent", !0), this.topGridContainer.set("maskContent", !0);
  }
  _removeSeries(e) {
    const t = e.get("xAxis");
    t && (vt(t.series, e), t.markDirtyExtremes());
    const s = e.get("yAxis");
    s && (vt(s.series, e), s.markDirtyExtremes());
    const r = this.get("cursor");
    if (r) {
      const n = r.get("snapToSeries");
      n && vt(n, e);
    }
    super._removeSeries(e);
  }
  /**
   * This method is invoked when mouse wheel is used over chart's plot
   * container, and handles zooming/pan.
   *
   * You can invoke this method manually, if you need to mimic chart's wheel
   * behavior over other elements of the chart.
   */
  handleWheel(e) {
    const t = this.get("wheelX"), s = this.get("wheelY"), r = this.plotContainer, n = e.originalEvent;
    if (eo(n, this))
      n.preventDefault();
    else
      return;
    const a = r.toLocal(this._root.documentPointToRoot({ x: n.clientX, y: n.clientY })), o = this.get("wheelStep", 0.2), l = n.deltaY / 100, u = n.deltaX / 100, h = this.get("wheelZoomPositionX"), c = this.get("wheelZoomPositionY");
    (t === "zoomX" || t === "zoomXY") && u != 0 && this.xAxes.each((d) => {
      if (d.get("zoomX")) {
        let f = d.get("start"), g = d.get("end"), p = d.fixPosition(a.x / r.width());
        h != null && (p = h);
        let m = f - o * (g - f) * u * p, _ = g + o * (g - f) * u * (1 - p);
        1 / (_ - m) < d.getPrivate("maxZoomFactor", 1 / 0) / d.get("minZoomCount", 1) && this._handleWheelAnimation(d.zoom(m, _));
      }
    }), (s === "zoomX" || s === "zoomXY") && l != 0 && this.xAxes.each((d) => {
      if (d.get("zoomX")) {
        let f = d.get("start"), g = d.get("end"), p = d.fixPosition(a.x / r.width());
        h != null && (p = h);
        let m = f - o * (g - f) * l * p, _ = g + o * (g - f) * l * (1 - p);
        1 / (_ - m) < d.getPrivate("maxZoomFactor", 1 / 0) / d.get("minZoomCount", 1) && this._handleWheelAnimation(d.zoom(m, _));
      }
    }), (t === "zoomY" || t === "zoomXY") && u != 0 && this.yAxes.each((d) => {
      if (d.get("zoomY")) {
        let f = d.get("start"), g = d.get("end"), p = d.fixPosition(a.y / r.height());
        c != null && (p = c);
        let m = f - o * (g - f) * u * p, _ = g + o * (g - f) * u * (1 - p);
        1 / (_ - m) < d.getPrivate("maxZoomFactor", 1 / 0) / d.get("minZoomCount", 1) && this._handleWheelAnimation(d.zoom(m, _));
      }
    }), (s === "zoomY" || s === "zoomXY") && l != 0 && this.yAxes.each((d) => {
      if (d.get("zoomY")) {
        let f = d.get("start"), g = d.get("end"), p = d.fixPosition(a.y / r.height());
        c != null && (p = c);
        let m = f - o * (g - f) * l * p, _ = g + o * (g - f) * l * (1 - p);
        1 / (_ - m) < d.getPrivate("maxZoomFactor", 1 / 0) / d.get("minZoomCount", 1) && this._handleWheelAnimation(d.zoom(m, _));
      }
    }), (t === "panX" || t === "panXY") && u != 0 && this.xAxes.each((d) => {
      if (d.get("panX")) {
        let f = d.get("start"), g = d.get("end"), p = this._getWheelSign(d) * o * (g - f) * u, m = f + p, _ = g + p, v = this._fixWheel(m, _);
        m = v[0], _ = v[1], this._handleWheelAnimation(d.zoom(m, _));
      }
    }), (s === "panX" || s === "panXY") && l != 0 && this.xAxes.each((d) => {
      if (d.get("panX")) {
        let f = d.get("start"), g = d.get("end"), p = this._getWheelSign(d) * o * (g - f) * l, m = f + p, _ = g + p, v = this._fixWheel(m, _);
        m = v[0], _ = v[1], this._handleWheelAnimation(d.zoom(m, _));
      }
    }), (t === "panY" || t === "panXY") && u != 0 && this.yAxes.each((d) => {
      if (d.get("panY")) {
        let f = d.get("start"), g = d.get("end"), p = this._getWheelSign(d) * o * (g - f) * u, m = f + p, _ = g + p, v = this._fixWheel(m, _);
        m = v[0], _ = v[1], this._handleWheelAnimation(d.zoom(m, _));
      }
    }), (s === "panY" || s === "panXY") && l != 0 && this.yAxes.each((d) => {
      if (d.get("panY")) {
        let f = d.get("start"), g = d.get("end"), p = this._getWheelSign(d) * o * (g - f) * l, m = f - p, _ = g - p, v = this._fixWheel(m, _);
        m = v[0], _ = v[1], this._handleWheelAnimation(d.zoom(m, _));
      }
    });
  }
  _handleSetWheel() {
    const e = this.get("wheelX"), t = this.get("wheelY"), s = this.plotContainer;
    e !== "none" || t !== "none" ? (this._wheelDp = s.events.on("wheel", (r) => {
      this.handleWheel(r);
    }), this._disposers.push(this._wheelDp)) : this._wheelDp && this._wheelDp.dispose();
  }
  _getWheelSign(e) {
    let t = 1;
    return e.get("renderer").get("inversed") && (t = -1), t;
  }
  _fixWheel(e, t) {
    const s = t - e;
    return e < 0 && (e = 0, t = e + s), t > 1 && (t = 1, e = t - s), [e, t];
  }
  _handlePlotDown(e) {
    if (e.button == 2)
      return;
    const t = this.plotContainer;
    let s = t.toLocal(this._root.documentPointToRoot({ x: e.clientX, y: e.clientY }));
    if ((this.get("pinchZoomX") || this.get("pinchZoomY")) && e.pointerId && Be(t._downPoints).length > 0) {
      const a = this.xAxes.getIndex(0), o = this.yAxes.getIndex(0);
      a && (this._downStartX = a.get("start", 0), this._downEndX = a.get("end", 1)), o && (this._downStartY = o.get("start", 0), this._downEndY = o.get("end", 1));
    }
    if ((this.get("panX") || this.get("panY")) && s.x >= 0 && s.y >= 0 && s.x <= t.width() && s.y <= this.height()) {
      this._downPoint = { x: e.clientX, y: e.clientY };
      const r = this.get("panX"), n = this.get("panY");
      r && this.xAxes.each((o) => {
        o._panStart = o.get("start"), o._panEnd = o.get("end");
      }), n && this.yAxes.each((o) => {
        o._panStart = o.get("start"), o._panEnd = o.get("end");
      });
      const a = "panstarted";
      this.events.isEnabled(a) && this.events.dispatch(a, { type: a, target: this, originalEvent: e });
    }
  }
  _handleWheelAnimation(e) {
    e ? e.events.on("stopped", () => {
      this._dispatchWheelAnimation();
    }) : this._dispatchWheelAnimation();
  }
  _dispatchWheelAnimation() {
    const e = "wheelended";
    this.events.isEnabled(e) && this.events.dispatch(e, { type: e, target: this });
  }
  _handlePlotUp(e) {
    const t = this._downPoint;
    if (t && (this.get("panX") || this.get("panY"))) {
      let s = this.plotContainer.toLocal(this._root.documentPointToRoot({ x: e.clientX, y: e.clientY }));
      if (s.x == t.x && s.y == t.y) {
        const n = "pancancelled";
        this.events.isEnabled(n) && this.events.dispatch(n, { type: n, target: this, originalEvent: e });
      }
      const r = "panended";
      this.events.isEnabled(r) && this.events.dispatch(r, { type: r, target: this, originalEvent: e });
    }
    this._downPoint = void 0, this.xAxes.each((s) => {
      s._isPanning = !1;
    }), this.yAxes.each((s) => {
      s._isPanning = !1;
    });
  }
  _handlePlotMove(e) {
    const t = this.plotContainer;
    if (this.get("pinchZoomX") || this.get("pinchZoomY")) {
      const n = e.pointerId;
      if (n && (this._movePoints[n] = this._root.documentPointToRoot({ x: e.clientX, y: e.clientY }), Be(t._downPoints).length > 1)) {
        this._handlePinch();
        return;
      }
    }
    let s = this._downPoint;
    if (s) {
      s = t.toLocal(this._root.documentPointToRoot(s));
      let r = t.toLocal(this._root.documentPointToRoot({ x: e.clientX, y: e.clientY }));
      const n = this.get("panX"), a = this.get("panY");
      if (n) {
        let o = this.get("scrollbarX");
        o && o.events.disableType("rangechanged"), this.xAxes.each((l) => {
          if (l.get("panX")) {
            l._isPanning = !0;
            let u = l._panStart, h = l._panEnd, d = (h - u) * (s.x - r.x) / t.width();
            l.get("renderer").get("inversed") && (d *= -1);
            let f = u + d, g = h + d;
            g - f < 1 + l.get("maxDeviation", 1) * 2 && (l.set("start", f), l.set("end", g));
          }
        }), o && o.events.enableType("rangechanged");
      }
      if (a) {
        let o = this.get("scrollbarY");
        o && o.events.disableType("rangechanged"), this.yAxes.each((l) => {
          if (l.get("panY")) {
            l._isPanning = !0;
            let u = l._panStart, h = l._panEnd, d = (h - u) * (s.y - r.y) / t.height();
            l.get("renderer").get("inversed") && (d *= -1);
            let f = u - d, g = h - d;
            g - f < 1 + l.get("maxDeviation", 1) * 2 && (l.set("start", f), l.set("end", g));
          }
        }), o && o.events.enableType("rangechanged");
      }
    }
  }
  _handlePinch() {
    const e = this.plotContainer;
    let t = 0, s = [], r = [];
    if (_e(e._downPoints, (n, a) => {
      s[t] = a;
      let o = this._movePoints[n];
      o && (r[t] = o), t++;
    }), s.length > 1 && r.length > 1) {
      const n = e.width(), a = e.height();
      let o = s[0], l = s[1], u = r[0], h = r[1];
      if (o && l && u && h) {
        if (u = e.toLocal(u), h = e.toLocal(h), o = e.toLocal(o), l = e.toLocal(l), this.get("pinchZoomX")) {
          const c = this._downStartX, d = this._downEndX;
          if (c != null && d != null) {
            o.x > l.x && ([o, l] = [l, o], [u, h] = [h, u]);
            let f = c + o.x / n * (d - c), g = c + l.x / n * (d - c), p = c + u.x / n * (d - c), m = c + h.x / n * (d - c), _ = Math.max(1e-3, g - f), v = Math.max(1e-3, m - p), b = _ / v, y = c * b + f - p * b, w = d * b + g - m * b;
            this.xAxes.each((D) => {
              let A = D.fixPosition(y), T = D.fixPosition(w);
              D.zoom(A, T, 0);
            });
          }
        }
        if (this.get("pinchZoomY")) {
          const c = this._downStartY, d = this._downEndY;
          if (c != null && d != null) {
            o.y < l.y && ([o, l] = [l, o], [u, h] = [h, u]);
            let f = c + (1 - o.y / a) * (d - c), g = c + (1 - l.y / a) * (d - c), p = c + (1 - u.y / a) * (d - c), m = c + (1 - h.y / a) * (d - c), _ = Math.max(1e-3, g - f), v = Math.max(1e-3, m - p), b = _ / v, y = c * b + f - p * b, w = d * b + g - m * b;
            this.yAxes.each((D) => {
              let A = D.fixPosition(y), T = D.fixPosition(w);
              D.zoom(A, T, 0);
            });
          }
        }
      }
    }
  }
  _handleCursorPosition() {
    const e = this.get("cursor");
    if (e) {
      const t = e.getPrivate("point");
      let s = e.get("snapToSeries");
      if (e._downPoint && (s = void 0), s && t) {
        const r = e.get("snapToSeriesBy"), n = [];
        x(s, (l) => {
          if (!l.isHidden() && !l.isHiding())
            if (r != "x!" && r != "y!") {
              const u = l.startIndex(), h = l.endIndex();
              for (let c = u; c < h; c++) {
                const d = l.dataItems[c];
                d && !d.isHidden() && n.push(d);
              }
            } else {
              const u = l.get("tooltipDataItem");
              u && n.push(u);
            }
        });
        let a = 1 / 0, o;
        if (x(n, (l) => {
          const u = l.get("point");
          if (u) {
            let h = 0;
            r == "x" || r == "x!" ? h = Math.abs(t.x - u.x) : r == "y" || r == "y!" ? h = Math.abs(t.y - u.y) : h = Math.hypot(t.x - u.x, t.y - u.y), h < a && (a = h, o = l);
          }
        }), x(s, (l) => {
          const u = l.get("tooltip");
          u && u._setDataItem(void 0);
        }), o) {
          let l = o.component;
          l.showDataItemTooltip(o);
          const u = o.get("point");
          u && e.handleMove(l.toGlobal({ x: u.x - l.x(), y: u.y - l.y() }), !0);
        }
      }
    }
  }
  _updateCursor() {
    let e = this.get("cursor");
    e && e.handleMove();
  }
  _addCursor(e) {
    this.plotContainer.children.push(e);
  }
  _prepareChildren() {
    if (super._prepareChildren(), this.series.each((e) => {
      this._colorize(e);
    }), (this.isDirty("wheelX") || this.isDirty("wheelY")) && this._handleSetWheel(), this.isDirty("cursor")) {
      const e = this._prevSettings.cursor, t = this.get("cursor");
      t !== e && (this._disposeProperty("cursor"), e && e.dispose(), t && (t._setChart(this), this._addCursor(t), this._pushPropertyDisposer("cursor", t.events.on("selectended", () => {
        this._handleCursorSelectEnd();
      }))), this._prevSettings.cursor = t);
    }
    if (this.isDirty("scrollbarX")) {
      const e = this._prevSettings.scrollbarX, t = this.get("scrollbarX");
      t !== e && (this._disposeProperty("scrollbarX"), e && e.dispose(), t && (t.parent || this.topAxesContainer.children.push(t), this._pushPropertyDisposer("scrollbarX", t.events.on("rangechanged", (s) => {
        this._handleScrollbar(this.xAxes, s.start, s.end, s.grip);
      })), t.setPrivate("positionTextFunction", (s) => {
        const r = this.xAxes.getIndex(0);
        return r && r.getTooltipText(s) || "";
      })), this._prevSettings.scrollbarX = t);
    }
    if (this.isDirty("scrollbarY")) {
      const e = this._prevSettings.scrollbarY, t = this.get("scrollbarY");
      t !== e && (this._disposeProperty("scrollbarY"), e && e.dispose(), t && (t.parent || this.rightAxesContainer.children.push(t), this._pushPropertyDisposer("scrollbarY", t.events.on("rangechanged", (s) => {
        this._handleScrollbar(this.yAxes, s.start, s.end, s.grip);
      })), t.setPrivate("positionTextFunction", (s) => {
        const r = this.yAxes.getIndex(0);
        return r && r.getTooltipText(s) || "";
      })), this._prevSettings.scrollbarY = t);
    }
    this._handleZoomOut();
  }
  _processSeries(e) {
    super._processSeries(e), this._colorize(e);
  }
  _colorize(e) {
    const t = this.get("colors");
    if (t && e.get("fill") == null) {
      const s = t.next();
      e._setSoft("stroke", s), e._setSoft("fill", s);
    }
  }
  _handleCursorSelectEnd() {
    const e = this.get("cursor"), t = e.get("behavior"), s = e.getPrivate("downPositionX", 0), r = e.getPrivate("downPositionY", 0), n = e.getPrivate("positionX", 0.5), a = e.getPrivate("positionY", 0.5);
    this.xAxes.each((o) => {
      if (t === "zoomX" || t === "zoomXY") {
        let l = o.toAxisPosition(s), u = o.toAxisPosition(n);
        o.zoom(l, u);
      }
      o.setPrivate("updateScrollbar", !0);
    }), this.yAxes.each((o) => {
      if (t === "zoomY" || t === "zoomXY") {
        let l = o.toAxisPosition(r), u = o.toAxisPosition(a);
        o.zoom(l, u);
      }
      o.setPrivate("updateScrollbar", !0);
    });
  }
  _handleScrollbar(e, t, s, r) {
    e.each((n) => {
      let a = n.fixPosition(t), o = n.fixPosition(s), l = n.zoom(a, o, void 0, r);
      const u = "updateScrollbar";
      n.setPrivateRaw(u, !1), l ? l.events.on("stopped", () => {
        n.setPrivateRaw(u, !0);
      }) : n.setPrivateRaw(u, !0);
    });
  }
  _processAxis(e, t) {
    return e.events.onAll((s) => {
      if (s.type === "clear")
        x(s.oldValues, (r) => {
          this._removeAxis(r);
        });
      else if (s.type === "push")
        t.children.push(s.newValue), s.newValue.processChart(this);
      else if (s.type === "setIndex")
        t.children.setIndex(s.index, s.newValue), s.newValue.processChart(this);
      else if (s.type === "insertIndex")
        t.children.insertIndex(s.index, s.newValue), s.newValue.processChart(this);
      else if (s.type === "removeIndex")
        this._removeAxis(s.oldValue);
      else if (s.type === "moveIndex")
        t.children.moveValue(s.value, s.newIndex), s.value.processChart(this);
      else
        throw new Error("Unknown IListEvent type");
    });
  }
  _removeAxis(e) {
    if (!e.isDisposed()) {
      const t = e.parent;
      t && t.children.removeValue(e);
      const s = e.gridContainer, r = s.parent;
      r && r.children.removeValue(s);
      const n = e.topGridContainer, a = n.parent;
      a && a.children.removeValue(n);
    }
  }
  _updateChartLayout() {
    const e = this.leftAxesContainer.width(), t = this.rightAxesContainer.width(), s = this.bottomAxesContainer;
    s.set("paddingLeft", e), s.set("paddingRight", t);
    const r = this.topAxesContainer;
    r.set("paddingLeft", e), r.set("paddingRight", t);
  }
  /**
   * @ignore
   */
  processAxis(e) {
  }
  _handleAxisSelection(e, t) {
    let s = e.fixPosition(e.get("start", 0)), r = e.fixPosition(e.get("end", 1));
    if (s > r && ([s, r] = [r, s]), this.xAxes.indexOf(e) != -1) {
      if (t || e.getPrivate("updateScrollbar")) {
        let n = this.get("scrollbarX");
        n && (!n.getPrivate("isBusy") || t) && (n.setRaw("start", s), n.setRaw("end", r), n.updateGrips());
      }
    } else if (this.yAxes.indexOf(e) != -1 && (t || e.getPrivate("updateScrollbar"))) {
      let n = this.get("scrollbarY");
      n && (!n.getPrivate("isBusy") || t) && (n.setRaw("start", s), n.setRaw("end", r), n.updateGrips());
    }
    this._handleZoomOut();
  }
  _handleZoomOut() {
    let e = this.zoomOutButton;
    if (e && e.parent) {
      let t = !1;
      this.xAxes.each((s) => {
        (s.get("start") != 0 || s.get("end") != 1) && (t = !0);
      }), this.yAxes.each((s) => {
        (s.get("start") != 0 || s.get("end") != 1) && (t = !0);
      }), t ? e.isHidden() && e.show() : e.hide();
    }
  }
  /**
   * Checks if point is within plot area.
   *
   * @param   point  Reference point
   * @return         Is within plot area?
   */
  inPlot(e) {
    const t = this.plotContainer, s = this.getPrivate("otherCharts", this._otherCharts), r = t.toGlobal(e);
    if (e.x >= -0.5 && e.y >= -0.5 && e.x <= t.width() + 0.5 && e.y <= t.height() + 0.5)
      return !0;
    if (s)
      for (let n = s.length - 1; n >= 0; n--) {
        const a = s[n];
        if (a != this) {
          const o = a.plotContainer, l = this._root.rootPointToDocument(r), u = a._root.documentPointToRoot(l), h = o.toLocal(u);
          if (h.x >= -0.1 && h.y >= -0.1 && h.x <= o.width() + 0.1 && h.y <= o.height() + 0.1)
            return !0;
        }
      }
    return !1;
  }
  /**
   * @ignore
   */
  arrangeTooltips() {
    const e = this.plotContainer, t = e.width(), s = e.height(), r = this.height();
    let n = e._display.toGlobal({ x: 0, y: 0 }), a = e._display.toGlobal({ x: t, y: s });
    const o = [];
    let l = 0, u = 1 / 0, h = this._movePoint, c = this.get("maxTooltipDistance"), d = this.get("maxTooltipDistanceBy", "xy"), f, g;
    S(c) && this.series.each((m) => {
      if (!m.isHidden()) {
        const _ = m.get("tooltip");
        if (_) {
          let v = _.get("pointTo");
          if (v) {
            let b = Math.hypot(h.x - v.x, h.y - v.y);
            d == "x" ? b = Math.abs(h.x - v.x) : d == "y" && (b = Math.abs(h.y - v.y)), b < u && (u = b, f = m, g = v);
          }
        }
      }
    });
    const p = [];
    if (this.series.each((m) => {
      const _ = m.get("tooltip");
      if (_) {
        let v = !1, b = _.get("pointTo");
        if (b) {
          if (c >= 0) {
            let y = _.get("pointTo");
            if (y && m != f) {
              let w = Math.hypot(g.x - y.x, g.y - y.y);
              d == "x" ? w = Math.abs(g.x - y.x) : d == "y" && (w = Math.abs(g.y - y.y)), w > c && (v = !0);
            }
          } else
            c == -1 && m != f && (v = !0);
          !this.inPlot(this._tooltipToLocal(b)) || !_.dataItem ? v = !0 : v || (l += b.y), v || m.isHidden() || m.isHiding() ? _.hide(0) : (_.show(), o.push(_), p.push(m));
        }
      }
    }), this.setPrivate("tooltipSeries", p), this.get("arrangeTooltips")) {
      const m = this._root.tooltipContainer, _ = o.length;
      if (l / _ > s / 2 + n.y) {
        o.sort((y, w) => Ku(w.get("pointTo").y, y.get("pointTo").y));
        let b = a.y;
        if (x(o, (y) => {
          let w = y.height(), D = y.get("centerY");
          D instanceof ne && (w *= D.value), w += y.get("marginBottom", 0), y.set("bounds", { left: n.x, top: n.y, right: a.x, bottom: b }), y.setPrivate("customData", { left: n.x, top: n.y, right: a.x, bottom: b }), b = Math.min(b - w, y._fy - w), y.parent == m && m.children.moveValue(y, 0);
        }), b < 0) {
          o.reverse();
          let y = b;
          x(o, (w) => {
            let D = w.get("bounds");
            if (D) {
              let A = D.top - b, T = D.bottom - b;
              A < y && (A = y, T = A + w.height()), w.set("bounds", { left: D.left, top: A, right: D.right, bottom: T }), y = D.bottom - b + w.get("marginBottom", 0);
            }
          });
        }
      } else {
        o.reverse(), o.sort((y, w) => Ku(y.get("pointTo").y, w.get("pointTo").y));
        let b = 0;
        if (x(o, (y) => {
          let w = y.height(), D = y.get("centerY");
          D instanceof ne && (w *= D.value), w += y.get("marginBottom", 0), y.set("bounds", { left: n.x, top: b, right: a.x, bottom: Math.max(n.y + r, b + w) }), y.parent == m && m.children.moveValue(y, 0), b = Math.max(b + w, y._fy + w);
        }), b > r) {
          o.reverse();
          let y = r;
          x(o, (w) => {
            let D = w.get("bounds");
            if (D) {
              let A = D.top - (r - b), T = D.bottom - (r - b);
              T > y && (T = y, A = T - w.height()), w.set("bounds", { left: D.left, top: A, right: D.right, bottom: T }), y = T - w.height() - w.get("marginBottom", 0);
            }
          });
        }
      }
    }
  }
  _tooltipToLocal(e) {
    return this.plotContainer.toLocal(e);
  }
  /**
   * Fully zooms out the chart.
   */
  zoomOut() {
    this.xAxes.each((e) => {
      e.setPrivate("updateScrollbar", !0), e.zoom(0, 1);
    }), this.yAxes.each((e) => {
      e.setPrivate("updateScrollbar", !0), e.zoom(0, 1);
    });
  }
};
Object.defineProperty(tr, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "XYChart"
});
Object.defineProperty(tr, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Bi.classNames.concat([tr.className])
});
class Zr extends yi {
  constructor() {
    super(...arguments), Object.defineProperty(this, "chart", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.children.push(tr.new(this._root, {
        themeTags: ["chart"],
        interactive: !1,
        interactiveChildren: !1,
        panX: !1,
        panY: !1,
        wheelX: "none",
        wheelY: "none"
      }))
    }), Object.defineProperty(this, "overlay", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.children.push(he.new(this._root, {
        themeTags: ["overlay"],
        interactive: !1
      }))
    });
  }
  _afterNew() {
    this._addOrientationClass(), this._settings.themeTags = se(this._settings.themeTags, ["scrollbar", "xy", "chart", this._settings.orientation]);
    const e = this.children;
    e.moveValue(this.thumb), e.moveValue(this.startGrip), e.moveValue(this.endGrip), this.thumb.set("opacity", 0), this.thumb.states.create("hover", { opacity: 0.2 });
    const t = this.chart.plotContainer;
    t.set("interactive", !1), t.remove("background"), t.children.removeValue(this.chart.zoomOutButton), super._afterNew();
  }
  _updateThumb() {
    super._updateThumb(), this.overlay.set("draw", (e) => {
      const t = this.startGrip, s = this.endGrip;
      let r = t.x(), n = t.y(), a = s.x(), o = s.y();
      const l = this.height(), u = this.width();
      r > a && ([r, a] = [a, r]), n > o && ([n, o] = [o, n]), this.get("orientation") === "horizontal" ? (e.moveTo(0, 0), e.lineTo(r, 0), e.lineTo(r, l), e.lineTo(0, l), e.lineTo(0, 0), e.moveTo(a, 0), e.lineTo(u, 0), e.lineTo(u, l), e.lineTo(a, l), e.lineTo(a, 0)) : (e.moveTo(0, 0), e.lineTo(0, n), e.lineTo(u, n), e.lineTo(u, 0), e.lineTo(0, 0), e.moveTo(0, o), e.lineTo(0, l), e.lineTo(u, l), e.lineTo(u, o), e.lineTo(0, o));
    });
  }
}
Object.defineProperty(Zr, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "XYChartScrollbar"
});
Object.defineProperty(Zr, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: yi.classNames.concat([Zr.className])
});
class Ss extends he {
  _beforeChanged() {
    super._beforeChanged(), (this.isPrivateDirty("width") || this.isPrivateDirty("height")) && (this._clear = !0);
  }
}
Object.defineProperty(Ss, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Grid"
});
Object.defineProperty(Ss, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: he.classNames.concat([Ss.className])
});
class Kr extends Z {
  constructor() {
    super(...arguments), Object.defineProperty(this, "lineX", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.children.push(Ss.new(this._root, {
        themeTags: ["x"]
      }))
    }), Object.defineProperty(this, "lineY", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.children.push(Ss.new(this._root, {
        themeTags: ["y"]
      }))
    }), Object.defineProperty(this, "selection", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.children.push(he.new(this._root, {
        themeTags: ["selection", "cursor"],
        layer: 30
      }))
    }), Object.defineProperty(this, "_movePoint", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_lastPoint", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: { x: 0, y: 0 }
    }), Object.defineProperty(this, "_tooltipX", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_tooltipY", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "chart", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_toX", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_toY", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  _afterNew() {
    this._settings.themeTags = se(this._settings.themeTags, ["xy", "cursor"]), super._afterNew(), this.setAll({ width: R, height: R, isMeasured: !0, position: "absolute" }), this.states.create("hidden", { visible: !0, opacity: 0 }), this._drawLines(), this.setPrivateRaw("visible", !1), this._disposers.push(this.setTimeout(() => {
      this.setPrivate("visible", !0);
    }, 500)), this._disposers.push(this.lineX.events.on("positionchanged", () => {
      this._handleXLine();
    })), this._disposers.push(this.lineY.events.on("positionchanged", () => {
      this._handleYLine();
    })), this._disposers.push(this.lineX.events.on("focus", (e) => this._handleLineFocus(e.target))), this._disposers.push(this.lineX.events.on("blur", (e) => this._handleLineBlur(e.target))), this._disposers.push(this.lineY.events.on("focus", (e) => this._handleLineFocus(e.target))), this._disposers.push(this.lineY.events.on("blur", (e) => this._handleLineBlur(e.target))), Ut("keyboardevents") && this._disposers.push(Ie(document, "keydown", (e) => {
      this._handleLineMove(e.keyCode);
    }));
  }
  _setUpTouch() {
    const e = this.chart;
    e && (e.plotContainer._display.cancelTouch = this.get("behavior") != "none");
  }
  _handleXLine() {
    let e = this.lineX.x(), t = !0;
    (e < 0 || e > this.width()) && (t = !1), this.lineX.setPrivate("visible", t);
  }
  _handleYLine() {
    let e = this.lineY.y(), t = !0;
    (e < 0 || e > this.height()) && (t = !1), this.lineY.setPrivate("visible", t);
  }
  _handleLineMove(e) {
    let t = "", s = 0, r = 0.1;
    const n = this.chart;
    this._root.focused(this.lineX) ? (n && n.xAxes.length && (r = n.xAxes.getIndex(0).getCellWidthPosition()), s = this.getPrivate("positionX", 0), t = "positionX", e == 37 ? s -= r : e == 39 && (s += r)) : this._root.focused(this.lineY) && (n && n.yAxes.length && (r = n.yAxes.getIndex(0).getCellWidthPosition()), s = this.getPrivate("positionY", 0), t = "positionY", e == 38 ? s -= r : e == 40 && (s += r)), s < 0 ? s = 0 : s > 1 && (s = 1), t != "" && this.set(t, s);
  }
  _handleLineFocus(e) {
    this.setAll({
      positionX: this.getPrivate("positionX"),
      positionY: this.getPrivate("positionY"),
      alwaysShow: !0
    });
  }
  _handleLineBlur(e) {
    this.setAll({
      positionX: void 0,
      positionY: void 0,
      alwaysShow: !1
    });
  }
  _prepareChildren() {
    if (super._prepareChildren(), this.isDirty("xAxis")) {
      this._tooltipX = !1;
      const e = this.get("xAxis");
      if (e) {
        const t = e.get("tooltip");
        t && (this._tooltipX = !0, this._disposers.push(t.on("pointTo", () => {
          this._updateXLine(t);
        })));
      }
    }
    if (this.isDirty("yAxis")) {
      this._tooltipY = !1;
      const e = this.get("yAxis");
      if (e) {
        const t = e.get("tooltip");
        t && (this._tooltipY = !0, this._disposers.push(t.on("pointTo", () => {
          this._updateYLine(t);
        })));
      }
    }
  }
  _handleSyncWith() {
    const e = this.chart;
    if (e) {
      const t = this.get("syncWith"), s = [];
      t && x(t, (r) => {
        const n = r.chart;
        n && s.push(n);
      }), e._otherCharts = s;
    }
  }
  _updateChildren() {
    if (super._updateChildren(), this._handleSyncWith(), this.isDirty("positionX") || this.isDirty("positionY")) {
      const e = this.get("positionX"), t = this.get("positionY");
      e == null && t == null ? this.hide(0) : (this._movePoint = this.toGlobal(this._getPoint(this.get("positionX", 0), this.get("positionY", 0))), this.handleMove());
    }
  }
  _updateXLine(e) {
    let t = tt(this._display.toLocal(e.get("pointTo", { x: 0, y: 0 })).x, 2);
    this._toX != t && (this.lineX.animate({ key: "x", to: t, duration: e.get("animationDuration", 0), easing: e.get("animationEasing") }), this._toX = t);
  }
  _updateYLine(e) {
    let t = tt(this._display.toLocal(e.get("pointTo", { x: 0, y: 0 })).y, 2);
    this._toY != t && (this.lineY.animate({ key: "y", to: t, duration: e.get("animationDuration", 0), easing: e.get("animationEasing") }), this._toY = t);
  }
  _drawLines() {
    this.lineX.set("draw", (e) => {
      e.moveTo(0, 0), e.lineTo(0, this.height());
    }), this.lineY.set("draw", (e) => {
      e.moveTo(0, 0), e.lineTo(this.width(), 0);
    });
  }
  _setChart(e) {
    this.chart = e, this._handleSyncWith();
    const t = e.plotContainer;
    this.events.on("boundschanged", () => {
      this._disposers.push(this.setTimeout(() => {
        this.get("alwaysShow") && (this._movePoint = this.toGlobal(this._getPoint(this.get("positionX", 0), this.get("positionY", 0))), this.handleMove());
      }, 50));
    }), Ut("touchevents") && (this._disposers.push(t.events.on("click", (r) => {
      ra(r.originalEvent) && this._handleMove(r.originalEvent);
    })), this._setUpTouch()), this._disposers.push(t.events.on("pointerdown", (r) => {
      this._handleCursorDown(r.originalEvent);
    })), this._disposers.push(t.events.on("globalpointerup", (r) => {
      this._handleCursorUp(r.originalEvent), !r.native && !this.isHidden() && this._handleMove(r.originalEvent);
    })), this._disposers.push(t.events.on("globalpointermove", (r) => {
      !this.get("syncWith") && Be(t._downPoints).length == 0 && !r.native && this.isHidden() || this._handleMove(r.originalEvent);
    }));
    const s = this.parent;
    s && s.children.moveValue(this.selection);
  }
  _inPlot(e) {
    const t = this.chart;
    return t ? t.inPlot(e) : !1;
  }
  _handleCursorDown(e) {
    if (e.button == 2)
      return;
    const t = this._root.documentPointToRoot({ x: e.clientX, y: e.clientY });
    let s = this._display.toLocal(t);
    const r = this.chart;
    if (this.selection.set("draw", () => {
    }), r && this._inPlot(s)) {
      if (this._downPoint = s, this.get("behavior") != "none") {
        this.selection.show();
        const o = "selectstarted";
        this.events.isEnabled(o) && this.events.dispatch(o, { type: o, target: this });
      }
      let n = this._getPosition(s).x, a = this._getPosition(s).y;
      this.setPrivate("downPositionX", n), this.setPrivate("downPositionY", a);
    }
  }
  _handleCursorUp(e) {
    if (this._downPoint) {
      const t = this.get("behavior", "none");
      if (t != "none") {
        t.charAt(0) === "z" && this.selection.hide();
        const s = this._root.documentPointToRoot({ x: e.clientX, y: e.clientY });
        let r = this._display.toLocal(s);
        const n = this._downPoint, a = this.get("moveThreshold", 1);
        if (r && n) {
          let o = !1;
          if ((t === "zoomX" || t === "zoomXY" || t === "selectX" || t === "selectXY") && Math.abs(r.x - n.x) > a && (o = !0), (t === "zoomY" || t === "zoomXY" || t === "selectY" || t === "selectXY") && Math.abs(r.y - n.y) > a && (o = !0), o) {
            const l = "selectended";
            this.events.isEnabled(l) && this.events.dispatch(l, { type: l, target: this });
          }
        }
      }
    }
    this._downPoint = void 0;
  }
  _handleMove(e) {
    if (this.getPrivate("visible")) {
      const t = this.chart;
      if (t && Be(t.plotContainer._downPoints).length > 1) {
        this.set("forceHidden", !0);
        return;
      } else
        this.set("forceHidden", !1);
      const s = this._root.documentPointToRoot({ x: e.clientX, y: e.clientY }), r = this._lastPoint;
      if (Math.round(r.x) === Math.round(s.x) && Math.round(r.y) === Math.round(s.y))
        return;
      this._lastPoint = s, this.setPrivate("lastPoint", s), this.handleMove({ x: s.x, y: s.y });
    }
  }
  _getPosition(e) {
    return { x: e.x / this.width(), y: e.y / this.height() };
  }
  /**
   * Moves the cursor to X/Y coordinates within chart container (`point`).
   *
   * If `skipEvent` parameter is set to `true`, the move will not invoke
   * the `"cursormoved"` event.
   *
   * @param  point      X/Y to move cursor to
   * @param  skipEvent  Do not fire "cursormoved" event
   */
  handleMove(e, t) {
    e || (e = this._movePoint);
    const s = this.get("alwaysShow");
    if (!e) {
      this.hide(0);
      return;
    }
    this._movePoint = e;
    let r = this._display.toLocal(e), n = this.chart;
    if (n && this._inPlot(r)) {
      n._movePoint = e, this.isHidden() && (this.show(), this.get("behavior", "").charAt(0) == "z" && this.selection.set("draw", () => {
      }));
      let a = r.x, o = r.y, l = this._getPosition(r);
      this.setPrivate("point", r);
      let u = this.get("snapToSeries");
      this._downPoint && (u = void 0);
      let h = this.get("positionX"), c = l.x;
      S(h) && (c = h);
      let d = this.get("positionY"), f = l.y;
      S(d) && (f = d), this.setPrivate("positionX", c), this.setPrivate("positionY", f);
      const g = this._getPoint(c, f);
      if (a = g.x, o = g.y, n.xAxes.each((p) => {
        p._handleCursorPosition(c, u), s && p.handleCursorShow();
      }), n.yAxes.each((p) => {
        p._handleCursorPosition(f, u), s && p.handleCursorShow();
      }), !t) {
        n._handleCursorPosition();
        const p = "cursormoved";
        this.events.isEnabled(p) && this.events.dispatch(p, { type: p, target: this });
      }
      this._updateLines(a, o), n.arrangeTooltips();
    } else if (!this._downPoint && !s) {
      this.hide(0);
      const a = "cursorhidden";
      this.events.isEnabled(a) && this.events.dispatch(a, { type: a, target: this });
    }
    this._downPoint && this.get("behavior") != "none" && this._updateSelection(r);
  }
  _getPoint(e, t) {
    return { x: this.width() * e, y: this.height() * t };
  }
  _updateLines(e, t) {
    this._tooltipX || this.lineX.set("x", e), this._tooltipY || this.lineY.set("y", t), this._drawLines();
  }
  _updateSelection(e) {
    const t = this.selection, s = this.get("behavior"), r = this.width(), n = this.height();
    e.x < 0 && (e.x = 0), e.x > r && (e.x = r), e.y < 0 && (e.y = 0), e.y > n && (e.y = n), t.set("draw", (a) => {
      const o = this._downPoint;
      o && (s === "zoomXY" || s === "selectXY" ? (a.moveTo(o.x, o.y), a.lineTo(o.x, e.y), a.lineTo(e.x, e.y), a.lineTo(e.x, o.y), a.lineTo(o.x, o.y)) : s === "zoomX" || s === "selectX" ? (a.moveTo(o.x, 0), a.lineTo(o.x, n), a.lineTo(e.x, n), a.lineTo(e.x, 0), a.lineTo(o.x, 0)) : (s === "zoomY" || s === "selectY") && (a.moveTo(0, o.y), a.lineTo(r, o.y), a.lineTo(r, e.y), a.lineTo(0, e.y), a.lineTo(0, o.y)));
    });
  }
  _onHide() {
    if (this.isHidden()) {
      let e = this.chart;
      e && (e.xAxes.each((t) => {
        t.handleCursorHide();
      }), e.yAxes.each((t) => {
        t.handleCursorHide();
      }), e.series.each((t) => {
        t.handleCursorHide();
      }));
    }
    super._onHide();
  }
  _onShow() {
    if (!this.isHidden()) {
      let e = this.chart;
      e && (e.xAxes.each((t) => {
        t.handleCursorShow();
      }), e.yAxes.each((t) => {
        t.handleCursorShow();
      }));
    }
    super._onShow();
  }
  _dispose() {
    super._dispose(), this.selection.dispose();
  }
}
Object.defineProperty(Kr, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "XYCursor"
});
Object.defineProperty(Kr, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Z.classNames.concat([Kr.className])
});
function iS(i, e) {
  return i == null ? e : e == null ? i : e < i ? e : i;
}
function sS(i, e) {
  return i == null ? e : e == null ? i : e > i ? e : i;
}
class Hi extends ai {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_xField", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_yField", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_xOpenField", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_yOpenField", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_xLowField", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_xHighField", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_yLowField", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_yHighField", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_axesDirty", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_stackDirty", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_selectionProcessed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_dataSets", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_mainContainerMask", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_x", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_y", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "mainContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.children.push(Z.new(this._root, {}))
    }), Object.defineProperty(this, "axisRanges", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new cr()
    }), Object.defineProperty(this, "_skipped", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_couldStackTo", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_reallyStackedTo", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_stackedSeries", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_aLocationX0", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_aLocationX1", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), Object.defineProperty(this, "_aLocationY0", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_aLocationY1", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), Object.defineProperty(this, "_showBullets", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "valueXFields", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: [
        "valueX",
        "openValueX",
        "lowValueX",
        "highValueX"
      ]
    }), Object.defineProperty(this, "valueYFields", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: [
        "valueY",
        "openValueY",
        "lowValueY",
        "highValueY"
      ]
    }), Object.defineProperty(this, "_valueXFields", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_valueYFields", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_valueXShowFields", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_valueYShowFields", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "__valueXShowFields", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "__valueYShowFields", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_emptyDataItem", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new Gt(this, void 0, {})
    }), Object.defineProperty(this, "_dataSetId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_tooltipFieldX", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_tooltipFieldY", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  _afterNew() {
    this.fields.push("categoryX", "categoryY", "openCategoryX", "openCategoryY"), this.valueFields.push("valueX", "valueY", "openValueX", "openValueY", "lowValueX", "lowValueY", "highValueX", "highValueY"), this._setRawDefault("vcx", 1), this._setRawDefault("vcy", 1), this._setRawDefault("valueXShow", "valueXWorking"), this._setRawDefault("valueYShow", "valueYWorking"), this._setRawDefault("openValueXShow", "openValueXWorking"), this._setRawDefault("openValueYShow", "openValueYWorking"), this._setRawDefault("lowValueXShow", "lowValueXWorking"), this._setRawDefault("lowValueYShow", "lowValueYWorking"), this._setRawDefault("highValueXShow", "highValueXWorking"), this._setRawDefault("highValueYShow", "highValueYWorking"), this._setRawDefault("lowValueXGrouped", "low"), this._setRawDefault("lowValueYGrouped", "low"), this._setRawDefault("highValueXGrouped", "high"), this._setRawDefault("highValueYGrouped", "high"), super._afterNew(), this._settings.xAxis.series.push(this), this._settings.yAxis.series.push(this), this.set("maskContent", !0), this._disposers.push(this.axisRanges.events.onAll((s) => {
      if (s.type === "clear")
        x(s.oldValues, (r) => {
          this._removeAxisRange(r);
        });
      else if (s.type === "push")
        this._processAxisRange(s.newValue);
      else if (s.type === "setIndex")
        this._processAxisRange(s.newValue);
      else if (s.type === "insertIndex")
        this._processAxisRange(s.newValue);
      else if (s.type === "removeIndex")
        this._removeAxisRange(s.oldValue);
      else if (s.type === "moveIndex")
        this._processAxisRange(s.value);
      else
        throw new Error("Unknown IStreamEvent type");
    }));
    const e = this.get("xAxis"), t = this.get("yAxis");
    this._disposers.push(e.events.on("positionchanged", () => {
      this._fixPosition();
    })), this._disposers.push(t.events.on("positionchanged", () => {
      this._fixPosition();
    })), this.get("baseAxis") || (t.isType("CategoryAxis") || t.isType("DateAxis") ? this.set("baseAxis", t) : this.set("baseAxis", e)), this.states.create("hidden", { opacity: 1, visible: !1 }), this._makeFieldNames();
  }
  _processAxisRange(e) {
    const t = Z.new(this._root, {});
    e.container = t, this.children.push(t), e.series = this;
    const s = e.axisDataItem;
    s.setRaw("isRange", !0);
    const r = s.component;
    if (r) {
      r._processAxisRange(s, ["range", "series"]);
      const n = s.get("bullet");
      if (n) {
        const o = n.get("sprite");
        o && o.setPrivate("visible", !1);
      }
      const a = s.get("axisFill");
      a && t.set("mask", a), r._seriesAxisRanges.push(s);
    }
  }
  _removeAxisRange(e) {
    const t = e.axisDataItem, s = t.component;
    s.disposeDataItem(t), vt(s._seriesAxisRanges, t);
    const r = e.container;
    r && r.dispose();
  }
  _updateFields() {
    super._updateFields(), this._valueXFields = [], this._valueYFields = [], this._valueXShowFields = [], this._valueYShowFields = [], this.__valueXShowFields = [], this.__valueYShowFields = [], this.valueXFields && x(this.valueXFields, (e) => {
      if (this.get(e + "Field")) {
        this._valueXFields.push(e);
        let s = this.get(e + "Show");
        this.__valueXShowFields.push(s), s.indexOf("Working") != -1 ? this._valueXShowFields.push(s.split("Working")[0]) : this._valueXShowFields.push(s);
      }
    }), this.valueYFields && x(this.valueYFields, (e) => {
      if (this.get(e + "Field")) {
        this._valueYFields.push(e);
        let s = this.get(e + "Show");
        this.__valueYShowFields.push(s), s.indexOf("Working") != -1 ? this._valueYShowFields.push(s.split("Working")[0]) : this._valueYShowFields.push(s);
      }
    });
  }
  _dispose() {
    super._dispose();
    const e = this.chart;
    e && e.series.removeValue(this), ot(this.get("xAxis").series, this), ot(this.get("yAxis").series, this);
  }
  // TODO use  SelectKeys<this["_privateSettings"], number | undefined>
  _min(e, t) {
    let s = iS(this.getPrivate(e), t);
    this.setPrivate(e, s);
  }
  // TODO use  SelectKeys<this["_privateSettings"], number | undefined>
  _max(e, t) {
    let s = sS(this.getPrivate(e), t);
    this.setPrivate(e, s);
  }
  _shouldMakeBullet(e) {
    const t = this.get("xAxis"), s = this.get("yAxis"), r = this.get("baseAxis");
    if (!t.inited || !s.inited)
      return !1;
    const n = this.get("minBulletDistance", 0);
    if (n > 0) {
      let a = this.startIndex(), l = this.endIndex() - a;
      if (t == r) {
        if (t.get("renderer").axisLength() / l < n / 5)
          return !1;
      } else if (s == r && s.get("renderer").axisLength() / l < n / 5)
        return !1;
    }
    return e.get(this._xField) != null && e.get(this._yField) != null;
  }
  _makeFieldNames() {
    const e = this.get("xAxis"), t = this.get("yAxis"), s = e.getPrivate("name"), r = al(s), n = t.getPrivate("name"), a = al(n), o = e.get("renderer").getPrivate("letter"), l = t.get("renderer").getPrivate("letter"), u = "open", h = "low", c = "high", d = "Show";
    e.className === "ValueAxis" ? (this._xField = this.get(s + o + d), this._xOpenField = this.get(u + r + o + d), this._xLowField = this.get(h + r + o + d), this._xHighField = this.get(c + r + o + d)) : (this._xField = s + o, this._xOpenField = u + r + o, this._xLowField = h + r + o, this._xHighField = c + r + o), t.className === "ValueAxis" ? (this._yField = this.get(n + l + d), this._yOpenField = this.get(u + a + l + d), this._yLowField = this.get(h + a + l + d), this._yHighField = this.get(c + a + l + d)) : (this._yField = n + l, this._yOpenField = u + a + l, this._yLowField = h + a + l, this._yHighField = c + a + l);
  }
  _fixVC() {
    const e = this.get("xAxis"), t = this.get("yAxis"), s = this.get("baseAxis"), r = this.states.lookup("hidden"), n = this.get("sequencedInterpolation");
    if (r) {
      let a = 0;
      n && (a = 0.999999999999), e === s ? r.set("vcy", a) : (t === s || r.set("vcy", a), r.set("vcx", a));
    }
  }
  _handleMaskBullets() {
    this.isDirty("maskBullets") && this.bulletsContainer.set("maskContent", this.get("maskBullets"));
  }
  _fixPosition() {
    const e = this.get("xAxis"), t = this.get("yAxis");
    this.set("x", e.x() - we(e.get("centerX", 0), e.width()) - e.parent.get("paddingLeft", 0)), this.set("y", t.y() - we(t.get("centerY", 0), t.height()) - t.parent.get("paddingTop", 0)), this.bulletsContainer.set("y", this.y()), this.bulletsContainer.set("x", this.x());
  }
  _prepareChildren() {
    super._prepareChildren(), (this.isDirty("valueYShow") || this.isDirty("valueXShow")) && (this._updateFields(), this._makeFieldNames(), this._valuesDirty = !0), this.set("width", this.get("xAxis").width()), this.set("height", this.get("yAxis").height()), this._handleMaskBullets();
    const e = this.get("xAxis"), t = this.get("yAxis"), s = this.get("baseAxis"), r = this.get("tooltipPositionX");
    let n;
    switch (r) {
      case "open":
        n = this._xOpenField;
        break;
      case "low":
        n = this._xLowField;
        break;
      case "high":
        n = this._xHighField;
        break;
      default:
        n = this._xField;
    }
    this._tooltipFieldX = n;
    const a = this.get("tooltipPositionY");
    let o;
    switch (a) {
      case "open":
        o = this._yOpenField;
        break;
      case "low":
        o = this._yLowField;
        break;
      case "high":
        o = this._yHighField;
        break;
      default:
        o = this._yField;
    }
    this._tooltipFieldY = o, this.isDirty("baseAxis") && this._fixVC(), this._fixPosition();
    const l = this.get("stacked");
    if (this.isDirty("stacked") && (l ? this._valuesDirty && !this._dataProcessed || this._stack() : this._unstack()), this._valuesDirty && !this._dataProcessed && (this._dataProcessed = !0, l && this._stack(), x(this.dataItems, (u) => {
      x(this._valueXShowFields, (h) => {
        let c = u.get(h);
        c != null && (l && (c += this.getStackedXValue(u, h)), this._min("minX", c), this._max("maxX", c));
      }), x(this._valueYShowFields, (h) => {
        let c = u.get(h);
        c != null && (l && (c += this.getStackedYValue(u, h)), this._min("minY", c), this._max("maxY", c));
      }), e.processSeriesDataItem(u, this._valueXFields), t.processSeriesDataItem(u, this._valueYFields);
    }), e._seriesValuesDirty = !0, t._seriesValuesDirty = !0, this.get("ignoreMinMax") || ((this.isPrivateDirty("minX") || this.isPrivateDirty("maxX")) && e.markDirtyExtremes(), (this.isPrivateDirty("minY") || this.isPrivateDirty("maxY")) && t.markDirtyExtremes()), this._markStakedDirtyStack(), this.get("tooltipDataItem") || this.updateLegendValue(void 0)), (this.isDirty("vcx") || this.isDirty("vcy")) && this._markStakedDirtyStack(), this._dataGrouped || (e._groupSeriesData(this), t._groupSeriesData(this), this._dataGrouped = !0), this._valuesDirty || this.isPrivateDirty("startIndex") || this.isPrivateDirty("endIndex") || this.isDirty("vcx") || this.isDirty("vcy") || this._stackDirty) {
      let u = this.startIndex(), h = this.endIndex(), c = this.get("minBulletDistance", 0);
      if (c > 0 && s && (s.get("renderer").axisLength() / (h - u) > c ? this._showBullets = !0 : this._showBullets = !1), (this._psi != u || this._pei != h || this.isDirty("vcx") || this.isDirty("vcy") || this._stackDirty || this._valuesDirty) && !this._selectionProcessed) {
        this._selectionProcessed = !0;
        const d = this.get("vcx", 1), f = this.get("vcy", 1), g = this.get("stacked", !1), p = this.getPrivate("outOfSelection");
        if (s === e)
          if (t._calculateTotals(), this.setPrivateRaw("selectionMinY", void 0), this.setPrivateRaw("selectionMaxY", void 0), p)
            t.markDirtySelectionExtremes();
          else
            for (let m = u; m < h; m++)
              this.processYSelectionDataItem(this.dataItems[m], f, g);
        else if (s === t)
          if (e._calculateTotals(), this.setPrivateRaw("selectionMinX", void 0), this.setPrivateRaw("selectionMaxX", void 0), p)
            t.markDirtySelectionExtremes();
          else
            for (let m = u; m < h; m++)
              this.processXSelectionDataItem(this.dataItems[m], d, g);
        if (s === e) {
          if (this.get("valueYShow") !== "valueYWorking") {
            const m = this.getPrivate("selectionMinY");
            m != null && (this.setPrivateRaw("minY", m), t.markDirtyExtremes());
            const _ = this.getPrivate("selectionMaxY");
            _ != null && (this.setPrivateRaw("maxY", _), t.markDirtyExtremes());
          }
        } else if (s === t && this.get("valueXShow") !== "valueXWorking") {
          const m = this.getPrivate("selectionMinX");
          m != null && (this.setPrivateRaw("minX", m), t.markDirtyExtremes());
          const _ = this.getPrivate("selectionMaxX");
          _ != null && (this.setPrivateRaw("maxX", _), e.markDirtyExtremes());
        }
        (this.isPrivateDirty("selectionMinX") || this.isPrivateDirty("selectionMaxX")) && e.markDirtySelectionExtremes(), (this.isPrivateDirty("selectionMinY") || this.isPrivateDirty("selectionMaxY")) && t.markDirtySelectionExtremes();
      }
    }
  }
  _makeRangeMask() {
    if (this.axisRanges.length > 0) {
      let e = this._mainContainerMask;
      e == null && (e = this.children.push(he.new(this._root, {})), this._mainContainerMask = e, e.set("draw", (t, s) => {
        const r = this.parent;
        if (r) {
          const n = this._root.container.width(), a = this._root.container.height();
          t.moveTo(-n, -a), t.lineTo(-n, a * 2), t.lineTo(n * 2, a * 2), t.lineTo(n * 2, -a), t.lineTo(-n, -a), this.axisRanges.each((o) => {
            const l = o.axisDataItem.get("axisFill");
            if (r && l) {
              let u = l.get("draw");
              u && u(t, s);
            }
          });
        }
        this.mainContainer._display.mask = e._display;
      })), e.markDirty(), e._markDirtyKey("fill");
    } else
      this.mainContainer._display.mask = null;
  }
  _updateChildren() {
    super._updateChildren(), this._x = this.x(), this._y = this.y(), this._makeRangeMask();
  }
  _stack() {
    const e = this.chart;
    if (e) {
      const t = e.series.indexOf(this);
      if (this._couldStackTo = [], t > 0) {
        let s;
        for (let r = t - 1; r >= 0 && (s = e.series.getIndex(r), !(s.get("xAxis") === this.get("xAxis") && s.get("yAxis") === this.get("yAxis") && s.className === this.className && (this._couldStackTo.push(s), !s.get("stacked")))); r--)
          ;
      }
      this._stackDataItems();
    }
  }
  _unstack() {
    _e(this._reallyStackedTo, (e, t) => {
      delete t._stackedSeries[this.uid];
    }), this._reallyStackedTo = {}, x(this.dataItems, (e) => {
      e.setRaw("stackToItemY", void 0), e.setRaw("stackToItemX", void 0);
    });
  }
  _stackDataItems() {
    const e = this.get("baseAxis"), t = this.get("xAxis"), s = this.get("yAxis");
    let r, n;
    e === t ? (r = "valueY", n = "stackToItemY") : e === s && (r = "valueX", n = "stackToItemX");
    let a = this._couldStackTo.length, o = 0;
    const l = this.get("stackToNegative");
    this._reallyStackedTo = {}, x(this.dataItems, (u) => {
      for (let h = 0; h < a; h++) {
        let c = this._couldStackTo[h], d = c.dataItems[o], f = u.get(r);
        if (d) {
          let g = d.get(r);
          if (l)
            if (S(f)) {
              if (S(g)) {
                if (f >= 0 && g >= 0) {
                  u.setRaw(n, d), this._reallyStackedTo[c.uid] = c, c._stackedSeries[this.uid] = this;
                  break;
                }
                if (f < 0 && g < 0) {
                  u.setRaw(n, d), this._reallyStackedTo[c.uid] = c, c._stackedSeries[this.uid] = this;
                  break;
                }
              }
            } else
              break;
          else if (S(f) && S(g)) {
            u.setRaw(n, d), this._reallyStackedTo[c.uid] = c, c._stackedSeries[this.uid] = this;
            break;
          }
        }
      }
      o++;
    });
  }
  processXSelectionDataItem(e, t, s) {
    x(this.__valueXShowFields, (r) => {
      let n = e.get(r);
      n != null && (s && (n += this.getStackedXValueWorking(e, r)), this._min("selectionMinX", n), this._max("selectionMaxX", n * t));
    });
  }
  processYSelectionDataItem(e, t, s) {
    x(this.__valueYShowFields, (r) => {
      let n = e.get(r);
      n != null && (s && (n += this.getStackedYValueWorking(e, r)), this._min("selectionMinY", n), this._max("selectionMaxY", n * t));
    });
  }
  /**
   * @ignore
   */
  getStackedYValueWorking(e, t) {
    const s = e.get("stackToItemY");
    if (s) {
      const r = s.component;
      return s.get(t, 0) * r.get("vcy", 1) + this.getStackedYValueWorking(s, t);
    }
    return 0;
  }
  /**
   * @ignore
   */
  getStackedXValueWorking(e, t) {
    const s = e.get("stackToItemX");
    if (s) {
      const r = s.component;
      return s.get(t, 0) * r.get("vcx", 1) + this.getStackedXValueWorking(s, t);
    }
    return 0;
  }
  /**
   * @ignore
   */
  getStackedYValue(e, t) {
    const s = e.get("stackToItemY");
    return s ? s.get(t, 0) + this.getStackedYValue(s, t) : 0;
  }
  /**
   * @ignore
   */
  getStackedXValue(e, t) {
    const s = e.get("stackToItemX");
    return s ? s.get(t, 0) + this.getStackedXValue(s, t) : 0;
  }
  /**
   * @ignore
   */
  createLegendMarker(e) {
    this.updateLegendMarker();
  }
  _markDirtyAxes() {
    this._axesDirty = !0, this.markDirty();
  }
  _markDataSetDirty() {
    this._afterDataChange(), this._valuesDirty = !0, this._dataProcessed = !1, this._aggregatesCalculated = !1, this.markDirty();
  }
  _clearDirty() {
    super._clearDirty(), this._axesDirty = !1, this._selectionProcessed = !1, this._stackDirty = !1, this._dataProcessed = !1;
  }
  _positionBullet(e) {
    let t = e.get("sprite");
    if (t) {
      let s = t.dataItem, r = e.get("locationX", s.get("locationX", 0.5)), n = e.get("locationY", s.get("locationY", 0.5)), a = this.get("xAxis"), o = this.get("yAxis");
      const l = a.getDataItemPositionX(s, this._xField, r, this.get("vcx", 1)), u = o.getDataItemPositionY(s, this._yField, n, this.get("vcy", 1));
      let h = this.getPoint(l, u), c = s.get("left", h.x), d = s.get("right", h.x), f = s.get("top", h.y), g = s.get("bottom", h.y);
      if (this._shouldShowBullet(l, u)) {
        e.getPrivate("hidden") ? t.setPrivate("visible", !1) : t.setPrivate("visible", !0);
        let p = d - c, m = g - f;
        t.isType("Label") && (t.setPrivate("maxWidth", Math.abs(p)), t.setPrivate("maxHeight", Math.abs(m)));
        let _ = c + p * r, v = g - m * n;
        t.set("x", _), t.set("y", v);
      } else
        t.setPrivate("visible", !1);
    }
  }
  _shouldShowBullet(e, t) {
    return this._showBullets;
  }
  /**
   * @ignore
   */
  setDataSet(e) {
    if (this._dataSets[e]) {
      this._handleDataSetChange(), this._dataItems = this._dataSets[e], this._markDataSetDirty(), this._dataSetId = e;
      const t = "datasetchanged";
      this.events.isEnabled(t) && this.events.dispatch(t, { type: t, target: this, id: e });
    }
  }
  _handleDataSetChange() {
    this.bullets.length > 0 && x(this._dataItems, (e) => {
      let t = e.bullets;
      t && x(t, (s) => {
        if (s) {
          let r = s.get("sprite");
          r && r.setPrivate("visible", !1);
        }
      });
    }), this._selectionProcessed = !1;
  }
  /**
   * Shows hidden series.
   *
   * @param   duration  Duration of animation in milliseconds
   * @return            Animation promise
   */
  show(e) {
    const t = Object.create(null, {
      show: { get: () => super.show }
    });
    return Ue(this, void 0, void 0, function* () {
      this._fixVC();
      let s = [];
      s.push(t.show.call(this, e).then(() => {
        this._isShowing = !1;
        let r = this.get("xAxis"), n = this.get("yAxis"), a = this.get("baseAxis");
        n !== a && n.markDirtySelectionExtremes(), r !== a && r.markDirtySelectionExtremes();
      })), s.push(this.bulletsContainer.show(e)), s.push(this._sequencedShowHide(!0, e)), yield Promise.all(s);
    });
  }
  /**
   * Hides series.
   *
   * @param   duration  Duration of animation in milliseconds
   * @return            Animation promise
   */
  hide(e) {
    const t = Object.create(null, {
      hide: { get: () => super.hide }
    });
    return Ue(this, void 0, void 0, function* () {
      this._fixVC();
      let s = [];
      s.push(t.hide.call(this, e).then(() => {
        this._isHiding = !1;
      })), s.push(this.bulletsContainer.hide(e)), s.push(this._sequencedShowHide(!1, e)), yield Promise.all(s);
    });
  }
  /**
   * Shows series's data item.
   *
   * @param   dataItem  Data item
   * @param   duration  Animation duration in milliseconds
   * @return            Promise
   */
  showDataItem(e, t) {
    const s = Object.create(null, {
      showDataItem: { get: () => super.showDataItem }
    });
    return Ue(this, void 0, void 0, function* () {
      const r = [s.showDataItem.call(this, e, t)];
      S(t) || (t = this.get("stateAnimationDuration", 0));
      const n = this.get("stateAnimationEasing");
      x(this._valueFields, (a) => {
        r.push(e.animate({ key: a + "Working", to: e.get(a), duration: t, easing: n }).waitForStop());
      }), yield Promise.all(r);
    });
  }
  /**
   * Hides series's data item.
   *
   * @param   dataItem  Data item
   * @param   duration  Animation duration in milliseconds
   * @return            Promise
   */
  hideDataItem(e, t) {
    const s = Object.create(null, {
      hideDataItem: { get: () => super.hideDataItem }
    });
    return Ue(this, void 0, void 0, function* () {
      const r = [s.hideDataItem.call(this, e, t)], n = this.states.create("hidden", {});
      S(t) || (t = n.get("stateAnimationDuration", this.get("stateAnimationDuration", 0)));
      const a = n.get("stateAnimationEasing", this.get("stateAnimationEasing")), o = this.get("xAxis"), l = this.get("yAxis"), u = this.get("baseAxis"), h = this.get("stacked");
      if ((u === o || !u) && x(this._valueYFields, (c) => {
        let d = l.getPrivate("min"), f = l.baseValue();
        S(d) && d > f && (f = d), h && (f = 0), e.get(c) != null && r.push(e.animate({ key: c + "Working", to: f, duration: t, easing: a }).waitForStop());
      }), u === l || !u) {
        let c = o.getPrivate("min"), d = o.baseValue();
        S(c) && c > d && (d = c), h && (d = 0), x(this._valueXFields, (f) => {
          e.get(f) != null && r.push(e.animate({ key: f + "Working", to: d, duration: t, easing: a }).waitForStop());
        });
      }
      yield Promise.all(r);
    });
  }
  _markDirtyStack() {
    this._stackDirty = !0, this.markDirty(), this._markStakedDirtyStack();
  }
  _markStakedDirtyStack() {
    const e = this._stackedSeries;
    e && _e(e, (t, s) => {
      s._stackDirty || s._markDirtyStack();
    });
  }
  _afterChanged() {
    super._afterChanged(), this._skipped && (this._markDirtyAxes(), this._skipped = !1);
  }
  /**
   * Shows a tooltip for specific data item.
   *
   * @param  dataItem  Data item
   */
  showDataItemTooltip(e) {
    this.updateLegendMarker(e), this.updateLegendValue(e);
    const t = this.get("tooltip");
    if (t) {
      if (this.isHidden())
        this.hideTooltip();
      else if (t._setDataItem(e), e) {
        let s = this.get("locationX", 0), r = this.get("locationY", 1), n = e.get("locationX", s), a = e.get("locationY", r);
        const o = this.get("xAxis"), l = this.get("yAxis"), u = this.get("vcx", 1), h = this.get("vcy", 1), c = o.getDataItemPositionX(e, this._tooltipFieldX, this._aLocationX0 + (this._aLocationX1 - this._aLocationX0) * n, u), d = l.getDataItemPositionY(e, this._tooltipFieldY, this._aLocationY0 + (this._aLocationY1 - this._aLocationY0) * a, h), f = this.getPoint(c, d);
        let g = !0;
        if (x(this._valueFields, (p) => {
          e.get(p) == null && (g = !1);
        }), g) {
          const p = this.chart;
          p && p.inPlot(f) ? (t.label.text.markDirtyText(), t.set("tooltipTarget", this._getTooltipTarget(e)), t.set("pointTo", this._display.toGlobal({ x: f.x, y: f.y }))) : t._setDataItem(void 0);
        } else
          t._setDataItem(void 0);
      }
    }
  }
  hideTooltip() {
    const e = this.get("tooltip");
    return e && e.set("tooltipTarget", this), super.hideTooltip();
  }
  _getTooltipTarget(e) {
    if (this.get("seriesTooltipTarget") == "bullet") {
      const t = e.bullets;
      if (t && t.length > 0) {
        const r = t[0].get("sprite");
        if (r)
          return r;
      }
    }
    return this;
  }
  /**
   * @ignore
   */
  updateLegendValue(e) {
    const t = this.get("legendDataItem");
    if (t) {
      const s = t.get("label");
      if (s) {
        let n = "";
        e ? (s._setDataItem(e), n = this.get("legendLabelText", s.get("text", this.get("name", "")))) : (s._setDataItem(this._emptyDataItem), n = this.get("legendRangeLabelText", this.get("legendLabelText", s.get("text", this.get("name", ""))))), s.set("text", n);
      }
      const r = t.get("valueLabel");
      if (r) {
        let n = "";
        e ? (r._setDataItem(e), n = this.get("legendValueText", r.get("text", ""))) : (r._setDataItem(this._emptyDataItem), n = this.get("legendRangeValueText", r.get("text", ""))), r.set("text", n);
      }
    }
  }
  _getItemReaderLabel() {
    let e = "X: {" + this._xField;
    return this.get("xAxis").isType("DateAxis") && (e += ".formatDate()"), e += "}; Y: {" + this._yField, this.get("yAxis").isType("DateAxis") && (e += ".formatDate()"), e += "}", e;
  }
  /**
   * @ignore
   */
  getPoint(e, t) {
    let s = this.get("xAxis").get("renderer").positionToCoordinate(e), r = this.get("yAxis").get("renderer").positionToCoordinate(t), n = 999999999;
    return r < -n && (r = -n), r > n && (r = n), s < -n && (s = -n), s > n && (s = n), { x: s, y: r };
  }
  _shouldInclude(e) {
    return !0;
  }
  /**
   * @ignore
   */
  handleCursorHide() {
    this.hideTooltip(), this.updateLegendValue(void 0), this.updateLegendMarker(void 0);
  }
  _afterDataChange() {
    super._afterDataChange(), this.get("xAxis")._markDirtyKey("start"), this.get("yAxis")._markDirtyKey("start"), this.resetExtremes();
  }
  // todo description
  resetExtremes() {
    this.setPrivate("selectionMinX", void 0), this.setPrivate("selectionMaxX", void 0), this.setPrivate("selectionMinY", void 0), this.setPrivate("selectionMaxY", void 0), this.setPrivate("minX", void 0), this.setPrivate("minY", void 0), this.setPrivate("maxX", void 0), this.setPrivate("maxY", void 0);
  }
  /**
   * Creates and returns an axis range object.
   *
   * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/axis-ranges/} for more info
   * @param   axisDataItem  Axis data item
   * @return                Axis range
   */
  createAxisRange(e) {
    return this.axisRanges.push({
      axisDataItem: e
    });
  }
  /**
   * A list of series's main (ungrouped) data items.
   *
   * @return  Data items
   */
  get mainDataItems() {
    return this._mainDataItems;
  }
}
Object.defineProperty(Hi, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "XYSeries"
});
Object.defineProperty(Hi, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: ai.classNames.concat([Hi.className])
});
class zi extends Hi {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_ph", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_pw", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    });
  }
  _makeGraphics(e, t) {
    return this.makeColumn(t, e);
  }
  _makeFieldNames() {
    super._makeFieldNames();
    const e = this.get("xAxis"), t = this.get("yAxis"), s = "CategoryAxis", r = "ValueAxis";
    e.isType(s) && (this.get("openCategoryXField") || (this._xOpenField = this._xField)), e.isType(r) && (this.get("openValueXField") || (this._xOpenField = this._xField)), t.isType(s) && (this.get("openCategoryYField") || (this._yOpenField = this._yField)), t.isType(r) && (this.get("openValueYField") || (this._yOpenField = this._yField));
  }
  _prepareChildren() {
    super._prepareChildren();
    const e = this.get("xAxis"), t = this.get("yAxis"), s = this.dataItems.length, r = Math.max(0, this.startIndex() - 2), n = Math.min(this.endIndex() + 2, s - 1);
    if (e.inited && t.inited)
      for (let a = r; a <= n; a++) {
        let o = this.dataItems[a];
        this._createGraphics(o);
      }
  }
  _updateChildren() {
    const e = this.chart;
    e && (this._ph = e.plotContainer.height(), this._pw = e.plotContainer.width());
    const t = this.get("xAxis"), s = this.get("yAxis"), r = this.get("baseAxis"), n = this.columns.template;
    this.isDirty("fill") && n.get("fill") == null && n.set("fill", this.get("fill")), this.isDirty("stroke") && n.get("stroke") == null && n.set("stroke", this.get("stroke"));
    let a = 0, o = 0, l = 0;
    x(r.series, (_) => {
      if (_ instanceof zi) {
        const v = _.get("stacked");
        v && l == 0 && o++, !v && _.get("clustered") && o++;
      }
      _ === this && (a = o - 1), l++;
    }), this.get("clustered") || (a = 0, o = 1), o === 0 && (o = 1, a = 0);
    const u = t.get("renderer"), h = s.get("renderer"), c = "cellStartLocation", d = "cellEndLocation", f = u.get(c, 0), g = u.get(d, 1), p = h.get(c, 0), m = h.get(d, 1);
    if (this._aLocationX0 = f + a / o * (g - f), this._aLocationX1 = f + (a + 1) / o * (g - f), this._aLocationY0 = p + a / o * (m - p), this._aLocationY1 = p + (a + 1) / o * (m - p), t.inited && s.inited) {
      if (this._axesDirty || this._valuesDirty || this._stackDirty || this.isDirty("vcx") || this.isDirty("vcy") || this._sizeDirty) {
        const _ = this.dataItems.length;
        let v = Math.max(0, this.startIndex() - 2), b = Math.min(this.endIndex() + 2, _ - 1);
        for (let w = 0; w < v; w++)
          this._toggleColumn(this.dataItems[w], !1);
        let y = this.dataItems[v];
        for (let w = v; w <= b; w++) {
          let D = this.dataItems[w];
          if (D.get("valueX") != null && D.get("valueY") != null) {
            if (y = D, w > 0 && v > 0)
              for (let A = w - 1; A >= 0; A--) {
                let T = this.dataItems[A];
                if (T.get("valueX") != null && T.get("valueY") != null) {
                  y = T;
                  break;
                }
              }
            break;
          } else
            this._toggleColumn(D, !1);
        }
        for (let w = v; w <= b; w++) {
          let D = this.dataItems[w];
          this._updateGraphics(D, y), D.get("valueX") != null && D.get("valueY") != null && (y = D);
        }
        for (let w = b + 1; w < _; w++)
          this._toggleColumn(this.dataItems[w], !1);
      }
    } else
      this._skipped = !0;
    this.updateLegendMarker(this.get("tooltipDataItem")), super._updateChildren();
  }
  _createGraphics(e) {
    let t = e.get("graphics");
    if (!t) {
      t = this._makeGraphics(this.columns, e), e.set("graphics", t), t._setDataItem(e);
      const s = e.get("legendDataItem");
      if (s) {
        const r = s.get("markerRectangle");
        r && r.setAll({ fill: t.get("fill"), stroke: t.get("stroke") });
      }
      this.axisRanges.each((r) => {
        const n = r.container, a = e.get("rangeGraphics", []);
        e.set("rangeGraphics", a);
        const o = this._makeGraphics(r.columns, e);
        a.push(o), o.setPrivate("list", r.columns), n.children.push(o);
      });
    }
  }
  _updateGraphics(e, t) {
    let s = e.get("graphics");
    const r = this._xField, n = this._yField, a = e.get(r), o = e.get(n);
    if (a != null && o != null) {
      const l = this._xOpenField, u = this._yOpenField, h = this.get("locationX", e.get("locationX", 0.5)), c = this.get("locationY", e.get("locationY", 0.5)), d = this.get("openLocationX", e.get("openLocationX", h)), f = this.get("openLocationY", e.get("openLocationY", c)), g = s.get("width"), p = s.get("height"), m = this.get("stacked"), _ = this.get("xAxis"), v = this.get("yAxis"), b = this.get("baseAxis"), y = _.get("start"), w = _.get("end"), D = v.get("start"), A = v.get("end");
      let T, j, C, L, E = this.get("vcy", 1), N = this.get("vcx", 1), J = !1, z = !1;
      if (v.isType("CategoryAxis") && _.isType("CategoryAxis")) {
        let Y = this._aLocationX0 + d - 0.5, U = this._aLocationX1 + h - 0.5;
        if (g instanceof ne) {
          let B = (U - Y) * (1 - g.value) / 2;
          Y += B, U -= B;
        }
        if (T = _.getDataItemPositionX(e, l, Y, N), j = _.getDataItemPositionX(e, r, U, N), Y = this._aLocationY0 + f - 0.5, U = this._aLocationY1 + c - 0.5, p instanceof ne) {
          let B = (U - Y) * (1 - p.value) / 2;
          Y += B, U -= B;
        }
        C = v.getDataItemPositionY(e, u, Y, E), L = v.getDataItemPositionY(e, n, U, E), e.setRaw("point", { x: T + (j - T) / 2, y: C + (L - C) / 2 });
      } else if (_ === b) {
        let Y = this._aLocationX0 + d - 0.5, U = this._aLocationX1 + h - 0.5;
        if (g instanceof ne) {
          let B = (U - Y) * (1 - g.value) / 2;
          Y += B, U -= B;
        }
        if (T = _.getDataItemPositionX(e, l, Y, N), j = _.getDataItemPositionX(e, r, U, N), C = v.getDataItemPositionY(e, n, c, E), this._yOpenField !== this._yField)
          L = v.getDataItemPositionY(e, u, f, E);
        else if (m) {
          let B = e.get("stackToItemY");
          B ? L = v.getDataItemPositionY(B, n, f, B.component.get("vcy")) : L = v.basePosition();
        } else
          L = v.basePosition();
        e.setRaw("point", { x: T + (j - T) / 2, y: C }), z = !0;
      } else if (v === b) {
        let Y = this._aLocationY0 + f - 0.5, U = this._aLocationY1 + c - 0.5;
        if (p instanceof ne) {
          let B = (U - Y) * (1 - p.value) / 2;
          Y += B, U -= B;
        }
        if (C = v.getDataItemPositionY(e, u, Y, E), L = v.getDataItemPositionY(e, n, U, E), j = _.getDataItemPositionX(e, r, h, N), this._xOpenField !== this._xField)
          T = _.getDataItemPositionX(e, l, d, N);
        else if (m) {
          let B = e.get("stackToItemX");
          B ? T = _.getDataItemPositionX(B, r, d, B.component.get("vcx")) : T = _.basePosition();
        } else
          T = _.basePosition();
        J = !0, e.setRaw("point", { x: j, y: C + (L - C) / 2 });
      }
      this._updateSeriesGraphics(e, s, T, j, C, L, J, z), T < y && j < y || T > w && j > w || C < D && L <= D || C >= A && L > A || $t(T) || $t(C) ? this._toggleColumn(e, !1) : this._toggleColumn(e, !0);
      let H = e.get("rangeGraphics");
      H && x(H, (Y) => {
        this._updateSeriesGraphics(e, Y, T, j, C, L, J, z);
      }), this._applyGraphicsStates(e, t);
    }
  }
  _updateSeriesGraphics(e, t, s, r, n, a, o, l) {
    const u = t.get("width"), h = t.get("height"), c = t.get("maxWidth"), d = t.get("maxHeight"), f = this.getPoint(s, n), g = this.getPoint(r, a), p = e.get("point");
    if (p) {
      const m = this.getPoint(p.x, p.y);
      p.x = m.x + this._x, p.y = m.y + this._y;
    }
    if (s = f.x, r = g.x, n = f.y, a = g.y, S(u)) {
      const m = (r - s - u) / 2;
      s += m, r -= m;
    }
    if (S(c) && c < Math.abs(r - s)) {
      const m = (r - s - c) / 2;
      s += m, r -= m;
    }
    if (S(h)) {
      const m = (a - n - h) / 2;
      n += m, a -= m;
    }
    if (S(d) && d < Math.abs(a - n)) {
      const m = (a - n - d) / 2;
      n += m, a -= m;
    }
    this.get("adjustBulletPosition") && (o && (r = Math.min(Math.max(0, r), this._pw), s = Math.min(Math.max(0, s), this._pw)), l && (n = Math.min(Math.max(0, n), this._ph), a = Math.min(Math.max(0, a), this._ph))), e.setRaw("left", s), e.setRaw("right", r), e.setRaw("top", n), e.setRaw("bottom", a), t.setPrivate("width", r - s), t.setPrivate("height", a - n), t.set("x", s), t.set("y", a - (a - n));
  }
  _handleDataSetChange() {
    super._handleDataSetChange(), x(this._dataItems, (e) => {
      this._toggleColumn(e, !1);
    });
  }
  _applyGraphicsStates(e, t) {
    const s = e.get("graphics"), r = s.states.lookup("dropFromOpen"), n = s.states.lookup("riseFromOpen"), a = s.states.lookup("dropFromPrevious"), o = s.states.lookup("riseFromPrevious");
    if (r || a || n || o) {
      const l = this.get("xAxis"), u = this.get("yAxis"), h = this.get("baseAxis");
      let c, d, f;
      h === l && u.isType("ValueAxis") ? (c = e.get(this._yOpenField), d = e.get(this._yField), f = t.get(this._yField)) : h === u && l.isType("ValueAxis") && (c = e.get(this._xOpenField), d = e.get(this._xField), f = t.get(this._xField)), S(c) && S(d) && (d < c ? r && r.apply() : n && n.apply(), S(f) && (d < f ? a && a.apply() : o && o.apply()));
    }
  }
  /**
   * @ignore
   */
  disposeDataItem(e) {
    super.disposeDataItem(e);
    const t = e.get("graphics");
    t && (this.columns.removeValue(t), t.dispose());
    const s = e.get("rangeGraphics");
    s && x(s, (r) => {
      const n = r.getPrivate("list");
      n && n.removeValue(r), r.dispose();
    });
  }
  /**
   * Hides series's data item.
   *
   * @param   dataItem  Data item
   * @param   duration  Animation duration in milliseconds
   * @return            Promise
   */
  hideDataItem(e, t) {
    const s = Object.create(null, {
      hideDataItem: { get: () => super.hideDataItem }
    });
    return Ue(this, void 0, void 0, function* () {
      const r = [s.hideDataItem.call(this, e, t)], n = e.get("graphics");
      n && r.push(n.hide(t));
      const a = e.get("rangeGraphics");
      a && x(a, (o) => {
        r.push(o.hide(t));
      }), yield Promise.all(r);
    });
  }
  _toggleColumn(e, t) {
    const s = e.get("graphics");
    s && s.setPrivate("visible", t);
    const r = e.get("rangeGraphics");
    r && x(r, (a) => {
      a.setPrivate("visible", t);
    });
    const n = e.bullets;
    n && x(n, (a) => {
      a.setPrivate("hidden", !t);
    });
  }
  /**
   * Shows series's data item.
   *
   * @param   dataItem  Data item
   * @param   duration  Animation duration in milliseconds
   * @return            Promise
   */
  showDataItem(e, t) {
    const s = Object.create(null, {
      showDataItem: { get: () => super.showDataItem }
    });
    return Ue(this, void 0, void 0, function* () {
      const r = [s.showDataItem.call(this, e, t)], n = e.get("graphics");
      n && r.push(n.show(t));
      const a = e.get("rangeGraphics");
      a && x(a, (o) => {
        r.push(o.show(t));
      }), yield Promise.all(r);
    });
  }
  /**
   * @ignore
   */
  updateLegendMarker(e) {
    let t = this.get("legendDataItem");
    if (this.get("useLastColorForLegendMarker") && !e) {
      const s = this.dataItems[this.endIndex() - 1];
      s && (e = s);
    }
    if (t) {
      let s = this.columns.template;
      if (e) {
        let n = e.get("graphics");
        n && (s = n);
      }
      const r = t.get("markerRectangle");
      r && (t.get("itemContainer").get("disabled") || x(Od, (n) => {
        r.set(n, s.get(n, this.get(n)));
      }));
    }
  }
  _getTooltipTarget(e) {
    if (this.get("seriesTooltipTarget") == "bullet")
      return super._getTooltipTarget(e);
    let t = e.get("graphics");
    return t || this;
  }
}
Object.defineProperty(zi, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "BaseColumnSeries"
});
Object.defineProperty(zi, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Hi.classNames.concat([zi.className])
});
class Xi extends $i {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_series", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_isPanning", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "labelsContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.children.push(Z.new(this._root, {}))
    }), Object.defineProperty(this, "gridContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Z.new(this._root, { width: R, height: R })
    }), Object.defineProperty(this, "topGridContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Z.new(this._root, { width: R, height: R })
    }), Object.defineProperty(this, "bulletsContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.children.push(Z.new(this._root, { isMeasured: !1, width: R, height: R, position: "absolute" }))
    }), Object.defineProperty(this, "chart", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_rangesDirty", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_panStart", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_panEnd", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), Object.defineProperty(this, "_sAnimation", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_eAnimation", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_skipSync", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "axisRanges", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new cr()
    }), Object.defineProperty(this, "_seriesAxisRanges", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "ghostLabel", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_cursorPosition", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: -1
    }), Object.defineProperty(this, "_snapToSeries", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_seriesValuesDirty", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "axisHeader", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.children.push(Z.new(this._root, {
        themeTags: ["axis", "header"],
        position: "absolute",
        background: mt.new(this._root, {
          themeTags: ["header", "background"],
          fill: this._root.interfaceColors.get("background")
        })
      }))
    }), Object.defineProperty(this, "_bullets", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    });
  }
  _dispose() {
    this.gridContainer.dispose(), this.topGridContainer.dispose(), this.bulletsContainer.dispose(), this.labelsContainer.dispose(), this.axisHeader.dispose(), super._dispose();
  }
  _afterNew() {
    super._afterNew(), this.setPrivate("updateScrollbar", !0), this._disposers.push(this.axisRanges.events.onAll((t) => {
      if (t.type === "clear")
        x(t.oldValues, (s) => {
          this.disposeDataItem(s);
        });
      else if (t.type === "push")
        this._processAxisRange(t.newValue, ["range"]);
      else if (t.type === "setIndex")
        this._processAxisRange(t.newValue, ["range"]);
      else if (t.type === "insertIndex")
        this._processAxisRange(t.newValue, ["range"]);
      else if (t.type === "removeIndex")
        this.disposeDataItem(t.oldValue);
      else if (t.type === "moveIndex")
        this._processAxisRange(t.value, ["range"]);
      else
        throw new Error("Unknown IStreamEvent type");
    }));
    const e = this.get("renderer");
    e && (e.axis = this, e.processAxis()), this.children.push(e), this.ghostLabel = e.makeLabel(new Gt(this, void 0, {}), []), this.ghostLabel.adapters.disable("text"), this.ghostLabel.setAll({ opacity: 0, tooltipText: void 0, tooltipHTML: void 0, interactive: !1 }), this.ghostLabel.events.disable();
  }
  _updateFinals(e, t) {
  }
  /**
   * Zooms the axis to relative locations.
   *
   * Both `start` and `end` are relative: 0 means start of the axis, 1 - end.
   *
   * @param   start     Relative start
   * @param   end       Relative end
   * @param   duration  Duration of the zoom animation in milliseconds
   * @return            Zoom animation
   */
  zoom(e, t, s, r) {
    if (this._updateFinals(e, t), this.get("start") !== e || this.get("end") != t) {
      let n = this._sAnimation, a = this._eAnimation, o = this.get("maxDeviation", 0.5) * Math.min(1, t - e);
      e < -o && (e = -o), t > 1 + o && (t = 1 + o), e > t && ([e, t] = [t, e]), S(s) || (s = this.get("interpolationDuration", 0)), r || (r = "end");
      let l = this.getPrivate("maxZoomFactor", this.get("maxZoomFactor", 100)), u = l;
      t === 1 && e !== 0 && (e < this.get("start") ? r = "start" : r = "end"), e === 0 && t !== 1 && (t > this.get("end") ? r = "end" : r = "start");
      let h = this.get("minZoomCount"), c = this.get("maxZoomCount");
      S(h) && (l = u / h);
      let d = 1;
      if (S(c) && (d = u / c), r === "start" ? (c > 0 && 1 / (t - e) < d && (t = e + 1 / d), 1 / (t - e) > l && (t = e + 1 / l), t > 1 && t - e < 1 / l && (e = t - 1 / l)) : (c > 0 && 1 / (t - e) < d && (e = t - 1 / d), 1 / (t - e) > l && (e = t - 1 / l), e < 0 && t - e < 1 / l && (t = e + 1 / l)), 1 / (t - e) > l && (t = e + 1 / l), 1 / (t - e) > l && (e = t - 1 / l), c != null && h != null && e == this.get("start") && t == this.get("end")) {
        const f = this.chart;
        f && f._handleAxisSelection(this, !0);
      }
      if ((n && n.playing && n.to == e || this.get("start") == e) && (a && a.playing && a.to == t || this.get("end") == t))
        return;
      if (s > 0) {
        let f = this.get("interpolationEasing"), g, p;
        if (this.get("start") != e && (g = this.animate({ key: "start", to: e, duration: s, easing: f })), this.get("end") != t && (p = this.animate({ key: "end", to: t, duration: s, easing: f })), this._sAnimation = g, this._eAnimation = p, g)
          return g;
        if (p)
          return p;
      } else
        this.set("start", e), this.set("end", t), this._root.events.once("frameended", () => {
          this._markDirtyKey("start"), this._root._markDirty();
        });
    } else
      this._sAnimation && this._sAnimation.stop(), this._eAnimation && this._eAnimation.stop();
  }
  /**
   * A list of series using this axis.
   *
   * @return Series
   */
  get series() {
    return this._series;
  }
  _processAxisRange(e, t) {
    e.setRaw("isRange", !0), this._createAssets(e, t), this._rangesDirty = !0, this._prepareDataItem(e);
    const s = e.get("above"), r = this.topGridContainer, n = e.get("grid");
    s && n && r.children.moveValue(n);
    const a = e.get("axisFill");
    s && a && r.children.moveValue(a);
  }
  _prepareDataItem(e, t) {
  }
  /**
   * @ignore
   */
  markDirtyExtremes() {
  }
  /**
   * @ignore
   */
  markDirtySelectionExtremes() {
  }
  _calculateTotals() {
  }
  _updateAxisRanges() {
    this._bullets = {}, this.axisRanges.each((e) => {
      this._prepareDataItem(e);
    }), x(this._seriesAxisRanges, (e) => {
      this._prepareDataItem(e);
    });
  }
  _prepareChildren() {
    if (super._prepareChildren(), this.get("fixAxisSize") ? this.ghostLabel.set("visible", !0) : this.ghostLabel.set("visible", !1), this.isDirty("start") || this.isDirty("end")) {
      this.chart._updateCursor();
      let t = this.get("start", 0), s = this.get("end", 1), r = this.get("maxDeviation", 0.5) * Math.min(1, s - t);
      if (t < -r) {
        let n = t + r;
        t = -r, this.setRaw("start", t), this.isDirty("end") && this.setRaw("end", s - n);
      }
      if (s > 1 + r) {
        let n = s - 1 - r;
        s = 1 + r, this.setRaw("end", s), this.isDirty("start") && this.setRaw("start", t - n);
      }
    }
    const e = this.get("renderer");
    if (e._start = this.get("start"), e._end = this.get("end"), e._inversed = e.get("inversed", !1), e._axisLength = e.axisLength() / (e._end - e._start), e._updateLC(), this.isDirty("tooltip")) {
      const t = this.get("tooltip");
      if (t) {
        const s = e.get("themeTags");
        t.addTag("axis"), t.addTag(this.className.toLowerCase()), t._applyThemes(), s && (t.set("themeTags", se(t.get("themeTags"), s)), t.label._applyThemes());
      }
    }
  }
  _updateTooltipBounds() {
    const e = this.get("tooltip");
    e && this.get("renderer").updateTooltipBounds(e);
  }
  _updateBounds() {
    super._updateBounds(), this._updateTooltipBounds();
  }
  /**
   * @ignore
   */
  processChart(e) {
    this.chart = e;
    const t = this.get("renderer");
    t.chart = e, e.gridContainer.children.push(this.gridContainer), e.topGridContainer.children.push(this.topGridContainer), e.axisHeadersContainer.children.push(this.axisHeader), this.on("start", () => {
      e._handleAxisSelection(this);
    }), this.on("end", () => {
      e._handleAxisSelection(this);
    }), e.plotContainer.onPrivate("width", () => {
      this.markDirtySize();
    }), e.plotContainer.onPrivate("height", () => {
      this.markDirtySize();
    }), e.processAxis(this);
  }
  /**
   * @ignore
   */
  hideDataItem(e) {
    return this._toggleDataItem(e, !1), super.hideDataItem(e);
  }
  /**
   * @ignore
   */
  showDataItem(e) {
    return this._toggleDataItem(e, !0), super.showDataItem(e);
  }
  _toggleDataItem(e, t) {
    const s = e.get("label");
    s && s.setPrivate("visible", t);
    const r = e.get("grid");
    r && r.setPrivate("visible", t);
    const n = e.get("tick");
    n && n.setPrivate("visible", t);
    const a = e.get("axisFill");
    a && a.setPrivate("visible", t);
    const o = e.get("bullet");
    if (o) {
      const l = o.get("sprite");
      l && l.setPrivate("visible", t);
    }
  }
  _createAssets(e, t) {
    const s = this.get("renderer");
    e.get("label") || s.makeLabel(e, t), e.get("grid") || s.makeGrid(e, t), e.get("tick") || s.makeTick(e, t), e.get("axisFill") || s.makeAxisFill(e, t), this._processBullet(e);
  }
  _processBullet(e) {
    let t = e.get("bullet"), s = this.get("bullet");
    if (!t && s && !e.get("isRange") && (t = s(this._root, this, e)), t) {
      t.axis = this;
      const r = t.get("sprite");
      r && (r._setDataItem(e), e.setRaw("bullet", t), r.parent || this.bulletsContainer.children.push(r));
    }
  }
  _afterChanged() {
    super._afterChanged();
    const e = this.chart;
    e && (e._updateChartLayout(), e.axisHeadersContainer.markDirtySize()), this.get("renderer")._updatePositions();
  }
  /**
   * @ignore
   */
  disposeDataItem(e) {
    super.disposeDataItem(e);
    const t = this.get("renderer"), s = e.get("label");
    s && (t.labels.removeValue(s), s.dispose());
    const r = e.get("tick");
    r && (t.ticks.removeValue(r), r.dispose());
    const n = e.get("grid");
    n && (t.grid.removeValue(n), n.dispose());
    const a = e.get("axisFill");
    a && (t.axisFills.removeValue(a), a.dispose());
    const o = e.get("bullet");
    o && o.dispose();
  }
  _updateGhost() {
    this.setPrivate("cellWidth", this.getCellWidthPosition() * this.get("renderer").axisLength());
    const e = this.ghostLabel;
    if (!e.isHidden()) {
      const r = e.localBounds(), n = r.right - r.left;
      let a = e.get("text");
      x(this.dataItems, (o) => {
        const l = o.get("label");
        if (l && !l.isHidden()) {
          const u = l.localBounds();
          u.right - u.left > n && (a = l.text._getText());
        }
      }), e.set("text", a);
    }
    let t = this.get("start", 0), s = this.get("end", 1);
    this.get("renderer").updateLabel(e, t + (s - t) * 0.5);
  }
  _handleCursorPosition(e, t) {
    e = this.get("renderer").toAxisPosition(e), this._cursorPosition = e, this._snapToSeries = t, this.updateTooltip();
  }
  /**
   * Can be called when axis zoom changes and you need to update tooltip
   * position.
   */
  updateTooltip() {
    const e = this._snapToSeries;
    let t = this._cursorPosition;
    const s = this.get("tooltip"), r = this.get("renderer");
    S(t) && (x(this.series, (n) => {
      if (n.get("baseAxis") === this) {
        const a = this.getSeriesItem(n, t, this.get("tooltipLocation"));
        n.setRaw("tooltipDataItem", a), e && e.indexOf(n) != -1 ? (n.updateLegendMarker(a), n.updateLegendValue(a)) : n.showDataItemTooltip(a);
      }
    }), s && (r.updateTooltipBounds(s), this.get("snapTooltip") && (t = this.roundAxisPosition(t, this.get("tooltipLocation", 0.5))), $t(t) ? s.hide(0) : (this.setPrivateRaw("tooltipPosition", t), this._updateTooltipText(s, t), r.positionTooltip(s, t), t < this.get("start") || t > this.get("end") ? s.hide(0) : s.show(0))));
  }
  _updateTooltipText(e, t) {
    e.label.set("text", this.getTooltipText(t));
  }
  /**
   * @ignore
   */
  roundAxisPosition(e, t) {
    return e;
  }
  /**
   * @ignore
   */
  handleCursorShow() {
    let e = this.get("tooltip");
    e && e.show();
  }
  /**
   * @ignore
   */
  handleCursorHide() {
    let e = this.get("tooltip");
    e && e.hide();
  }
  /**
   * @ignore
   */
  processSeriesDataItem(e, t) {
  }
  _clearDirty() {
    super._clearDirty(), this._sizeDirty = !1, this._rangesDirty = !1;
  }
  /**
   * Converts pixel coordinate to a relative position on axis.
   *
   * @param   coordinate  Coordinate
   * @return              Relative position
   */
  coordinateToPosition(e) {
    const t = this.get("renderer");
    return t.toAxisPosition(e / t.axisLength());
  }
  /**
   * Converts relative position of the plot area to relative position of the
   * axis with zoom taken into account.
   *
   * @param position Position
   * @return Relative position
   */
  toAxisPosition(e) {
    return this.get("renderer").toAxisPosition(e);
  }
  /**
   * Adjusts position with inversed taken into account.
   *
   * @ignore
   */
  fixPosition(e) {
    return this.get("renderer").fixPosition(e);
  }
  /**
   * @ignore
   */
  shouldGap(e, t, s, r) {
    return !1;
  }
  /**
   * Creates and returns an axis range object.
   *
   * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/axis-ranges/} for more info
   * @param   axisDataItem  Axis data item
   * @return                Axis range
   */
  createAxisRange(e) {
    return this.axisRanges.push(e);
  }
  /**
   * @ignore
   */
  _groupSeriesData(e) {
  }
  /**
   * Returns relative position between two grid lines of the axis.
   *
   * @return Position
   */
  getCellWidthPosition() {
    return 0.05;
  }
}
Object.defineProperty(Xi, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Axis"
});
Object.defineProperty(Xi, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: $i.classNames.concat([Xi.className])
});
class vi extends Xi {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_frequency", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), Object.defineProperty(this, "_itemMap", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    });
  }
  _afterNew() {
    this._settings.themeTags = se(this._settings.themeTags, ["axis"]), this.fields.push("category"), this.setPrivateRaw("name", "category"), this.addTag("category"), super._afterNew();
  }
  _prepareChildren() {
    super._prepareChildren();
    const e = this.dataItems.length;
    let t = 0;
    this._valuesDirty && (this._itemMap = {}, x(this.dataItems, (s) => {
      s.setRaw("index", t), this._itemMap[s.get("category")] = s, t++;
    }), this.setPrivateRaw("maxZoomFactor", e)), this.setPrivateRaw("startIndex", Math.max(Math.round(this.get("start", 0) * e), 0)), this.setPrivateRaw("endIndex", Math.min(Math.round(this.get("end", 1) * e), e)), (this._sizeDirty || this._valuesDirty || this.isDirty("start") || this.isDirty("end") || this.isPrivateDirty("endIndex") || this.isPrivateDirty("startIndex") || this.isPrivateDirty("width") || this.isPrivateDirty("height")) && this.dataItems.length > 0 && (this._handleRangeChange(), this._prepareAxisItems(), this._updateAxisRanges());
  }
  _handleRangeChange() {
    x(this.series, (e) => {
      let t = this.dataItems[this.startIndex()].get("category"), s = this.dataItems[this.endIndex() - 1].get("category"), r = e.get("baseAxis"), n = e.get("xAxis"), a = e.get("yAxis");
      if (n instanceof vi && a instanceof vi)
        e._markDirtyAxes();
      else if (r === this) {
        let o, l, u = a;
        if (n === r ? (e.get("categoryXField") && (o = "categoryX"), e.get("openCategoryXField") && (l = "openCategoryX")) : a === r && (e.get("categoryYField") && (o = "categoryY"), e.get("openCategoryYField") && (l = "openCategoryY"), u = n), u.className == "ValueAxis" && (o || l)) {
          let h, c;
          for (let p = 0, m = e.dataItems.length; p < m; p++) {
            let _ = e.dataItems[p];
            if (o && _.get(o) === t) {
              h = _;
              break;
            }
            if (l && _.get(l) === t) {
              h = _;
              break;
            }
          }
          for (let p = e.dataItems.length - 1; p >= 0; p--) {
            let m = e.dataItems[p];
            if (o && m.get(o) === s) {
              c = m;
              break;
            }
            if (l && m.get(l) === s) {
              c = m;
              break;
            }
          }
          let d = 0, f = e.dataItems.length;
          h && (d = e.dataItems.indexOf(h)), c && (f = e.dataItems.indexOf(c) + 1), e.setPrivate("startIndex", d), e.setPrivate("endIndex", f);
          let g = !1;
          for (let p = d; p < f; p++) {
            const m = e.dataItems[p];
            if (x(e.__valueXShowFields, (_) => {
              m.get(_) != null && (g = !0);
            }), x(e.__valueYShowFields, (_) => {
              m.get(_) != null && (g = !0);
            }), g)
              break;
          }
          e.setPrivate("outOfSelection", !g);
        }
        e._markDirtyAxes();
      }
    });
  }
  _prepareAxisItems() {
    const e = this.get("renderer"), t = this.dataItems.length;
    let s = this.startIndex();
    s > 0 && s--;
    let r = this.endIndex();
    r < t && r++;
    let n = e.axisLength() / Math.max(e.get("minGridDistance"), 1 / Number.MAX_SAFE_INTEGER), a = Math.max(1, Math.min(t, Math.ceil((r - s) / n)));
    s = Math.floor(s / a) * a, this._frequency = a;
    for (let l = 0; l < t; l++)
      this.dataItems[l].hide();
    let o = this.dataItems[s].get("index", 0);
    for (let l = s; l < r; l = l + a) {
      let u = this.dataItems[l];
      this._createAssets(u, []), u.isHidden() && u.show(), this._prepareDataItem(u, o, a), o++;
    }
    this._updateGhost();
  }
  _prepareDataItem(e, t, s) {
    let r = this.get("renderer"), n = e.get("categoryLocation", 0), a = e.get("endCategoryLocation", 1), o = e.get("index");
    S(o) || (o = this.categoryToIndex(e.get("category")));
    let l = this.indexToPosition(o, n), u = e.get("endCategory"), h;
    u ? (h = this.categoryToIndex(u), S(h) || (h = o)) : h = o;
    let c = this.indexToPosition(h, a), d, f;
    e.get("isRange") ? d = h : d = o + this._frequency - 1, f = this.indexToPosition(d, a), r.updateLabel(e.get("label"), l, c, s), r.updateGrid(e.get("grid"), l, c), r.updateTick(e.get("tick"), l, c, s), r.updateFill(e.get("axisFill"), l, f), this._processBullet(e), r.updateBullet(e.get("bullet"), l, c);
    const g = this.get("fillRule");
    g && g(e, t);
  }
  startIndex() {
    let e = this.dataItems.length;
    return Math.min(Math.max(this.getPrivate("startIndex", 0), 0), e - 1);
  }
  endIndex() {
    let e = this.dataItems.length;
    return Math.max(1, Math.min(this.getPrivate("endIndex", e), e));
  }
  /**
   * @ignore
   */
  baseValue() {
  }
  /**
   * @ignore
   */
  basePosition() {
    return 0;
  }
  /**
   * Returns X coordinate in pixels corresponding to specific category index.
   *
   * @param   value  Index
   * @return         X coordinate
   */
  getX(e) {
    let t = this._itemMap[e];
    return t ? this._settings.renderer.positionToCoordinate(this.indexToPosition(t.get("index", 0))) : NaN;
  }
  /**
   * Returns Y coordinate in pixels corresponding to specific category index.
   *
   * @param   value  Index
   * @return         Y coordinate
   */
  getY(e) {
    let t = this._itemMap[e];
    return t ? this._settings.renderer.positionToCoordinate(this.indexToPosition(t.get("index", 0))) : NaN;
  }
  /**
   * @ignore
   */
  getDataItemPositionX(e, t, s, r) {
    const n = e.get(t), a = this._itemMap[n];
    return a ? this.indexToPosition(a.get("index", 0), s) : NaN;
  }
  /**
   * @ignore
   */
  getDataItemCoordinateX(e, t, s, r) {
    return this._settings.renderer.positionToCoordinate(this.getDataItemPositionX(e, t, s, r));
  }
  /**
   * @ignore
   */
  getDataItemPositionY(e, t, s, r) {
    const n = e.get(t), a = this._itemMap[n];
    return a ? this.indexToPosition(a.get("index", 0), s) : NaN;
  }
  /**
   * @ignore
   */
  getDataItemCoordinateY(e, t, s, r) {
    return this._settings.renderer.positionToCoordinate(this.getDataItemPositionY(e, t, s, r));
  }
  /**
   * Converts category index to a relative position.
   *
   * `location` indicates relative position within category: 0 - start, 1 - end.
   *
   * If not set, will use middle (0.5) of the category.
   *
   * @param   index     Index
   * @param   location  Location
   * @return            Index
   */
  indexToPosition(e, t) {
    S(t) || (t = 0.5);
    let s = this.dataItems.length, r = this.get("startLocation", 0), n = this.get("endLocation", 1);
    s -= r, s -= 1 - n;
    let a = (e + t - r) / s, o = this.dataItems[e];
    return o && (a += o.get("deltaPosition", 0)), a;
  }
  /**
   * Returns an index of a category.
   *
   * @param   category  Category to look up
   * @return            Index
   */
  categoryToIndex(e) {
    let t = this._itemMap[e];
    return t ? t.get("index") : NaN;
  }
  /**
   * @ignore
   */
  dataItemToPosition(e) {
    return this.indexToPosition(e.get("index"));
  }
  /**
   * @ignore
   */
  roundAxisPosition(e, t) {
    return e += (0.5 - t) / this.dataItems.length, this.indexToPosition(this.axisPositionToIndex(e), t);
  }
  /**
   * Returns an index of the category that corresponds to specific pixel
   * position within axis.
   *
   * @param position  Position (px)
   * @return Category index
   */
  axisPositionToIndex(e) {
    let t = this.dataItems.length;
    return Ne(Math.floor(e * t), 0, t - 1);
  }
  /**
   * Returns text to be used in an axis tooltip for specific relative position.
   *
   * @param   position  Position
   * @return            Tooltip text
   */
  getTooltipText(e) {
    const t = this.dataItems[this.axisPositionToIndex(e)];
    if (t) {
      const s = t.get("label");
      if (s)
        return zr(s, this.get("tooltipText", ""));
    }
  }
  _updateTooltipText(e, t) {
    e._setDataItem(this.dataItems[this.axisPositionToIndex(t)]), e.label.text.markDirtyText();
  }
  /**
   * Returns a data item from series that is closest to the `position`.
   *
   * @param   series    Series
   * @param   position  Relative position
   * @return            Data item
   */
  getSeriesItem(e, t) {
    if (this.dataItems.length > 0) {
      let s = this.getPrivate("name") + this.get("renderer").getPrivate("letter"), r = this.axisPositionToIndex(t), n = e.dataItems[r], a = this.dataItems[r], o = a.get("category");
      if (n && a && n.get(s) === o)
        return n;
      for (let l = 0, u = e.dataItems.length; l < u; l++) {
        let h = e.dataItems[l];
        if (h.get(s) === o)
          return h;
      }
    }
  }
  /**
   * Zooms the axis to specific `start` and `end` indexes.
   *
   * Optional `duration` specifies duration of zoom animation in milliseconds.
   *
   * @param  start     Start index
   * @param  end       End index
   * @param  duration  Duration in milliseconds
   */
  zoomToIndexes(e, t, s) {
    let r = this.dataItems.length;
    this.zoom(e / r, t / r, s);
  }
  zoomToCategories(e, t, s) {
    this.zoomToIndexes(this.categoryToIndex(e), this.categoryToIndex(t) + 1, s);
  }
  /**
   * Returns position span between start and end of a single cell in axis.
   *
   * @since 5.2.30
   * @return Position
   */
  getCellWidthPosition() {
    return this._frequency / this.dataItems.length / (this.get("end", 1) - this.get("start", 0));
  }
}
Object.defineProperty(vi, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "CategoryAxis"
});
Object.defineProperty(vi, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Xi.classNames.concat([vi.className])
});
class wa extends vi {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_frequency", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), Object.defineProperty(this, "_itemMap", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    });
  }
  _afterNew() {
    this._settings.themeTags = se(this._settings.themeTags, ["axis"]), this.fields.push("category"), super._afterNew();
  }
  _prepareAxisItems() {
    this.setPrivateRaw("baseInterval", this.get("baseInterval"));
    const e = this.get("renderer"), t = this.dataItems.length;
    let s = this.startIndex();
    s > 0 && s--;
    let r = this.endIndex();
    r < t && r++;
    let n = e.axisLength() / Math.max(e.get("minGridDistance"), 1 / Number.MAX_SAFE_INTEGER), a = Math.min(t, Math.ceil((r - s) / n));
    s = Math.floor(s / a) * a, this._frequency = a;
    for (let y = 0; y < t; y++)
      this.dataItems[y].hide();
    let o = Number(this.dataItems[s].get("category")), l = Number(this.dataItems[r - 1].get("category")), u = l - o;
    r - s < n && (u = l - o - ((l - o) / this.baseDuration() - (r - s)) * this.baseDuration());
    let h = Qs(0, u, n, this.get("gridIntervals"));
    const c = hn(h.timeUnit), d = this.getPrivate("baseInterval");
    Mt(h) < this.baseDuration() && (h = Object.assign({}, d));
    const f = this.get("dateFormats");
    let g = -1 / 0, p = -1 / 0, m = -1 / 0, _, v = [], b = !1;
    for (let y = s; y < r; y++) {
      let w = this.dataItems[y], D = w.get("index"), A = !1, T = Number(w.get("category")), j = new Date(T), C = Hd(j, h.timeUnit);
      _ = f[h.timeUnit];
      let L = !1;
      h.timeUnit != "year" && h.timeUnit != "week" && c && this.get("markUnitChange") && S(g) && cn(T, g, c, this._root.utc) && (_ = this.get("periodChangeDateFormats")[h.timeUnit], D - a * 0.5 < p && v.pop(), v.push({ format: _, dataItem: w }), b = !0, L = !0, p = D, m = C);
      let E = !1;
      h.timeUnit === "day" || h.timeUnit === "week" ? D - p >= a && (E = !0) : C % h.count === 0 && C != m && (E = !0), !L && E && (D - a * 0.7 < p && b && (A = !0), A || (v.push({ format: _, dataItem: w }), p = D, m = C), b = !1), g = T;
    }
    if (v.length > 0) {
      let y = v[0].dataItem.get("index", 0);
      x(v, (w) => {
        const D = w.dataItem, A = w.format;
        this._createAssets(D, []), D.isHidden() && D.show();
        let T = Number(D.get("category")), j = new Date(T);
        const C = D.get("label");
        C && C.set("text", this._root.dateFormatter.format(j, A)), y++, this._prepareDataItem(D, y, a);
      });
    }
  }
  /**
   * Returns a duration of currently active `baseInterval` in milliseconds.
   *
   * @return Duration
   */
  baseDuration() {
    return Mt(this.getPrivate("baseInterval"));
  }
  /**
   * Returns text to be used in an axis tooltip for specific relative position.
   *
   * @param   position  Position
   * @return            Tooltip text
   */
  getTooltipText(e) {
    let t = this.dataItems[this.axisPositionToIndex(e)];
    if (t) {
      let s = this.get("dateFormats")[this.getPrivate("baseInterval").timeUnit];
      return this._root.dateFormatter.format(new Date(t.get("category", 0)), this.get("tooltipDateFormat", s));
    }
  }
  _updateTooltipText(e, t) {
    e.label.set("text", this.getTooltipText(t));
  }
}
Object.defineProperty(wa, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "CategoryDateAxis"
});
Object.defineProperty(wa, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: vi.classNames.concat([wa.className])
});
class Vi extends Xi {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_dirtyExtremes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_dirtySelectionExtremes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_deltaMinMax", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), Object.defineProperty(this, "_minReal", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_maxReal", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_baseValue", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_syncDp", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_minLogAdjusted", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    });
  }
  /**
   * @ignore
   */
  markDirtyExtremes() {
    this._dirtyExtremes = !0, this.markDirty();
  }
  /**
   * @ignore
   */
  markDirtySelectionExtremes() {
    this._dirtySelectionExtremes = !0, this.markDirty();
  }
  _afterNew() {
    this._settings.themeTags = se(this._settings.themeTags, ["axis"]), this.setPrivateRaw("name", "value"), this.addTag("value"), super._afterNew();
  }
  _prepareChildren() {
    if (super._prepareChildren(), this.isDirty("syncWithAxis")) {
      this._prevSettings.syncWithAxis && this._syncDp && this._syncDp.dispose();
      let t = this.get("syncWithAxis");
      t && (this._syncDp = new nt([
        t.onPrivate("selectionMinFinal", () => {
          this._dirtySelectionExtremes = !0;
        }),
        t.onPrivate("selectionMaxFinal", () => {
          this._dirtySelectionExtremes = !0;
        })
      ]));
    }
    (this._sizeDirty || this._dirtyExtremes || this._valuesDirty || this.isPrivateDirty("width") || this.isPrivateDirty("height") || this.isDirty("min") || this.isDirty("max") || this.isDirty("extraMin") || this.isDirty("extraMax") || this.isDirty("logarithmic") || this.isDirty("treatZeroAs") || this.isDirty("baseValue") || this.isDirty("strictMinMax") || this.isDirty("strictMinMaxSelection") || this.isDirty("maxPrecision") || this.isDirty("numberFormat")) && (this._getMinMax(), this.ghostLabel.set("text", ""), this._dirtyExtremes = !1), this._dirtySelectionExtremes && !this._isPanning && this.get("autoZoom", !0) && (this._getSelectionMinMax(), this._dirtySelectionExtremes = !1), this._groupData(), (this._sizeDirty || this._valuesDirty || this.isDirty("start") || this.isDirty("end") || this.isPrivateDirty("min") || this.isPrivateDirty("selectionMax") || this.isPrivateDirty("selectionMin") || this.isPrivateDirty("max") || this.isPrivateDirty("step") || this.isPrivateDirty("width") || this.isPrivateDirty("height") || this.isDirty("logarithmic")) && (this._handleRangeChange(), this._prepareAxisItems(), this._updateAxisRanges()), this._baseValue = this.baseValue();
  }
  _groupData() {
  }
  _formatText(e) {
    const t = this.get("numberFormat"), s = this.getNumberFormatter();
    let r = "";
    return t ? r = s.format(e, t) : r = s.format(e, void 0, this.getPrivate("stepDecimalPlaces")), r;
  }
  _prepareAxisItems() {
    const e = this.getPrivate("min"), t = this.getPrivate("max");
    if (S(e) && S(t)) {
      const s = this.get("logarithmic"), r = this.getPrivate("step"), n = this.getPrivate("selectionMin"), a = this.getPrivate("selectionMax") + r;
      let o = n - r, l = 0, u = 1, h = e;
      if (s) {
        if (o = this._minLogAdjusted, o < n)
          for (; o < n; )
            o += r;
        h = o, h <= 0 && (h = 1, r < 1 && (h = r)), u = Math.log(a - r) * Math.LOG10E - Math.log(h) * Math.LOG10E, u > 2 && (o = Math.pow(10, Math.log(h) * Math.LOG10E - 5));
      }
      let c = -1 / 0;
      for (; o < a; ) {
        let d;
        this.dataItems.length < l + 1 ? (d = new Gt(this, void 0, {}), this._dataItems.push(d), this.processDataItem(d)) : d = this.dataItems[l], this._createAssets(d, []), d.isHidden() && d.show(), d.setRaw("value", o);
        const f = d.get("label");
        if (f && f.set("text", this._formatText(o)), this._prepareDataItem(d), s && u > 2 ? o = Math.pow(10, Math.log(h) * Math.LOG10E + l - 5) : o += r, c == o)
          break;
        let g = Math.pow(10, Math.floor(Math.log(Math.abs(r)) * Math.LOG10E));
        if (g < 1) {
          let p = Math.round(Math.abs(Math.log(Math.abs(g)) * Math.LOG10E)) + 2;
          o = tt(o, p);
        }
        l++, c = o;
      }
      for (let d = l; d < this.dataItems.length; d++)
        this.dataItems[d].hide();
      x(this.series, (d) => {
        d.inited && d._markDirtyAxes();
      }), this._updateGhost();
    }
  }
  _prepareDataItem(e, t) {
    let s = this.get("renderer"), r = e.get("value"), n = e.get("endValue"), a = this.valueToPosition(r), o = a, l = this.valueToPosition(r + this.getPrivate("step"));
    S(n) && (o = this.valueToPosition(n), l = o), e.get("isRange") && n == null && (l = a), s.updateLabel(e.get("label"), a, o, t);
    const u = e.get("grid");
    if (s.updateGrid(u, a, o), u && (r == this.get("baseValue", 0) ? (u.addTag("base"), u._applyThemes()) : u.hasTag("base") && (u.removeTag("base"), u._applyThemes())), s.updateTick(e.get("tick"), a, o, t), s.updateFill(e.get("axisFill"), a, l), this._processBullet(e), s.updateBullet(e.get("bullet"), a, o), !e.get("isRange")) {
      const h = this.get("fillRule");
      h && h(e);
    }
  }
  _handleRangeChange() {
    let e = this.positionToValue(this.get("start", 0)), t = this.positionToValue(this.get("end", 1));
    const s = this.get("renderer").gridCount();
    let r = this._adjustMinMax(e, t, s, !0), n = od(r.step);
    this.setPrivateRaw("stepDecimalPlaces", n), e = tt(e, n), t = tt(t, n), r = this._adjustMinMax(e, t, s, !0);
    let a = r.step;
    e = r.min, t = r.max, (this.getPrivate("selectionMin") !== e || this.getPrivate("selectionMax") !== t || this.getPrivate("step") !== a) && (this.setPrivateRaw("selectionMin", e), this.setPrivateRaw("selectionMax", t), this.setPrivateRaw("step", a));
  }
  /**
   * Converts a relative position to a corresponding numeric value from axis
   * scale.
   *
   * @param   position  Relative position
   * @return            Value
   */
  positionToValue(e) {
    const t = this.getPrivate("min"), s = this.getPrivate("max");
    return this.get("logarithmic") ? Math.pow(Math.E, (e * (Math.log(s) * Math.LOG10E - Math.log(t) * Math.LOG10E) + Math.log(t) * Math.LOG10E) / Math.LOG10E) : e * (s - t) + t;
  }
  /**
   * Convers value to a relative position on axis.
   *
   * @param   value  Value
   * @return         Relative position
   */
  valueToPosition(e) {
    const t = this.getPrivate("min"), s = this.getPrivate("max");
    if (this.get("logarithmic")) {
      if (e <= 0) {
        let r = this.get("treatZeroAs");
        S(r) && (e = r);
      }
      return (Math.log(e) * Math.LOG10E - Math.log(t) * Math.LOG10E) / (Math.log(s) * Math.LOG10E - Math.log(t) * Math.LOG10E);
    } else
      return (e - t) / (s - t);
  }
  /**
   * @ignore
   */
  valueToFinalPosition(e) {
    const t = this.getPrivate("minFinal"), s = this.getPrivate("maxFinal");
    if (this.get("logarithmic")) {
      if (e <= 0) {
        let r = this.get("treatZeroAs");
        S(r) && (e = r);
      }
      return (Math.log(e) * Math.LOG10E - Math.log(t) * Math.LOG10E) / (Math.log(s) * Math.LOG10E - Math.log(t) * Math.LOG10E);
    } else
      return (e - t) / (s - t);
  }
  /**
   * Returns X coordinate in pixels corresponding to specific value.
   *
   * @param   value     Numeric value
   * @param   location  Location
   * @param   baseValue Base value
   * @return            X coordinate
   */
  getX(e, t, s) {
    e = s + (e - s) * t;
    const r = this.valueToPosition(e);
    return this._settings.renderer.positionToCoordinate(r);
  }
  /**
   * Returns X coordinate in pixels corresponding to specific value.
   *
   * @param   value     Numeric value
   * @param   location  Location
   * @param   baseValue Base value
   * @return            X coordinate
   */
  getY(e, t, s) {
    e = s + (e - s) * t;
    const r = this.valueToPosition(e);
    return this._settings.renderer.positionToCoordinate(r);
  }
  /**
   * @ignore
   */
  getDataItemCoordinateX(e, t, s, r) {
    return this._settings.renderer.positionToCoordinate(this.getDataItemPositionX(e, t, s, r));
  }
  /**
   * @ignore
   */
  getDataItemPositionX(e, t, s, r) {
    let n = e.get(t);
    if (e.get("stackToItemX")) {
      const o = e.component;
      n = n * r + o.getStackedXValueWorking(e, t);
    } else
      n = this._baseValue + (n - this._baseValue) * r;
    return this.valueToPosition(n);
  }
  /**
   * @ignore
   */
  getDataItemCoordinateY(e, t, s, r) {
    return this._settings.renderer.positionToCoordinate(this.getDataItemPositionY(e, t, s, r));
  }
  /**
   * @ignore
   */
  getDataItemPositionY(e, t, s, r) {
    let n = e.get(t);
    if (e.get("stackToItemY")) {
      const o = e.component;
      n = n * r + o.getStackedYValueWorking(e, t);
    } else
      n = this._baseValue + (n - this._baseValue) * r;
    return this.valueToPosition(n);
  }
  /**
   * Returns relative position of axis' `baseValue`.
   *
   * @return  Base value position
   */
  basePosition() {
    return this.valueToPosition(this.baseValue());
  }
  /**
   * Base value of the [[ValueAxis]], which determines positive and negative
   * values.
   *
   * @return Base value
   */
  baseValue() {
    const e = Math.min(this.getPrivate("minFinal", -1 / 0), this.getPrivate("selectionMin", -1 / 0)), t = Math.max(this.getPrivate("maxFinal", 1 / 0), this.getPrivate("selectionMax", 1 / 0));
    let s = this.get("baseValue", 0);
    return s < e && (s = e), s > t && (s = t), s;
  }
  /**
   * @ignore
   */
  cellEndValue(e) {
    return e;
  }
  fixSmallStep(e) {
    return 1 + e === 1 ? (e *= 2, this.fixSmallStep(e)) : e;
  }
  _fixMin(e) {
    return e;
  }
  _fixMax(e) {
    return e;
  }
  _calculateTotals() {
    if (this.get("calculateTotals")) {
      let e = this.series[0];
      if (e) {
        let t = e.startIndex();
        if (e.dataItems.length > 0) {
          t > 0 && t--;
          let s = e.endIndex();
          s < e.dataItems.length && s++;
          let r, n;
          e.get("yAxis") == this ? (r = "valueY", n = "vcy") : e.get("xAxis") == this && (r = "valueX", n = "vcx");
          let a = r + "Working";
          if (r)
            for (let o = t; o < s; o++) {
              let l = 0, u = 0;
              x(this.series, (h) => {
                if (!h.get("excludeFromTotal")) {
                  let c = h.dataItems[o];
                  if (c) {
                    let d = c.get(a) * h.get(n);
                    $t(d) || (l += d, u += Math.abs(d));
                  }
                }
              }), x(this.series, (h) => {
                if (!h.get("excludeFromTotal")) {
                  let c = h.dataItems[o];
                  if (c) {
                    let d = c.get(a) * h.get(n);
                    $t(d) || (c.set(r + "Total", u), c.set(r + "Sum", l), c.set(r + "TotalPercent", d / u * 100));
                  }
                }
              });
            }
        }
      }
    }
  }
  _getSelectionMinMax() {
    const e = this.getPrivate("minFinal"), t = this.getPrivate("maxFinal"), s = this.get("min"), r = this.get("max");
    let n = this.get("extraMin", 0), a = this.get("extraMax", 0);
    this.get("logarithmic") && (this.get("extraMin") == null && (n = 0.1), this.get("extraMax") == null && (a = 0.2));
    const o = this.get("renderer").gridCount(), l = this.get("strictMinMaxSelection"), u = this.get("strictMinMax");
    if (S(e) && S(t)) {
      let h = t, c = e;
      if (x(this.series, (b) => {
        if (!b.get("ignoreMinMax")) {
          let y, w;
          const D = b.getPrivate("outOfSelection");
          b.get("xAxis") === this ? D || (y = b.getPrivate("selectionMinX", b.getPrivate("minX")), w = b.getPrivate("selectionMaxX", b.getPrivate("maxX"))) : b.get("yAxis") === this && (D || (y = b.getPrivate("selectionMinY", b.getPrivate("minY")), w = b.getPrivate("selectionMaxY", b.getPrivate("maxY")))), !b.isHidden() && !b.isShowing() && (S(y) && (h = Math.min(h, y)), S(w) && (c = Math.max(c, w)));
        }
      }), this.axisRanges.each((b) => {
        if (b.get("affectsMinMax")) {
          let y = b.get("value");
          y != null && (h = Math.min(h, y), c = Math.max(c, y)), y = b.get("endValue"), y != null && (h = Math.min(h, y), c = Math.max(c, y));
        }
      }), h > c && ([h, c] = [c, h]), S(s) ? u ? h = s : h = e : u && S(this._minReal) && (h = this._minReal), S(r) ? u ? c = r : c = t : u && S(this._maxReal) && (c = this._maxReal), h === c) {
        h -= this._deltaMinMax, c += this._deltaMinMax;
        let b = this._adjustMinMax(h, c, o, u);
        h = b.min, c = b.max;
      }
      let d = h, f = c;
      h -= (c - h) * n, c += (c - h) * a;
      let g = this._adjustMinMax(h, c, o);
      h = g.min, c = g.max, h = Ne(h, e, t), c = Ne(c, e, t), g = this._adjustMinMax(h, c, o, !0), u || (h = g.min, c = g.max);
      const p = this.get("syncWithAxis");
      p && (g = this._syncAxes(h, c, g.step, p.getPrivate("selectionMinFinal", p.getPrivate("minFinal", 0)), p.getPrivate("selectionMaxFinal", p.getPrivate("maxFinal", 1)), p.getPrivate("selectionStepFinal", p.getPrivate("step", 1))), h = g.min, c = g.max), u && (S(s) && (h = Math.max(h, s)), S(r) && (c = Math.min(c, r))), l && (h = d - (c - h) * n, c = f + (c - h) * a), this.get("logarithmic") && (h <= 0 && (h = d * (1 - Math.min(n, 0.99))), h < e && (h = e), c > t && (c = t));
      let m = Math.min(20, Math.ceil(Math.log(this.getPrivate("maxZoomFactor", 100) + 1) / Math.LN10) + 2), _ = tt(this.valueToFinalPosition(h), m), v = tt(this.valueToFinalPosition(c), m);
      this.setPrivateRaw("selectionMinFinal", h), this.setPrivateRaw("selectionMaxFinal", c), this.setPrivateRaw("selectionStepFinal", g.step), this.zoom(_, v);
    }
  }
  _getMinMax() {
    let e = this.get("min"), t = this.get("max"), s = 1 / 0, r = -1 / 0, n = this.get("extraMin", 0), a = this.get("extraMax", 0);
    this.get("logarithmic") && (this.get("extraMin") == null && (n = 0.1), this.get("extraMax") == null && (a = 0.2));
    let o = 1 / 0;
    if (x(this.series, (b) => {
      if (!b.get("ignoreMinMax")) {
        let y, w;
        if (b.get("xAxis") === this ? (y = b.getPrivate("minX"), w = b.getPrivate("maxX")) : b.get("yAxis") === this && (y = b.getPrivate("minY"), w = b.getPrivate("maxY")), S(y) && S(w)) {
          s = Math.min(s, y), r = Math.max(r, w);
          let D = w - y;
          D <= 0 && (D = Math.abs(w / 100)), D < o && (o = D);
        }
      }
    }), this.axisRanges.each((b) => {
      if (b.get("affectsMinMax")) {
        let y = b.get("value");
        y != null && (s = Math.min(s, y), r = Math.max(r, y)), y = b.get("endValue"), y != null && (s = Math.min(s, y), r = Math.max(r, y));
      }
    }), this.get("logarithmic")) {
      let b = this.get("treatZeroAs");
      S(b) && s <= 0 && (s = b);
    }
    if (s === 0 && r === 0 && (r = 0.9, s = -0.9), S(e) && (s = e), S(t) && (r = t), s === 1 / 0 || r === -1 / 0) {
      this.setPrivate("minFinal", void 0), this.setPrivate("maxFinal", void 0);
      return;
    }
    const l = s, u = r;
    let h = this.adapters.fold("min", s), c = this.adapters.fold("max", r);
    S(h) && (s = h), S(c) && (r = c), s = this._fixMin(s), r = this._fixMax(r), r - s <= 1 / Math.pow(10, 15) && (r - s !== 0 ? this._deltaMinMax = (r - s) / 2 : this._getDelta(r), s -= this._deltaMinMax, r += this._deltaMinMax), s -= (r - s) * n, r += (r - s) * a, this.get("logarithmic") && (s < 0 && l >= 0 && (s = 0), r > 0 && u <= 0 && (r = 0)), this._minReal = s, this._maxReal = r;
    let d = this.get("strictMinMax"), f = this.get("strictMinMaxSelection", !1);
    f && (d = f);
    let g = d;
    S(t) && (g = !0);
    let p = this.get("renderer").gridCount(), m = this._adjustMinMax(s, r, p, g);
    s = m.min, r = m.max, m = this._adjustMinMax(s, r, p, !0), s = m.min, r = m.max, d && (S(e) ? s = e : s = this._minReal, S(t) ? r = t : r = this._maxReal, r - s <= 1e-8 && (s -= this._deltaMinMax, r += this._deltaMinMax), s -= (r - s) * n, r += (r - s) * a), h = this.adapters.fold("min", s), c = this.adapters.fold("max", r), S(h) && (s = h), S(c) && (r = c), o == 1 / 0 && (o = r - s);
    let _ = Math.round(Math.abs(Math.log(Math.abs(r - s)) * Math.LOG10E)) + 5;
    s = tt(s, _), r = tt(r, _);
    const v = this.get("syncWithAxis");
    if (v && (m = this._syncAxes(s, r, m.step, v.getPrivate("minFinal", v.getPrivate("min", 0)), v.getPrivate("maxFinal", v.getPrivate("max", 1)), v.getPrivate("step", 1)), s = m.min, r = m.max), this.setPrivateRaw("maxZoomFactor", Math.max(1, Math.ceil((r - s) / o * this.get("maxZoomFactor", 100)))), this._fixZoomFactor(), this.get("logarithmic") && (this._minLogAdjusted = s, s = this._minReal, r = this._maxReal, s <= 0 && (s = l * (1 - Math.min(n, 0.99)))), S(s) && S(r) && (this.getPrivate("minFinal") !== s || this.getPrivate("maxFinal") !== r)) {
      this.setPrivate("minFinal", s), this.setPrivate("maxFinal", r), this._saveMinMax(s, r);
      const b = this.get("interpolationDuration", 0), y = this.get("interpolationEasing");
      this.animatePrivate({ key: "min", to: s, duration: b, easing: y }), this.animatePrivate({ key: "max", to: r, duration: b, easing: y });
    }
  }
  _fixZoomFactor() {
  }
  _getDelta(e) {
    let t = Math.log(Math.abs(e)) * Math.LOG10E, s = Math.pow(10, Math.floor(t));
    s = s / 10, this._deltaMinMax = s;
  }
  _saveMinMax(e, t) {
  }
  _adjustMinMax(e, t, s, r) {
    s <= 1 && (s = 1), s = Math.round(s);
    let n = e, a = t, o = t - e;
    o === 0 && (o = Math.abs(t));
    let l = Math.log(Math.abs(o)) * Math.LOG10E, u = Math.pow(10, Math.floor(l));
    u = u / 10;
    let h = u;
    r && (h = 0), r ? (e = Math.floor(e / u) * u, t = Math.ceil(t / u) * u) : (e = Math.ceil(e / u) * u - h, t = Math.floor(t / u) * u + h), e < 0 && n >= 0 && (e = 0), t > 0 && a <= 0 && (t = 0), l = Math.log(Math.abs(o)) * Math.LOG10E, u = Math.pow(10, Math.floor(l)), u = u / 100;
    let c = Math.ceil(o / s / u) * u, d = Math.pow(10, Math.floor(Math.log(Math.abs(c)) * Math.LOG10E)), f = Math.ceil(c / d);
    f > 5 ? f = 10 : f <= 5 && f > 2 && (f = 5), c = Math.ceil(c / (d * f)) * d * f;
    let g = this.get("maxPrecision");
    if (S(g)) {
      let v = wd(c, g);
      g < Number.MAX_VALUE && c !== v && (c = v);
    }
    let p = 0;
    d < 1 && (p = Math.round(Math.abs(Math.log(Math.abs(d)) * Math.LOG10E)) + 1, c = tt(c, p));
    let m = Math.floor(e / c);
    e = tt(c * m, p);
    let _;
    return r ? _ = Math.floor(t / c) : _ = Math.ceil(t / c), _ === m && _++, t = tt(c * _, p), t < a && (t = t + c), e > n && (e = e - c), c = this.fixSmallStep(c), { min: e, max: t, step: c };
  }
  /**
   * Returns text to be used in an axis tooltip for specific relative position.
   *
   * @param   position  Position
   * @return            Tooltip text
   */
  getTooltipText(e) {
    const t = this.get("tooltipNumberFormat", this.get("numberFormat")), s = this.getNumberFormatter(), r = this.get("extraTooltipPrecision", 0), n = this.getPrivate("stepDecimalPlaces", 0) + r, a = tt(this.positionToValue(e), n);
    return t ? s.format(a, t) : s.format(a, void 0, n);
  }
  /**
   * Returns a data item from series that is closest to the `position`.
   *
   * @param   series    Series
   * @param   position  Relative position
   * @return            Data item
   */
  getSeriesItem(e, t) {
    let s = this.getPrivate("name") + this.get("renderer").getPrivate("letter"), r = this.positionToValue(t), n, a;
    if (x(e.dataItems, (o, l) => {
      const u = Math.abs(o.get(s) - r);
      (n === void 0 || u < a) && (n = l, a = u);
    }), n != null)
      return e.dataItems[n];
  }
  /**
   * Zooms the axis to specific `start` and `end` values.
   *
   * Optional `duration` specifies duration of zoom animation in milliseconds.
   *
   * @param  start     Start value
   * @param  end       End value
   * @param  duration  Duration in milliseconds
   */
  zoomToValues(e, t, s) {
    const r = this.getPrivate("minFinal", 0), n = this.getPrivate("maxFinal", 0);
    this.getPrivate("min") != null && this.getPrivate("max") != null && this.zoom((e - r) / (n - r), (t - r) / (n - r), s);
  }
  /**
   * Syncs with a target axis.
   *
   * @param  min  Min
   * @param  max  Max
   * @param  step Step
   */
  _syncAxes(e, t, s, r, n, a) {
    if (this.get("syncWithAxis")) {
      let l = Math.round(n - r) / a, u = Math.round((t - e) / s), h = this.get("renderer").gridCount();
      if (S(l) && S(u)) {
        let c = !1, d = 0, f = (t - e) * 0.01, g = e, p = t, m = s;
        for (; c != !0; )
          if (c = this._checkSync(g, p, m, l), d++, d > 500 && (c = !0), c)
            e = g, t = p, s = m;
          else {
            d / 3 == Math.round(d / 3) ? (g = e - f * d, e >= 0 && g < 0 && (g = 0)) : (p = t + f * d, p <= 0 && p > 0 && (p = 0));
            let _ = this._adjustMinMax(g, p, h, !0);
            g = _.min, p = _.max, m = _.step;
          }
      }
    }
    return { min: e, max: t, step: s };
  }
  /**
   * Returns `true` if axis needs to be resunced with some other axis.
   */
  _checkSync(e, t, s, r) {
    let n = (t - e) / s;
    for (let a = 1; a < r; a++)
      if (tt(n / a, 1) == r || n * a == r)
        return !0;
    return !1;
  }
  /**
   * Returns relative position between two grid lines of the axis.
   *
   * @return Position
   */
  getCellWidthPosition() {
    let e = this.getPrivate("selectionMax", this.getPrivate("max")), t = this.getPrivate("selectionMin", this.getPrivate("min"));
    return S(e) && S(t) ? this.getPrivate("step", 1) / (e - t) : 0.05;
  }
}
Object.defineProperty(Vi, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "ValueAxis"
});
Object.defineProperty(Vi, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Xi.classNames.concat([Vi.className])
});
class ir extends Vi {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_dataGrouped", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_seriesDataGrouped", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_groupingCalculated", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_intervalDuration", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), Object.defineProperty(this, "_baseDuration", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), Object.defineProperty(this, "_intervalMax", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_intervalMin", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    });
  }
  _afterNew() {
    this._settings.themeTags = se(this._settings.themeTags, ["axis"]), super._afterNew(), this._setBaseInterval(this.get("baseInterval")), this.on("baseInterval", () => {
      this._setBaseInterval(this.get("baseInterval"));
    });
  }
  _setBaseInterval(e) {
    this.setPrivateRaw("baseInterval", e), this._baseDuration = Mt(e);
  }
  _fixZoomFactor() {
    var e = this.get("maxZoomFactor");
    e != null && e != 1 / 0 ? this.setPrivateRaw("maxZoomFactor", e) : this.setPrivateRaw("maxZoomFactor", Math.round((this.getPrivate("max", 0) - this.getPrivate("min", 0)) / this.baseMainDuration()));
  }
  _groupData() {
    const e = this.getPrivate("min"), t = this.getPrivate("max");
    if (S(e) && S(t)) {
      this._fixZoomFactor();
      const s = this.getPrivate("groupInterval");
      if (s ? this._setBaseInterval(s) : this._setBaseInterval(this.get("baseInterval")), this.isDirty("groupInterval")) {
        let r = this.get("groupInterval");
        r && this.setRaw("groupIntervals", [r]);
      }
      if (this.isDirty("groupData") && !this._dataGrouped) {
        if (this.get("groupData"))
          x(this.series, (r) => {
            this._groupSeriesData(r);
          }), this._handleRangeChange();
        else {
          let r = this.get("baseInterval"), n = r.timeUnit + r.count;
          x(this.series, (a) => {
            a.setDataSet(n);
          }), this._setBaseInterval(r), this.setPrivateRaw("groupInterval", void 0), this.markDirtyExtremes();
        }
        this._dataGrouped = !0;
      }
    }
  }
  _groupSeriesData(e) {
    if (this.get("groupData") && !e.get("groupDataDisabled")) {
      this._dataGrouped = !0, this._seriesDataGrouped = !0;
      let t = [], s = this.baseMainDuration(), r = this.get("groupIntervals");
      x(r, (m) => {
        Mt(m) > s && t.push(m);
      }), e._dataSets = {};
      const n = this.getPrivate("name") + this.get("renderer").getPrivate("letter");
      let a;
      const o = e.get("baseAxis");
      e.get("xAxis") === o ? a = e._valueYFields : e.get("yAxis") === o && (a = e._valueXFields);
      let l = e._mainDataItems, u = this.get("baseInterval"), h = u.timeUnit + u.count;
      e._dataSets[h] = l;
      const c = e.get("groupDataCallback");
      let d = e.get("groupDataWithOriginals", !1);
      c && (d = !0);
      const f = this._root.locale.firstDayOfWeek, g = this._root.utc, p = this._root.timezone;
      x(t, (m) => {
        let _ = -1 / 0, v = m.timeUnit + m.count;
        e._dataSets[v] = [];
        let b, y = {}, w = {}, D = {}, A = {};
        x(a, (E) => {
          y[E] = 0, w[E] = 0, D[E] = e.get(E + "Grouped"), A[E] = E + "Working";
        });
        let T = xt(m.timeUnit), j = l[0], C;
        j && (C = new Date(l[0].get(n)));
        let L;
        x(l, (E) => {
          let N = E.get(n), J = Ge(new Date(N), m.timeUnit, m.count, f, g, C, p).getTime(), z;
          _ < J - T / 24 ? (z = Mi(E.dataContext), b = new Gt(e, z, e._makeDataItem(z)), b.setRaw(n, J), e._dataSets[v].push(b), x(a, (H) => {
            let Y = E.get(H);
            S(Y) ? (b.setRaw(H, Y), b.setRaw(A[H], Y), w[H] = 1, y[H] = Y) : (y[H] = 0, w[H] = 0);
          }), d && b.set("originals", [E]), c && L && c(L, m), L = b) : (x(a, (H) => {
            let Y = D[H], U = E.get(H);
            if (U !== void 0) {
              let B = b.get(H);
              switch (Y) {
                case "close":
                  b.setRaw(H, U);
                  break;
                case "sum":
                  U != null && b.setRaw(H, B + U);
                  break;
                case "open":
                  break;
                case "low":
                  U < B && b.setRaw(H, U);
                  break;
                case "high":
                  U > B && b.setRaw(H, U);
                  break;
                case "average":
                  w[H]++, y[H] += U;
                  let O = y[H] / w[H];
                  b.setRaw(H, O);
                  break;
                case "extreme":
                  Math.abs(U) > Math.abs(B) && b.setRaw(H, U);
                  break;
              }
              b.setRaw(A[H], b.get(H));
              let ue = Mi(E.dataContext);
              ue[n] = J, b.dataContext = ue;
            }
          }), d && b.get("originals").push(E)), _ = J;
        }), c && L && c(L, m);
      }), e._dataSetId && e.setDataSet(e._dataSetId), this.markDirtySize();
    }
  }
  _clearDirty() {
    super._clearDirty(), this._groupingCalculated = !1, this._dataGrouped = !1;
  }
  /**
   * Returns a time interval axis would group data to for a specified duration.
   *
   * @since 5.2.1
   */
  getGroupInterval(e) {
    let t = this.get("baseInterval"), s = Qs(0, e, this.get("groupCount", 1 / 0), this.get("groupIntervals"));
    return Mt(s) < Mt(t) && (s = Object.assign({}, t)), s;
  }
  /**
   * Return `max` of a specified time interval.
   *
   * Will work only if the axis was grouped to this interval at least once.
   *
   * @since 5.2.1
   * @param   interval  Interval
   * @return            Max
   */
  getIntervalMax(e) {
    return this._intervalMax[e.timeUnit + e.count];
  }
  /**
   * Return `min` of a specified time interval.
   *
   * Will work only if the axis was grouped to this interval at least once.
   *
   * @since 5.2.1
   * @param   interval  Interval
   * @return            Min
   */
  getIntervalMin(e) {
    return this._intervalMin[e.timeUnit + e.count];
  }
  _handleRangeChange() {
    super._handleRangeChange();
    let e = Math.round(this.getPrivate("selectionMin")), t = Math.round(this.getPrivate("selectionMax"));
    if (S(e) && S(t)) {
      if (this.get("endLocation") == 0 && (t += 1), this.get("groupData") && !this._groupingCalculated) {
        this._groupingCalculated = !0;
        let s = t - e + (this.get("startLocation", 0) + (1 - this.get("endLocation", 1)) * this.baseDuration()), r = this.get("groupInterval");
        r || (r = this.getGroupInterval(s));
        let n = this.getPrivate("groupInterval");
        if (r && (!n || n.timeUnit !== r.timeUnit || n.count !== r.count || this._seriesDataGrouped)) {
          this._seriesDataGrouped = !1, this.setPrivateRaw("groupInterval", r), this._setBaseInterval(r);
          let a = r.timeUnit + r.count;
          x(this.series, (o) => {
            o.get("baseAxis") === this && o.setDataSet(a);
          }), this.markDirtyExtremes(), this._root.events.once("frameended", () => {
            this._root.events.once("frameended", () => {
              const o = "groupintervalchanged";
              this.events.isEnabled(o) && this.events.dispatch(o, { type: o, target: this });
            });
          });
        }
      }
      x(this.series, (s) => {
        if (s.get("baseAxis") === this) {
          let r = this.getPrivate("name") + this.get("renderer").getPrivate("letter"), a = Ei(s.dataItems, (p) => Et(p.get(r), e)).index;
          a > 0 && (a -= 1), t += this.baseDuration() * (1 - this.get("endLocation", 1));
          let l = Ei(s.dataItems, (p) => Et(p.get(r), t)).index, u = l;
          u > 0 && u--;
          const h = s.dataItems[a], c = s.dataItems[u];
          let d, f;
          h && (f = h.get(r)), c && (d = c.get(r));
          let g = !1;
          d != null && f != null && (d < e || f > t) && (g = !0), s.setPrivate("outOfSelection", g), s.setPrivate("startIndex", a), s.setPrivate("endIndex", l);
        }
      });
    }
  }
  _adjustMinMax(e, t, s, r) {
    return { min: e, max: t, step: (t - e) / s };
  }
  /**
   * @ignore
   */
  intervalDuration() {
    return this._intervalDuration;
  }
  _saveMinMax(e, t) {
    let s = this.getPrivate("groupInterval");
    s || (s = this.get("baseInterval"));
    let r = s.timeUnit + s.count;
    this._intervalMin[r] = e, this._intervalMax[r] = t;
  }
  _getM(e) {
    return e == "month" || e == "year" || e == "day" ? 1.05 : 1.01;
  }
  _prepareAxisItems() {
    const e = this.getPrivate("min"), t = this.getPrivate("max");
    if (S(e) && S(t)) {
      const s = Math.round(this.getPrivate("selectionMin")), r = Math.round(this.getPrivate("selectionMax")), n = this.get("renderer"), a = this.getPrivate("baseInterval");
      let o = s, l = 0;
      const u = this.get("gridIntervals");
      let h = Qs(0, r - s, n.gridCount(), u);
      Mt(h) < this.baseDuration() && (h = Object.assign({}, a));
      const c = Mt(h);
      this._intervalDuration = c;
      const d = hn(h.timeUnit), f = this._root.locale.firstDayOfWeek, g = this._root.utc, p = this._root.timezone;
      o = Ge(new Date(s - c), h.timeUnit, h.count, f, g, new Date(e), p).getTime();
      let m = o - c, _;
      const v = this.get("dateFormats");
      for (this.setPrivateRaw("gridInterval", h); o < r + c; ) {
        let b;
        this.dataItems.length < l + 1 ? (b = new Gt(this, void 0, {}), this._dataItems.push(b), this.processDataItem(b)) : b = this.dataItems[l], this._createAssets(b, []), b.isHidden() && b.show(), b.setRaw("value", o);
        let y = o + xt(h.timeUnit, h.count * this._getM(h.timeUnit));
        y = Ge(new Date(y), h.timeUnit, 1, f, g, void 0, p).getTime(), b.setRaw("endValue", y);
        let w = new Date(o);
        _ = v[h.timeUnit], d && this.get("markUnitChange") && S(m) && h.timeUnit != "year" && cn(o, m, d, g, p) && (_ = this.get("periodChangeDateFormats")[h.timeUnit]);
        const D = b.get("label");
        if (D && D.set("text", this._root.dateFormatter.format(w, _)), this._prepareDataItem(b, h.count), m = o, o = y, o == m)
          break;
        l++;
      }
      for (let b = l; b < this.dataItems.length; b++)
        this.dataItems[b].hide();
      x(this.series, (b) => {
        b.inited && b._markDirtyAxes();
      });
    }
    this._updateGhost();
  }
  _updateFinals(e, t) {
    this.setPrivateRaw("selectionMinFinal", this.positionToValue(e)), this.setPrivateRaw("selectionMaxFinal", this.positionToValue(t));
  }
  _getDelta() {
    this._deltaMinMax = this.baseDuration() / 2;
  }
  _fixMin(e) {
    const t = this.getPrivate("baseInterval"), s = this._root.locale.firstDayOfWeek, r = this._root.timezone, n = this._root.utc, a = t.timeUnit;
    let o = Ge(new Date(e), a, t.count, s, n, void 0, r).getTime(), l = o + xt(a, t.count * this._getM(a));
    return l = Ge(new Date(l), a, 1, s, n, void 0, r).getTime(), o + (l - o) * this.get("startLocation", 0);
  }
  _fixMax(e) {
    const t = this.getPrivate("baseInterval"), s = this._root.locale.firstDayOfWeek, r = this._root.timezone, n = this._root.utc, a = t.timeUnit;
    let o = Ge(new Date(e), a, t.count, s, n, void 0, r).getTime(), l = o + xt(a, t.count * this._getM(a));
    return l = Ge(new Date(l), a, 1, s, n, void 0, r).getTime(), o + (l - o) * this.get("endLocation", 1);
  }
  _updateDates(e) {
  }
  /**
   * Returns a duration of currently active `baseInterval` in milliseconds.
   *
   * @return Duration
   */
  baseDuration() {
    return this._baseDuration;
  }
  /**
   * Returns a duration of user-defined `baseInterval` in milliseconds.
   *
   * @return Duration
   */
  baseMainDuration() {
    return Mt(this.get("baseInterval"));
  }
  /**
   * @ignore
   */
  processSeriesDataItem(e, t) {
    const s = this.getPrivate("baseInterval");
    e.open || (e.open = {}), e.close || (e.close = {}), x(t, (r) => {
      let n = e.get(r);
      if (S(n)) {
        let a = e.open[r], o = e.close[r];
        if (!(n >= a && n <= o)) {
          const l = this._root.locale.firstDayOfWeek, u = this._root.utc, h = this._root.timezone, c = s.timeUnit, d = s.count;
          a = Ge(new Date(n), c, d, l, u, void 0, h).getTime(), o = a + xt(c, d * this._getM(c)), o = Ge(new Date(o), c, 1, l, u, void 0, h).getTime(), e.open[r] = a, e.close[r] = o;
        }
        this._updateDates(a);
      }
    });
  }
  /**
   * @ignore
   */
  getDataItemPositionX(e, t, s, r) {
    let n, a;
    e.open && e.close ? (n = e.open[t], a = e.close[t]) : (n = e.get(t), a = n);
    let o = n + (a - n) * s;
    return o = this._baseValue + (o - this._baseValue) * r, this.valueToPosition(o);
  }
  /**
   * @ignore
   */
  getDataItemCoordinateX(e, t, s, r) {
    return this._settings.renderer.positionToCoordinate(this.getDataItemPositionX(e, t, s, r));
  }
  /**
   * @ignore
   */
  getDataItemPositionY(e, t, s, r) {
    let n, a;
    e.open && e.close ? (n = e.open[t], a = e.close[t]) : (n = e.get(t), a = n);
    let o = n + (a - n) * s;
    return o = this._baseValue + (o - this._baseValue) * r, this.valueToPosition(o);
  }
  /**
   * @ignore
   */
  getDataItemCoordinateY(e, t, s, r) {
    return this._settings.renderer.positionToCoordinate(this.getDataItemPositionY(e, t, s, r));
  }
  /**
   * @ignore
   */
  roundAxisPosition(e, t) {
    let s = this.positionToValue(e);
    s = s - (t - 0.5) * this.baseDuration();
    let r = this.getPrivate("baseInterval");
    if (!$t(s)) {
      const n = this._root.locale.firstDayOfWeek, a = r.timeUnit, o = this._root.utc, l = this._root.timezone, u = r.count;
      s = Ge(new Date(s), a, u, n, o, new Date(this.getPrivate("min", 0)), l).getTime();
      let h = Yn(r, new Date(s), n, o, l);
      return l && (s = Ge(new Date(s + this.baseDuration() * 0.05), a, u, n, o, new Date(this.getPrivate("min", 0)), l).getTime(), h = Yn(r, new Date(s + h * t), n, o, l)), this.valueToPosition(s + h * t);
    }
    return NaN;
  }
  /**
   * Returns text to be used in an axis tooltip for specific relative position.
   *
   * @param   position  Position
   * @return            Tooltip text
   */
  getTooltipText(e) {
    if (this.getPrivate("min") != null) {
      let t = this.get("tooltipDateFormats")[this.getPrivate("baseInterval").timeUnit], s = this.positionToValue(e), r = new Date(s), n = this.getPrivate("baseInterval"), a = Yn(n, r, this._root.locale.firstDayOfWeek, this._root.utc, this._root.timezone);
      return this._root.dateFormatter.format(new Date(s + this.get("tooltipIntervalOffset", -this.get("tooltipLocation", 0.5)) * a), this.get("tooltipDateFormat", t));
    }
    return "";
  }
  /**
   * Returns a data item from series that is closest to the `position`.
   *
   * @param   series    Series
   * @param   position  Relative position
   * @return            Data item
   */
  getSeriesItem(e, t, s) {
    let r = this.getPrivate("name") + this.get("renderer").getPrivate("letter"), n = this.positionToValue(t);
    s == null && (s = 0.5), n = n - (s - 0.5) * this.baseDuration();
    const a = Ei(e.dataItems, (o) => {
      var l = 0;
      return o.open && (l = o.open[r]), Et(l, n);
    });
    if (e.get("snapTooltip")) {
      let o = e.dataItems[a.index - 1], l = e.dataItems[a.index];
      if (o && l && o.open && l.close) {
        let u = o.open[r], h = l.close[r];
        if (Math.abs(n - u) > Math.abs(n - h))
          return l;
      }
      if (o)
        return o;
      if (l)
        return l;
    } else {
      const o = e.dataItems[a.index - 1];
      if (o && o.open && o.close) {
        let l = o.open[r], u = o.close[r];
        if (n >= l && n <= u)
          return o;
      }
    }
  }
  /**
   * @ignore
   */
  shouldGap(e, t, s, r) {
    const n = e.get(r);
    return t.get(r) - n > this.baseDuration() * s;
  }
  /**
   * Zooms the axis to specific `start` and `end` dates.
   *
   * Optional `duration` specifies duration of zoom animation in milliseconds.
   *
   * @param  start     Start Date
   * @param  end       End Date
   * @param  duration  Duration in milliseconds
   */
  zoomToDates(e, t, s) {
    this.zoomToValues(e.getTime(), t.getTime(), s);
  }
  /**
   * Returns a `Date` object corresponding to specific position within plot
   * area.
   *
   * @param   position  Pposition
   * @return            Date
   */
  positionToDate(e) {
    return new Date(this.positionToValue(e));
  }
  /**
   * Returns a relative position within plot area that corresponds to specific
   * date.
   *
   * @param   date  Date
   * @return        Position
   */
  dateToPosition(e) {
    return this.valueToPosition(e.getTime());
  }
  /**
   * Returns relative position between two grid lines of the axis.
   *
   * @since 5.2.30
   * @return Position
   */
  getCellWidthPosition() {
    let e = this.getPrivate("selectionMax", this.getPrivate("max")), t = this.getPrivate("selectionMin", this.getPrivate("min"));
    return S(e) && S(t) ? this._intervalDuration / (e - t) : 0.05;
  }
}
Object.defineProperty(ir, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "DateAxis"
});
Object.defineProperty(ir, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Vi.classNames.concat([ir.className])
});
class Sa extends ir {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_frequency", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), Object.defineProperty(this, "_dates", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    });
  }
  _afterNew() {
    this.valueFields.push("date"), super._afterNew();
  }
  _updateDates(e) {
    const t = this._dates, s = Ei(t, (r) => Et(r, e));
    s.found || Xs(t, s.index, e);
  }
  _updateAllDates() {
    this._dates.length = 0, x(this.series, (e) => {
      let t = "valueX";
      e.get("yAxis") == this && (t = "valueY"), x(e.dataItems, (s) => {
        let r = s.get(t);
        S(r) && s.open && this._updateDates(s.open[t]);
      });
    });
  }
  /**
   * Convers value to a relative position on axis.
   *
   * @param   value  Value
   * @return         Relative position
   */
  valueToPosition(e) {
    const t = this._dates, s = this.get("startLocation", 0), r = this.get("endLocation", 1), n = t.length - s - (1 - r), a = Ei(t, (l) => Et(l, e));
    let o = a.index;
    if (a.found)
      return (o - s) / n;
    {
      o > 0 && (o -= 1);
      let l = t[o], u = 0;
      return l > e ? u = l - e : u = e - l, (o - s) / n + u / this.baseDuration() / n;
    }
  }
  /**
   * Converts numeric value from axis scale to index.
   *
   * @param  value  Value
   * @return        Index
   */
  valueToIndex(e) {
    const t = this._dates, s = Ei(t, (n) => Et(n, e));
    let r = s.index;
    return s.found || r > 0 && (r -= 1), r;
  }
  /**
   * Converts a relative position to a corresponding numeric value from axis
   * scale.
   *
   * @param   position  Relative position
   * @return            Value
   */
  positionToValue(e) {
    const t = this.get("startLocation", 0), s = this.get("endLocation", 1);
    let r = Math.round(this._dates.length - t - (1 - s)), n = e * r, a = Math.floor(n);
    return a < 0 && (a = 0), a > r - 1 && (a = r - 1), this._dates[a] + (n - a + t) * this.baseDuration();
  }
  _fixZoomFactor() {
    this.setPrivateRaw("maxZoomFactor", this._dates.length - this.get("startLocation", 0) - (1 - this.get("endLocation", 1)));
  }
  /**
   * Zooms the axis to specific `start` and `end` values.
   *
   * Optional `duration` specifies duration of zoom animation in milliseconds.
   *
   * @param  start     Start value
   * @param  end       End value
   * @param  duration  Duration in milliseconds
   */
  zoomToValues(e, t, s) {
    this.zoom(this.valueToPosition(e), this.valueToPosition(t), s);
  }
  _prepareAxisItems() {
    let e = this.getPrivate("selectionMin", 0), t = this.getPrivate("selectionMax", 0);
    if (S(e) && S(t)) {
      this._seriesValuesDirty && (this._seriesValuesDirty = !1, this._updateAllDates());
      const s = this._dates, r = this.get("renderer"), n = s.length;
      let a = this.valueToIndex(e);
      a > 0 && a--;
      let o = this.valueToIndex(t);
      o < n - 1 && o++;
      let l = r.axisLength() / Math.max(r.get("minGridDistance"), 1 / Number.MAX_SAFE_INTEGER), u = Math.min(n, Math.ceil((o - a) / l));
      u = Math.max(1, u), a = Math.floor(a / u) * u, this._frequency = u;
      for (let D = 0, A = this.dataItems.length; D < A; D++)
        this.dataItems[D].hide();
      let h = t - e - ((t - e) / this.baseDuration() - (o - a)) * this.baseDuration(), c = Qs(0, h, l, this.get("gridIntervals"));
      const d = this.getPrivate("baseInterval");
      let f = Mt(c);
      f < this.baseDuration() && (c = Object.assign({}, d), f = Mt(c)), this._intervalDuration = f;
      const g = this.get("dateFormats");
      let p = [], m = new Date();
      this._dates[0] && (m = new Date(this._dates[0]));
      let _ = Ge(new Date(this.getPrivate("min", 0)), c.timeUnit, c.count, this._root.locale.firstDayOfWeek, this._root.utc, m, this._root.timezone), v = Bd(_, c.timeUnit, -1, this._root.utc, this._root.timezone).getTime(), b = this.getPrivate("selectionMax"), y = -1 / 0, w = (this.get("end", 1) - this.get("start", 0)) / l;
      for (; v <= b; ) {
        let D = this.valueToIndex(v), A = this._dates[D];
        if (A < v) {
          for (let C = D, L = this._dates.length; C < L; C++)
            if (this._dates[C] >= v) {
              D = C;
              break;
            }
        }
        let T = this.valueToPosition(A);
        T - y >= w * 0.95 && (Vc(p, D), y = T);
        let j = v;
        if (v += xt(c.timeUnit, c.count * this._getM(c.timeUnit)), v = Ge(new Date(v), c.timeUnit, c.count, this._root.locale.firstDayOfWeek, this._root.utc, void 0, this._root.timezone).getTime(), v == j)
          break;
      }
      if (p.length > 0) {
        let D = 0, A = v - f * 10;
        const T = hn(c.timeUnit);
        x(p, (j) => {
          let C;
          this.dataItems.length < D + 1 ? (C = new Gt(this, void 0, {}), this._dataItems.push(C), this.processDataItem(C)) : C = this.dataItems[D];
          let L = s[j], E = new Date(L), N = L;
          if (D < p.length - 1 ? N = s[p[D + 1]] : N += f, C.setRaw("value", L), C.setRaw("endValue", N), C.setRaw("index", D), j > a - 100 && j < o + 100) {
            let J = g[c.timeUnit];
            J = g[c.timeUnit], T && this.get("markUnitChange") && S(A) && c.timeUnit != "year" && cn(L, A, T, this._root.utc, this._root.timezone) && (J = this.get("periodChangeDateFormats")[c.timeUnit]), this._createAssets(C, []);
            const z = C.get("label");
            z && z.set("text", this._root.dateFormatter.format(E, J)), C.isHidden() && C.show(), this._prepareDataItem(C, c.count);
          }
          D++, A = L;
        });
      }
      x(this.series, (D) => {
        D.inited && D._markDirtyAxes();
      });
    }
    this._updateGhost();
  }
}
Object.defineProperty(Sa, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "GaplessDateAxis"
});
Object.defineProperty(Sa, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: ir.classNames.concat([Sa.className])
});
class Da extends Vi {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_dataGrouped", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_groupingCalculated", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_intervalDuration", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    });
  }
  _afterNew() {
    this._settings.themeTags = se(this._settings.themeTags, ["axis"]), super._afterNew();
  }
  _adjustMinMax(e, t, s, r) {
    let n;
    const a = this.getDurationFormatter(), o = this.get("baseUnit");
    if (this.setRaw("maxPrecision", 0), o == "millisecond" || o == "second" || o == "minute" || o == "hour") {
      s <= 1 && (s = 1), s = Math.round(s);
      let l = t - e;
      l === 0 && (l = Math.abs(t));
      let u = l / s, h = [60, 30, 20, 15, 10, 2, 1], c = 1;
      o == "hour" && (h = [24, 12, 6, 4, 2, 1]);
      for (let _ of h)
        if (l / _ > s) {
          c = _;
          break;
        }
      let d = Math.ceil((t - e) / c / s), f = Math.log(Math.abs(d)) * Math.LOG10E, g = Math.pow(10, Math.floor(f)) / 10, p = d / g;
      d = Pd(h, p) * g, u = c * d, e = Math.floor(e / u) * u, t = Math.ceil(t / u) * u, n = { min: e, max: t, step: u };
    } else
      n = super._adjustMinMax(e, t, s, r);
    return this.setPrivateRaw("durationFormat", a.getFormat(n.step, n.max, o)), n;
  }
  _formatText(e) {
    return this.getDurationFormatter().format(e, this.getPrivate("durationFormat"), this.get("baseUnit"));
  }
  /**
   * Returns text to be used in an axis tooltip for specific relative position.
   *
   * @param   position  Position
   * @return            Tooltip text
   */
  getTooltipText(e) {
    const t = this.getDurationFormatter(), s = this.get("extraTooltipPrecision", 0), r = this.getPrivate("stepDecimalPlaces", 0) + s, n = tt(this.positionToValue(e), r);
    return t.format(n, this.getPrivate("durationFormat"), this.get("baseUnit"));
  }
}
Object.defineProperty(Da, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "DurationAxis"
});
Object.defineProperty(Da, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Vi.classNames.concat([Da.className])
});
class Pa extends De {
  constructor() {
    super(...arguments), Object.defineProperty(this, "axis", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  _beforeChanged() {
    super._beforeChanged();
    const e = this.get("sprite");
    if (this.isDirty("sprite") && e && (e.setAll({ position: "absolute", role: "figure" }), this._disposers.push(e)), this.isDirty("location")) {
      const t = e.dataItem;
      this.axis && e && t && this.axis._prepareDataItem(t);
    }
  }
}
Object.defineProperty(Pa, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "AxisBullet"
});
Object.defineProperty(Pa, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: De.classNames.concat([Pa.className])
});
class Qr extends We {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_tickPoints", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    });
  }
}
Object.defineProperty(Qr, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "AxisLabel"
});
Object.defineProperty(Qr, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: We.classNames.concat([Qr.className])
});
class Ta extends vs {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_tickPoints", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    });
  }
}
Object.defineProperty(Ta, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "AxisLabelRadial"
});
Object.defineProperty(Ta, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: vs.classNames.concat([Ta.className])
});
class Jr extends xs {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_tickPoints", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    });
  }
}
Object.defineProperty(Jr, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "AxisTick"
});
Object.defineProperty(Jr, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: xs.classNames.concat([Jr.className])
});
class Wi extends he {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_axisLength", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 100
    }), Object.defineProperty(this, "_start", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_end", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), Object.defineProperty(this, "_inversed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_minSize", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "chart", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_lc", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), Object.defineProperty(this, "_ls", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_thumbDownPoint", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_downStart", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_downEnd", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "ticks", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new Ae(ge.new({}), () => Jr._new(this._root, {
        themeTags: se(this.ticks.template.get("themeTags", []), this.get("themeTags", []))
      }, [this.ticks.template]))
    }), Object.defineProperty(this, "grid", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new Ae(ge.new({}), () => Ss._new(this._root, {
        themeTags: se(this.grid.template.get("themeTags", []), this.get("themeTags", []))
      }, [this.grid.template]))
    }), Object.defineProperty(this, "axisFills", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new Ae(ge.new({}), () => he._new(this._root, {
        themeTags: se(this.axisFills.template.get("themeTags", ["axis", "fill"]), this.get("themeTags", []))
      }, [this.axisFills.template]))
    }), Object.defineProperty(this, "labels", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new Ae(ge.new({}), () => Qr._new(this._root, {
        themeTags: se(this.labels.template.get("themeTags", []), this.get("themeTags", []))
      }, [this.labels.template]))
    }), Object.defineProperty(this, "axis", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "thumb", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  /**
   * @ignore
   */
  makeTick(e, t) {
    const s = this.ticks.make();
    return s._setDataItem(e), e.setRaw("tick", s), s.set("themeTags", se(s.get("themeTags"), t)), this.axis.labelsContainer.children.push(s), this.ticks.push(s), s;
  }
  /**
   * @ignore
   */
  makeGrid(e, t) {
    const s = this.grid.make();
    return s._setDataItem(e), e.setRaw("grid", s), s.set("themeTags", se(s.get("themeTags"), t)), this.axis.gridContainer.children.push(s), this.grid.push(s), s;
  }
  /**
   * @ignore
   */
  makeAxisFill(e, t) {
    const s = this.axisFills.make();
    return s._setDataItem(e), s.set("themeTags", se(s.get("themeTags"), t)), this.axis.gridContainer.children.push(s), e.setRaw("axisFill", s), this.axisFills.push(s), s;
  }
  /**
   * @ignore
   */
  makeLabel(e, t) {
    const s = this.labels.make();
    return s.set("themeTags", se(s.get("themeTags"), t)), this.axis.labelsContainer.children.moveValue(s, 0), s._setDataItem(e), e.setRaw("label", s), this.labels.push(s), s;
  }
  axisLength() {
    return 0;
  }
  /**
   * @ignore
   */
  gridCount() {
    return this.axisLength() / this.get("minGridDistance", 50);
  }
  _updatePositions() {
  }
  _afterNew() {
    super._afterNew(), this.set("isMeasured", !1);
    const e = this.thumb;
    e && (this._disposers.push(e.events.on("pointerdown", (t) => {
      this._handleThumbDown(t.originalEvent);
    })), this._disposers.push(e.events.on("globalpointerup", (t) => {
      this._handleThumbUp(t.originalEvent);
    })), this._disposers.push(e.events.on("globalpointermove", (t) => {
      this._handleThumbMove(t.originalEvent);
    })));
  }
  _changed() {
    if (super._changed(), this.isDirty("pan")) {
      const e = this.thumb;
      if (e) {
        const t = this.axis.labelsContainer, s = this.get("pan");
        s == "zoom" ? t.children.push(e) : s == "none" && t.children.removeValue(e);
      }
    }
  }
  _handleThumbDown(e) {
    this._thumbDownPoint = this.toLocal(this._root.documentPointToRoot({ x: e.clientX, y: e.clientY }));
    const t = this.axis;
    this._downStart = t.get("start"), this._downEnd = t.get("end");
  }
  _handleThumbUp(e) {
    this._thumbDownPoint = void 0;
  }
  _handleThumbMove(e) {
    const t = this._thumbDownPoint;
    if (t) {
      const s = this.toLocal(this._root.documentPointToRoot({ x: e.clientX, y: e.clientY })), r = this._downStart, n = this._downEnd, a = this._getPan(s, t) * Math.min(1, n - r) / 2;
      this.axis.setAll({ start: r - a, end: n + a });
    }
  }
  _getPan(e, t) {
    return 0;
  }
  /**
   * Converts relative position (0-1) on axis to a pixel coordinate.
   *
   * @param position  Position (0-1)
   * @return Coordinate (px)
   */
  positionToCoordinate(e) {
    return this._inversed ? (this._end - e) * this._axisLength : (e - this._start) * this._axisLength;
  }
  /**
   * @ignore
   */
  updateTooltipBounds(e) {
  }
  _updateSize() {
    this.markDirty(), this._clear = !0;
  }
  toAxisPosition(e) {
    const t = this._start || 0, s = this._end || 1;
    return e = e * (s - t), this.get("inversed") ? e = s - e : e = t + e, e;
  }
  /**
   * @ignore
   */
  fixPosition(e) {
    return this.get("inversed") ? 1 - e : e;
  }
  _updateLC() {
  }
  toggleVisibility(e, t, s, r) {
    let n = this.axis;
    const a = n.get("start", 0), o = n.get("end", 1);
    let l = a + (o - a) * (s - 1e-4), u = a + (o - a) * (r + 1e-4);
    t < l || t > u ? e.setPrivate("visible", !1) : e.setPrivate("visible", !0);
  }
  _positionTooltip(e, t) {
    const s = this.chart;
    s && (s.inPlot(t) ? e.set("pointTo", this._display.toGlobal(t)) : e.hide());
  }
  processAxis() {
  }
}
Object.defineProperty(Wi, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "AxisRenderer"
});
Object.defineProperty(Wi, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: he.classNames.concat([Wi.className])
});
class sr extends Wi {
  constructor() {
    super(...arguments), Object.defineProperty(this, "thumb", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: mt.new(this._root, { width: R, isMeasured: !1, themeTags: ["axis", "x", "thumb"] })
    });
  }
  _afterNew() {
    this._settings.themeTags = se(this._settings.themeTags, ["renderer", "x"]), super._afterNew(), this.setPrivateRaw("letter", "X");
    const e = this.grid.template;
    e.set("height", R), e.set("width", 0), e.set("draw", (t, s) => {
      t.moveTo(0, 0), t.lineTo(0, s.height());
    }), this.set("draw", (t, s) => {
      t.moveTo(0, 0), t.lineTo(s.width(), 0);
    });
  }
  _changed() {
    super._changed();
    const e = this.axis;
    e.ghostLabel.setPrivate("visible", !this.get("inside")), e.ghostLabel.set("x", -1e3);
    const t = "opposite", s = "inside";
    if (this.isDirty(t) || this.isDirty(s)) {
      const r = this.chart, n = e.children;
      if (this.get(s) ? e.addTag(s) : e.removeTag(s), r) {
        if (this.get(t)) {
          const a = r.topAxesContainer.children;
          a.indexOf(e) == -1 && a.insertIndex(0, e), e.addTag(t), n.moveValue(this);
        } else {
          const a = r.bottomAxesContainer.children;
          a.indexOf(e) == -1 && a.moveValue(e), e.removeTag(t), n.moveValue(this, 0);
        }
        e.ghostLabel._applyThemes(), this.labels.each((a) => {
          a._applyThemes();
        }), this.root._markDirtyRedraw();
      }
      e.markDirtySize();
    }
    this.thumb.setPrivate("height", e.labelsContainer.height());
  }
  _getPan(e, t) {
    return (t.x - e.x) / this.width();
  }
  toAxisPosition(e) {
    const t = this._start || 0, s = this._end || 1;
    return e -= this._ls, e = e * (s - t) / this._lc, this.get("inversed") ? e = s - e : e = t + e, e;
  }
  _updateLC() {
    const e = this.axis, t = e.parent;
    if (t) {
      const s = t.innerWidth();
      this._lc = this.axisLength() / s, this._ls = (e.x() - t.get("paddingLeft", 0)) / s;
    }
  }
  _updatePositions() {
    const e = this.axis;
    e.gridContainer.set("x", e.x() - we(e.get("centerX", 0), e.width()) - e.parent.get("paddingLeft", 0)), e.bulletsContainer.set("y", this.y());
    const t = e.chart;
    if (t) {
      const s = t.plotContainer, r = e.axisHeader;
      let n = e.get("marginLeft", 0), a = e.x() - n;
      const o = e.parent;
      o && (a -= o.get("paddingLeft", 0)), r.children.length > 0 ? (n = e.axisHeader.width(), e.set("marginLeft", n + 1)) : r.set("width", n), r.setAll({ x: a, y: -1, height: s.height() + 2 });
    }
  }
  /**
   * @ignore
   */
  processAxis() {
    super.processAxis();
    const e = this.axis;
    e.set("width", R);
    const t = this._root.verticalLayout;
    e.set("layout", t), e.labelsContainer.set("width", R), e.axisHeader.setAll({ layout: t });
  }
  /**
   * @ignore
   */
  axisLength() {
    return this.axis.width();
  }
  /**
   * Converts axis relative position to actual coordinate in pixels.
   *
   * @param   position  Position
   * @return            Point
   */
  positionToPoint(e) {
    return { x: this.positionToCoordinate(e), y: 0 };
  }
  /**
   * @ignore
   */
  updateTick(e, t, s, r) {
    if (e) {
      S(t) || (t = 0);
      let n = 0.5;
      S(r) && r > 1 ? n = e.get("multiLocation", n) : n = e.get("location", n), S(s) && s != t && (t = t + (s - t) * n), e.set("x", this.positionToCoordinate(t));
      let a = e.get("length", 0);
      const o = e.get("inside", this.get("inside", !1));
      this.get("opposite") ? (e.set("y", R), o || (a *= -1)) : (e.set("y", 0), o && (a *= -1)), e.set("draw", (l) => {
        l.moveTo(0, 0), l.lineTo(0, a);
      }), this.toggleVisibility(e, t, e.get("minPosition", 0), e.get("maxPosition", 1));
    }
  }
  /**
   * @ignore
   */
  updateLabel(e, t, s, r) {
    if (e) {
      let n = 0.5;
      S(r) && r > 1 ? n = e.get("multiLocation", n) : n = e.get("location", n), S(t) || (t = 0);
      const a = e.get("inside", this.get("inside", !1));
      this.get("opposite") ? a ? (e.set("position", "absolute"), e.set("y", 0)) : (e.set("position", "relative"), e.set("y", R)) : a ? (e.set("y", 0), e.set("position", "absolute")) : (e.set("y", void 0), e.set("position", "relative")), S(s) && s != t && (t = t + (s - t) * n), e.set("x", this.positionToCoordinate(t)), this.toggleVisibility(e, t, e.get("minPosition", 0), e.get("maxPosition", 1));
    }
  }
  /**
   * @ignore
   */
  updateGrid(e, t, s) {
    if (e) {
      S(t) || (t = 0);
      let r = e.get("location", 0.5);
      S(s) && s != t && (t = t + (s - t) * r), e.set("x", this.positionToCoordinate(t)), this.toggleVisibility(e, t, 0, 1);
    }
  }
  /**
   * @ignore
   */
  updateBullet(e, t, s) {
    if (e) {
      const r = e.get("sprite");
      if (r) {
        S(t) || (t = 0);
        let n = e.get("location", 0.5);
        S(s) && s != t && (t = t + (s - t) * n);
        let a = this.axis.roundAxisPosition(t, n), o = this.axis._bullets[a], l = -1;
        if (this.get("opposite") && (l = 1), e.get("stacked"))
          if (o) {
            let u = o.get("sprite");
            u && r.set("y", u.y() + u.height() * l);
          } else
            r.set("y", 0);
        this.axis._bullets[a] = e, r.set("x", this.positionToCoordinate(t)), this.toggleVisibility(r, t, 0, 1);
      }
    }
  }
  /**
   * @ignore
   */
  updateFill(e, t, s) {
    if (e) {
      S(t) || (t = 0), S(s) || (s = 1);
      let r = this.positionToCoordinate(t), n = this.positionToCoordinate(s);
      this.fillDrawMethod(e, r, n);
    }
  }
  fillDrawMethod(e, t, s) {
    e.set("draw", (r) => {
      const n = this.axis.gridContainer.height(), a = this.width();
      s < t && ([s, t] = [t, s]), !(t > a || s < 0) && (r.moveTo(t, 0), r.lineTo(s, 0), r.lineTo(s, n), r.lineTo(t, n), r.lineTo(t, 0));
    });
  }
  /**
   * @ignore
   */
  positionTooltip(e, t) {
    this._positionTooltip(e, { x: this.positionToCoordinate(t), y: 0 });
  }
  /**
   * @ignore
   */
  updateTooltipBounds(e) {
    const t = this.get("inside"), s = 1e5;
    let r = this._display.toGlobal({ x: 0, y: 0 }), n = r.x, a = 0, o = this.axisLength(), l = s, u = "up";
    this.get("opposite") ? t ? (u = "up", a = r.y, l = s) : (u = "down", a = r.y - s, l = s) : t ? (u = "down", a = r.y - s, l = s) : (u = "up", a = r.y, l = s);
    const h = { left: n, right: n + o, top: a, bottom: a + l }, c = e.get("bounds");
    Su(h, c) || (e.set("bounds", h), e.set("pointerOrientation", u));
  }
}
Object.defineProperty(sr, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "AxisRendererX"
});
Object.defineProperty(sr, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Wi.classNames.concat([sr.className])
});
class Oi extends Wi {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_downY", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "thumb", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: mt.new(this._root, { height: R, isMeasured: !1, themeTags: ["axis", "y", "thumb"] })
    });
  }
  _afterNew() {
    this._settings.themeTags = se(this._settings.themeTags, ["renderer", "y"]), this._settings.opposite && this._settings.themeTags.push("opposite"), super._afterNew(), this.setPrivateRaw("letter", "Y");
    const e = this.grid.template;
    e.set("width", R), e.set("height", 0), e.set("draw", (t, s) => {
      t.moveTo(0, 0), t.lineTo(s.width(), 0);
    }), this.set("draw", (t, s) => {
      t.moveTo(0, 0), t.lineTo(0, s.height());
    });
  }
  _getPan(e, t) {
    return (e.y - t.y) / this.height();
  }
  _changed() {
    super._changed();
    const e = this.axis;
    e.ghostLabel.setPrivate("visible", !this.get("inside")), e.ghostLabel.set("y", -1e3);
    const t = this.thumb, s = "opposite", r = "inside", n = this.chart;
    if (this.isDirty(s) || this.isDirty(r)) {
      const o = e.children;
      if (this.get(r) ? e.addTag(r) : e.removeTag(r), n) {
        if (this.get(s)) {
          const l = n.rightAxesContainer.children;
          l.indexOf(e) == -1 && l.moveValue(e, 0), e.addTag(s), o.moveValue(this, 0);
        } else {
          const l = n.leftAxesContainer.children;
          l.indexOf(e) == -1 && l.moveValue(e), e.removeTag(s), o.moveValue(this);
        }
        e.ghostLabel._applyThemes(), this.labels.each((l) => {
          l._applyThemes();
        }), this.root._markDirtyRedraw();
      }
      e.markDirtySize();
    }
    var a = e.labelsContainer.width();
    n && (this.get(s) ? t.set("centerX", 0) : t.set("centerX", a)), t.setPrivate("width", a);
  }
  /**
   * @ignore
   */
  processAxis() {
    super.processAxis();
    const e = this.axis;
    e.get("height") == null && e.set("height", R);
    const t = this._root.horizontalLayout;
    e.set("layout", t), e.labelsContainer.set("height", R), e.axisHeader.set("layout", t);
  }
  _updatePositions() {
    const e = this.axis;
    e.gridContainer.set("y", e.y() - we(e.get("centerY", 0), e.height())), e.bulletsContainer.set("x", this.x());
    const t = e.chart;
    if (t) {
      const s = t.plotContainer, r = e.axisHeader;
      let n = e.get("marginTop", 0);
      r.children.length > 0 ? (n = e.axisHeader.height(), e.set("marginTop", n + 1)) : r.set("height", n), r.setAll({ y: e.y() - n, x: -1, width: s.width() + 2 });
    }
  }
  /**
   * @ignore
   */
  axisLength() {
    return this.axis.innerHeight();
  }
  /**
   * Converts axis relative position to actual coordinate in pixels.
   *
   * @param   position  Position
   * @return            Point
   */
  positionToPoint(e) {
    return { x: 0, y: this.positionToCoordinate(e) };
  }
  /**
   * @ignore
   */
  updateLabel(e, t, s, r) {
    if (e) {
      S(t) || (t = 0);
      let n = 0.5;
      S(r) && r > 1 ? n = e.get("multiLocation", n) : n = e.get("location", n);
      const a = this.get("opposite"), o = e.get("inside", this.get("inside", !1));
      a ? (e.set("x", 0), o ? e.set("position", "absolute") : e.set("position", "relative")) : o ? (e.set("x", 0), e.set("position", "absolute")) : (e.set("x", void 0), e.set("position", "relative")), S(s) && s != t && (t = t + (s - t) * n), e.set("y", this.positionToCoordinate(t)), this.toggleVisibility(e, t, e.get("minPosition", 0), e.get("maxPosition", 1));
    }
  }
  /**
   * @ignore
   */
  updateGrid(e, t, s) {
    if (e) {
      S(t) || (t = 0);
      let r = e.get("location", 0.5);
      S(s) && s != t && (t = t + (s - t) * r), e.set("y", this.positionToCoordinate(t)), this.toggleVisibility(e, t, 0, 1);
    }
  }
  /**
   * @ignore
   */
  updateTick(e, t, s, r) {
    if (e) {
      S(t) || (t = 0);
      let n = 0.5;
      S(r) && r > 1 ? n = e.get("multiLocation", n) : n = e.get("location", n), S(s) && s != t && (t = t + (s - t) * n), e.set("y", this.positionToCoordinate(t));
      let a = e.get("length", 0);
      const o = e.get("inside", this.get("inside", !1));
      this.get("opposite") ? (e.set("x", 0), o && (a *= -1)) : o || (a *= -1), e.set("draw", (l) => {
        l.moveTo(0, 0), l.lineTo(a, 0);
      }), this.toggleVisibility(e, t, e.get("minPosition", 0), e.get("maxPosition", 1));
    }
  }
  /**
   * @ignore
   */
  updateBullet(e, t, s) {
    if (e) {
      const r = e.get("sprite");
      if (r) {
        S(t) || (t = 0);
        let n = e.get("location", 0.5);
        S(s) && s != t && (t = t + (s - t) * n);
        let a = this.axis.roundAxisPosition(t, n), o = this.axis._bullets[a], l = 1;
        if (this.get("opposite") && (l = -1), e.get("stacked"))
          if (o) {
            let u = o.get("sprite");
            u && r.set("x", u.x() + u.width() * l);
          } else
            r.set("x", 0);
        this.axis._bullets[a] = e, r.set("y", this.positionToCoordinate(t)), this.toggleVisibility(r, t, 0, 1);
      }
    }
  }
  /**
   * @ignore
   */
  updateFill(e, t, s) {
    if (e) {
      S(t) || (t = 0), S(s) || (s = 1);
      let r = this.positionToCoordinate(t), n = this.positionToCoordinate(s);
      this.fillDrawMethod(e, r, n);
    }
  }
  fillDrawMethod(e, t, s) {
    e.set("draw", (r) => {
      const n = this.axis.gridContainer.width(), a = this.height();
      s < t && ([s, t] = [t, s]), !(t > a || s < 0) && (r.moveTo(0, t), r.lineTo(n, t), r.lineTo(n, s), r.lineTo(0, s), r.lineTo(0, t));
    });
  }
  /**
   * Converts relative position (0-1) on axis to a pixel coordinate.
   *
   * @param position  Position (0-1)
   * @return Coordinate (px)
   */
  positionToCoordinate(e) {
    return this._inversed ? (e - this._start) * this._axisLength : (this._end - e) * this._axisLength;
  }
  /**
   * @ignore
   */
  positionTooltip(e, t) {
    this._positionTooltip(e, { x: 0, y: this.positionToCoordinate(t) });
  }
  /**
   * @ignore
   */
  updateTooltipBounds(e) {
    const t = this.get("inside"), s = 1e5;
    let r = this._display.toGlobal({ x: 0, y: 0 }), n = r.y, a = 0, o = this.axisLength(), l = s, u = "right";
    this.get("opposite") ? t ? (u = "right", a = r.x - s, l = s) : (u = "left", a = r.x, l = s) : t ? (u = "left", a = r.x, l = s) : (u = "right", a = r.x - s, l = s);
    const h = { left: a, right: a + l, top: n, bottom: n + o }, c = e.get("bounds");
    Su(h, c) || (e.set("bounds", h), e.set("pointerOrientation", u));
  }
  _updateLC() {
    const e = this.axis, t = e.parent;
    if (t) {
      const s = t.innerHeight();
      this._lc = this.axisLength() / s, this._ls = e.y() / s;
    }
  }
  /**
   * @ignore
   */
  toAxisPosition(e) {
    const t = this._start || 0, s = this._end || 1;
    return e -= this._ls, e = e * (s - t) / this._lc, this.get("inversed") ? e = t + e : e = s - e, e;
  }
  /**
   * @ignore
   */
  fixPosition(e) {
    return this.get("inversed") ? e : 1 - e;
  }
}
Object.defineProperty(Oi, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "AxisRendererY"
});
Object.defineProperty(Oi, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Wi.classNames.concat([Oi.className])
});
class Ui extends it {
  _beforeChanged() {
    super._beforeChanged(), (this.isDirty("lowX0") || this.isDirty("lowY0") || this.isDirty("lowX1") || this.isDirty("lowY1") || this.isDirty("highX0") || this.isDirty("highX1") || this.isDirty("highY0") || this.isDirty("highY1")) && (this._clear = !0);
  }
  _draw() {
    super._draw();
    const e = this._display;
    e.moveTo(this.get("lowX0", 0), this.get("lowY0", 0)), e.lineTo(this.get("lowX1", 0), this.get("lowY1", 0)), e.moveTo(this.get("highX0", 0), this.get("highY0", 0)), e.lineTo(this.get("highX1", 0), this.get("highY1", 0));
  }
}
Object.defineProperty(Ui, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Candlestick"
});
Object.defineProperty(Ui, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: it.classNames.concat([Ui.className])
});
class Gi extends zi {
  constructor() {
    super(...arguments), Object.defineProperty(this, "columns", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new Ae(ge.new({}), () => it._new(this._root, {
        position: "absolute",
        themeTags: se(this.columns.template.get("themeTags", []), ["series", "column"])
      }, [this.columns.template]))
    });
  }
  /**
   * @ignore
   */
  makeColumn(e, t) {
    const s = this.mainContainer.children.push(t.make());
    return s._setDataItem(e), t.push(s), s;
  }
  _processAxisRange(e) {
    super._processAxisRange(e), e.columns = new Ae(ge.new({}), () => it._new(this._root, {
      position: "absolute",
      themeTags: se(e.columns.template.get("themeTags", []), ["series", "column"])
    }, [this.columns.template, e.columns.template]));
  }
}
Object.defineProperty(Gi, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "ColumnSeries"
});
Object.defineProperty(Gi, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: zi.classNames.concat([Gi.className])
});
class Zi extends Gi {
  constructor() {
    super(...arguments), Object.defineProperty(this, "columns", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new Ae(ge.new({
        themeTags: ["autocolor"]
      }), () => Ui._new(this._root, {
        themeTags: se(this.columns.template.get("themeTags", []), ["candlestick", "series", "column"])
      }, [this.columns.template]))
    });
  }
  /**
   * @ignore
   */
  makeColumn(e, t) {
    const s = this.mainContainer.children.push(t.make());
    return s._setDataItem(e), t.push(s), s;
  }
  _updateGraphics(e, t) {
    super._updateGraphics(e, t);
    const s = this.getRaw("xAxis"), r = this.getRaw("yAxis"), n = this.getRaw("baseAxis");
    let a = this.get("vcy", 1), o = this.get("vcx", 1), l, u, h, c, d, f, g, p, m = this.get("locationX", e.get("locationX", 0.5)), _ = this.get("locationY", e.get("locationY", 0.5)), v = this.get("openLocationX", e.get("openLocationX", m)), b = this.get("openLocationY", e.get("openLocationY", _)), y;
    if (r === n) {
      let w = s.getDataItemPositionX(e, this._xOpenField, 1, o), D = s.getDataItemPositionX(e, this._xField, 1, o);
      u = s.getDataItemPositionX(e, this._xLowField, 1, o), f = s.getDataItemPositionX(e, this._xHighField, 1, o), d = Math.max(w, D), l = Math.min(w, D);
      let A = this._aLocationY0 + b - 0.5, T = this._aLocationY1 + _ - 0.5;
      h = r.getDataItemPositionY(e, this._yField, A + (T - A) / 2, a), c = h, g = h, p = h, y = "horizontal";
    } else {
      let w = r.getDataItemPositionY(e, this._yOpenField, 1, a), D = r.getDataItemPositionY(e, this._yField, 1, a);
      c = r.getDataItemPositionY(e, this._yLowField, 1, a), p = r.getDataItemPositionY(e, this._yHighField, 1, a), g = Math.max(w, D), h = Math.min(w, D);
      let A = this._aLocationX0 + v - 0.5, T = this._aLocationX1 + m - 0.5;
      l = s.getDataItemPositionX(e, this._xField, A + (T - A) / 2, o), u = l, d = l, f = l, y = "vertical";
    }
    this._updateCandleGraphics(e, l, u, h, c, d, f, g, p, y);
  }
  _updateCandleGraphics(e, t, s, r, n, a, o, l, u, h) {
    let c = e.get("graphics");
    if (c) {
      let d = this.getPoint(t, r), f = this.getPoint(s, n), g = this.getPoint(a, l), p = this.getPoint(o, u), m = c.x(), _ = c.y();
      c.set("lowX0", d.x - m), c.set("lowY0", d.y - _), c.set("lowX1", f.x - m), c.set("lowY1", f.y - _), c.set("highX0", g.x - m), c.set("highY0", g.y - _), c.set("highX1", p.x - m), c.set("highY1", p.y - _), c.set("orientation", h);
      let v = e.get("rangeGraphics");
      v && x(v, (b) => {
        b.set("lowX0", d.x - m), b.set("lowY0", d.y - _), b.set("lowX1", f.x - m), b.set("lowY1", f.y - _), b.set("highX0", g.x - m), b.set("highY0", g.y - _), b.set("highX1", p.x - m), b.set("highY1", p.y - _), b.set("orientation", h);
      });
    }
  }
  _processAxisRange(e) {
    super._processAxisRange(e), e.columns = new Ae(ge.new({}), () => Ui._new(this._root, {
      themeTags: se(e.columns.template.get("themeTags", []), ["candlestick", "series", "column"])
    }, [this.columns.template, e.columns.template]));
  }
}
Object.defineProperty(Zi, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "CandlestickSeries"
});
Object.defineProperty(Zi, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Gi.classNames.concat([Zi.className])
});
class rr extends Ui {
  _draw() {
    const e = this._display;
    e.moveTo(this.get("lowX1", 0), this.get("lowY1", 0)), e.lineTo(this.get("highX1", 0), this.get("highY1", 0));
    let t = this.width(), s = this.height();
    if (this.get("orientation") == "vertical") {
      let r = s, n = 0;
      e.moveTo(0, r), e.lineTo(t / 2, r), e.moveTo(t / 2, n), e.lineTo(t, n);
    } else {
      let r = 0, n = t;
      e.moveTo(r, 0), e.lineTo(r, s / 2), e.moveTo(n, s / 2), e.lineTo(n, s);
    }
  }
}
Object.defineProperty(rr, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "OHLC"
});
Object.defineProperty(rr, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Ui.classNames.concat([rr.className])
});
class ka extends Zi {
  constructor() {
    super(...arguments), Object.defineProperty(this, "columns", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new Ae(ge.new({
        themeTags: ["autocolor"]
      }), () => rr._new(this._root, {
        themeTags: se(this.columns.template.get("themeTags", []), ["ohlc", "series", "column"])
      }, [this.columns.template]))
    });
  }
  /**
   * @ignore
   */
  makeColumn(e, t) {
    const s = this.mainContainer.children.push(t.make());
    return s._setDataItem(e), t.push(s), s;
  }
  _processAxisRange(e) {
    super._processAxisRange(e), e.columns = new Ae(ge.new({}), () => rr._new(this._root, {
      themeTags: se(e.columns.template.get("themeTags", []), ["ohlc", "series", "column"])
    }, [this.columns.template, e.columns.template]));
  }
}
Object.defineProperty(ka, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "OHLCSeries"
});
Object.defineProperty(ka, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Zi.classNames.concat([ka.className])
});
class lt extends Hi {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_endIndex", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_strokeGenerator", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Ud()
    }), Object.defineProperty(this, "_fillGenerator", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Zw()
    }), Object.defineProperty(this, "_legendStroke", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_legendFill", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "strokes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new Ae(ge.new({}), () => he._new(this._root, {
        themeTags: se(this.strokes.template.get("themeTags", []), ["line", "series", "stroke"])
      }, [this.strokes.template]))
    }), Object.defineProperty(this, "fills", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new Ae(ge.new({}), () => he._new(this._root, {
        themeTags: se(this.strokes.template.get("themeTags", []), ["line", "series", "fill"])
      }, [this.fills.template]))
    }), Object.defineProperty(this, "_fillTemplate", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_strokeTemplate", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_previousPoint", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: [0, 0, 0, 0]
    }), Object.defineProperty(this, "_dindex", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_sindex", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    });
  }
  _afterNew() {
    this._fillGenerator.y0(function(e) {
      return e[3];
    }), this._fillGenerator.x0(function(e) {
      return e[2];
    }), this._fillGenerator.y1(function(e) {
      return e[1];
    }), this._fillGenerator.x1(function(e) {
      return e[0];
    }), super._afterNew();
  }
  /**
   * @ignore
   */
  makeStroke(e) {
    const t = this.mainContainer.children.push(e.make());
    return e.push(t), t;
  }
  /**
   * @ignore
   */
  makeFill(e) {
    const t = this.mainContainer.children.push(e.make());
    return e.push(t), t;
  }
  _updateChildren() {
    this._strokeTemplate = void 0, this._fillTemplate = void 0;
    let e = this.get("xAxis"), t = this.get("yAxis");
    if (this.isDirty("stroke")) {
      const s = this.get("stroke");
      this.strokes.template.set("stroke", s);
      const r = this._legendStroke;
      r && r.states.lookup("default").set("stroke", s);
    }
    if (this.isDirty("fill")) {
      const s = this.get("fill");
      this.fills.template.set("fill", s);
      const r = this._legendFill;
      r && r.states.lookup("default").set("fill", s);
    }
    if (this.isDirty("curveFactory")) {
      const s = this.get("curveFactory");
      s && (this._strokeGenerator.curve(s), this._fillGenerator.curve(s));
    }
    if (e.inited && t.inited) {
      if (this._axesDirty || this._valuesDirty || this._stackDirty || this.isDirty("vcx") || this.isDirty("vcy") || this._sizeDirty || this.isDirty("connect") || this.isDirty("curveFactory")) {
        this.fills.each((h) => {
          h.setPrivate("visible", !1);
        }), this.strokes.each((h) => {
          h.setPrivate("visible", !1);
        }), this.axisRanges.each((h) => {
          let c = h.fills;
          c && c.each((f) => {
            f.setPrivate("visible", !1);
          });
          let d = h.strokes;
          d && d.each((f) => {
            f.setPrivate("visible", !1);
          });
        });
        let s = this.startIndex(), r = this.strokes.template.get("templateField"), n = this.fills.template.get("templateField"), a = !0, o = !0;
        r && (a = !1), n && (o = !1);
        for (let h = s - 1; h >= 0; h--) {
          let c = this.dataItems[h], d = !0, f = c.dataContext;
          if (r && f[r] && (a = !0), n && f[n] && (o = !0), x(this._valueFields, (g) => {
            S(c.get(g)) || (d = !1);
          }), d && a && o) {
            s = h;
            break;
          }
        }
        let l = this.dataItems.length, u = this.endIndex();
        if (u < l) {
          u++;
          for (let h = u; h < l; h++) {
            let c = this.dataItems[h], d = !0;
            if (x(this._valueFields, (f) => {
              S(c.get(f)) || (d = !1);
            }), d) {
              u = h + 1;
              break;
            }
          }
        }
        if (s > 0 && s--, this._endIndex = u, this._clearGraphics(), this._sindex = 0, this._dindex = s, this.dataItems.length == 1)
          this._startSegment(0);
        else
          for (; this._dindex < u - 1; )
            this._startSegment(this._dindex), this._sindex++;
      }
    } else
      this._skipped = !0;
    super._updateChildren();
  }
  _clearGraphics() {
    this.strokes.clear(), this.fills.clear();
  }
  _startSegment(e) {
    let t = this._endIndex, s = t;
    const r = this.get("autoGapCount"), n = this.get("connect"), a = this.makeFill(this.fills), o = this._fillTemplate, l = this.fills.template;
    o && o != l && (a.template = o), a.setPrivate("visible", !0);
    const u = this.makeStroke(this.strokes), h = this._strokeTemplate;
    h && h != this.strokes.template && (u.template = h), u.setPrivate("visible", !0);
    let c = this.get("xAxis"), d = this.get("yAxis"), f = this.get("baseAxis"), g = this.get("vcx", 1), p = this.get("vcy", 1), m = this._xField, _ = this._yField, v = this._xOpenField, b = this._yOpenField;
    const y = this.get("openValueXField"), w = this.get("openValueYField");
    y || (v = this._xField), w || (b = this._yField);
    const D = this.get("stacked"), A = c.basePosition(), T = d.basePosition();
    let j;
    f === d ? j = this._yField : j = this._xField;
    const C = [];
    let L = [];
    C.push(L);
    const E = this.strokes.template.get("templateField"), N = this.fills.template.get("templateField");
    let J = this.get("locationX", 0.5), z = this.get("locationY", 0.5), H = this.get("openLocationX", J), Y = this.get("openLocationY", z);
    const U = this.get("minDistance", 0);
    let B, ue = this.fills.template.get("visible");
    this.axisRanges.length > 0 && (ue = !0);
    let O = !1;
    (D || y || w) && (O = !0);
    const k = {
      points: L,
      segments: C,
      stacked: D,
      getOpen: O,
      basePosX: A,
      basePosY: T,
      fillVisible: ue,
      xField: m,
      yField: _,
      xOpenField: v,
      yOpenField: b,
      vcx: g,
      vcy: p,
      baseAxis: f,
      xAxis: c,
      yAxis: d,
      locationX: J,
      locationY: z,
      openLocationX: H,
      openLocationY: Y,
      minDistance: U
    };
    for (B = e; B < s; B++) {
      this._dindex = B;
      const M = this._dataItems[B];
      let $ = M.get(m), q = M.get(_);
      if ($ == null || q == null ? n || (L = [], C.push(L), k.points = L) : this._getPoints(M, k), E) {
        let W = M.dataContext[E];
        if (W)
          if (W instanceof ge || (W = ge.new(W)), this._strokeTemplate = W, B > e) {
            s = B;
            break;
          } else
            u.template = W;
      }
      if (N) {
        let W = M.dataContext[N];
        if (W)
          if (W instanceof ge || (W = ge.new(W)), this._fillTemplate = W, B > e) {
            s = B;
            break;
          } else
            a.template = W;
      }
      if (!n) {
        let W = this.dataItems[B + 1];
        W && f.shouldGap(M, W, r, j) && (L = [], C.push(L), k.points = L);
      }
    }
    a.setRaw("userData", [e, B]), u.setRaw("userData", [e, B]), B === t && this._endLine(L, C[0][0]), u && this._drawStroke(u, C), a && this._drawFill(a, C), this.axisRanges.each((M) => {
      const $ = M.container, q = M.fills, W = this.makeFill(q);
      $ && $.children.push(W), W.setPrivate("visible", !0), this._drawFill(W, C);
      const fe = M.strokes, ve = this.makeStroke(fe);
      $ && $.children.push(ve), ve.setPrivate("visible", !0), this._drawStroke(ve, C), W.setRaw("userData", [e, B]), ve.setRaw("userData", [e, B]);
    });
  }
  _getPoints(e, t) {
    let s = t.points, r = e.get("locationX", t.locationX), n = e.get("locationY", t.locationY), a = t.xAxis.getDataItemPositionX(e, t.xField, r, t.vcx), o = t.yAxis.getDataItemPositionY(e, t.yField, n, t.vcy);
    if (this._shouldInclude(a)) {
      const l = this.getPoint(a, o), u = [l.x, l.y];
      if (l.x += this._x, l.y += this._y, e.set("point", l), t.fillVisible) {
        let h = a, c = o;
        if (t.baseAxis === t.xAxis ? c = t.basePosY : t.baseAxis === t.yAxis && (h = t.basePosX), t.getOpen) {
          let f = e.get(t.xOpenField), g = e.get(t.yOpenField);
          if (f != null && g != null) {
            let p = e.get("openLocationX", t.openLocationX), m = e.get("openLocationY", t.openLocationY);
            if (t.stacked) {
              let _ = e.get("stackToItemX"), v = e.get("stackToItemY");
              _ ? (h = t.xAxis.getDataItemPositionX(_, t.xField, p, _.component.get("vcx")), $t(h) && (h = t.basePosX)) : t.yAxis === t.baseAxis ? h = t.basePosX : h = t.xAxis.getDataItemPositionX(e, t.xOpenField, p, t.vcx), v ? (c = t.yAxis.getDataItemPositionY(v, t.yField, m, v.component.get("vcy")), $t(c) && (c = t.basePosY)) : t.xAxis === t.baseAxis ? c = t.basePosY : c = t.yAxis.getDataItemPositionY(e, t.yOpenField, m, t.vcy);
            } else
              h = t.xAxis.getDataItemPositionX(e, t.xOpenField, p, t.vcx), c = t.yAxis.getDataItemPositionY(e, t.yOpenField, m, t.vcy);
          }
        }
        let d = this.getPoint(h, c);
        u[2] = d.x, u[3] = d.y;
      }
      if (t.minDistance > 0) {
        const h = u[0], c = u[1], d = u[2], f = u[3], g = this._previousPoint, p = g[0], m = g[1], _ = g[2], v = g[3];
        (Math.hypot(h - p, c - m) > t.minDistance || d && f && Math.hypot(d - _, f - v) > t.minDistance) && (s.push(u), this._previousPoint = u);
      } else
        s.push(u);
    }
  }
  _endLine(e, t) {
  }
  _drawStroke(e, t) {
    e.get("visible") && !e.get("forceHidden") && e.set("draw", (s) => {
      x(t, (r) => {
        this._strokeGenerator.context(s), this._strokeGenerator(r);
      });
    });
  }
  _drawFill(e, t) {
    e.get("visible") && !e.get("forceHidden") && e.set("draw", (s) => {
      x(t, (r) => {
        this._fillGenerator.context(s), this._fillGenerator(r);
      });
    });
  }
  _processAxisRange(e) {
    super._processAxisRange(e), e.fills = new Ae(ge.new({}), () => he._new(this._root, {
      themeTags: se(e.fills.template.get("themeTags", []), ["line", "series", "fill"])
    }, [this.fills.template, e.fills.template])), e.strokes = new Ae(ge.new({}), () => he._new(this._root, {
      themeTags: se(e.strokes.template.get("themeTags", []), ["line", "series", "stroke"])
    }, [this.strokes.template, e.strokes.template]));
  }
  /**
   * @ignore
   */
  createLegendMarker(e) {
    const t = this.get("legendDataItem");
    if (t) {
      const s = t.get("marker"), r = t.get("markerRectangle");
      r && r.setPrivate("visible", !1), s.set("background", mt.new(s._root, { fillOpacity: 0, fill: oe(0) }));
      const n = s.children.push(he._new(s._root, {
        themeTags: ["line", "series", "legend", "marker", "stroke"],
        interactive: !1
      }, [this.strokes.template]));
      this._legendStroke = n;
      const a = s.children.push(he._new(s._root, {
        themeTags: ["line", "series", "legend", "marker", "fill"]
      }, [this.fills.template]));
      this._legendFill = a;
      const o = this._root.interfaceColors.get("disabled");
      if (n.states.create("disabled", { fill: o, stroke: o }), a.states.create("disabled", { fill: o, stroke: o }), this.bullets.length > 0) {
        const l = this.bullets.getIndex(0);
        if (l) {
          const u = l(s._root, this, new Gt(this, {}, {}));
          if (u) {
            const h = u.get("sprite");
            h instanceof he && h.states.create("disabled", { fill: o, stroke: o }), h && (h.set("tooltipText", void 0), h.set("tooltipHTML", void 0), s.children.push(h), h.setAll({ x: s.width() / 2, y: s.height() / 2 }));
          }
        }
      }
    }
  }
}
Object.defineProperty(lt, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "LineSeries"
});
Object.defineProperty(lt, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Hi.classNames.concat([lt.className])
});
class rS {
  constructor(e, t) {
    Object.defineProperty(this, "_line", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_point", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_context", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_x0", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_x1", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_y0", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_y1", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_t0", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_tension", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), this._context = e, this._tension = t;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN, this._point = 0;
  }
  lineEnd() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        Do(this, this._t0, hh(this, this._t0));
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  }
  point(e, t) {
    [e, t] = [t, e];
    let s = NaN;
    if (e = +e, t = +t, !(e === this._x1 && t === this._y1)) {
      switch (this._point) {
        case 0:
          this._point = 1, this._line ? this._context.lineTo(t, e) : this._context.moveTo(t, e);
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3, Do(this, hh(this, s = uh(this, e, t)), s);
          break;
        default:
          Do(this, this._t0, s = uh(this, e, t));
          break;
      }
      this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t, this._t0 = s;
    }
  }
}
function pl(i) {
  function e(t) {
    return new rS(t, i);
  }
  return e.tension = function(t) {
    return pl(+t);
  }, e;
}
function lh(i) {
  return i < 0 ? -1 : 1;
}
function uh(i, e, t) {
  let s = i._x1 - i._x0, r = e - i._x1, n = (i._y1 - i._y0) / (s || r < 0 && -0), a = (t - i._y1) / (r || s < 0 && -0), o = (n * r + a * s) / (s + r);
  return (lh(n) + lh(a)) * Math.min(Math.abs(n), Math.abs(a), 0.5 * Math.abs(o)) || 0;
}
function hh(i, e) {
  let t = i._x1 - i._x0;
  return t ? (3 * (i._y1 - i._y0) / t - e) / 2 : e;
}
function Do(i, e, t) {
  let s = i._x0, r = i._y0, n = i._x1, a = i._y1, o = (n - s) / 1.5 * (1 - i._tension);
  i._context.bezierCurveTo(r + o * e, s + o, a - o * t, n - o, a, n);
}
class Ca extends lt {
  _afterNew() {
    this._setDefault("curveFactory", pl(this.get("tension", 0.5))), super._afterNew();
  }
  _updateChildren() {
    this.isDirty("tension") && (this.set("curveFactory", pl(this.get("tension", 0.5))), this._valuesDirty = !0), super._updateChildren();
  }
}
Object.defineProperty(Ca, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "SmoothedYLineSeries"
});
Object.defineProperty(Ca, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: lt.classNames.concat([Ca.className])
});
class nS {
  constructor(e, t) {
    Object.defineProperty(this, "_line", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_point", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_context", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_x0", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_x1", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_y0", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_y1", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_t0", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_tension", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), this._context = e, this._tension = t;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN, this._point = 0;
  }
  lineEnd() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        Po(this, this._t0, ph(this, this._t0));
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  }
  point(e, t) {
    let s = NaN;
    if (e = +e, t = +t, !(e === this._x1 && t === this._y1)) {
      switch (this._point) {
        case 0:
          this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3, Po(this, ph(this, s = fh(this, e, t)), s);
          break;
        default:
          Po(this, this._t0, s = fh(this, e, t));
          break;
      }
      this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t, this._t0 = s;
    }
  }
}
function ch(i) {
  function e(t) {
    return new nS(t, i);
  }
  return e;
}
function dh(i) {
  return i < 0 ? -1 : 1;
}
function fh(i, e, t) {
  let s = i._x1 - i._x0, r = e - i._x1, n = (i._y1 - i._y0) / (s || r < 0 && -0), a = (t - i._y1) / (r || s < 0 && -0), o = (n * r + a * s) / (s + r);
  return (dh(n) + dh(a)) * Math.min(Math.abs(n), Math.abs(a), 0.5 * Math.abs(o)) || 0;
}
function ph(i, e) {
  let t = i._x1 - i._x0;
  return t ? (3 * (i._y1 - i._y0) / t - e) / 2 : e;
}
function Po(i, e, t) {
  let s = i._x0, r = i._y0, n = i._x1, a = i._y1, o = (n - s) / 1.5 * (1 - i._tension);
  i._context.bezierCurveTo(s + o, r + o * e, n - o, a - o * t, n, a);
}
class qr extends lt {
  _afterNew() {
    this._setDefault("curveFactory", ch(this.get("tension", 0.5))), super._afterNew();
  }
  _updateChildren() {
    this.isDirty("tension") && (this.set("curveFactory", ch(this.get("tension", 0.5))), this._valuesDirty = !0), super._updateChildren();
  }
}
Object.defineProperty(qr, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "SmoothedXLineSeries"
});
Object.defineProperty(qr, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: lt.classNames.concat([qr.className])
});
class Ma extends lt {
  _afterNew() {
    this._setDefault("curveFactory", ah.tension(this.get("tension", 0.5))), super._afterNew();
  }
  _updateChildren() {
    this.isDirty("tension") && (this.set("curveFactory", ah.tension(this.get("tension", 0.5))), this._valuesDirty = !0), super._updateChildren();
  }
}
Object.defineProperty(Ma, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "SmoothedXYLineSeries"
});
Object.defineProperty(Ma, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: lt.classNames.concat([Ma.className])
});
class nr extends lt {
  _afterNew() {
    this._setDefault("curveFactory", Kw), super._afterNew();
  }
  _getPoints(e, t) {
    let s = t.points, r = this.get("stepWidth", R).value / 2, n = e.get("locationX", t.locationX), a = e.get("locationY", t.locationY), o = n, l = a;
    t.baseAxis === t.xAxis ? (n -= r, o += r) : t.baseAxis === t.yAxis && (a -= r, l += r);
    let u = t.xAxis.getDataItemPositionX(e, t.xField, n, t.vcx), h = t.yAxis.getDataItemPositionY(e, t.yField, a, t.vcy), c = t.xAxis.getDataItemPositionX(e, t.xField, o, t.vcx), d = t.yAxis.getDataItemPositionY(e, t.yField, l, t.vcy);
    if (this._shouldInclude(u)) {
      const f = this.getPoint(u, h), g = [f.x, f.y], p = this.getPoint(c, d), m = [p.x, p.y];
      if (t.fillVisible) {
        let _ = u, v = h, b = c, y = d;
        if (t.baseAxis === t.xAxis ? (v = t.basePosY, y = t.basePosY) : t.baseAxis === t.yAxis && (_ = t.basePosX, b = t.basePosX), t.getOpen) {
          let A = e.get(t.xOpenField), T = e.get(t.yOpenField);
          if (A != null && T != null)
            if (n = e.get("openLocationX", t.openLocationX), a = e.get("openLocationY", t.openLocationY), o = n, l = a, t.baseAxis === t.xAxis ? (n -= r, o += r) : t.baseAxis === t.yAxis && (a -= r, l += r), t.stacked) {
              let j = e.get("stackToItemX"), C = e.get("stackToItemY");
              j ? (_ = t.xAxis.getDataItemPositionX(j, t.xField, n, j.component.get("vcx")), b = t.xAxis.getDataItemPositionX(j, t.xField, o, j.component.get("vcx"))) : t.yAxis === t.baseAxis ? (_ = t.basePosX, b = t.basePosX) : t.baseAxis === t.yAxis && (_ = t.xAxis.getDataItemPositionX(e, t.xOpenField, n, t.vcx), b = t.xAxis.getDataItemPositionX(e, t.xOpenField, o, t.vcx)), C ? (v = t.yAxis.getDataItemPositionY(C, t.yField, a, C.component.get("vcy")), y = t.yAxis.getDataItemPositionY(C, t.yField, l, C.component.get("vcy"))) : t.xAxis === t.baseAxis ? (v = t.basePosY, y = t.basePosY) : t.baseAxis === t.yAxis && (v = t.yAxis.getDataItemPositionY(e, t.yOpenField, a, t.vcy), y = t.yAxis.getDataItemPositionY(e, t.yOpenField, l, t.vcy));
            } else
              _ = t.xAxis.getDataItemPositionX(e, t.xOpenField, n, t.vcx), v = t.yAxis.getDataItemPositionY(e, t.yOpenField, a, t.vcy), b = t.xAxis.getDataItemPositionX(e, t.xOpenField, o, t.vcx), y = t.yAxis.getDataItemPositionY(e, t.yOpenField, l, t.vcy);
        }
        let w = this.getPoint(_, v), D = this.getPoint(b, y);
        g[2] = w.x, g[3] = w.y, m[2] = D.x, m[3] = D.y;
      }
      s.push(g), s.push(m), e.set("point", { x: g[0] + (m[0] - g[0]) / 2, y: g[1] + (m[1] - g[1]) / 2 });
    }
    this.get("noRisers") && (t.points = [], t.segments.push(s));
  }
}
Object.defineProperty(nr, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "StepLineSeries"
});
Object.defineProperty(nr, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: lt.classNames.concat([nr.className])
});
const ks = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Axis: Xi,
  AxisBullet: Pa,
  AxisLabel: Qr,
  AxisLabelRadial: Ta,
  AxisRenderer: Wi,
  AxisRendererX: sr,
  AxisRendererY: Oi,
  AxisTick: Jr,
  BaseColumnSeries: zi,
  Candlestick: Ui,
  CandlestickSeries: Zi,
  CategoryAxis: vi,
  CategoryDateAxis: wa,
  ColumnSeries: Gi,
  DateAxis: ir,
  DefaultTheme: Qd,
  DurationAxis: Da,
  GaplessDateAxis: Sa,
  Grid: Ss,
  LineSeries: lt,
  OHLC: rr,
  OHLCSeries: ka,
  SmoothedXLineSeries: qr,
  SmoothedXYLineSeries: Ma,
  SmoothedYLineSeries: Ca,
  StepLineSeries: nr,
  ValueAxis: Vi,
  XYChart: tr,
  XYChartScrollbar: Zr,
  XYCursor: Kr,
  XYSeries: Hi
}, Symbol.toStringTag, { value: "Module" }));
class Jd extends dr {
  setupDefaultRules() {
    super.setupDefaultRules(), this.rule("Component").setAll({
      interpolationDuration: 600
    }), this.rule("Hierarchy").set("animationDuration", 600), this.rule("Scrollbar").set("animationDuration", 600), this.rule("Tooltip").set("animationDuration", 300), this.rule("MapChart").set("animationDuration", 1e3), this.rule("MapChart").set("wheelDuration", 300), this.rule("Entity").setAll({
      stateAnimationDuration: 600
    }), this.rule("Sprite").states.create("default", { stateAnimationDuration: 600 }), this.rule("Tooltip", ["axis"]).setAll({
      animationDuration: 200
    }), this.rule("WordCloud").set("animationDuration", 500);
  }
}
var aS = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function oS(i) {
  return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i;
}
function lS(i) {
  if (i.__esModule)
    return i;
  var e = i.default;
  if (typeof e == "function") {
    var t = function s() {
      if (this instanceof s) {
        var r = [null];
        r.push.apply(r, arguments);
        var n = Function.bind.apply(e, r);
        return new n();
      }
      return e.apply(this, arguments);
    };
    t.prototype = e.prototype;
  } else
    t = {};
  return Object.defineProperty(t, "__esModule", { value: !0 }), Object.keys(i).forEach(function(s) {
    var r = Object.getOwnPropertyDescriptor(i, s);
    Object.defineProperty(t, s, r.get ? r : {
      enumerable: !0,
      get: function() {
        return i[s];
      }
    });
  }), t;
}
var uS = function(e) {
  return hS(e) && !cS(e);
};
function hS(i) {
  return !!i && typeof i == "object";
}
function cS(i) {
  var e = Object.prototype.toString.call(i);
  return e === "[object RegExp]" || e === "[object Date]" || pS(i);
}
var dS = typeof Symbol == "function" && Symbol.for, fS = dS ? Symbol.for("react.element") : 60103;
function pS(i) {
  return i.$$typeof === fS;
}
function gS(i) {
  return Array.isArray(i) ? [] : {};
}
function en(i, e) {
  return e.clone !== !1 && e.isMergeableObject(i) ? ar(gS(i), i, e) : i;
}
function mS(i, e, t) {
  return i.concat(e).map(function(s) {
    return en(s, t);
  });
}
function _S(i, e) {
  if (!e.customMerge)
    return ar;
  var t = e.customMerge(i);
  return typeof t == "function" ? t : ar;
}
function bS(i) {
  return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(i).filter(function(e) {
    return Object.propertyIsEnumerable.call(i, e);
  }) : [];
}
function gh(i) {
  return Object.keys(i).concat(bS(i));
}
function qd(i, e) {
  try {
    return e in i;
  } catch {
    return !1;
  }
}
function yS(i, e) {
  return qd(i, e) && !(Object.hasOwnProperty.call(i, e) && Object.propertyIsEnumerable.call(i, e));
}
function vS(i, e, t) {
  var s = {};
  return t.isMergeableObject(i) && gh(i).forEach(function(r) {
    s[r] = en(i[r], t);
  }), gh(e).forEach(function(r) {
    yS(i, r) || (qd(i, r) && t.isMergeableObject(e[r]) ? s[r] = _S(r, t)(i[r], e[r], t) : s[r] = en(e[r], t));
  }), s;
}
function ar(i, e, t) {
  t = t || {}, t.arrayMerge = t.arrayMerge || mS, t.isMergeableObject = t.isMergeableObject || uS, t.cloneUnlessOtherwiseSpecified = en;
  var s = Array.isArray(e), r = Array.isArray(i), n = s === r;
  return n ? s ? t.arrayMerge(i, e, t) : vS(i, e, t) : en(e, t);
}
ar.all = function(e, t) {
  if (!Array.isArray(e))
    throw new Error("first argument should be an array");
  return e.reduce(function(s, r) {
    return ar(s, r, t);
  }, {});
};
var xS = ar, wS = xS;
function Fe(i, e) {
  const t = [];
  return i && t.push(i), e && t.push(e), wS.all(t);
}
var SS = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    staticStyle: {
      position: "relative",
      padding: "0px 20px"
    },
    style: i.styleProps
  }, [i.data.length === 0 ? t("div", {
    staticClass: "no-data-chart",
    style: i.styleProps
  }, [i._v(" No Data Available ")]) : i._e(), i.data.length > 0 ? t("div", {
    ref: i.chartSetComputed.refProps,
    style: i.styleProps,
    attrs: {
      id: i.chartSetComputed.id
    }
  }) : i._e(), i.previousButton.visible ? t("icon-button", {
    attrs: {
      "button-type": "arrow-backward-skinny",
      "click-handler": i.previousButton.handler,
      disabled: i.previousButton.disabled,
      "style-props": "position: absolute; left: 0; top: 50%"
    }
  }) : i._e(), i.nextButton.visible ? t("icon-button", {
    attrs: {
      "button-type": "arrow-forward-skinny",
      "click-handler": i.nextButton.handler,
      disabled: i.nextButton.disabled,
      "style-props": "position: absolute; right: 0; top: 50%;"
    }
  }) : i._e()], 1);
}, DS = [];
const PS = {
  components: {
    "icon-button": gu
  },
  props: {
    // new
    setCustom: Function,
    setCustomLegend: Function,
    // ====
    dataStartPoint: {
      type: String,
      default: ""
    },
    dataEndPoint: {
      type: String,
      default: ""
    },
    setDataStartPoint: Function,
    setDataEndPoint: Function,
    yAxisRange: Array,
    previousButton: {
      type: Object,
      default: () => ({ visible: !1, disabled: !1 })
    },
    nextButton: {
      type: Object,
      default: () => ({ visible: !1, disabled: !1 })
    },
    // =============================== requirement value =========================
    // data, category, axisDataBinder, (lineDataBinder || bubbleDataBinder || barDataBinder || candlestickDataBinder, timeScale, selectionMin, selectionMax)
    data: {
      type: Array,
      default: () => []
    },
    category: String,
    axisDataBinder: Object,
    lineDataBinder: Array,
    stepLineDataBinder: Array,
    bubbleDataBinder: Array,
    barDataBinder: Array,
    candlestickDataBinder: Array,
    timeScale: String,
    selectionMin: String,
    selectionMax: String,
    tooltipHTML: {
      type: String,
      default: "<div>{name} in {categoryX}: {valueY}</div>"
    },
    // ============================== adpaters =================================
    xAxisGridStrokeOpacityAdapter: Function,
    // x축 grid 의 선을 custom
    xAxisLabelTextAdapter: Function,
    // x축 label을 custom
    xAxisTooltipLabelTextAdapter: Function,
    // x축 tooltip의 text를 custom
    seriesTooltipLabelHtmlAdapter: Function,
    // 시리즈 툴팁을 custom
    xScrollbarXAxisLabelTextAdapter: Function,
    // x스크롤바의 label을 custom
    seriesTooltipForceHiddenAdapter: Function,
    // 시리즈 툴팁의 숨김 여부를 custom
    // detailScrollbarXAxisLabelTextAdapter: Function,
    // ============================== adpaters end =================================
    // ============================== etc function ==============================
    getWheelCursorPositionX: Function,
    chartItemClickHandler: Function,
    setSelectionMin: Function,
    setSelectionMax: Function,
    zoomHandler: Function,
    panHandler: Function,
    // ============================== etc function end ==============================
    //  ============================== optional settings ==========================
    styleProps: {
      type: String,
      default: "height: 400px; width: 100%; min-width: 800px;"
    },
    chartSet: Object,
    legendSet: Object,
    candlestickSet: Object,
    lineSet: Object,
    stepLineSet: Object,
    bubbleSet: Object,
    barSet: Object,
    xScrollbarSet: Object
    //  ============================== optional settings end ==========================
  },
  data() {
    return {
      xySeries: "",
      xScrollbarOverallSeriesItem: "",
      chartTitle: "",
      xAxisExtraLabel: "",
      logTest: !1,
      range: "",
      rangeDataItem: "",
      root: "",
      chart: "",
      xAxis: "",
      yAxisList: [],
      lineSeriesList: [],
      lineSeries: "",
      stepLineSeriesList: [],
      stepLineSeries: "",
      columnSeriesList: [],
      columnSeries: "",
      bubbleSeriesList: [],
      bubbleSeries: "",
      candlestickSeriesList: [],
      candlestickSeries: "",
      xScrollbarSeriesList: [],
      xScrollbarSeries: "",
      xScrollbarOverallSeries: "",
      xScrollbarColumnSeriesList: [],
      xScrollbarColumnSeries: "",
      xScrollbarLineSeriesList: [],
      xScrollbarLineSeries: "",
      xScrollbarStepLineSeriesList: [],
      xScrollbarStepLineSeries: "",
      xScrollbarBubbleSeriesList: [],
      xScrollbarBubbleSeries: "",
      xScrollbarCandlestickSeriesList: [],
      xScrollbarCandlestickSeries: "",
      legend: "",
      legendSettings: "",
      xScrollbar: "",
      xScrollbarXAxis: "",
      xScrollbarYAxis: "",
      // settings
      // chartSetComputed.cursor.isAvailable
      chartSetData: {
        cursor: {
          isAvailable: !1
        },
        refProps: "defaultXYChart",
        id: "defaultXYChart",
        chartType: "default",
        titleLabel: {
          text: "",
          fontSize: 12,
          fontWeight: "normal",
          textAlign: "center",
          x: 5,
          centerX: 0,
          paddingTop: 0,
          paddingBottom: 0,
          color: "#555"
        },
        isZoomOutButton: !1,
        isYAxesPlotContainerVisible: !0,
        isBottomAxesContainerVisible: !0,
        panX: !1,
        panY: !1,
        wheelX: "",
        // 'zoomX', 'zoomY', 'zoomXY', 'panX', 'panY', 'panXY', 'none'
        wheelY: ""
        // 'zoomX', 'zoomY', 'zoomXY', 'panX', 'panY', 'panXY', 'none'
      },
      axisDataBinderData: {
        xAxis: {
          name: "",
          type: "CategoryAxis"
        },
        yAxis: {
          name: "",
          type: "ValueAxis",
          isLeft: !0
        },
        ySecondAxis: {
          name: "",
          type: "ValueAxis",
          isLeft: !1,
          isAvailable: !1
        }
      },
      legendSetData: {
        isVisible: !0,
        layout: "gridLayout",
        x: 50,
        centerX: 50,
        y: 100,
        centerY: 100,
        maxColumns: void 0
      },
      candlestickSetData: {
        riseColor: "#ff0000",
        dropColor: "#0000ff"
      },
      lineSetData: {
        isConnected: !0,
        isLineVisible: !1,
        isFillVisible: !1,
        isBullet: !0,
        strokeWidth: 2,
        fillOpacity: 0.1,
        bullet: { strokeWidth: 2, radius: 3 },
        colorList: [
          "#f08080",
          "#fa8072",
          "#e9967a",
          "#ff7f50",
          "#ff6347",
          "#f4a460",
          "#ffa07a"
        ]
      },
      stepLineSetData: {
        isLineVisible: !1,
        strokeWidth: 1,
        colorList: [
          "#f08080",
          "#fa8072",
          "#e9967a",
          "#ff7f50",
          "#ff6347",
          "#f4a460",
          "#ffa07a"
        ],
        isFillVisible: !0,
        fillOpacity: 0.5,
        isBullet: !1
        // bullet: { strokeWidth: 2, radius: 3 },
      },
      bubbleSetData: {
        strokeWidth: 2,
        bullet: { strokeWidth: 2, radius: 3 },
        colorList: [
          "#f08080",
          "#fa8072",
          "#e9967a",
          "#ff7f50",
          "#ff6347",
          "#f4a460",
          "#ffa07a"
        ]
      },
      barSetData: {
        isStacked: !1,
        isClustered: !1,
        width: 15,
        strokeWidth: 1.5,
        fillOpacity: 0.3,
        cornerRadius: { topLeft: 0, topRight: 0 },
        colorList: [
          "#BCE2C7",
          "#4EBCD5",
          "#1A2281",
          "#4169e1",
          "#1e90ff",
          "#0000cd",
          "#000080"
        ]
      },
      xScrollbarSetData: {
        isVisible: !1,
        isDown: !1,
        gripScale: 0.9,
        isStartGrip: !1,
        isEndGrip: !1,
        startPosition: 0,
        endPosition: 1,
        thumb: { fill: "#550000", fillOpacity: 0.05 },
        detail: {
          isVisible: !1,
          height: 50,
          mainValue: { key: "", displayName: "" },
          line: { color: "#fb9f57", strokeWidth: 2, fillOpacity: 0.2 },
          background: {
            fill: "#000000",
            fillOpacity: 0.05,
            cornerRadius: {
              topLeft: 0,
              topRight: 10,
              bottomLeft: 10,
              bottomRight: 10
            }
          }
        }
      }
    };
  },
  updated() {
    this.logTest && (this.logTest && console.log("xy updated"), this.logTest && console.log("previousButton: ", this.previousButton), this.logTest && console.log("nextButton: ", this.nextButton));
  },
  mounted() {
    this.logTest && (console.log("xy mounted"), console.log("previousButton: ", this.previousButton), console.log("nextButton: ", this.nextButton), console.log("data: ", this.data), console.log("category: ", this.category), console.log("axisDataBinder: ", this.axisDataBinder), console.log("lineDataBinder: ", this.lineDataBinder), console.log("bubbleDataBinder: ", this.bubbleDataBinder), console.log("barDataBinder: ", this.barDataBinder), console.log("candlestickDataBinder: ", this.candlestickDataBinder), console.log("timeScale: ", this.timeScale), console.log("selectionMin: ", this.selectionMin), console.log("selectionMax: ", this.selectionMax), console.log("tooltipHTML: ", this.tooltipHTML), console.log(
      "xAxisGridStrokeOpacityAdapter: ",
      this.xAxisGridStrokeOpacityAdapter
    ), console.log("xAxisLabelTextAdapter: ", this.xAxisLabelTextAdapter), console.log(
      "xAxisTooltipLabelTextAdapter: ",
      this.xAxisTooltipLabelTextAdapter
    ), console.log(
      "seriesTooltipLabelHtmlAdapter: ",
      this.seriesTooltipLabelHtmlAdapter
    ), console.log(
      "xScrollbarXAxisLabelTextAdapter: ",
      this.xScrollbarXAxisLabelTextAdapter
    ), console.log(
      "seriesTooltipForceHiddenAdapter: ",
      this.seriesTooltipForceHiddenAdapter
    ), console.log("getWheelCursorPositionX: ", this.getWheelCursorPositionX), console.log("chartItemClickHandler: ", this.chartItemClickHandler), console.log("setSelectionMin: ", this.setSelectionMin), console.log("setSelectionMax: ", this.setSelectionMax), console.log("zoomHandler: ", this.zoomHandler), console.log("panHandler: ", this.panHandler), console.log("styleProps: ", this.styleProps), console.log("chartSet: ", this.chartSet), console.log("legendSet: ", this.legendSet), console.log("candlestickSet: ", this.candlestickSet), console.log("lineSet: ", this.lineSet), console.log("bubbleSet: ", this.bubbleSet), console.log("barSet: ", this.barSet), console.log("data: ", this.data), console.log("xScrollbarSet: ", this.xScrollbarSet)), this.createChart();
  },
  watch: {
    dataStartPoint: {
      handler(i) {
        console.log("watch dataStartPoint: ", i);
      }
    },
    dataEndPoint: {
      handler(i) {
        console.log("watch dataEndPoint: ", i);
      }
    },
    axisDataBinder: {
      handler() {
        this.logTest && console.log("watch axisDataBinder"), this.setAxes();
      },
      deep: !0
    },
    lineDataBinder: {
      handler() {
        this.logTest && console.log("watch lineDataBinder"), this.setLineSeries();
      },
      deep: !0
    },
    stepLineDataBinder: {
      handler() {
        this.logTest && console.log("watch stepLineDataBinder"), this.setStepLineSeries();
      },
      deep: !0
    },
    barDataBinder: {
      handler() {
        this.logTest && console.log("watch barDataBinder"), this.setColumnSeries();
      },
      deep: !0
    },
    bubbleDataBinder: {
      handler() {
        this.logTest && console.log("watch bubbleDataBinder"), this.setBubbleSeries();
      },
      deep: !0
    },
    candlestickDataBinder: {
      handler() {
        this.logTest && console.log("watch candlestickDataBinder"), this.setCandlestickSeries();
      },
      deep: !0
    },
    selectionMin: {
      handler(i) {
        this.xAxis && this.data && this.xAxis.data.setAll(this.data);
      },
      immediate: !0
    },
    selectionMax: {
      handler(i) {
        this.xAxis && this.data && this.xAxis.data.setAll(this.data);
      },
      immediate: !0
    },
    xScrollbarSetComputed: {
      handler(i) {
        this.logTest && console.log("watch xScrollbarSetComputed: ", i);
      },
      deep: !0,
      immediate: !0
    },
    "chartSetComputed.titleLabel.text": {
      handler(i, e) {
        this.logTest && console.log("watch chartSetComputed.titleLabel.text"), this.logTest && console.log(i), this.logTest && console.log(e), this.setXAxisExtraLabel();
      }
    },
    "xScrollbarSetComputed.detail.mainValue.displayName": {
      handler(i, e) {
        this.logTest && console.log(
          "watch xScrollbarSetComputed.detail.mainValue.displayName 11"
        ), this.logTest && console.log(i), this.logTest && console.log(e), this.setChartTitle(), this.setScrollbar();
      }
    },
    data(i) {
      if (console.log("watch data"), console.log(i), console.log("this.root: ", this.root), !this.root)
        return console.log("11111111"), this.createChart();
      if (this.root && i.length === 0)
        return console.log("this.root.dispose 22222222"), this.root.dispose();
      if (this.root && this.root.isDisposed())
        return console.log("33333333"), this.createChart();
      [
        "xAxis",
        "yAxis",
        "ySecondAxis",
        "candlestickSeries",
        "xScrollbarSeries",
        "xScrollbarColumnSeries",
        "xScrollbarLineSeries",
        "xScrollbarBubbleSeries",
        "xScrollbarCandlestickSeries",
        "xScrollbarXAxis",
        "xScrollbarYAxis",
        "xScrollbarSecondYAxis"
      ].map((t) => {
        this[t] && this[t].data && this[t].data.setAll(i);
      }), this.setLineSeries(), this.setStepLineSeries(), this.setColumnSeries(), this.setBubbleSeries();
    }
  },
  computed: {
    chartSetComputed() {
      let i = Fe(this.chartSetData, this.chartSet);
      return Object.assign({}, i);
    },
    axisDataBinderComputed() {
      let i = Fe(this.axisDataBinderData, this.axisDataBinder);
      return Object.assign({}, i);
    },
    legendSetComputed() {
      let i = Fe(this.legendSetData, this.legendSet);
      return Object.assign({}, i);
    },
    barSetComputed() {
      return Fe(this.barSetData, this.barSet);
    },
    bubbleSetComputed() {
      return Fe(this.bubbleSetData, this.bubbleSet);
    },
    lineSetComputed() {
      return Fe(this.lineSetData, this.lineSet);
    },
    stepLineSetComputed() {
      return Fe(this.stepLineSetData, this.stepLineSet);
    },
    candlestickSetComputed() {
      return Fe(this.candlestickSetData, this.candlestickSet);
    },
    xScrollbarSetComputed() {
      return Fe(this.xScrollbarSetData, this.xScrollbarSet);
    },
    closeDataStartPoint() {
      if (this.dataStartPoint && this.data.length > 0) {
        let i = P(
          this.dataStartPoint,
          "YYYYMMDDmmss"
        ).unix(), e = NaN, t = i;
        for (let s = 0; s < this.data.length; s++) {
          let r = P(
            this.data[s][this.category],
            "YYYYMMDDmmss"
          ).unix();
          t > Math.abs(r - i) && (t = Math.abs(r - i), e = this.data[s][this.category]);
        }
        if (!isNaN(e))
          return e;
      }
    },
    closeDataEndPoint() {
      if (this.dataEndPoint && this.data.length > 0) {
        let i = P(this.dataEndPoint, "YYYYMMDDmmss").unix(), e = NaN, t = i;
        for (let s = 0; s < this.data.length; s++) {
          let r = P(
            this.data[s][this.category],
            "YYYYMMDDmmss"
          ).unix();
          t > Math.abs(r - i) && (t = Math.abs(r - i), e = this.data[s][this.category]);
        }
        if (!isNaN(e))
          return e;
      }
    },
    // default 의 selectionMin 과 가장 가까운 overall 의 selectionMin
    closeSelectionMin() {
      if (this.selectionMin && this.selectionMax && this.data.length > 0) {
        this.logTest && console.log("yyyyyyyyyyyyyy");
        let i = P(this.selectionMin, "YYYYMMDDmmss").unix(), e = NaN, t = i;
        for (let s = 0; s < this.data.length; s++) {
          let r = P(
            this.data[s][this.category],
            "YYYYMMDDmmss"
          ).unix();
          t > Math.abs(r - i) && (t = Math.abs(r - i), e = this.data[s][this.category]);
        }
        if (!isNaN(e))
          return e;
      }
    },
    // default 의 selectionMax 과 가장 가까운 overall 의 selectionMax
    closeSelectionMax() {
      if (this.selectionMin && this.selectionMax && this.data.length > 0) {
        let i = P(this.selectionMax, "YYYYMMDDmmss").unix(), e = NaN, t = i;
        for (let s = 0; s < this.data.length; s++) {
          let r = P(
            this.data[s][this.category],
            "YYYYMMDDmmss"
          ).unix();
          t > Math.abs(r - i) && (t = Math.abs(r - i), e = this.data[s][this.category]);
        }
        if (!isNaN(e))
          return e;
      }
    }
  },
  methods: {
    setXAxisLabelHTML(i, e) {
      return '<div style="display: flex; flex-direction: column; align-items: center; font-size: 11px;">' + (i && `<div>${i}</div>`) + `<div>${e}</div></div>`;
    },
    getRanHex(i) {
      let e = [], t = [
        "0",
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        "a",
        "b",
        "c",
        "d",
        "e",
        "f"
      ];
      for (let s = 0; s < i; s++)
        e.push(t[Math.floor(Math.random() * 16)]);
      return e.join("");
    },
    getColor(i, e, t) {
      if (this.logTest && console.log("getColor"), t)
        return this.logTest && console.log("get specificColor: ", t), t;
      if (i && e >= 0 && i[e])
        return this.logTest && console.log("get colorList[index]: ", i[e]), i[e];
      {
        let s = "#" + this.getRanHex(6);
        return this.logTest && console.log("get random color: ", s), s;
      }
    },
    resetChart() {
      this.root && (this.logTest && console.log("root dipsose"), this.root.dispose()), this.createChart();
    },
    setZoomHandler() {
      if (this.logTest && console.log("setZoomHandler"), this.xAxis) {
        let i = 0, e = 0;
        if (this.xAxis.getPrivate("startIndex") && (i = this.xAxis.getPrivate("startIndex")), this.xAxis.getPrivate("endIndex") && (e = this.xAxis.getPrivate("endIndex")), e > 0) {
          let t = this.xAxis.dataItems[i].dataContext[this.category], s = this.xAxis.dataItems[e - 1].dataContext[this.category];
          this.logTest && console.log("%c zoom !!!", "color: red;"), this.zoomHandler(t, s);
        }
      }
    },
    setPlotContainerPanHandler() {
      if (console.log("setPlotContainerPanHandler"), this.xAxis) {
        let i = 0, e = 0;
        this.xAxis.getPrivate("startIndex") && (i = this.xAxis.getPrivate("startIndex")), this.xAxis.getPrivate("endIndex") && (e = this.xAxis.getPrivate("endIndex")), e > 0 && (this.setSelectionMin && (console.log(
          "setSelectionMin value: ",
          this.xAxis.dataItems[i].dataContext[this.category]
        ), this.setSelectionMin(
          this.xAxis.dataItems[i].dataContext[this.category]
        )), this.setSelectionMax && (console.log(
          "setSelectionMax value: ",
          this.xAxis.dataItems[e - 1].dataContext[this.category]
        ), this.setSelectionMax(
          this.xAxis.dataItems[e - 1].dataContext[this.category]
        )), i === 0 && (this.logTest && console.log("%c previous", "color: red;"), setTimeout(() => {
          this.panHandler("previous");
        }, 500)), e >= this.data.length - 1 && (this.logTest && console.log("%c next", "color: red;"), this.panHandler("next")));
      }
    },
    setZoomPanEvents() {
      const i = this;
      this.logTest && console.log("setZoomPanEvents"), this.logTest && console.log(
        "this.chartSetComputed.chartType: ",
        this.chartSetComputed.chartType
      ), this.logTest && console.log("this.zoomHandler: ", this.zoomHandler), this.logTest && console.log("this.panHandler: ", this.panHandler), this.logTest && console.log("this.xScrollbar: ", this.xScrollbar), this.zoomHandler && (this.logTest && console.log("xxxxxxxxxxxxxxx"), this.chart.events.on("wheelended", function(e) {
        i.setZoomHandler(i.xScrollbar, e);
      })), this.panHandler && (console.log("set pan handler"), this.xScrollbar.events.on("rangechanged", function(e) {
        if (console.log("rangeChanged !!!"), console.log("ev.target: ", e.target), console.log("ev.start: ", e.start), console.log("ev.end: ", e.end), e.target.chart.xAxes._values[0]) {
          let t = e.target.chart.xAxes._values[0].getSeriesItem(
            i.xySeries,
            e.start
          ), s = e.target.chart.xAxes._values[0].getSeriesItem(
            i.xySeries,
            e.end
          );
          i.chartSetComputed.chartType === "overall" && !(e.start === 0 && e.end === 1) && (i.setDataStartPoint(t.dataContext[i.category]), i.setDataEndPoint(s.dataContext[i.category]));
        }
        i.logTest && console.log("==================================");
      }), this.xScrollbar.thumb.events.on("pointerup", function(e) {
        console.log("x scrollbar thumb panning handler"), i.logTest && console.log("self.data: ", i.data);
        let t = 0;
        i.data.map((r, n) => {
          r[i.category] === i.dataStartPoint && (t = n);
        }), i.setSelectionMin(i.data[t][i.category]);
        let s = 0;
        i.data.map((r, n) => {
          r[i.category] === i.dataEndPoint && (s = n);
        }), startIndex === s ? i.setSelectionMax(i.data[t + 1][i.category]) : i.setSelectionMax(i.data[s][i.category]), console.log(
          "self.chartSetComputed.chartType: ",
          i.chartSetComputed.chartType
        ), i.panHandler();
      }), this.chart.plotContainer.events.on("pointerup", function(e) {
        console.log("plot container panning handler"), i.setPlotContainerPanHandler();
      }));
    },
    setSeries() {
      this.logTest && console.log("setSeries"), this.setLineSeries(), this.setStepLineSeries(), this.setColumnSeries(), this.setBubbleSeries(), this.setCandlestickSeries();
    },
    setLineSeries(i = 0) {
      this.root && this.xAxis && this.yAxisList[i] && this.lineDataBinder && this.lineDataBinder.length > 0 && (this.lineSeriesList.map((e) => {
        console.log("lineSeries dispose"), e.dispose();
      }), this.lineSeriesList = [], this.lineDataBinder.map((e, t) => {
        let s = e == null ? void 0 : e.displayName, r = e == null ? void 0 : e.key, n = e == null ? void 0 : e.openKey, a = e == null ? void 0 : e.strokeWidth, o = e == null ? void 0 : e.isLineVisible;
        a === void 0 && (a = this.lineSetComputed.strokeWidth);
        let l = {
          strokeWidth: Number(a),
          visible: o !== void 0 ? o : !0
        }, u = this.getColor(
          this.lineSetComputed.colorList,
          t,
          e == null ? void 0 : e.color
        );
        e.color = u;
        let h = {};
        n && (h = { openValueYField: n });
        let c = {
          name: s,
          xAxis: this.xAxis,
          yAxis: e.isYSecondAxis ? this.ySecondAxis : this.yAxisList[i],
          valueYField: r,
          ...h,
          categoryXField: this.category,
          stroke: oe(e.color),
          fill: oe(e.color),
          connect: this.lineSetComputed.isConnected,
          userData: {
            chartType: "line",
            category: this.category,
            value: r,
            item: e
          }
        }, d = e.isFillVisible !== void 0 ? e.isFillVisible : this.lineSetComputed.isFillVisible, f = {
          fillOpacity: Number(this.lineSetComputed.fillOpacity),
          visible: d
        };
        this.lineSeries = lt.new(this.root, {
          ...c
        }), this.xySeries = this.chart.series.push(this.lineSeries), this.lineSeriesList.push(this.lineSeries), this.setLineSeriesChart(
          l,
          f,
          e,
          t
        ), this.setLineSeriesXScrollbar(
          c,
          l,
          e,
          t
        );
      }), this.setLegend());
    },
    setLineSeriesChart(i, e, t, s) {
      const r = this;
      let n = ge.new(this.root, {});
      r.chartItemClickHandler && n.events.on("click", function(a) {
        r.logTest && console.log("click"), a.target.dataItem.component.className === "LineSeries" && r.chartItemClickHandler(a);
      }), ((t == null ? void 0 : t.isBullet) !== void 0 ? t != null && t.isBullet : this.lineSetComputed.isBullet) && this.lineSeries.bullets.push(function() {
        let o = r.getTooltipText(t).labelHTML;
        return r.seriesTooltipLabelHtmlAdapter && (o = r.seriesTooltipLabelHtmlAdapter(
          r.data[s],
          t
        )), qt.new(r.root, {
          sprite: ei.new(
            r.root,
            {
              tooltipHTML: o,
              strokeWidth: r.lineSetComputed.bullet.strokeWidth,
              radius: Number(r.lineSetComputed.bullet.radius),
              stroke: oe(t.color),
              fill: r.root.interfaceColors.get("background"),
              userData: {
                chartType: "line",
                category: r.category
              }
            },
            n
          )
        });
      }), this.lineSeries.strokes.template.setAll({
        ...i
      }), this.lineSeries.fills.template.setAll({
        ...e
      }), this.lineSeries.data.setAll(this.data);
    },
    setLineSeriesXScrollbar(i, e, t, s) {
      this.logTest && console.log("setLineSeriesXScrollbar");
      const r = this;
      this.xScrollbarSetComputed.isDetailed && !this.xScrollbarSetComputed.detail.mainValue.key && this.xScrollbar && (this.logTest && console.log("setLineSeriesXScrollbar 22"), this.xScrollbarLineSeries = lt.new(r.root, {
        ...i,
        xAxis: r.xScrollbarXAxis,
        yAxis: t.ySecondAxis ? this.xScrollbarSecondYAxis : this.xScrollbarYAxis
      }), this.xScrollbar.chart.series.push(this.xScrollbarLineSeries), this.xScrollbarLineSeries.bullets.push(function() {
        return qt.new(r.root, {
          sprite: ei.new(r.root, { ...lineBulletSettings })
          // sprite: am5.Circle.new(self.root, {}),
        });
      }), this.xScrollbarLineSeries.strokes.template.setAll({
        ...e
      }), this.xScrollbarLineSeries.data.setAll(this.data));
    },
    // step line series
    setStepLineSeries(i = 0) {
      this.root && this.xAxis && this.yAxisList[i] && this.stepLineDataBinder && this.stepLineDataBinder.length > 0 && (this.stepLineSeriesList.map((e) => {
        console.log("lineSeries dispose"), e.dispose();
      }), this.stepLineSeriesList = [], this.stepLineDataBinder.map((e, t) => {
        let s = e == null ? void 0 : e.displayName, r = e == null ? void 0 : e.key, n = e == null ? void 0 : e.openKey, a = e == null ? void 0 : e.strokeWidth, o = e == null ? void 0 : e.isLineVisible;
        a === void 0 && (a = this.stepLineSetComputed.strokeWidth);
        let l = {
          strokeWidth: Number(a),
          visible: o !== void 0 ? o : !0
        }, u = this.getColor(
          this.lineSetComputed.colorList,
          t,
          e == null ? void 0 : e.color
        );
        e.color = u;
        let h = "";
        n && (h = { openValueYField: n });
        let c = {
          name: s,
          xAxis: this.xAxis,
          yAxis: e.isYSecondAxis ? this.ySecondAxis : this.yAxisList[i],
          valueYField: r,
          ...h,
          categoryXField: this.category,
          stroke: oe(e.color),
          fill: oe(e.color),
          userData: {
            chartType: "line",
            category: this.category,
            value: r,
            item: e
          }
        }, d = e.isFillVisible !== void 0 ? e.isFillVisible : this.stepLineSetComputed.isFillVisible, f = {
          fillOpacity: Number(this.stepLineSetComputed.fillOpacity),
          visible: d
        };
        this.stepLineSeries = nr.new(this.root, {
          ...c
        }), this.xySeries = this.chart.series.push(this.stepLineSeries), this.stepLineSeriesList.push(this.stepLineSeries), this.setStepLineSeriesChart(
          l,
          f,
          e,
          t
        ), this.setStepLineSeriesXScrollbar(
          c,
          l,
          e,
          t
        );
      }), this.setLegend());
    },
    setStepLineSeriesChart(i, e, t, s) {
      const r = this;
      let n = ge.new(this.root, {});
      r.chartItemClickHandler && n.events.on("click", function(a) {
        r.logTest && console.log("click"), a.target.dataItem.component.className === "StepLineSeries" && r.chartItemClickHandler(a);
      }), ((t == null ? void 0 : t.isBullet) !== void 0 ? t != null && t.isBullet : this.stepLineSetComputed.isBullet) && this.stepLineSeries.bullets.push(function() {
        let o = r.getTooltipText(t).labelHTML;
        return r.seriesTooltipLabelHtmlAdapter && (o = r.seriesTooltipLabelHtmlAdapter(
          r.data[s],
          t
        )), qt.new(r.root, {
          sprite: ei.new(
            r.root,
            {
              tooltipHTML: o,
              strokeWidth: r.stepLineSetComputed.bullet.strokeWidth,
              radius: Number(r.stepLineSetComputed.bullet.radius),
              stroke: oe(t.color),
              fill: r.root.interfaceColors.get("background"),
              userData: {
                chartType: "stepLine",
                category: r.category
              }
            },
            n
          )
        });
      }), this.stepLineSeries.strokes.template.setAll({
        ...i
      }), this.stepLineSeries.fills.template.setAll({
        ...e
      }), this.stepLineSeries.data.setAll(this.data);
    },
    setStepLineSeriesXScrollbar(i, e, t, s) {
      this.logTest && console.log("setStepLineSeriesXScrollbar");
      const r = this;
      this.xScrollbarSetComputed.isDetailed && !this.xScrollbarSetComputed.detail.mainValue.key && this.xScrollbar && (this.xScrollbarStepLineSeries = nr.new(r.root, {
        ...i,
        xAxis: r.xScrollbarXAxis,
        yAxis: t.ySecondAxis ? this.xScrollbarSecondYAxis : this.xScrollbarYAxis
      }), this.xScrollbar.chart.series.push(this.xScrollbarStepLineSeries), this.xScrollbarStepLineSeries.bullets.push(function() {
        return qt.new(r.root, {
          sprite: ei.new(r.root, { ...stepLineBulletSettings })
          // sprite: am5.Circle.new(self.root, {}),
        });
      }), this.xScrollbarStepLineSeries.strokes.template.setAll({
        ...e
      }), this.xScrollbarStepLineSeries.data.setAll(this.data));
    },
    setBubbleSeries(i = 0) {
      this.root && this.xAxis && this.yAxisList[i] && this.bubbleDataBinder && this.bubbleDataBinder.length > 0 && (this.logTest && console.log("setBubbleSeries"), this.logTest && console.log("this.chart: ", this.chart), this.logTest && console.log("this.chart.series: ", this.chart.series), this.logTest && console.log(" this.bubbleSeriesList: ", this.bubbleSeriesList), this.bubbleSeriesList.map((e) => {
        this.logTest && console.log("bubbleSeries dispose"), e.dispose();
      }), this.bubbleSeriesList = [], this.bubbleDataBinder.map((e, t) => {
        console.log("item.isYSecondAxis: ", e.isYSecondAxis), console.log("bubbleDataBinder item: ", e);
        let s = e == null ? void 0 : e.displayName, r = e == null ? void 0 : e.key, n = {
          strokeWidth: Number(this.bubbleSetComputed.strokeWidth),
          visible: !1
        }, a = this.getColor(
          this.bubbleSetComputed.colorList,
          t,
          e == null ? void 0 : e.color
        );
        e.color = a;
        let o = {
          name: s,
          xAxis: this.xAxis,
          yAxis: e.isYSecondAxis ? this.ySecondAxis : this.yAxisList[i],
          valueYField: r,
          categoryXField: this.category,
          stroke: oe(e.color),
          fill: oe(e.color),
          userData: {
            chartType: "bubble",
            category: this.category,
            value: r,
            item: e
          }
        }, l = {
          fillOpacity: Number(this.bubbleSetComputed.fillOpacity),
          visible: this.bubbleSetComputed.isFillVisible
        };
        this.bubbleSeries = lt.new(this.root, {
          ...o
        }), this.xySeries = this.chart.series.push(this.bubbleSeries), this.bubbleSeriesList.push(this.bubbleSeries), this.setBubbleSeriesChart(
          n,
          l,
          e,
          t
        ), this.setBubbleSeriesXScrollbar(
          o,
          n,
          e,
          t
        );
      }), this.setLegend());
    },
    setBubbleSeriesChart(i, e, t, s) {
      const r = this;
      let n = ge.new(this.root, {});
      r.chartItemClickHandler && n.events.on("click", function(a) {
        r.logTest && console.log("click"), a.target.dataItem.component.className === "LineSeries" && r.chartItemClickHandler(a);
      }), this.bubbleSeries.bullets.push(function() {
        let o = r.getTooltipText(t).labelHTML;
        if (r.seriesTooltipLabelHtmlAdapter) {
          let l = JSON.parse(JSON.stringify(t));
          o = r.seriesTooltipLabelHtmlAdapter(
            r.data[s],
            l
          );
        }
        return qt.new(r.root, {
          sprite: ei.new(
            r.root,
            {
              tooltipHTML: o,
              strokeWidth: r.bubbleSetComputed.bullet.strokeWidth,
              stroke: oe(t.color),
              fill: r.root.interfaceColors.get("background"),
              radius: Number(r.bubbleSetComputed.bullet.radius),
              userData: {
                chartType: "bubble",
                category: r.category
              }
            },
            n
          )
        });
      }), this.bubbleSeries.strokes.template.setAll({
        ...i
      }), this.bubbleSeries.fills.template.setAll({
        ...e
      }), this.bubbleSeries.data.setAll(this.data);
    },
    setBubbleSeriesXScrollbar(i, e, t, s, r) {
      this.logTest && console.log("setBubbleSeriesXScrollbar");
      const n = this;
      this.xScrollbarSetComputed.isDetailed && !this.xScrollbarSetComputed.detail.mainValue.key && (this.logTest && console.log("setBubbleSeriesXScrollbar 22"), this.xScrollbarBubbleSeries = lt.new(n.root, {
        ...i,
        xAxis: n.xScrollbarXAxis,
        yAxis: s.ySecondAxis ? n.xScrollbarSecondYAxis : n.xScrollbarYAxis
      }), this.xScrollbar.chart.series.push(this.xScrollbarBubbleSeries), this.xScrollbarBubbleSeries.bullets.push(function() {
        return qt.new(n.root, {
          sprite: ei.new(n.root, { ...e })
        });
      }), this.xScrollbarBubbleSeries.strokes.template.setAll({
        ...t
      }), this.xScrollbarBubbleSeries.data.setAll(this.data));
    },
    hexToRgbA(i) {
      var e;
      if (/^#([A-Fa-f0-9]{3}){1,2}$/.test(i)) {
        e = i.substring(1).split(""), e.length == 3 && (e = [
          e[0],
          e[0],
          e[1],
          e[1],
          e[2],
          e[2]
        ]), e = "0x" + e.join("");
        let t = e >> 16 & 255, s = e >> 8 & 255, r = e & 255;
        return [t, r, s];
      }
      throw new Error("Bad Hex");
    },
    rgbaToHex(i) {
      this.logTest && console.log("rgbaStr: ", i);
      let e = i.replace(/\s/g, "").match(/^rgba?\((\d+),(\d+),(\d+),?([^,\s)]+)?/i);
      return this.logTest && console.log("rgb: ", e), e ? (e[1] | 1 << 8).toString(16).slice(1) + (e[2] | 1 << 8).toString(16).slice(1) + (e[3] | 1 << 8).toString(16).slice(1) : i;
    },
    setColumnSeries(i = 0) {
      this.root && this.xAxis && this.yAxisList[i] && this.barDataBinder && this.barDataBinder.length > 0 && (this.columnSeriesList.length > 0 && (this.columnSeriesList.map((e) => {
        this.logTest && console.log("columnSeries dispose"), e.dispose();
      }), this.columnSeriesList = []), this.barDataBinder.map((e, t) => {
        let s = e == null ? void 0 : e.displayName, r = e == null ? void 0 : e.key;
        if (e == null ? void 0 : e.disabled) {
          let c = this.hexToRgbA(e == null ? void 0 : e.color), d = Math.floor((c[0] + c[1] + c[2]) / 3), f = this.rgbaToHex(
            `rgba(${d}, ${d}, ${d})`
          );
          e != null && e.color && (e.color = `#${f}`);
        }
        let a = {};
        this.axisDataBinderComputed.yAxis.isPercent && (a = { valueYShow: "valueYTotalPercent" });
        let o = {
          name: s,
          stacked: this.barSetComputed.isStacked,
          clustered: this.barSetComputed.isClustered,
          valueYField: r,
          categoryXField: this.category,
          ...a
        }, l = this.getTooltipText(e), u = this.getColor(
          this.barSetComputed.colorList,
          t,
          e == null ? void 0 : e.color
        ), h = {
          tooltipY: 0,
          tooltipHTML: l.labelHTML,
          templateField: "columnSettings",
          stroke: oe(u),
          fill: oe(u),
          width: Number(this.barSetComputed.width),
          fillOpacity: Number(this.barSetComputed.fillOpacity),
          strokeWidth: Number(this.barSetComputed.strokeWidth),
          cornerRadiusTL: Number(this.barSetComputed.cornerRadius.topLeft),
          cornerRadiusTR: Number(this.barSetComputed.cornerRadius.topRight),
          userData: {
            chartType: "bar",
            category: this.category,
            value: r
          }
        };
        this.setColumnSeriesChart(
          o,
          h,
          e,
          t
        ), this.setColumnSeriesXScrollbar(
          o,
          h,
          t
        );
      }));
    },
    setColumnSeriesChart(i, e, t, s) {
      const r = this;
      this.xAxis || this.setXAxis(), t.yAxisIndex && !this.yAxisList[t.yAxisIndex] && this.setYAxis(t.yAxisIndex);
      let n = this.xAxis ? this.xAxis : this.xAxis, a = this.yAxisList[t.yAxisIndex] ? this.yAxisList[t.yAxisIndex] : this.yAxisList[0];
      a.axisHeader.children.push(
        We.new(r.root, {
          text: t.yAxisHeaderName,
          fontWeight: "500"
        })
      ), a.axisHeader.set("paddingTop", 10), this.columnSeries = Gi.new(this.root, {
        ...i,
        xAxis: n,
        yAxis: t.isYSecondAxis ? this.ySecondAxis : a
        // yAxis: yAxis,
      }), this.columnSeriesList.push(this.columnSeries), this.xySeries = this.chart.series.push(this.columnSeries);
      let o = At.new(r.root, {
        getFillFromSprite: !1,
        getStrokeFromSprite: !0,
        autoTextColor: !1,
        getLabelFillFromSprite: !0
      });
      o.get("background").setAll({
        fill: oe(16777215),
        fillOpacity: 0.8
      }), this.logTest && console.log("columnTooltip: ", o), this.seriesTooltipLabelHtmlAdapter && o.label.adapters.add("html", function(l, u) {
        return r.seriesTooltipLabelHtmlAdapter(r.data[s], t);
      }), this.columnSeries.set("tooltip", o), this.columnSeries.columns.template.setAll({
        ...e
      }), this.seriesTooltipForceHiddenAdapter, this.columnSeries.columns.template.events.on(
        "click",
        this.chartItemClickHandler
      ), this.columnSeries.data.setAll(this.data), this.setLegend();
    },
    setColumnSeriesXScrollbar(i, e, t, s) {
      this.xScrollbarSetComputed.isDetailed && !this.xScrollbarSetComputed.detail.mainValue.key && this.xScrollbar && (this.xScrollbarColumnSeries = this.xScrollbar.chart.series.push(
        Gi.new(this.root, {
          ...i,
          xAxis: this.xScrollbarXAxis,
          yAxis: t.ySecondAxis ? this.xScrollbarSecondYAxis : this.xScrollbarYAxis
        })
      ), this.xScrollbarColumnSeries.columns.template.setAll({
        ...e
      }), this.xScrollbarColumnSeries.data.setAll(this.data));
    },
    setXAxisGridStrokeOpacityAdapter() {
      const i = this;
      this.xAxisGridStrokeOpacityAdapter && this.xAxis.get("renderer").grid.template.adapters.add(
        "strokeOpacity",
        function(e, t) {
          return i.xAxisGridStrokeOpacityAdapter(t);
        }
      );
    },
    createChart() {
      console.log("createChart");
      const i = this;
      this.$nextTick(() => {
        if (i.data.length > 0) {
          (!i.root || i.root && i.root.isDisposed()) && (i.root = un.new(
            i.$refs[i.chartSetComputed.refProps]
          ));
          const e = dr.new(i.root);
          i.root.setThemes([Jd.new(i.root), e]), i.setContainer(), i.setAxes(), i.setSeries(), i.setCursor(), i.setScrollbar(), i.setZoomPanEvents(), i.setZoomOutButton(), i.root.numberFormatter.setAll({
            // numberFormat: "#'%'",
            numberFormat: "#.#",
            numericFields: ["valueY"]
          }), i.chart.leftAxesContainer.set("layout", i.root.verticalLayout), i.setCustom && i.setCustom(oh, i), i.chart.appear(1e3, 100);
        }
      });
    },
    // 스크롤바 설정 함수
    setScrollbar() {
      this.logTest && console.log("setScrollbar 22");
      let i = {};
      this.xScrollbarSetComputed.isDetailed && (i = { height: Number(this.xScrollbarSetComputed.detail.height) }), this.xScrollbar = [], this.xScrollbar = this.chart.set(
        "scrollbarX",
        Zr.new(this.root, {
          orientation: "horizontal",
          ...i
        })
      ), this.logTest && console.log("this.xScrollbar 22: ", this.xScrollbar), this.setDetailScrollAxis(), this.setXScrollbarPosition(), this.setXScrollbarThumb(), this.setXScrollbarGrip(), this.setXScrollbarBackground(), this.setXScrollbarMainLine(), this.xScrollbarSetComputed.isDetailed || this.xScrollbar.set("visible", !1);
    },
    setDetailScrollAxis() {
      this.logTest && console.log("setDetailScrollAxis"), this.logTest && console.log(
        "this.xScrollbarSetComputed.isDetailed: ",
        this.xScrollbarSetComputed.isDetailed
      ), this.xScrollbarSetComputed.isDetailed && (this.setDetailScrollXAxis(), this.setDetailScrollYAxis(), this.setDetailScrollYSecondAxis());
    },
    setDetailScrollXAxis() {
      this.logTest && console.log("setDetailScrollXAxis"), this.logTest && console.log("this.xScrollbar: ", this.xScrollbar);
      const i = this;
      if (
        // this.axisDataBinderComputed &&
        // this.axisDataBinderComputed.xAxis &&
        this.xScrollbar
      ) {
        if (this.logTest && console.log(this.xScrollbar), this.logTest && console.log(this.xScrollbar.chart), this.logTest && console.log(this.xScrollbar.chart.xAxes), this.logTest && console.log(
          "this.xScrollbar.chart.xAxes.values.length: ",
          this.xScrollbar.chart.xAxes.values.length
        ), this.xScrollbar.chart.xAxes.values.length === 0) {
          let e = At.new(i.root, {});
          this.xScrollbarXAxis = this.xScrollbar.chart.xAxes.push(
            ks[this.axisDataBinderComputed.xAxis.type].new(i.root, {
              tooltip: e,
              categoryField: i.category,
              renderer: sr.new(i.root, {
                minGridDistance: 5
              })
            })
          );
        }
        this.xScrollbarXAxisLabelTextAdapter && this.xScrollbarXAxis.get("renderer").labels.template.adapters.add("text", function(e, t) {
          return i.xScrollbarXAxisLabelTextAdapter(
            e,
            t,
            i.data
          );
        }), this.xScrollbarXAxis.get("renderer").grid.template.adapters.add(
          "strokeOpacity",
          function(e, t) {
            return t.dataItem.dataContext.title === "1" ? 0.1 : 0;
          }
        ), this.xScrollbarXAxis.get("renderer").labels.template.setAll({
          fontSize: 10,
          textAlign: "center"
        }), this.xScrollbarXAxis.get("renderer").grid.template.setAll({
          strokeWidth: 1,
          strokeOpacity: 0,
          location: 0.5
        }), this.xScrollbarXAxis.data.setAll(this.data);
      }
    },
    setDetailScrollYAxis() {
      if (this.logTest && console.log("setDetailScrollYAxis"), this.logTest && console.log("this.xScrollbar: ", this.xScrollbar), this.xScrollbar) {
        const i = this;
        let e = this.axisDataBinderComputed.yAxis.type === "DateAxis" ? { baseInterval: { timeUnit: "day", count: 1 } } : "";
        this.logTest && console.log(
          "this.xScrollbar.chart.yAxes.values.length: ",
          this.xScrollbar.chart.yAxes.values.length
        ), this.xScrollbar.chart.yAxes.values.length === 0 && (this.xScrollbarYAxis = this.xScrollbar.chart.yAxes.push(
          ks[this.axisDataBinderComputed.yAxis.type].new(i.root, {
            ...e,
            min: 0,
            extraMax: 0.2,
            renderer: Oi.new(i.root, {})
          })
        )), this.xScrollbarYAxis.data.setAll(this.data);
      }
    },
    setDetailScrollYSecondAxis() {
      if (this.logTest && console.log("setDetailScrollYSecondAxis"), this.logTest && console.log("this.xScrollbar: ", this.xScrollbar), this.xScrollbar) {
        const i = this;
        let e = this.axisDataBinderComputed.yAxis.type === "DateAxis" ? { baseInterval: { timeUnit: "day", count: 1 } } : "";
        this.logTest && console.log(
          "this.xScrollbar.chart.yAxes.values.length (second axis): ",
          this.xScrollbar.chart.yAxes.values.length
        ), this.xScrollbar.chart.yAxes.values.length === 1 && (this.xScrollbarSecondYAxis = this.xScrollbar.chart.yAxes.push(
          ks[this.axisDataBinderComputed.ySecondAxis.type].new(i.root, {
            ...e,
            min: 0,
            extraMax: 0.1,
            renderer: Oi.new(i.root, {})
          })
        )), this.xScrollbarSecondYAxis.data.setAll(this.data);
      }
    },
    setXScrollbarPosition() {
      this.logTest && console.log("setXScrollbarPosition"), this.xScrollbar.set(
        "start",
        Number(this.xScrollbarSetComputed.startPosition)
      ), this.xScrollbar.set(
        "end",
        Number(this.xScrollbarSetComputed.endPosition)
      ), this.xScrollbarSetComputed.isDown && (this.logTest && console.log(
        "this.chart.bottomAxesContainer.children :",
        this.chart.bottomAxesContainer.children
      ), this.chart.bottomAxesContainer.children.push(this.xScrollbar));
    },
    setXScrollbarThumb() {
      this.xScrollbar.thumb.setAll({
        fill: oe(this.xScrollbarSetComputed.thumb.fill),
        fillOpacity: Number(this.xScrollbarSetComputed.thumb.fillOpacity)
      });
    },
    setXScrollbarGrip() {
      this.xScrollbar.startGrip.setAll({
        visible: this.xScrollbarSetComputed.isStartGrip,
        scale: this.xScrollbarSetComputed.gripScale
      }), this.xScrollbar.endGrip.setAll({
        visible: this.xScrollbarSetComputed.isEndGrip,
        scale: this.xScrollbarSetComputed.gripScale
      });
    },
    setXScrollbarBackground() {
      this.xScrollbarSetComputed.isDetailed && this.xScrollbar.get("background").setAll({
        fill: oe(this.xScrollbarSetComputed.detail.background.fill),
        fillOpacity: Number(
          this.xScrollbarSetComputed.detail.background.fillOpacity
        ),
        cornerRadiusTL: Number(
          this.xScrollbarSetComputed.detail.background.cornerRadius.topLeft
        ),
        cornerRadiusTR: Number(
          this.xScrollbarSetComputed.detail.background.cornerRadius.topRight
        ),
        cornerRadiusBL: Number(
          this.xScrollbarSetComputed.detail.background.cornerRadius.bottomLeft
        ),
        cornerRadiusBR: Number(
          this.xScrollbarSetComputed.detail.background.cornerRadius.bottomRight
        )
      });
    },
    setZoomOutButton() {
      this.chartSetComputed.isZoomOutButton || this.chart.zoomOutButton.set("forceHidden", !0);
    },
    setXScrollbarMainLine() {
      const i = this;
      this.logTest && (console.log("setXScrollbarMainLine"), console.log(
        "this.xScrollbarSetComputed.isDetailed: ",
        this.xScrollbarSetComputed.isDetailed
      ), console.log(
        "this.xScrollbarSetComputed.detail.mainValue.key: ",
        this.xScrollbarSetComputed.detail.mainValue.key
      ), console.log("this.xScrollbar: ", this.xScrollbar), console.log("this.xScrollbarXAxis: ", this.xScrollbarXAxis), console.log("this.xScrollbarYAxis: ", this.xScrollbarYAxis)), this.xScrollbar && this.xScrollbarXAxis && this.xScrollbarYAxis && this.xScrollbarSetComputed.isDetailed && this.xScrollbarSetComputed.detail.mainValue.key && (this.xScrollbarColumnSeries && this.xScrollbarColumnSeries.hide().then(function(e) {
        this.logTest && console.log("xScrollbarColumnSeries 를 숨겼습니다."), this.logTest && console.log(e);
      }), this.xScrollbarLineSeries && (this.xScrollbarLineSeries.hide().then(function(e) {
        this.logTest && console.log("xScrollbarLineSeries 를 숨겼습니다 4."), this.logTest && console.log(e);
      }), this.logTest && console.log(
        "this.xScrollbarLineSeries: ",
        this.xScrollbarLineSeries
      ), this.xScrollbarLineSeries.set("forceHidden", !0), this.logTest && console.log("333")), this.xScrollbarBubbleSeries && this.xScrollbarBubbleSeries.hide().then(function(e) {
        this.logTest && console.log("xScrollbarBubbleSeries 를 숨겼습니다."), this.logTest && console.log(e);
      }), this.xScrollbarCandlestickSeries && this.xScrollbarCandlestickSeries.hide().then(function(e) {
        this.logTest && console.log("xScrollbarCandlestickSeries 를 숨겼습니다."), this.logTest && console.log(e);
      }), this.xScrollbar.chart.series.values.length === 0 && (this.xScrollbarOverallSeries = qr.new(
        i.root,
        {
          valueYField: i.xScrollbarSetComputed.detail.mainValue.key,
          categoryXField: i.category,
          fill: oe(i.xScrollbarSetComputed.detail.line.color),
          stroke: oe(i.xScrollbarSetComputed.detail.line.color),
          xAxis: i.xScrollbarXAxis,
          yAxis: i.xScrollbarYAxis
        }
      ), this.xScrollbar.chart.series.push(i.xScrollbarOverallSeries)), this.xScrollbarOverallSeries.set(
        "valueYField",
        i.xScrollbarSetComputed.detail.mainValue.key
      ), this.xScrollbarOverallSeries.strokes.template.setAll({
        strokeWidth: Number(
          this.xScrollbarSetComputed.detail.line.strokeWidth
        )
      }), this.xScrollbarOverallSeries.fills.template.setAll({
        fillOpacity: Number(
          this.xScrollbarSetComputed.detail.line.fillOpacity
        ),
        visible: !0
      }), this.xScrollbarOverallSeries.data.setAll(this.data));
    },
    setXAxis() {
      this.createXAxis(), this.setXAxisExtraLabel(), this.setXAxisLabel(), this.setXAxisGrid(), this.setXAxisLabelTextAdapter(), this.setXAxisTooltipLabelTextAdapter(), this.setXAxisGridStrokeOpacityAdapter(), this.setXAxisZoomToCategories(), this.xAxis.data.setAll(this.data);
    },
    createXAxis() {
      const i = this;
      let e = this.axisDataBinderComputed.xAxis.tooltipHTML ? { labelHTML: this.axisDataBinderComputed.xAxis.tooltipHTML } : {}, t = At.new(i.root, { ...e });
      (!this.xAxis || this.xAxis.isDisposed()) && (this.xAxis = ks[i.axisDataBinderComputed.xAxis.type].new(
        i.root,
        {
          tooltip: t,
          maxDeviation: 0,
          categoryField: i.category,
          renderer: sr.new(i.root, {
            minGridDistance: 5
          }),
          // axisfill 활성화
          fillRule: function(s) {
            var r = s.get("axisFill");
            r.setPrivate("visible", !0);
          }
        }
      ), this.chart.xAxes.push(this.xAxis));
    },
    setXAxisExtraLabel() {
      this.logTest && console.log("setXAxisExtraLabel");
      const i = this;
      this.xAxis && (this.xAxisExtraLabel || (this.xAxisExtraLabel = this.xAxis.children.push(
        We.new(i.root, {
          html: i.setXAxisLabelHTML(
            i.chartSetComputed.titleLabel.text,
            i.axisDataBinderComputed.xAxis.name
          ),
          x: ie,
          centerX: ie,
          paddingBottom: 25
        })
      )), this.logTest && console.log("7777777"), this.xAxisExtraLabel.set(
        "html",
        i.setXAxisLabelHTML(
          i.chartSetComputed.titleLabel.text,
          i.axisDataBinderComputed.xAxis.name
        )
      ));
    },
    setXAxisLabel() {
      this.xAxis.get("renderer").labels.template.setAll({
        fontSize: 14,
        textAlign: "center",
        oversizedBehavior: "none"
        // 'none', 'hide', 'fit', 'wrap', 'wrap-no-break', 'truncate'
        // maxWidth: 150, // with 'truncate'
        // ellipsis: '...' // with 'truncate'
      });
    },
    setXAxisGrid() {
      this.xAxis.get("renderer").grid.template.setAll({
        strokeWidth: 1,
        strokeOpacity: 0.1,
        location: 0.5
      });
    },
    setXAxisLabelTextAdapter() {
      const i = this;
      this.xAxisLabelTextAdapter && this.xAxis.get("renderer").labels.template.adapters.add("text", function(e, t) {
        return i.xAxisLabelTextAdapter(e, t, i.timeScale);
      });
    },
    setXAxisTooltipLabelTextAdapter() {
      const i = this;
      this.xAxisTooltipLabelTextAdapter && this.xAxis.get("tooltip").label.adapters.add("text", function(e, t) {
        return i.xAxisTooltipLabelTextAdapter(e, t);
      });
    },
    setXAxisZoomToCategories() {
      const i = this;
      i.closeSelectionMin && i.closeSelectionMax && setTimeout(() => {
        console.log(
          "self.chartSetComputed.chartType: ",
          i.chartSetComputed.chartType
        ), i.chartSetComputed.chartType === "overall" && (console.log("self.closeDataPoint: "), console.log(i.closeDataStartPoint), console.log(i.closeDataEndPoint), i.xAxis.zoomToCategories(
          i.closeDataStartPoint,
          i.closeDataEndPoint
        )), i.chartSetComputed.chartType === "default" && (console.log("self.closeSelection"), console.log(i.closeSelectionMin), console.log(i.closeSelectionMax), i.xAxis.zoomToCategories(
          i.closeSelectionMin,
          i.closeSelectionMax
        ));
      }, 1e3);
    },
    setYAxis(i = 0) {
      this.axisDataBinderComputed && this.axisDataBinderComputed.yAxis && (this.createYAxis(i), this.setYAxisCreateRange(i), this.setYAxisLabel(i), this.yAxisList[i].data.setAll(this.data));
    },
    createYAxis(i) {
      const e = this;
      let t = this.axisDataBinderComputed.yAxis.tooltipHTML ? { labelHTML: this.axisDataBinderComputed.yAxis.tooltipHTML } : {}, s = {};
      this.axisDataBinderComputed.yAxis.isPercent && (s = {
        min: 0,
        max: 100,
        numberFormat: "#'%'",
        calculateTotals: !0
      });
      let r = At.new(e.root, { ...t });
      this.logTest && console.log("y axis push"), this.yAxisList[i] = this.chart.yAxes.push(
        ks[this.axisDataBinderComputed.yAxis.type].new(e.root, {
          strictMinMaxSelection: !0,
          min: 0,
          extraMax: 0.2,
          ...s,
          syncWithAxis: e.ySecondAxis,
          tooltip: r,
          renderer: Oi.new(e.root, {
            opposite: !e.axisDataBinderComputed.yAxis.isLeft
            // minGridDistance: 50,
            // inside: true,
          })
        })
      );
    },
    setYAxisLabel(i) {
      this.yAxisList[i].children[this.axisDataBinderComputed.yAxis.isLeft ? "unshift" : "push"](
        We.new(this.root, {
          rotation: this.axisDataBinderComputed.yAxis.isLeft ? -90 : 90,
          text: this.axisDataBinderComputed.yAxis.name,
          y: ie,
          centerX: ie
        })
      ), this.yAxisList[i].get("renderer").labels.template.setAll({
        fontSize: 14,
        textAlign: "center",
        visible: !0,
        minPosition: 0,
        maxPosition: 0.9
      });
    },
    setYAxisCreateRange(i) {
      this.yAxisRange && this.yAxisRange.map((e) => {
        let t = this.yAxisList[i].makeDataItem({
          value: e.value,
          endValue: e.endValue,
          above: !0
        });
        this.range = this.yAxisList[i].createAxisRange(t);
        let s = typeof e.location == "number" ? { location: e.location } : { location: 0.5 }, r = e.color ? e.color : "#579ffb", n = e.strokeDasharray ? { strokeDasharray: e.strokeDasharray } : {};
        this.setRangeGrid(r, n, s), this.setRangeAxisFill(r), this.setRangeLabel(e.text, s, r);
      });
    },
    setRangeGrid(i, e, t) {
      this.range.get("grid").setAll({
        stroke: oe(i),
        strokeOpacity: 1,
        ...e,
        ...t
      });
    },
    setRangeAxisFill(i) {
      this.range.get("axisFill").setAll({
        fill: oe(i),
        fillOpacity: 0.1,
        visible: !0
      });
    },
    setRangeLabel(i, e, t) {
      const s = this;
      i && this.range.get("label").setAll({
        fill: oe(16777215),
        text: i,
        ...e,
        background: it.new(s.root, {
          fill: oe(t)
        })
      });
    },
    setYSecondAxis(i = 0) {
      this.logTest && console.log("setYSecondAxis");
      const e = this;
      let t = {};
      t = this.axisDataBinderComputed.ySecondAxis.tooltipHTML && {
        labelHTML: this.axisDataBinderComputed.ySecondAxis.tooltipHTML
      };
      let s = At.new(e.root, { ...t });
      s.set(
        "forceHidden",
        !this.axisDataBinderComputed.ySecondAxis.isAvailable
      ), this.logTest && console.log(
        "this.chart.yAxes.values.length 22: ",
        this.chart.yAxes.values.length
      ), this.chart.yAxes.values.length === 1 && (this.logTest && console.log("second y axis push 22"), this.ySecondAxis = this.chart.yAxes.push(
        ks[this.axisDataBinderComputed.ySecondAxis.type].new(e.root, {
          tooltip: s,
          strictMinMaxSelection: !0,
          min: 0,
          extraMax: 0.2,
          syncWithAxis: e.yAxisList[i],
          renderer: Oi.new(e.root, {
            opposite: !this.axisDataBinderComputed.ySecondAxis.isLeft
            // minGridDistance: 50,
          })
        })
      ), this.ySecondAxis.children[this.axisDataBinderComputed.ySecondAxis.isLeft ? "unshift" : "push"](
        We.new(this.root, {
          rotation: this.axisDataBinderComputed.ySecondAxis.isLeft ? -90 : 90,
          text: this.axisDataBinderComputed.ySecondAxis.name,
          y: ie,
          centerX: ie
        })
      )), this.logTest && console.log("ySecondAxis data setAll"), this.ySecondAxis.data.setAll(this.data);
    },
    setAxes() {
      this.root && (this.logTest && console.log("setAxes"), this.setXAxis(), this.setYAxis(), this.setYSecondAxis());
    },
    setCursor() {
      if (this.chartSetComputed.cursor.isAvailable) {
        const i = this;
        this.logTest && console.log("setCursor"), this.chart.set(
          "cursor",
          Kr.new(i.root, {
            // behavior: "zoomXY", // default: 'none'
            // xAxis: this.xAxis
            // snapToSeries: [series1, series2],
            // snapToSeriesBy: "y!",
          })
        );
        let e = this.chart.get("cursor");
        i.getWheelCursorPositionX && e.events.on("wheel", function(t) {
          t.target.getPrivate("positionX") && i.getWheelCursorPositionX(t.target.getPrivate("positionX"));
        }), e.setAll({});
      }
    },
    setChartTitle() {
      this.logTest && console.log("setChartTitle");
      const i = this;
      if (this.chart && this.chartSetComputed.chartType === "overall") {
        let e = {
          text: i.chartSetComputed.titleLabel.text,
          fill: oe(i.chartSetComputed.titleLabel.color),
          fontSize: i.chartSetComputed.titleLabel.fontSize,
          fontWeight: i.chartSetComputed.titleLabel.fontWeight,
          textAlign: i.chartSetComputed.titleLabel.textAlign,
          x: Ce(i.chartSetComputed.titleLabel.x),
          centerX: Ce(i.chartSetComputed.titleLabel.centerX),
          paddingTop: i.chartSetComputed.titleLabel.paddingTop,
          paddingBottom: i.chartSetComputed.titleLabel.paddingBottom
        };
        this.chartTitle || (this.chartTitle = this.chart.children.push(
          We.new(i.root, { ...e })
        )), this.chartTitle.setAll({ ...e });
      }
    },
    setChartContainer() {
      this.logTest && (this.logTest && console.log("setChartContainer"), this.logTest && console.log("this.chart: ", this.chart));
      const i = this;
      (!this.chart || this.chart.isDisposed()) && (this.chart = tr.new(i.root, {
        focusable: !1,
        maxTooltipDistance: -1,
        maxTooltipDistanceBy: "xy",
        panX: i.chartSetComputed.panX,
        panY: i.chartSetComputed.panY,
        wheelX: i.chartSetComputed.wheelX,
        wheelY: i.chartSetComputed.wheelY,
        layout: i.root[i.chartSetComputed.chartLayout],
        paddingTop: 0
      }), this.logTest && console.log("this.chart.plotContainer: ", this.chart.plotContainer), this.root.container.children.push(this.chart), this.logTest && console.log("2222")), this.chartSetComputed.isYAxesPlotContainerVisible || (this.chart.yAxesAndPlotContainer.set("forceHidden", !0), this.chart.yAxesAndPlotContainer.set("height", 0)), this.chartSetComputed.isBottomAxesContainerVisible || (this.chart.bottomAxesContainer.set("forceHidden", !0), this.chart.bottomAxesContainer.set("height", 0));
    },
    setContainer() {
      this.logTest && console.log("setContainer"), this.setChartContainer(), this.setChartTitle();
    },
    getTooltipText(i) {
      let e = { labelHTML: this.tooltipHTML };
      return i.tooltipHTML && (e = { labelHTML: i.tooltipHTML }), e;
    },
    setTooltip(i, e) {
      this.logTest && console.log("setTooltip"), this.logTest && console.log("tooltip: ", i), this.logTest && console.log("strokeColor: ", e), i.get("background").setAll({
        fill: oe("#fff"),
        fillOpacity: 0.9,
        strokeWidth: 2,
        stroke: e
      }), i.setAll({
        pointerOrientation: "horizontal"
      });
    },
    setCandlestickSeries(i = 0) {
      var e, t, s, r, n, a, o, l, u;
      if (this.root && this.xAxis && this.yAxisList[i] && this.candlestickDataBinder && this.candlestickDataBinder.length > 0) {
        let c = {
          tooltip: At.new(this.root, {}),
          name: (e = this.candlestickDataBinder) == null ? void 0 : e.displayName,
          openValueYField: (s = (t = this.candlestickDataBinder) == null ? void 0 : t.openValue) == null ? void 0 : s.key,
          highValueYField: (n = (r = this.candlestickDataBinder) == null ? void 0 : r.highValue) == null ? void 0 : n.key,
          lowValueYField: (o = (a = this.candlestickDataBinder) == null ? void 0 : a.lowValue) == null ? void 0 : o.key,
          valueYField: (u = (l = this.candlestickDataBinder) == null ? void 0 : l.defaultValue) == null ? void 0 : u.key,
          categoryXField: this.category
        };
        this.setCandlestickSeriesChart(c), this.setCandlestickSeriesXScrollbar(c);
      }
    },
    setCandlestickSeriesChart(i, e = 0) {
      var t, s, r, n, a, o, l, u, h, c;
      this.candlestickSeries = Zi.new(this.root, {
        xAxis: this.xAxis,
        yAxis: this.yAxisList[e],
        ...i
      }), this.xySeries = this.chart.series.push(this.candlestickSeries), this.candlestickSeries.columns.template.setAll({
        width: 30
      }), this.candlestickSeries.columns.template.states.create("riseFromOpen", {
        fill: oe(this.candlestickSetComputed.riseColor),
        stroke: oe(this.candlestickSetComputed.riseColor)
      }), this.candlestickSeries.columns.template.states.create("dropFromOpen", {
        fill: oe(this.candlestickSetComputed.dropColor),
        stroke: oe(this.candlestickSetComputed.dropColor)
      }), this.candlestickSeries.get("tooltip").label.set(
        "text",
        `${(s = (t = this.candlestickDataBinder) == null ? void 0 : t.openValue) == null ? void 0 : s.displayName}: {openValueY}
${(n = (r = this.candlestickDataBinder) == null ? void 0 : r.highValue) == null ? void 0 : n.displayName}: {highValueY}
${(o = (a = this.candlestickDataBinder) == null ? void 0 : a.lowValue) == null ? void 0 : o.displayName}: {lowValueY}
${(u = (l = this.candlestickDataBinder) == null ? void 0 : l.defaultValue) == null ? void 0 : u.displayName}: {valueY}`
      ), this.candlestickSeries.columns.template.setAll({
        userData: {
          chartType: "candlestick",
          category: this.category,
          value: (c = (h = this.candlestickDataBinder) == null ? void 0 : h.defaultValue) == null ? void 0 : c.key
        }
      }), this.candlestickSeries.columns.template.events.on(
        "click",
        this.chartItemClickHandler
      ), this.candlestickSeries.data.setAll(this.data), this.setLegend();
    },
    setCandlestickSeriesXScrollbar(i) {
      this.xScrollbarSetComputed.isDetailed && !this.xScrollbarSetComputed.detail.mainValue.key && (this.xScrollbarCandlestickSeries = Zi.new(
        this.root,
        {
          xAxis: this.xScrollbarXAxis,
          yAxis: this.xScrollbarYAxis,
          ...i
        }
      ), this.xScrollbar.chart.series.push(this.xScrollbarCandlestickSeries), this.xScrollbarCandlestickSeries.columns.template.states.create(
        "riseFromOpen",
        {
          fill: oe(this.candlestickSetComputed.riseColor),
          stroke: oe(this.candlestickSetComputed.riseColor)
        }
      ), this.xScrollbarCandlestickSeries.columns.template.states.create(
        "dropFromOpen",
        {
          fill: oe(this.candlestickSetComputed.dropColor),
          stroke: oe(this.candlestickSetComputed.dropColor)
        }
      ), this.xScrollbarCandlestickSeries.data.setAll(this.data));
    },
    setLegend() {
      this.logTest && console.log("setLegend");
      const i = this;
      this.legendSetComputed.isVisible && ((!this.legend || this.legend.isDisposed()) && (this.legend = Js.new(i.root, {
        x: Ce(Number(i.legendSetComputed.x)),
        centerX: Ce(Number(i.legendSetComputed.centerX)),
        y: Ce(Number(i.legendSetComputed.y)),
        centerY: Ce(Number(i.legendSetComputed.centerY)),
        layout: bi.new(i.root, {
          maxColumns: i.legendSetComputed.maxColumns,
          fixedWidthGrid: !1
        }),
        height: 50,
        verticalScrollbar: yi.new(i.root, {
          orientation: "vertical"
        }),
        nameField: "name",
        fillField: "fill",
        strokeField: "stroke",
        clickTarget: "itemContainer",
        // 'itemContainer'(default), 'marker', 'none'
        useDefaultMarker: !1
        // false(default), true, undefined
      }), this.chart.children.push(this.legend)), this.legend.data.setAll(this.chart.series.values), i.setCustomLegend && i.setCustomLegend(oh, i));
    }
  },
  beforeUnmount() {
    this.logTest && console.log("xy-chart beforeDestroy"), this.root && (this.logTest && console.log("root dispose"), this.root.dispose());
  },
  unmounted() {
    this.logTest && console.log("xy-chart destroyed");
  }
}, mh = {};
var TS = /* @__PURE__ */ te(
  PS,
  SS,
  DS,
  !1,
  kS,
  "5bc59446",
  null,
  null
);
function kS(i) {
  for (let e in mh)
    this[e] = mh[e];
}
const CS = /* @__PURE__ */ function() {
  return TS.exports;
}();
var MS = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", [t("xy-chart", {
    key: 1e3,
    ref: "defaultXYChart",
    attrs: {
      "data-start-point": i.dataStartPoint,
      "data-end-point": i.dataEndPoint,
      "set-data-start-point": i.setDataStartPoint,
      "set-data-end-point": i.setDataEndPoint,
      "time-scale": i.timeScale,
      "style-props": "width: 100%; height: 110px",
      "chart-set": i.overallChartSetComputed,
      "bar-set": i.barSetComputed,
      "bubble-set": i.bubbleSetComputed,
      "line-set": i.lineSetComputed,
      "candlestick-set": i.candlestickSetComputed,
      "legend-set": i.overallLegendSetComputed,
      "x-scrollbar-set": i.xScrollbarSetComputed,
      "set-selection-min": i.setSelectionMin,
      "set-selection-max": i.setSelectionMax,
      "selection-min": i.selectionMin,
      "selection-max": i.selectionMax,
      "pan-handler": i.overallPanHandler,
      "chart-item-click-handler": i.chartItemClickHandler,
      data: i.overallData,
      category: i.category,
      "bubble-data-binder": i.bubbleDataBinder,
      "line-data-binder": i.lineDataBinder,
      "bar-data-binder": i.barDataBinder,
      "candlestick-data-binder": i.candlestickDataBinder,
      "axis-data-binder": i.axisDataBinder,
      "x-scrollbar-x-axis-label-text-adapter": i.xScrollbarXAxisLabelTextAdapter
    }
  }), t("xy-chart", {
    key: 2e3,
    ref: "overallXYChart",
    attrs: {
      "data-start-point": i.dataStartPoint,
      "data-end-point": i.dataEndPoint,
      "set-data-start-point": i.setDataStartPoint,
      "set-data-end-point": i.setDataEndPoint,
      "time-scale": i.timeScale,
      "chart-set": i.defaultChartSetComputed,
      "get-wheel-cursor-position-x": i.getWheelCursorPositionX,
      "zoom-handler": i.defaultZoomHandler,
      "pan-handler": i.defaultPanHandler,
      "bar-set": i.barSetComputed,
      "bubble-set": i.bubbleSetComputed,
      "line-set": i.lineSetComputed,
      "candlestick-set": i.candlestickSetComputed,
      "legend-set": i.legendSetComputed,
      "style-props": i.styleProps,
      "set-selection-min": i.setSelectionMin,
      "set-selection-max": i.setSelectionMax,
      "selection-min": i.selectionMin,
      "selection-max": i.selectionMax,
      "chart-item-click-handler": i.chartItemClickHandler,
      category: i.category,
      "bubble-data-binder": i.bubbleDataBinder,
      "line-data-binder": i.lineDataBinder,
      "bar-data-binder": i.barDataBinder,
      "candlestick-data-binder": i.candlestickDataBinder,
      "axis-data-binder": i.axisDataBinder,
      "x-axis-grid-stroke-opacity-adapter": i.xAxisGridStrokeOpacityAdapter,
      "x-axis-label-text-adapter": i.xAxisLabelTextAdapter,
      "x-axis-tooltip-label-text-adapter": i.xAxisTooltipLabelTextAdapter,
      "series-tooltip-label-html-adapter": i.seriesTooltipLabelHtmlAdapter,
      "series-tooltip-force-hidden-adapter": i.seriesTooltipForceHiddenAdapter
    },
    model: {
      value: i.defaultData,
      callback: function(s) {
        i.defaultData = s;
      },
      expression: "defaultData"
    }
  })], 1);
}, OS = [];
const AS = {
  name: "OverallXYChart",
  components: {
    "xy-chart": CS
  },
  watch: {
    dataStartPoint: {
      handler(i) {
        console.log("watch dataStartPoint 22: ", i);
      }
    },
    dataEndPoint: {
      handler(i) {
        console.log("watch dataEndPoint 22: ", i);
      }
    },
    xScrollbarSetComputed: {
      handler(i, e) {
        this.logTest && console.log("watch overall-xy-chart xScrollbarSetComputed"), this.logTest && console.log(i), this.logTest && console.log(e);
      },
      deep: !0
    },
    "xScrollbarSetComputed.detail.mainValue.displayName": {
      handler(i, e) {
        this.logTest && console.log(
          "watch overall-xy-chart xScrollbarSetComputed.detail.mainValue.displayName"
        ), this.logTest && console.log(i), this.logTest && console.log(e);
      }
    },
    defaultData: {
      handler() {
        this.logTest && console.log("watch defaultData: ", this.defaultData);
      },
      immediate: !0,
      deep: !0
    },
    overallData: {
      handler() {
        this.logTest && console.log("watch overallData: ", this.overallData);
      },
      immediate: !0,
      deep: !0
    }
  },
  computed: {
    defaultChartSetComputed() {
      return Fe(this.defaultChartSetData, this.defaultChartSet);
    },
    overallChartSetComputed() {
      return Fe(this.overallChartSetData, this.overallChartSet);
    },
    barSetComputed() {
      return Fe(this.barSetData, this.barSet);
    },
    bubbleSetComputed() {
      return Fe(this.bubbleSetData, this.bubbleSet);
    },
    lineSetComputed() {
      return Fe(this.lineSetData, this.lineSet);
    },
    candlestickSetComputed() {
      return Fe(this.candlestickSetData, this.candlestickSet);
    },
    legendSetComputed() {
      return Fe(this.defaultLegendSetData, this.defaultLegendSet);
    },
    overallLegendSetComputed() {
      return Fe(this.overallLegendSetData, this.overallLegendSet);
    },
    xScrollbarSetComputed() {
      return Fe(this.xScrollbarSetData, this.xScrollbarSet);
    }
  },
  data() {
    return {
      logTest: !1,
      candlestickSetData: {
        riseColor: "#ff0000",
        dropColor: "#0000ff"
      },
      lineSetData: {
        isLineVisible: !1,
        strokeWidth: 2,
        fillOpacity: 0.1,
        bullet: {
          strokeWidth: 2,
          radius: 3
        },
        colorList: [
          "#f08080",
          "#fa8072",
          "#e9967a",
          "#ff7f50",
          "#ff6347",
          "#f4a460",
          "#ffa07a"
        ]
      },
      bubbleSetData: {
        strokeWidth: 2,
        bullet: {
          strokeWidth: 2,
          radius: 3
        },
        colorList: [
          "#f08080",
          "#fa8072",
          "#e9967a",
          "#ff7f50",
          "#ff6347",
          "#f4a460",
          "#ffa07a"
        ]
      },
      barSetData: {
        isStacked: !1,
        isClustered: !1,
        width: 15,
        strokeWidth: 1.5,
        fillOpacity: 0.3,
        cornerRadius: {
          topLeft: 0,
          topRight: 0
        },
        colorList: [
          "#BCE2C7",
          "#4EBCD5",
          "#1A2281",
          "#4169e1",
          "#1e90ff",
          "#0000cd",
          "#000080"
        ]
      },
      overallLegendSetData: {
        isVisible: !1,
        layout: "gridLayout",
        x: 50,
        centerX: 50,
        y: 100,
        centerY: 100
      },
      overallChartSetData: {
        refProps: "overallXYChart",
        id: "overallXYChart",
        chartType: "overall",
        titleLabel: {
          text: "",
          fontSize: 12,
          fontWeight: "normal",
          textAlign: "center",
          x: 5,
          centerX: 0,
          paddingTop: 0,
          paddingBottom: 0,
          color: "#555"
        },
        isZoomOutButton: !1,
        isYAxesPlotContainerVisible: !1,
        isBottomAxesContainerVisible: !1,
        chartLayout: "verticalLayout",
        panX: !0,
        panY: !1,
        wheelX: "",
        wheelY: "zoomX"
      },
      xScrollbarSetData: {
        isVisible: !0,
        isDown: !1,
        gripScale: 0.9,
        isStartGrip: !1,
        isEndGrip: !1,
        // startPosition: 0.2,
        // endPosition: 0.8,
        startPosition: 0,
        endPosition: 1,
        thumb: { fill: "#550000", fillOpacity: 0.05 },
        isDetailed: !0,
        detail: {
          isVisible: !0,
          height: 50,
          mainValue: { key: "", displayName: "" },
          line: { color: "#fb9f57", strokeWidth: 2, fillOpacity: 0.2 },
          background: {
            fill: "#000000",
            fillOpacity: 0.05,
            cornerRadius: {
              topLeft: 0,
              topRight: 10,
              bottomLeft: 10,
              bottomRight: 10
            }
          }
        }
      },
      defaultLegendSetData: {
        isVisible: !0,
        layout: "gridLayout",
        x: 50,
        centerX: 50,
        y: 100,
        centerY: 100
      },
      defaultChartSetData: {
        refProps: "defaultXYChart",
        id: "defaultXYChart",
        chartType: "default",
        titleLabel: {
          text: "",
          fontSize: 12,
          fontWeight: "normal",
          textAlign: "center",
          x: 5,
          centerX: 0,
          paddingTop: 0,
          paddingBottom: 0,
          color: "#555"
        },
        isZoomOutButton: !1,
        isYAxesPlotContainerVisible: !0,
        isBottomAxesContainerVisible: !0,
        chartLayout: "verticalLayout",
        panX: !0,
        panY: !1,
        wheelX: "",
        wheelY: "zoomX"
      }
    };
  },
  props: {
    // new
    dataStartPoint: String,
    dataEndPoint: String,
    setDataStartPoint: Function,
    setDataEndPoint: Function,
    getWheelCursorPositionX: Function,
    xAxisGridStrokeOpacityAdapter: Function,
    xAxisLabelTextAdapter: Function,
    xAxisTooltipLabelTextAdapter: Function,
    seriesTooltipLabelHtmlAdapter: Function,
    xScrollbarXAxisLabelTextAdapter: Function,
    seriesTooltipForceHiddenAdapter: Function,
    // data binder
    axisDataBinder: Object,
    styleProps: {
      type: String,
      default: "height: 400px; width: 100%; min-width: 800px;"
    },
    // chart ui common settings
    candlestickSet: Object,
    lineSet: Object,
    bubbleSet: Object,
    barSet: Object,
    // common
    setSelectionMin: Function,
    setSelectionMax: Function,
    selectionMin: [String, Number],
    selectionMax: [String, Number],
    timeScale: String,
    xScrollbarSet: Object,
    // default
    defaultChartSet: Object,
    defaultLegendSet: Object,
    defaultZoomHandler: Function,
    defaultPanHandler: Function,
    // overall
    overallChartSet: Object,
    overallLegendSet: Object,
    overallZoomHandler: Function,
    overallPanHandler: Function,
    // data settings
    defaultData: Array,
    overallData: Array,
    category: String,
    bubbleDataBinder: Array,
    lineDataBinder: Array,
    barDataBinder: Array,
    candlestickDataBinder: Array,
    chartItemClickHandler: Function
  },
  // methods: {
  //   setDataStartPoint(result) {
  //     console.log("setDataStartPoint: ", result);
  //     this.dataStartPoint = result;
  //   },
  //   setDataEndPoint(result) {
  //     console.log("setDataEndPoint: ", result);
  //     this.dataEndPoint = result;
  //   },
  // },
  mounted() {
    this.logTest && console.log("overall-xy-chart mounted"), this.logTest && console.log("defaultData: ", this.defaultData), this.logTest && console.log("overallData: ", this.overallData);
  }
}, _h = {};
var LS = /* @__PURE__ */ te(
  AS,
  MS,
  OS,
  !1,
  jS,
  null,
  null,
  null
);
function jS(i) {
  for (let e in _h)
    this[e] = _h[e];
}
const tA = /* @__PURE__ */ function() {
  return LS.exports;
}();
class ES extends dr {
  setupDefaultRules() {
    super.setupDefaultRules();
    const e = this._root.interfaceColors, t = this.rule.bind(this);
    t("PercentSeries").setAll({
      legendLabelText: "{category}",
      legendValueText: "{valuePercentTotal.formatNumber('0.00p')}",
      colors: ws.new(this._root, {}),
      width: R,
      height: R
    }), t("PieChart").setAll({
      radius: Ce(80),
      startAngle: -90,
      endAngle: 270
    }), t("PieSeries").setAll({
      alignLabels: !0,
      startAngle: -90,
      endAngle: 270
    }), t("PieSeries").states.create("hidden", { endAngle: -90, opacity: 0 }), t("Slice", ["pie"]).setAll({
      position: "absolute",
      isMeasured: !1,
      x: 0,
      y: 0,
      toggleKey: "active",
      tooltipText: "{category}: {valuePercentTotal.formatNumber('0.00p')}",
      strokeWidth: 1,
      strokeOpacity: 1,
      role: "figure",
      lineJoin: "round"
    }), t("Slice", ["pie"]).states.create("active", { shiftRadius: 20, scale: 1 }), t("Slice", ["pie"]).states.create("hoverActive", { scale: 1.04 }), t("Slice", ["pie"]).states.create("hover", { scale: 1.04 }), t("RadialLabel", ["pie"]).setAll({
      textType: "aligned",
      radius: 10,
      text: "{category}: {valuePercentTotal.formatNumber('0.00p')}",
      paddingTop: 5,
      paddingBottom: 5,
      populateText: !0
    }), t("Tick", ["pie"]).setAll({
      location: 1
    }), t("SlicedChart").setAll({
      paddingLeft: 10,
      paddingRight: 10,
      paddingTop: 10,
      paddingBottom: 10
    }), t("FunnelSeries").setAll({
      startLocation: 0,
      endLocation: 1,
      orientation: "vertical",
      alignLabels: !0,
      sequencedInterpolation: !0
    }), t("FunnelSlice").setAll({
      interactive: !0,
      expandDistance: 0
      //tooltipText: "{category}: {valuePercentTotal.formatNumber('0.00p')}"
    }), t("FunnelSlice").states.create("hover", { expandDistance: 0.15 }), t("Label", ["funnel"]).setAll({
      populateText: !0,
      text: "{category}: {valuePercentTotal.formatNumber('0.00p')}",
      centerY: ie
    }), t("Label", ["funnel", "horizontal"]).setAll({
      centerX: 0,
      centerY: ie,
      rotation: -90
    }), t("Label", ["funnel", "vertical"]).setAll({
      centerY: ie,
      centerX: 0
    }), t("Tick", ["funnel"]).setAll({
      location: 1
    }), t("FunnelSlice", ["funnel", "link"]).setAll({
      fillOpacity: 0.5,
      strokeOpacity: 0,
      expandDistance: -0.1
    }), t("FunnelSlice", ["funnel", "link", "vertical"]).setAll({
      height: 10
    }), t("FunnelSlice", ["funnel", "link", "horizontal"]).setAll({
      width: 10
    }), t("PyramidSeries").setAll({
      valueIs: "area"
    }), t("FunnelSlice", ["pyramid", "link"]).setAll({
      fillOpacity: 0.5
    }), t("FunnelSlice", ["pyramid", "link", "vertical"]).setAll({
      height: 0
    }), t("FunnelSlice", ["pyramid", "link", "horizontal"]).setAll({
      width: 0
    }), t("FunnelSlice", ["pyramid"]).setAll({
      interactive: !0,
      expandDistance: 0
    }), t("FunnelSlice", ["pyramid"]).states.create("hover", { expandDistance: 0.15 }), t("Label", ["pyramid"]).setAll({
      populateText: !0,
      text: "{category}: {valuePercentTotal.formatNumber('0.00p')}",
      centerY: ie
    }), t("Label", ["pyramid", "horizontal"]).setAll({
      centerX: 0,
      centerY: ie,
      rotation: -90
    }), t("Label", ["pyramid", "vertical"]).setAll({
      centerY: ie,
      centerX: 0
    }), t("Tick", ["pyramid"]).setAll({
      location: 1
    }), t("FunnelSlice", ["pictorial"]).setAll({
      interactive: !0,
      tooltipText: "{category}: {valuePercentTotal.formatNumber('0.00p')}"
    }), t("Label", ["pictorial"]).setAll({
      populateText: !0,
      text: "{category}: {valuePercentTotal.formatNumber('0.00p')}",
      centerY: ie
    }), t("Label", ["pictorial", "horizontal"]).setAll({
      centerX: 0,
      centerY: ie,
      rotation: -90
    }), t("Label", ["pictorial", "vertical"]).setAll({
      centerY: ie,
      centerX: 0
    }), t("FunnelSlice", ["pictorial", "link"]).setAll({
      fillOpacity: 0.5,
      width: 0,
      height: 0
    }), t("Tick", ["pictorial"]).setAll({
      location: 0.5
    });
    {
      const s = t("Graphics", ["pictorial", "background"]);
      s.setAll({
        fillOpacity: 0.2
      }), K(s, "fill", e, "alternativeBackground");
    }
  }
}
class tn extends Bi {
  _afterNew() {
    this._defaultThemes.push(ES.new(this._root)), super._afterNew(), this.chartContainer.children.push(this.seriesContainer), this.seriesContainer.children.push(this.bulletsContainer);
  }
  _processSeries(e) {
    super._processSeries(e), this.seriesContainer.children.moveValue(this.bulletsContainer, this.seriesContainer.children.length - 1);
  }
}
Object.defineProperty(tn, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "PercentChart"
});
Object.defineProperty(tn, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Bi.classNames.concat([tn.className])
});
class sn extends ai {
  constructor() {
    super(...arguments), Object.defineProperty(this, "slicesContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.children.push(Z.new(this._root, { position: "absolute", isMeasured: !1 }))
    }), Object.defineProperty(this, "labelsContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.children.push(Z.new(this._root, { position: "absolute", isMeasured: !1 }))
    }), Object.defineProperty(this, "ticksContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.children.push(Z.new(this._root, { position: "absolute", isMeasured: !1 }))
    }), Object.defineProperty(this, "_lLabels", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_rLabels", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_hLabels", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "slices", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._makeSlices()
    }), Object.defineProperty(this, "labels", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._makeLabels()
    }), Object.defineProperty(this, "ticks", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._makeTicks()
    });
  }
  /**
   * @ignore
   */
  makeSlice(e) {
    const t = this.slicesContainer.children.push(this.slices.make());
    return t.on("fill", () => {
      this.updateLegendMarker(e);
    }), t.on("stroke", () => {
      this.updateLegendMarker(e);
    }), t._setDataItem(e), e.set("slice", t), this.slices.push(t), t;
  }
  /**
   * @ignore
   */
  makeLabel(e) {
    const t = this.labelsContainer.children.push(this.labels.make());
    return t._setDataItem(e), e.set("label", t), this.labels.push(t), t;
  }
  _shouldMakeBullet(e) {
    return e.get("value") != null;
  }
  /**
   * @ignore
   */
  makeTick(e) {
    const t = this.ticksContainer.children.push(this.ticks.make());
    return t._setDataItem(e), e.set("tick", t), this.ticks.push(t), t;
  }
  _afterNew() {
    this.fields.push("category", "fill"), super._afterNew();
  }
  _onDataClear() {
    const e = this.get("colors");
    e && e.reset();
  }
  _prepareChildren() {
    if (super._prepareChildren(), this._lLabels = [], this._rLabels = [], this._hLabels = [], this._valuesDirty) {
      let e = 0, t = 0, s = 0, r = 1 / 0, n = 0;
      x(this._dataItems, (a) => {
        let o = a.get("valueWorking", 0);
        e += o, t += Math.abs(o);
      }), x(this._dataItems, (a) => {
        let o = a.get("valueWorking", 0);
        o > s && (s = o), o < r && (r = o), n++;
        let l = o / t;
        t == 0 && (l = 0), a.setRaw("valuePercentTotal", l * 100);
      }), this.setPrivateRaw("valueLow", r), this.setPrivateRaw("valueHigh", s), this.setPrivateRaw("valueSum", e), this.setPrivateRaw("valueAverage", e / n), this.setPrivateRaw("valueAbsoluteSum", t);
    }
  }
  /**
   * Shows hidden series.
   *
   * @param   duration  Animation duration in milliseconds
   * @return            Animation promise
   */
  show(e) {
    const t = Object.create(null, {
      show: { get: () => super.show }
    });
    return Ue(this, void 0, void 0, function* () {
      let s = [];
      s.push(t.show.call(this, e)), s.push(this._sequencedShowHide(!0, e)), yield Promise.all(s);
    });
  }
  /**
   * Hide whole series.
   *
   * @param   duration  Animation duration in milliseconds
   * @return            Animation promise
   */
  hide(e) {
    const t = Object.create(null, {
      hide: { get: () => super.hide }
    });
    return Ue(this, void 0, void 0, function* () {
      let s = [];
      s.push(t.hide.call(this, e)), s.push(this._sequencedShowHide(!1, e)), yield Promise.all(s);
    });
  }
  /**
   * @ignore
   */
  _updateChildren() {
    super._updateChildren(), this._valuesDirty && x(this._dataItems, (e) => {
      e.get("label").text.markDirtyText();
    }), (this.isDirty("legendLabelText") || this.isDirty("legendValueText")) && x(this._dataItems, (e) => {
      this.updateLegendValue(e);
    }), this._arrange();
  }
  _arrange() {
    this._arrangeDown(this._lLabels), this._arrangeUp(this._lLabels), this._arrangeDown(this._rLabels), this._arrangeUp(this._rLabels), this._arrangeLeft(this._hLabels), this._arrangeRight(this._hLabels), x(this.dataItems, (e) => {
      this._updateTick(e);
    });
  }
  _afterChanged() {
    super._afterChanged(), this._arrange();
  }
  processDataItem(e) {
    if (super.processDataItem(e), e.get("fill") == null) {
      let t = this.get("colors");
      t && e.setRaw("fill", t.next());
    }
  }
  /**
   * Shows series's data item.
   *
   * @param   dataItem  Data item
   * @param   duration  Animation duration in milliseconds
   * @return            Promise
   */
  showDataItem(e, t) {
    const s = Object.create(null, {
      showDataItem: { get: () => super.showDataItem }
    });
    return Ue(this, void 0, void 0, function* () {
      const r = [s.showDataItem.call(this, e, t)];
      S(t) || (t = this.get("stateAnimationDuration", 0));
      const n = this.get("stateAnimationEasing");
      let a = e.get("value");
      const o = e.animate({ key: "valueWorking", to: a, duration: t, easing: n });
      o && r.push(o.waitForStop());
      const l = e.get("tick");
      l && r.push(l.show(t));
      const u = e.get("label");
      u && r.push(u.show(t));
      const h = e.get("slice");
      h && r.push(h.show(t)), h.get("active") && h.states.applyAnimate("active"), yield Promise.all(r);
    });
  }
  /**
   * Hides series's data item.
   *
   * @param   dataItem  Data item
   * @param   duration  Animation duration in milliseconds
   * @return            Promise
   */
  hideDataItem(e, t) {
    const s = Object.create(null, {
      hideDataItem: { get: () => super.hideDataItem }
    });
    return Ue(this, void 0, void 0, function* () {
      const r = [s.hideDataItem.call(this, e, t)], n = this.states.create("hidden", {});
      S(t) || (t = n.get("stateAnimationDuration", this.get("stateAnimationDuration", 0)));
      const a = n.get("stateAnimationEasing", this.get("stateAnimationEasing")), o = e.animate({ key: "valueWorking", to: 0, duration: t, easing: a });
      o && r.push(o.waitForStop());
      const l = e.get("tick");
      l && r.push(l.hide(t));
      const u = e.get("label");
      u && r.push(u.hide(t));
      const h = e.get("slice");
      h.hideTooltip(), h && r.push(h.hide(t)), yield Promise.all(r);
    });
  }
  /**
   * @ignore
   */
  disposeDataItem(e) {
    super.disposeDataItem(e);
    let t = e.get("label");
    t && (this.labels.removeValue(t), t.dispose());
    let s = e.get("tick");
    s && (this.ticks.removeValue(s), s.dispose());
    let r = e.get("slice");
    r && (this.slices.removeValue(r), r.dispose());
  }
  /**
   * Triggers hover on a series data item.
   *
   * @since 5.0.7
   * @param  dataItem  Target data item
   */
  hoverDataItem(e) {
    const t = e.get("slice");
    t && !t.isHidden() && t.hover();
  }
  /**
   * Triggers un-hover on a series data item.
   *
   * @since 5.0.7
   * @param  dataItem  Target data item
   */
  unhoverDataItem(e) {
    const t = e.get("slice");
    t && t.unhover();
  }
  /**
   * @ignore
   */
  updateLegendMarker(e) {
    const t = e.get("slice");
    if (t) {
      const s = e.get("legendDataItem");
      if (s) {
        const r = s.get("markerRectangle");
        x(Od, (n) => {
          t.get(n) != null && r.set(n, t.get(n));
        });
      }
    }
  }
  _arrangeDown(e) {
    if (e) {
      let t = this._getNextDown();
      e.sort((s, r) => s.y > r.y ? 1 : s.y < r.y ? -1 : 0), x(e, (s) => {
        const r = s.label.adjustedLocalBounds();
        let n = r.top;
        s.y + n < t && (s.y = t - n), s.label.set("y", s.y), t = s.y + r.bottom;
      });
    }
  }
  _getNextUp() {
    return this.labelsContainer.maxHeight();
  }
  _getNextDown() {
    return 0;
  }
  _arrangeUp(e) {
    if (e) {
      let t = this._getNextUp();
      e.sort((s, r) => s.y < r.y ? 1 : s.y > r.y ? -1 : 0), x(e, (s) => {
        const r = s.label.adjustedLocalBounds();
        let n = r.bottom;
        s.y + n > t && (s.y = t - n), s.label.set("y", s.y), t = s.y + r.top;
      });
    }
  }
  _arrangeRight(e) {
    if (e) {
      let t = 0;
      e.sort((s, r) => s.y > r.y ? 1 : s.y < r.y ? -1 : 0), x(e, (s) => {
        const r = s.label.adjustedLocalBounds();
        let n = r.left;
        s.y + n < t && (s.y = t - n), s.label.set("x", s.y), t = s.y + r.right;
      });
    }
  }
  _arrangeLeft(e) {
    if (e) {
      let t = this.labelsContainer.maxWidth();
      e.sort((s, r) => s.y < r.y ? 1 : s.y > r.y ? -1 : 0), x(e, (s) => {
        const r = s.label.adjustedLocalBounds();
        let n = r.right;
        s.y + n > t && (s.y = t - n), s.label.set("x", s.y), t = s.y + r.left;
      });
    }
  }
  _updateSize() {
    super._updateSize(), this.markDirty();
  }
  _updateTick(e) {
  }
  _dispose() {
    super._dispose();
    const e = this.chart;
    e && e.series.removeValue(this);
  }
}
Object.defineProperty(sn, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "PercentSeries"
});
Object.defineProperty(sn, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: ai.classNames.concat([sn.className])
});
class Oa extends tn {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_maxRadius", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    });
  }
  _afterNew() {
    super._afterNew(), this.seriesContainer.setAll({ x: ie, y: ie });
  }
  _prepareChildren() {
    super._prepareChildren();
    const e = this.chartContainer, t = e.innerWidth(), s = e.innerHeight(), r = this.get("startAngle", 0), n = this.get("endAngle", 0), a = this.get("innerRadius");
    let o = aa(0, 0, r, n, 1);
    const l = t / (o.right - o.left), u = s / (o.bottom - o.top);
    let h = { left: 0, right: 0, top: 0, bottom: 0 };
    if (a instanceof ne) {
      let f = a.value, g = Math.min(l, u);
      f = Math.max(g * f, g - Math.min(s, t)) / g, h = aa(0, 0, r, n, f), this.setPrivateRaw("irModifyer", f / a.value);
    }
    o = Sd([o, h]);
    const c = this._maxRadius;
    this._maxRadius = Math.min(l, u);
    const d = we(this.get("radius", 0), this._maxRadius);
    this.seriesContainer.setAll({
      dy: -d * (o.bottom + o.top) / 2,
      dx: -d * (o.right + o.left) / 2
    }), (this.isDirty("startAngle") || this.isDirty("endAngle") || c != this._maxRadius) && this.series.each((f) => {
      f._markDirtyKey("startAngle");
    }), (this.isDirty("innerRadius") || this.isDirty("radius")) && this.series.each((f) => {
      f._markDirtyKey("innerRadius");
    });
  }
  /**
   * Returns outer radius in pixels.
   *
   * If optional series parameter is passed in, it will return outer radius
   * of that particular series.
   *
   * @param   series  Series
   * @return          Radius in pixels
   */
  radius(e) {
    let t = we(this.get("radius", 0), this._maxRadius), s = we(this.get("innerRadius", 0), t);
    if (e) {
      let r = this.series.indexOf(e), n = this.series.length, a = e.get("radius");
      return a != null ? s + we(a, t - s) : s + (t - s) / n * (r + 1);
    }
    return t;
  }
  /**
   * Returns inner radius in pixels.
   *
   * If optional series parameter is passed in, it will return inner radius
   * of that particular series.
   *
   * @param   series  Series
   * @return          Radius in pixels
   */
  innerRadius(e) {
    const t = this.radius();
    let s = we(this.get("innerRadius", 0), t);
    if (s < 0 && (s = t + s), e) {
      let r = this.series.indexOf(e), n = this.series.length, a = e.get("innerRadius");
      return a != null ? s + we(a, t - s) : s + (t - s) / n * r;
    }
    return s;
  }
}
Object.defineProperty(Oa, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "PieChart"
});
Object.defineProperty(Oa, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: tn.classNames.concat([Oa.className])
});
class Aa extends sn {
  _makeSlices() {
    return new Ae(ge.new({}), () => Gr._new(this._root, {
      themeTags: se(this.slices.template.get("themeTags", []), ["pie", "series"])
    }, [this.slices.template]));
  }
  _makeLabels() {
    return new Ae(ge.new({}), () => vs._new(this._root, {
      themeTags: se(this.labels.template.get("themeTags", []), ["pie", "series"])
    }, [this.labels.template]));
  }
  _makeTicks() {
    return new Ae(ge.new({}), () => xs._new(this._root, {
      themeTags: se(this.ticks.template.get("themeTags", []), ["pie", "series"])
    }, [this.ticks.template]));
  }
  processDataItem(e) {
    super.processDataItem(e);
    const t = this.makeSlice(e);
    t.on("scale", () => {
      this._updateTick(e);
    }), t.on("shiftRadius", () => {
      this._updateTick(e);
    }), t.events.on("positionchanged", () => {
      this._updateTick(e);
    });
    const s = this.makeLabel(e);
    s.events.on("positionchanged", () => {
      this._updateTick(e);
    }), this.makeTick(e), t.events.on("positionchanged", () => {
      s.markDirty();
    });
  }
  _getNextUp() {
    const e = this.chart;
    return e ? e._maxRadius : this.labelsContainer.maxHeight() / 2;
  }
  _getNextDown() {
    const e = this.chart;
    return e ? -e._maxRadius : -this.labelsContainer.maxHeight() / 2;
  }
  _prepareChildren() {
    super._prepareChildren();
    const e = this.chart;
    if (e) {
      if (this.isDirty("alignLabels")) {
        let t = this.labels.template;
        if (this.get("alignLabels"))
          t.set("textType", "aligned");
        else {
          let s = t.get("textType");
          (s == null || s == "aligned") && t.set("textType", "adjusted");
        }
      }
      if (this._valuesDirty || this.isDirty("radius") || this.isDirty("innerRadius") || this.isDirty("startAngle") || this.isDirty("endAngle") || this.isDirty("alignLabels")) {
        this.markDirtyBounds();
        const t = this.get("startAngle", e.get("startAngle", -90)), r = this.get("endAngle", e.get("endAngle", 270)) - t;
        let n = t;
        const a = e.radius(this);
        this.setPrivateRaw("radius", a);
        let o = e.innerRadius(this) * e.getPrivate("irModifyer", 1);
        o < 0 && (o = a + o), x(this._dataItems, (l) => {
          this.updateLegendValue(l);
          let u = r * l.get("valuePercentTotal") / 100;
          const h = l.get("slice");
          if (h) {
            h.set("radius", a), h.set("innerRadius", o), h.set("startAngle", n), h.set("arc", u);
            const f = l.get("fill");
            h._setDefault("fill", f), h._setDefault("stroke", f);
          }
          let c = _s(n + u / 2);
          const d = l.get("label");
          if (d && (d.setPrivate("radius", a), d.setPrivate("innerRadius", o), d.set("labelAngle", c), d.get("textType") == "aligned")) {
            let f = a + d.get("radius", 0), g = a * qe(c);
            c > 90 && c <= 270 ? (!d.isHidden() && !d.isHiding() && this._lLabels.push({ label: d, y: g }), f *= -1, f -= this.labelsContainer.get("paddingLeft", 0), d.set("centerX", R), d.setPrivateRaw("left", !0)) : (!d.isHidden() && !d.isHiding() && this._rLabels.push({ label: d, y: g }), f += this.labelsContainer.get("paddingRight", 0), d.set("centerX", 0), d.setPrivateRaw("left", !1)), d.set("x", f), d.set("y", a * qe(c));
          }
          n += u, this._updateTick(l);
        });
      }
    }
  }
  _updateTick(e) {
    const t = e.get("tick"), s = e.get("label"), r = e.get("slice"), n = t.get("location", 1);
    if (t && s && r) {
      const a = (r.get("shiftRadius", 0) + r.get("radius", 0)) * r.get("scale", 1) * n, o = s.get("labelAngle", 0), l = ht(o), u = qe(o), h = this.labelsContainer, c = h.get("paddingLeft", 0), d = h.get("paddingRight", 0);
      let f = 0, g = 0;
      if (f = s.x(), g = s.y(), s.get("textType") == "circular") {
        const m = s.radius() - s.get("paddingBottom", 0), _ = s.get("labelAngle", 0);
        f = m * ht(_), g = m * qe(_);
      }
      let p = -d;
      s.getPrivate("left") && (p = c), t.set("points", [{ x: r.x() + a * l, y: r.y() + a * u }, { x: f + p, y: g }, { x: f, y: g }]);
    }
  }
  _positionBullet(e) {
    const t = e.get("sprite");
    if (t) {
      const r = t.dataItem.get("slice");
      if (r) {
        const n = r.get("innerRadius", 0), a = r.get("radius", 0), o = r.get("startAngle", 0), l = r.get("arc", 0), u = e.get("locationX", 0.5), h = e.get("locationY", 0.5), c = o + l * u, d = n + (a - n) * h;
        t.setAll({ x: ht(c) * d, y: qe(c) * d });
      }
    }
  }
}
Object.defineProperty(Aa, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "PieSeries"
});
Object.defineProperty(Aa, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: sn.classNames.concat([Aa.className])
});
var IS = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", [i.data.length === 0 ? t("div", [i._v("no data")]) : t("div", {
    ref: "pieChartDiv",
    style: i.styleProps
  })]);
}, RS = [];
const YS = {
  name: "PieChart",
  props: {
    // new
    chartSet: Object,
    pieSet: Object,
    legendSet: Object,
    // container
    styleProps: {
      type: String,
      default: "width: 100%; height: 400px"
    },
    data: {
      type: Array,
      default: () => []
    },
    pieDataBinder: {
      type: Array,
      default: () => []
    }
  },
  data() {
    return {
      root: "",
      legend: "",
      chart: "",
      series: "",
      chartSetData: {
        chartLayout: "verticalLayout",
        cursor: {
          isAvailable: !1
        },
        refProps: "defaultXYChart",
        id: "defaultXYChart",
        chartType: "default",
        titleLabel: {
          text: "",
          fontSize: 12,
          fontWeight: "normal",
          textAlign: "center",
          x: 5,
          centerX: 0,
          paddingTop: 0,
          paddingBottom: 0,
          color: "#555"
        },
        isZoomOutButton: !1,
        isYAxesPlotContainerVisible: !0,
        isBottomAxesContainerVisible: !0,
        panX: !1,
        panY: !1,
        wheelX: "",
        // 'zoomX', 'zoomY', 'zoomXY', 'panX', 'panY', 'panXY', 'none'
        wheelY: ""
        // 'zoomX', 'zoomY', 'zoomXY', 'panX', 'panY', 'panXY', 'none'
      },
      pieSetData: {
        colorList: ["#095256", "#087f8c", "#5aaa95", "#86a873", "#bb9f06"],
        radius: 100,
        innerRadius: 0,
        startAngle: -90,
        endAngle: 270,
        slices: {
          isToggled: !0,
          borderColor: "#000000",
          borderWidth: 2,
          shiftRadius: 0,
          fillOpacity: 0.5
          // tooltipText:
          // "{category}: [bold]{valuePercentTotal.formatNumber('0.00')}%[/] ({value})",
        },
        label: {
          isAligned: !0,
          isInsided: !0,
          isTextVisibled: !0,
          fill: "#550000",
          text: "{category}",
          textType: "circular",
          radius: 50
        },
        // pie tick
        tick: {
          isVisibled: !0,
          stroke: "#550000",
          strokeWidth: 2,
          location: 0.5
        }
      },
      legendSetData: {
        // legend
        x: 50,
        centerX: 50,
        marginTop: 15,
        marginBottom: 15
      }
    };
  },
  watch: {
    // container
    styleProps() {
      this.resetChart();
    }
  },
  mounted() {
    this.createChart();
  },
  computed: {
    chartSetComputed() {
      let i = Fe(this.chartSetData, this.chartSet);
      return Object.assign({}, i);
    },
    pieSetComputed() {
      let i = Fe(this.pieSetData, this.pieSet);
      return Object.assign({}, i);
    },
    legendSetComputed() {
      let i = Fe(this.legendSetData, this.legendSet);
      return Object.assign({}, i);
    },
    computedPieData() {
      let i = [];
      return this.pieDataBinder.map((e) => {
        i.push({ ...e, value: this.data[0][e.key] });
      }), i;
    }
  },
  methods: {
    createChart() {
      this.root = un.new(this.$refs.pieChartDiv), this.root.setThemes([Jd.new(this.root)]), this.setChartConfig(), this.setSeries(), this.setLegend(this.series), this.series.appear(1e3, 100);
    },
    resetChart() {
      this.root && this.root.dispose(), this.createChart();
    },
    setChartConfig() {
      const i = this;
      this.chart = this.root.container.children.push(
        Oa.new(i.root, {
          layout: i.root[i.chartSetComputed.chartLayout]
        })
      );
    },
    setSeries() {
      this.pieDataBinder.map((i) => {
        this.series = this.chart.series.push(
          Aa.new(this.root, {
            name: "abc",
            categoryField: "displayName",
            valueField: "value",
            radius: Ce(Number(this.pieSetComputed.radius)),
            innerRadius: Ce(Number(this.pieSetComputed.innerRadius)),
            startAngle: Number(this.pieSetComputed.startAngle),
            endAngle: Number(this.pieSetComputed.endAngle),
            alignLabels: this.pieSetComputed.label.isAligned
          })
        );
      }), this.setColor(), this.setSlice(), this.setLabel(), this.setTicks(), this.series.data.setAll(this.computedPieData);
    },
    setColor() {
      let i = [];
      typeof this.pieSetComputed.colorList == "string" && (this.pieSetComputed.colorList = this.pieSetComputed.colorList.split(",")), this.pieSetComputed.colorList.map((e) => {
        i.push(oe(e));
      }), this.series.get("colors").set("colors", [...i]);
    },
    setSlice() {
      this.series.slices.template.setAll({
        shiftRadius: Number(this.pieSetComputed.slices.shiftRadius),
        fillOpacity: Number(this.pieSetComputed.slices.fillOpacity),
        stroke: oe(this.pieSetComputed.slices.borderColor),
        strokeWidth: Number(this.pieSetComputed.slices.borderWidth)
      }), this.pieSetComputed.slices.isToggled || this.series.slices.template.set("toggleKey", "none"), this.series.slices.template.set(
        "tooltipText",
        this.pieSetComputed.slices.tooltipText
      );
    },
    setLabel() {
      this.series.labels.template.setAll({
        // fontSize: 20,
        fill: oe(this.pieSetComputed.label.fill),
        text: this.pieSetComputed.label.text,
        textType: this.pieSetComputed.label.textType,
        radius: Number(this.pieSetComputed.label.radius),
        inside: this.pieSetComputed.label.isInsided,
        centerX: Ce(100)
      }), this.series.labels.template.set(
        "forceHidden",
        !this.pieSetComputed.label.isTextVisibled
      );
    },
    setTicks() {
      this.series.ticks.template.setAll({
        stroke: oe(this.pieSetComputed.tick.stroke),
        strokeWidth: Number(this.pieSetComputed.tick.strokeWidth)
      }), this.series.ticks.template.set(
        "visible",
        this.pieSetComputed.tick.isVisibled
      ), this.series.ticks.template.setAll({
        location: Number(this.pieSetComputed.tick.location)
      });
    },
    setLegend() {
      this.legend = this.chart.children.push(
        Js.new(this.root, {
          x: Ce(Number(this.legendSetComputed.x)),
          centerX: Ce(Number(this.legendSetComputed.centerX)),
          marginTop: Number(Number(this.legendSetComputed.marginTop)),
          marginBottom: Number(Number(this.legendSetComputed.marginBottom))
        })
      ), this.legend.data.setAll(this.series.dataItems);
    }
  }
}, bh = {};
var NS = /* @__PURE__ */ te(
  YS,
  IS,
  RS,
  !1,
  $S,
  null,
  null,
  null
);
function $S(i) {
  for (let e in bh)
    this[e] = bh[e];
}
const iA = /* @__PURE__ */ function() {
  return NS.exports;
}(), FS = {
  props: {
    changeHandlerParam: {
      type: Array,
      default: () => []
    },
    changeHandler: {
      type: Function,
      default: () => !0
    },
    idName: {
      type: String,
      default: ""
    },
    valueName: {
      type: String,
      default: ""
    },
    checkedName: {
      type: String,
      default: "checked"
    },
    disabledName: {
      type: String,
      default: "disabled"
    },
    enabledName: {
      type: String,
      default: ""
    },
    labelTextName: {
      type: String,
      default: "name"
    },
    styleProps: {
      type: String,
      default: ""
    },
    size: {
      type: String,
      default: ""
    },
    flexDirection: {
      type: String,
      default: "column"
    },
    itemList: {
      type: Array,
      default: () => []
    },
    category: {
      type: String,
      default: ""
    }
  },
  computed: {
    checkListClassComputed() {
      return `${this.$style.check_list} ${this.$style[this.size]} ${this.$style[this.flexDirection]}`;
    }
  }
};
var BS = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("ul", {
    class: i.checkListClassComputed,
    style: i.styleProps
  }, i._l(i.itemList, function(s, r) {
    return t("li", {
      key: r
    }, [t("label", {
      attrs: {
        for: `${i.category ? i.category : "checkbox"}-${s[i.idName]}-${r}`,
        disabled: i.enabledName ? !s[i.enabledName] : !!s[i.disabledName]
      }
    }, [t("input", {
      attrs: {
        id: `${i.category ? i.category : "checkbox"}-${s[i.idName]}-${r}`,
        type: "checkbox"
      },
      domProps: {
        value: s[i.checkedName],
        checked: !!s[i.checkedName]
      },
      on: {
        input: function(n) {
          var a;
          return (a = i).changeHandler.apply(a, [n].concat(i.changeHandlerParam));
        }
      }
    }), t("div", {
      class: [`${i.$style.checkbox_custom} ${s[i.labelTextName] ? i.$style.with_label : ""}`]
    }), i._t("default")], 2)]);
  }), 0);
}, HS = [];
const zS = "_check_list_1ywte_5", XS = "_row_1ywte_13", VS = "_checkbox_custom_1ywte_20", WS = "_with_label_1ywte_47", US = "_small_1ywte_66", GS = {
  check_list: zS,
  row: XS,
  checkbox_custom: VS,
  with_label: WS,
  small: US
}, gl = {};
gl.$style = GS;
var ZS = /* @__PURE__ */ te(
  FS,
  BS,
  HS,
  !1,
  KS,
  null,
  null,
  null
);
function KS(i) {
  for (let e in gl)
    this[e] = gl[e];
}
const sA = /* @__PURE__ */ function() {
  return ZS.exports;
}(), QS = {
  props: {
    styleProps: {
      type: String,
      default: ""
    },
    inactive: {
      type: Boolean,
      default: !1
    },
    clickHandler: Function
  },
  methods: {
    executor() {
      this.clickHandler && this.clickHandler();
    }
  }
};
var JS = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    class: i.$style["chips-container"],
    style: i.styleProps,
    attrs: {
      inactive: i.inactive
    }
  }, [t("span", [i._t("default")], 2), i.inactive ? i._e() : t("div", {
    on: {
      click: i.executor
    }
  }, [t("img", {
    attrs: {
      alt: "close-icon"
    }
  })])]);
}, qS = [];
const eD = {
  "chips-container": "_chips-container_1bomp_1"
}, ml = {};
ml.$style = eD;
var tD = /* @__PURE__ */ te(
  QS,
  JS,
  qS,
  !1,
  iD,
  null,
  null,
  null
);
function iD(i) {
  for (let e in ml)
    this[e] = ml[e];
}
const rA = /* @__PURE__ */ function() {
  return tD.exports;
}(), sD = {
  props: {
    styleProps: String,
    placeholderText: {
      type: String,
      default: "placeholder-text"
    },
    // 검색어와 일치한 list
    searchList: {
      type: Array,
      default: () => []
    },
    // searchList 중에 현재 어디에 focus 되어 있는 지 표시.
    focusPosition: {
      type: Number,
      default: 0
    },
    // 검색을 시작할 때 사용될 keyword
    searchCompleteKeyword: {
      type: String,
      default: ""
    },
    // 검색을 시작하기 전 검색할 검색어를 저장시켜준다.
    setSearchCompleteKeyword: {
      type: Function,
      default: () => !0
    },
    // 포커스의 위치를 정한다.
    setFocusPosition: {
      type: Function,
      default: () => !0
    }
  },
  data() {
    return {
      keyword: "",
      timeout: null,
      focusOnSearchbar: 0
    };
  },
  methods: {
    // 검색된 keyword 를 complete keyword 로 저장한다.
    // 이미 키워드가 입력된 상태에서 함수를 실행했다면 next search handler 실행
    searchHandler() {
      this.searchCompleteKeyword === this.keyword && this.nextSearchHandler(), this.setSearchCompleteKeyword(this.keyword), this.focusOnSearchbar += 1;
    },
    // 다음 search list 로 focus를 이동.
    nextSearchHandler() {
      this.focusPosition < this.searchList.length && this.setFocusPosition(this.focusPosition + 1), this.focusPosition === this.searchList.length && this.setFocusPosition(1), this.focusOnSearchbar += 1;
    },
    // 이전 search list 로 focus 를 이동.
    previousSearchHandler() {
      this.focusPosition > 1 && this.setFocusPosition(this.focusPosition - 1), this.focusOnSearchbar += 1;
    },
    searchDebounce() {
      clearTimeout(this.timeout), this.timeout = setTimeout(() => {
        this.searchHandler();
      }, 300);
    }
  },
  watch: {
    focusOnSearchbar() {
      this.$refs.searchInputRef && this.$refs.searchInputRef.focus();
    }
  }
};
var rD = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    staticClass: "search-bar-container",
    style: i.styleProps
  }, [t("div", {
    staticClass: "search-icon",
    on: {
      click: i.searchHandler
    }
  }, [t("img", {
    staticClass: "search-icon-svg"
  })]), t("input", {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: i.keyword,
      expression: "keyword"
    }],
    ref: "searchInputRef",
    staticClass: "search-input",
    attrs: {
      placeholder: i.placeholderText,
      type: "text"
    },
    domProps: {
      value: i.keyword
    },
    on: {
      keyup: i.searchDebounce,
      input: function(s) {
        s.target.composing || (i.keyword = s.target.value);
      }
    }
  }), i.searchList.length && i.focusPosition ? t("div", {
    staticClass: "search-list-wrap"
  }, [t("div", {
    staticClass: "display-searchlist"
  }, [i._v(" " + i._s(i.focusPosition) + " of " + i._s(i.searchList.length) + " ")]), t("div", {
    staticClass: "search-btn"
  }, [t("button", {
    on: {
      click: i.previousSearchHandler
    }
  }, [t("img", {
    attrs: {
      alt: ""
    }
  })]), t("button", {
    on: {
      click: i.nextSearchHandler
    }
  }, [t("img", {
    attrs: {
      alt: ""
    }
  })])])]) : i._e()]);
}, nD = [];
const yh = {};
var aD = /* @__PURE__ */ te(
  sD,
  rD,
  nD,
  !1,
  oD,
  "9d2768f6",
  null,
  null
);
function oD(i) {
  for (let e in yh)
    this[e] = yh[e];
}
const Du = /* @__PURE__ */ function() {
  return aD.exports;
}();
var _l = {}, lD = {
  get exports() {
    return _l;
  },
  set exports(i) {
    _l = i;
  }
};
/**!
 * Sortable 1.10.2
 * @author	RubaXa   <trash@rubaxa.org>
 * @author	owenm    <owen23355@gmail.com>
 * @license MIT
 */
function Nn(i) {
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Nn = function(e) {
    return typeof e;
  } : Nn = function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Nn(i);
}
function uD(i, e, t) {
  return e in i ? Object.defineProperty(i, e, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : i[e] = t, i;
}
function Ft() {
  return Ft = Object.assign || function(i) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var s in t)
        Object.prototype.hasOwnProperty.call(t, s) && (i[s] = t[s]);
    }
    return i;
  }, Ft.apply(this, arguments);
}
function Ki(i) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {}, s = Object.keys(t);
    typeof Object.getOwnPropertySymbols == "function" && (s = s.concat(Object.getOwnPropertySymbols(t).filter(function(r) {
      return Object.getOwnPropertyDescriptor(t, r).enumerable;
    }))), s.forEach(function(r) {
      uD(i, r, t[r]);
    });
  }
  return i;
}
function hD(i, e) {
  if (i == null)
    return {};
  var t = {}, s = Object.keys(i), r, n;
  for (n = 0; n < s.length; n++)
    r = s[n], !(e.indexOf(r) >= 0) && (t[r] = i[r]);
  return t;
}
function cD(i, e) {
  if (i == null)
    return {};
  var t = hD(i, e), s, r;
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(i);
    for (r = 0; r < n.length; r++)
      s = n[r], !(e.indexOf(s) >= 0) && Object.prototype.propertyIsEnumerable.call(i, s) && (t[s] = i[s]);
  }
  return t;
}
function dD(i) {
  return fD(i) || pD(i) || gD();
}
function fD(i) {
  if (Array.isArray(i)) {
    for (var e = 0, t = new Array(i.length); e < i.length; e++)
      t[e] = i[e];
    return t;
  }
}
function pD(i) {
  if (Symbol.iterator in Object(i) || Object.prototype.toString.call(i) === "[object Arguments]")
    return Array.from(i);
}
function gD() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}
var mD = "1.10.2";
function gi(i) {
  if (typeof window < "u" && window.navigator)
    return !!/* @__PURE__ */ navigator.userAgent.match(i);
}
var Si = gi(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i), dn = gi(/Edge/i), vh = gi(/firefox/i), bl = gi(/safari/i) && !gi(/chrome/i) && !gi(/android/i), ef = gi(/iP(ad|od|hone)/i), _D = gi(/chrome/i) && gi(/android/i), tf = {
  capture: !1,
  passive: !1
};
function pe(i, e, t) {
  i.addEventListener(e, t, !Si && tf);
}
function ce(i, e, t) {
  i.removeEventListener(e, t, !Si && tf);
}
function La(i, e) {
  if (e) {
    if (e[0] === ">" && (e = e.substring(1)), i)
      try {
        if (i.matches)
          return i.matches(e);
        if (i.msMatchesSelector)
          return i.msMatchesSelector(e);
        if (i.webkitMatchesSelector)
          return i.webkitMatchesSelector(e);
      } catch {
        return !1;
      }
    return !1;
  }
}
function bD(i) {
  return i.host && i !== document && i.host.nodeType ? i.host : i.parentNode;
}
function Vt(i, e, t, s) {
  if (i) {
    t = t || document;
    do {
      if (e != null && (e[0] === ">" ? i.parentNode === t && La(i, e) : La(i, e)) || s && i === t)
        return i;
      if (i === t)
        break;
    } while (i = bD(i));
  }
  return null;
}
var xh = /\s+/g;
function Oe(i, e, t) {
  if (i && e)
    if (i.classList)
      i.classList[t ? "add" : "remove"](e);
    else {
      var s = (" " + i.className + " ").replace(xh, " ").replace(" " + e + " ", " ");
      i.className = (s + (t ? " " + e : "")).replace(xh, " ");
    }
}
function G(i, e, t) {
  var s = i && i.style;
  if (s) {
    if (t === void 0)
      return document.defaultView && document.defaultView.getComputedStyle ? t = document.defaultView.getComputedStyle(i, "") : i.currentStyle && (t = i.currentStyle), e === void 0 ? t : t[e];
    !(e in s) && e.indexOf("webkit") === -1 && (e = "-webkit-" + e), s[e] = t + (typeof t == "string" ? "" : "px");
  }
}
function gs(i, e) {
  var t = "";
  if (typeof i == "string")
    t = i;
  else
    do {
      var s = G(i, "transform");
      s && s !== "none" && (t = s + " " + t);
    } while (!e && (i = i.parentNode));
  var r = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
  return r && new r(t);
}
function sf(i, e, t) {
  if (i) {
    var s = i.getElementsByTagName(e), r = 0, n = s.length;
    if (t)
      for (; r < n; r++)
        t(s[r], r);
    return s;
  }
  return [];
}
function ii() {
  var i = document.scrollingElement;
  return i || document.documentElement;
}
function Re(i, e, t, s, r) {
  if (!(!i.getBoundingClientRect && i !== window)) {
    var n, a, o, l, u, h, c;
    if (i !== window && i !== ii() ? (n = i.getBoundingClientRect(), a = n.top, o = n.left, l = n.bottom, u = n.right, h = n.height, c = n.width) : (a = 0, o = 0, l = window.innerHeight, u = window.innerWidth, h = window.innerHeight, c = window.innerWidth), (e || t) && i !== window && (r = r || i.parentNode, !Si))
      do
        if (r && r.getBoundingClientRect && (G(r, "transform") !== "none" || t && G(r, "position") !== "static")) {
          var d = r.getBoundingClientRect();
          a -= d.top + parseInt(G(r, "border-top-width")), o -= d.left + parseInt(G(r, "border-left-width")), l = a + n.height, u = o + n.width;
          break;
        }
      while (r = r.parentNode);
    if (s && i !== window) {
      var f = gs(r || i), g = f && f.a, p = f && f.d;
      f && (a /= p, o /= g, c /= g, h /= p, l = a + h, u = o + c);
    }
    return {
      top: a,
      left: o,
      bottom: l,
      right: u,
      width: c,
      height: h
    };
  }
}
function wh(i, e, t) {
  for (var s = Ai(i, !0), r = Re(i)[e]; s; ) {
    var n = Re(s)[t], a = void 0;
    if (t === "top" || t === "left" ? a = r >= n : a = r <= n, !a)
      return s;
    if (s === ii())
      break;
    s = Ai(s, !1);
  }
  return !1;
}
function ja(i, e, t) {
  for (var s = 0, r = 0, n = i.children; r < n.length; ) {
    if (n[r].style.display !== "none" && n[r] !== ee.ghost && n[r] !== ee.dragged && Vt(n[r], t.draggable, i, !1)) {
      if (s === e)
        return n[r];
      s++;
    }
    r++;
  }
  return null;
}
function Pu(i, e) {
  for (var t = i.lastElementChild; t && (t === ee.ghost || G(t, "display") === "none" || e && !La(t, e)); )
    t = t.previousElementSibling;
  return t || null;
}
function Ee(i, e) {
  var t = 0;
  if (!i || !i.parentNode)
    return -1;
  for (; i = i.previousElementSibling; )
    i.nodeName.toUpperCase() !== "TEMPLATE" && i !== ee.clone && (!e || La(i, e)) && t++;
  return t;
}
function Sh(i) {
  var e = 0, t = 0, s = ii();
  if (i)
    do {
      var r = gs(i), n = r.a, a = r.d;
      e += i.scrollLeft * n, t += i.scrollTop * a;
    } while (i !== s && (i = i.parentNode));
  return [e, t];
}
function yD(i, e) {
  for (var t in i)
    if (i.hasOwnProperty(t)) {
      for (var s in e)
        if (e.hasOwnProperty(s) && e[s] === i[t][s])
          return Number(t);
    }
  return -1;
}
function Ai(i, e) {
  if (!i || !i.getBoundingClientRect)
    return ii();
  var t = i, s = !1;
  do
    if (t.clientWidth < t.scrollWidth || t.clientHeight < t.scrollHeight) {
      var r = G(t);
      if (t.clientWidth < t.scrollWidth && (r.overflowX == "auto" || r.overflowX == "scroll") || t.clientHeight < t.scrollHeight && (r.overflowY == "auto" || r.overflowY == "scroll")) {
        if (!t.getBoundingClientRect || t === document.body)
          return ii();
        if (s || e)
          return t;
        s = !0;
      }
    }
  while (t = t.parentNode);
  return ii();
}
function vD(i, e) {
  if (i && e)
    for (var t in e)
      e.hasOwnProperty(t) && (i[t] = e[t]);
  return i;
}
function To(i, e) {
  return Math.round(i.top) === Math.round(e.top) && Math.round(i.left) === Math.round(e.left) && Math.round(i.height) === Math.round(e.height) && Math.round(i.width) === Math.round(e.width);
}
var Rr;
function rf(i, e) {
  return function() {
    if (!Rr) {
      var t = arguments, s = this;
      t.length === 1 ? i.call(s, t[0]) : i.apply(s, t), Rr = setTimeout(function() {
        Rr = void 0;
      }, e);
    }
  };
}
function xD() {
  clearTimeout(Rr), Rr = void 0;
}
function nf(i, e, t) {
  i.scrollLeft += e, i.scrollTop += t;
}
function Tu(i) {
  var e = window.Polymer, t = window.jQuery || window.Zepto;
  return e && e.dom ? e.dom(i).cloneNode(!0) : t ? t(i).clone(!0)[0] : i.cloneNode(!0);
}
function Dh(i, e) {
  G(i, "position", "absolute"), G(i, "top", e.top), G(i, "left", e.left), G(i, "width", e.width), G(i, "height", e.height);
}
function ko(i) {
  G(i, "position", ""), G(i, "top", ""), G(i, "left", ""), G(i, "width", ""), G(i, "height", "");
}
var at = "Sortable" + new Date().getTime();
function wD() {
  var i = [], e;
  return {
    captureAnimationState: function() {
      if (i = [], !!this.options.animation) {
        var s = [].slice.call(this.el.children);
        s.forEach(function(r) {
          if (!(G(r, "display") === "none" || r === ee.ghost)) {
            i.push({
              target: r,
              rect: Re(r)
            });
            var n = Ki({}, i[i.length - 1].rect);
            if (r.thisAnimationDuration) {
              var a = gs(r, !0);
              a && (n.top -= a.f, n.left -= a.e);
            }
            r.fromRect = n;
          }
        });
      }
    },
    addAnimationState: function(s) {
      i.push(s);
    },
    removeAnimationState: function(s) {
      i.splice(yD(i, {
        target: s
      }), 1);
    },
    animateAll: function(s) {
      var r = this;
      if (!this.options.animation) {
        clearTimeout(e), typeof s == "function" && s();
        return;
      }
      var n = !1, a = 0;
      i.forEach(function(o) {
        var l = 0, u = o.target, h = u.fromRect, c = Re(u), d = u.prevFromRect, f = u.prevToRect, g = o.rect, p = gs(u, !0);
        p && (c.top -= p.f, c.left -= p.e), u.toRect = c, u.thisAnimationDuration && To(d, c) && !To(h, c) && // Make sure animatingRect is on line between toRect & fromRect
        (g.top - c.top) / (g.left - c.left) === (h.top - c.top) / (h.left - c.left) && (l = DD(g, d, f, r.options)), To(c, h) || (u.prevFromRect = h, u.prevToRect = c, l || (l = r.options.animation), r.animate(u, g, c, l)), l && (n = !0, a = Math.max(a, l), clearTimeout(u.animationResetTimer), u.animationResetTimer = setTimeout(function() {
          u.animationTime = 0, u.prevFromRect = null, u.fromRect = null, u.prevToRect = null, u.thisAnimationDuration = null;
        }, l), u.thisAnimationDuration = l);
      }), clearTimeout(e), n ? e = setTimeout(function() {
        typeof s == "function" && s();
      }, a) : typeof s == "function" && s(), i = [];
    },
    animate: function(s, r, n, a) {
      if (a) {
        G(s, "transition", ""), G(s, "transform", "");
        var o = gs(this.el), l = o && o.a, u = o && o.d, h = (r.left - n.left) / (l || 1), c = (r.top - n.top) / (u || 1);
        s.animatingX = !!h, s.animatingY = !!c, G(s, "transform", "translate3d(" + h + "px," + c + "px,0)"), SD(s), G(s, "transition", "transform " + a + "ms" + (this.options.easing ? " " + this.options.easing : "")), G(s, "transform", "translate3d(0,0,0)"), typeof s.animated == "number" && clearTimeout(s.animated), s.animated = setTimeout(function() {
          G(s, "transition", ""), G(s, "transform", ""), s.animated = !1, s.animatingX = !1, s.animatingY = !1;
        }, a);
      }
    }
  };
}
function SD(i) {
  return i.offsetWidth;
}
function DD(i, e, t, s) {
  return Math.sqrt(Math.pow(e.top - i.top, 2) + Math.pow(e.left - i.left, 2)) / Math.sqrt(Math.pow(e.top - t.top, 2) + Math.pow(e.left - t.left, 2)) * s.animation;
}
var _r = [], Co = {
  initializeByDefault: !0
}, fn = {
  mount: function(e) {
    for (var t in Co)
      Co.hasOwnProperty(t) && !(t in e) && (e[t] = Co[t]);
    _r.push(e);
  },
  pluginEvent: function(e, t, s) {
    var r = this;
    this.eventCanceled = !1, s.cancel = function() {
      r.eventCanceled = !0;
    };
    var n = e + "Global";
    _r.forEach(function(a) {
      t[a.pluginName] && (t[a.pluginName][n] && t[a.pluginName][n](Ki({
        sortable: t
      }, s)), t.options[a.pluginName] && t[a.pluginName][e] && t[a.pluginName][e](Ki({
        sortable: t
      }, s)));
    });
  },
  initializePlugins: function(e, t, s, r) {
    _r.forEach(function(o) {
      var l = o.pluginName;
      if (!(!e.options[l] && !o.initializeByDefault)) {
        var u = new o(e, t, e.options);
        u.sortable = e, u.options = e.options, e[l] = u, Ft(s, u.defaults);
      }
    });
    for (var n in e.options)
      if (e.options.hasOwnProperty(n)) {
        var a = this.modifyOption(e, n, e.options[n]);
        typeof a < "u" && (e.options[n] = a);
      }
  },
  getEventProperties: function(e, t) {
    var s = {};
    return _r.forEach(function(r) {
      typeof r.eventProperties == "function" && Ft(s, r.eventProperties.call(t[r.pluginName], e));
    }), s;
  },
  modifyOption: function(e, t, s) {
    var r;
    return _r.forEach(function(n) {
      e[n.pluginName] && n.optionListeners && typeof n.optionListeners[t] == "function" && (r = n.optionListeners[t].call(e[n.pluginName], s));
    }), r;
  }
};
function Tr(i) {
  var e = i.sortable, t = i.rootEl, s = i.name, r = i.targetEl, n = i.cloneEl, a = i.toEl, o = i.fromEl, l = i.oldIndex, u = i.newIndex, h = i.oldDraggableIndex, c = i.newDraggableIndex, d = i.originalEvent, f = i.putSortable, g = i.extraEventProperties;
  if (e = e || t && t[at], !!e) {
    var p, m = e.options, _ = "on" + s.charAt(0).toUpperCase() + s.substr(1);
    window.CustomEvent && !Si && !dn ? p = new CustomEvent(s, {
      bubbles: !0,
      cancelable: !0
    }) : (p = document.createEvent("Event"), p.initEvent(s, !0, !0)), p.to = a || t, p.from = o || t, p.item = r || t, p.clone = n, p.oldIndex = l, p.newIndex = u, p.oldDraggableIndex = h, p.newDraggableIndex = c, p.originalEvent = d, p.pullMode = f ? f.lastPutMode : void 0;
    var v = Ki({}, g, fn.getEventProperties(s, e));
    for (var b in v)
      p[b] = v[b];
    t && t.dispatchEvent(p), m[_] && m[_].call(e, p);
  }
}
var _t = function(e, t) {
  var s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, r = s.evt, n = cD(s, ["evt"]);
  fn.pluginEvent.bind(ee)(e, t, Ki({
    dragEl: F,
    parentEl: ze,
    ghostEl: ae,
    rootEl: Me,
    nextEl: os,
    lastDownEl: $n,
    cloneEl: Le,
    cloneHidden: Ti,
    dragStarted: kr,
    putSortable: et,
    activeSortable: ee.active,
    originalEvent: r,
    oldIndex: $s,
    oldDraggableIndex: Yr,
    newIndex: Ct,
    newDraggableIndex: Pi,
    hideGhostForTarget: uf,
    unhideGhostForTarget: hf,
    cloneNowHidden: function() {
      Ti = !0;
    },
    cloneNowShown: function() {
      Ti = !1;
    },
    dispatchSortableEvent: function(o) {
      ft({
        sortable: t,
        name: o,
        originalEvent: r
      });
    }
  }, n));
};
function ft(i) {
  Tr(Ki({
    putSortable: et,
    cloneEl: Le,
    targetEl: F,
    rootEl: Me,
    oldIndex: $s,
    oldDraggableIndex: Yr,
    newIndex: Ct,
    newDraggableIndex: Pi
  }, i));
}
var F, ze, ae, Me, os, $n, Le, Ti, $s, Ct, Yr, Pi, Dn, et, Ls = !1, Ea = !1, Ia = [], ts, zt, Mo, Oo, Ph, Th, kr, Cs, Nr, $r = !1, Pn = !1, Fn, rt, Ao = [], yl = !1, Ra = [], lo = typeof document < "u", Tn = ef, kh = dn || Si ? "cssFloat" : "float", PD = lo && !_D && !ef && "draggable" in document.createElement("div"), af = function() {
  if (lo) {
    if (Si)
      return !1;
    var i = document.createElement("x");
    return i.style.cssText = "pointer-events:auto", i.style.pointerEvents === "auto";
  }
}(), of = function(e, t) {
  var s = G(e), r = parseInt(s.width) - parseInt(s.paddingLeft) - parseInt(s.paddingRight) - parseInt(s.borderLeftWidth) - parseInt(s.borderRightWidth), n = ja(e, 0, t), a = ja(e, 1, t), o = n && G(n), l = a && G(a), u = o && parseInt(o.marginLeft) + parseInt(o.marginRight) + Re(n).width, h = l && parseInt(l.marginLeft) + parseInt(l.marginRight) + Re(a).width;
  if (s.display === "flex")
    return s.flexDirection === "column" || s.flexDirection === "column-reverse" ? "vertical" : "horizontal";
  if (s.display === "grid")
    return s.gridTemplateColumns.split(" ").length <= 1 ? "vertical" : "horizontal";
  if (n && o.float && o.float !== "none") {
    var c = o.float === "left" ? "left" : "right";
    return a && (l.clear === "both" || l.clear === c) ? "vertical" : "horizontal";
  }
  return n && (o.display === "block" || o.display === "flex" || o.display === "table" || o.display === "grid" || u >= r && s[kh] === "none" || a && s[kh] === "none" && u + h > r) ? "vertical" : "horizontal";
}, TD = function(e, t, s) {
  var r = s ? e.left : e.top, n = s ? e.right : e.bottom, a = s ? e.width : e.height, o = s ? t.left : t.top, l = s ? t.right : t.bottom, u = s ? t.width : t.height;
  return r === o || n === l || r + a / 2 === o + u / 2;
}, kD = function(e, t) {
  var s;
  return Ia.some(function(r) {
    if (!Pu(r)) {
      var n = Re(r), a = r[at].options.emptyInsertThreshold, o = e >= n.left - a && e <= n.right + a, l = t >= n.top - a && t <= n.bottom + a;
      if (a && o && l)
        return s = r;
    }
  }), s;
}, lf = function(e) {
  function t(n, a) {
    return function(o, l, u, h) {
      var c = o.options.group.name && l.options.group.name && o.options.group.name === l.options.group.name;
      if (n == null && (a || c))
        return !0;
      if (n == null || n === !1)
        return !1;
      if (a && n === "clone")
        return n;
      if (typeof n == "function")
        return t(n(o, l, u, h), a)(o, l, u, h);
      var d = (a ? o : l).options.group.name;
      return n === !0 || typeof n == "string" && n === d || n.join && n.indexOf(d) > -1;
    };
  }
  var s = {}, r = e.group;
  (!r || Nn(r) != "object") && (r = {
    name: r
  }), s.name = r.name, s.checkPull = t(r.pull, !0), s.checkPut = t(r.put), s.revertClone = r.revertClone, e.group = s;
}, uf = function() {
  !af && ae && G(ae, "display", "none");
}, hf = function() {
  !af && ae && G(ae, "display", "");
};
lo && document.addEventListener("click", function(i) {
  if (Ea)
    return i.preventDefault(), i.stopPropagation && i.stopPropagation(), i.stopImmediatePropagation && i.stopImmediatePropagation(), Ea = !1, !1;
}, !0);
var is = function(e) {
  if (F) {
    e = e.touches ? e.touches[0] : e;
    var t = kD(e.clientX, e.clientY);
    if (t) {
      var s = {};
      for (var r in e)
        e.hasOwnProperty(r) && (s[r] = e[r]);
      s.target = s.rootEl = t, s.preventDefault = void 0, s.stopPropagation = void 0, t[at]._onDragOver(s);
    }
  }
}, CD = function(e) {
  F && F.parentNode[at]._isOutsideThisEl(e.target);
};
function ee(i, e) {
  if (!(i && i.nodeType && i.nodeType === 1))
    throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(i));
  this.el = i, this.options = e = Ft({}, e), i[at] = this;
  var t = {
    group: null,
    sort: !0,
    disabled: !1,
    store: null,
    handle: null,
    draggable: /^[uo]l$/i.test(i.nodeName) ? ">li" : ">*",
    swapThreshold: 1,
    // percentage; 0 <= x <= 1
    invertSwap: !1,
    // invert always
    invertedSwapThreshold: null,
    // will be set to same as swapThreshold if default
    removeCloneOnHide: !0,
    direction: function() {
      return of(i, this.options);
    },
    ghostClass: "sortable-ghost",
    chosenClass: "sortable-chosen",
    dragClass: "sortable-drag",
    ignore: "a, img",
    filter: null,
    preventOnFilter: !0,
    animation: 0,
    easing: null,
    setData: function(a, o) {
      a.setData("Text", o.textContent);
    },
    dropBubble: !1,
    dragoverBubble: !1,
    dataIdAttr: "data-id",
    delay: 0,
    delayOnTouchOnly: !1,
    touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
    forceFallback: !1,
    fallbackClass: "sortable-fallback",
    fallbackOnBody: !1,
    fallbackTolerance: 0,
    fallbackOffset: {
      x: 0,
      y: 0
    },
    supportPointer: ee.supportPointer !== !1 && "PointerEvent" in window,
    emptyInsertThreshold: 5
  };
  fn.initializePlugins(this, i, t);
  for (var s in t)
    !(s in e) && (e[s] = t[s]);
  lf(e);
  for (var r in this)
    r.charAt(0) === "_" && typeof this[r] == "function" && (this[r] = this[r].bind(this));
  this.nativeDraggable = e.forceFallback ? !1 : PD, this.nativeDraggable && (this.options.touchStartThreshold = 1), e.supportPointer ? pe(i, "pointerdown", this._onTapStart) : (pe(i, "mousedown", this._onTapStart), pe(i, "touchstart", this._onTapStart)), this.nativeDraggable && (pe(i, "dragover", this), pe(i, "dragenter", this)), Ia.push(this.el), e.store && e.store.get && this.sort(e.store.get(this) || []), Ft(this, wD());
}
ee.prototype = /** @lends Sortable.prototype */
{
  constructor: ee,
  _isOutsideThisEl: function(e) {
    !this.el.contains(e) && e !== this.el && (Cs = null);
  },
  _getDirection: function(e, t) {
    return typeof this.options.direction == "function" ? this.options.direction.call(this, e, t, F) : this.options.direction;
  },
  _onTapStart: function(e) {
    if (e.cancelable) {
      var t = this, s = this.el, r = this.options, n = r.preventOnFilter, a = e.type, o = e.touches && e.touches[0] || e.pointerType && e.pointerType === "touch" && e, l = (o || e).target, u = e.target.shadowRoot && (e.path && e.path[0] || e.composedPath && e.composedPath()[0]) || l, h = r.filter;
      if (ID(s), !F && !(/mousedown|pointerdown/.test(a) && e.button !== 0 || r.disabled) && !u.isContentEditable && (l = Vt(l, r.draggable, s, !1), !(l && l.animated) && $n !== l)) {
        if ($s = Ee(l), Yr = Ee(l, r.draggable), typeof h == "function") {
          if (h.call(this, e, l, this)) {
            ft({
              sortable: t,
              rootEl: u,
              name: "filter",
              targetEl: l,
              toEl: s,
              fromEl: s
            }), _t("filter", t, {
              evt: e
            }), n && e.cancelable && e.preventDefault();
            return;
          }
        } else if (h && (h = h.split(",").some(function(c) {
          if (c = Vt(u, c.trim(), s, !1), c)
            return ft({
              sortable: t,
              rootEl: c,
              name: "filter",
              targetEl: l,
              fromEl: s,
              toEl: s
            }), _t("filter", t, {
              evt: e
            }), !0;
        }), h)) {
          n && e.cancelable && e.preventDefault();
          return;
        }
        r.handle && !Vt(u, r.handle, s, !1) || this._prepareDragStart(e, o, l);
      }
    }
  },
  _prepareDragStart: function(e, t, s) {
    var r = this, n = r.el, a = r.options, o = n.ownerDocument, l;
    if (s && !F && s.parentNode === n) {
      var u = Re(s);
      if (Me = n, F = s, ze = F.parentNode, os = F.nextSibling, $n = s, Dn = a.group, ee.dragged = F, ts = {
        target: F,
        clientX: (t || e).clientX,
        clientY: (t || e).clientY
      }, Ph = ts.clientX - u.left, Th = ts.clientY - u.top, this._lastX = (t || e).clientX, this._lastY = (t || e).clientY, F.style["will-change"] = "all", l = function() {
        if (_t("delayEnded", r, {
          evt: e
        }), ee.eventCanceled) {
          r._onDrop();
          return;
        }
        r._disableDelayedDragEvents(), !vh && r.nativeDraggable && (F.draggable = !0), r._triggerDragStart(e, t), ft({
          sortable: r,
          name: "choose",
          originalEvent: e
        }), Oe(F, a.chosenClass, !0);
      }, a.ignore.split(",").forEach(function(h) {
        sf(F, h.trim(), jo);
      }), pe(o, "dragover", is), pe(o, "mousemove", is), pe(o, "touchmove", is), pe(o, "mouseup", r._onDrop), pe(o, "touchend", r._onDrop), pe(o, "touchcancel", r._onDrop), vh && this.nativeDraggable && (this.options.touchStartThreshold = 4, F.draggable = !0), _t("delayStart", this, {
        evt: e
      }), a.delay && (!a.delayOnTouchOnly || t) && (!this.nativeDraggable || !(dn || Si))) {
        if (ee.eventCanceled) {
          this._onDrop();
          return;
        }
        pe(o, "mouseup", r._disableDelayedDrag), pe(o, "touchend", r._disableDelayedDrag), pe(o, "touchcancel", r._disableDelayedDrag), pe(o, "mousemove", r._delayedDragTouchMoveHandler), pe(o, "touchmove", r._delayedDragTouchMoveHandler), a.supportPointer && pe(o, "pointermove", r._delayedDragTouchMoveHandler), r._dragStartTimer = setTimeout(l, a.delay);
      } else
        l();
    }
  },
  _delayedDragTouchMoveHandler: function(e) {
    var t = e.touches ? e.touches[0] : e;
    Math.max(Math.abs(t.clientX - this._lastX), Math.abs(t.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1)) && this._disableDelayedDrag();
  },
  _disableDelayedDrag: function() {
    F && jo(F), clearTimeout(this._dragStartTimer), this._disableDelayedDragEvents();
  },
  _disableDelayedDragEvents: function() {
    var e = this.el.ownerDocument;
    ce(e, "mouseup", this._disableDelayedDrag), ce(e, "touchend", this._disableDelayedDrag), ce(e, "touchcancel", this._disableDelayedDrag), ce(e, "mousemove", this._delayedDragTouchMoveHandler), ce(e, "touchmove", this._delayedDragTouchMoveHandler), ce(e, "pointermove", this._delayedDragTouchMoveHandler);
  },
  _triggerDragStart: function(e, t) {
    t = t || e.pointerType == "touch" && e, !this.nativeDraggable || t ? this.options.supportPointer ? pe(document, "pointermove", this._onTouchMove) : t ? pe(document, "touchmove", this._onTouchMove) : pe(document, "mousemove", this._onTouchMove) : (pe(F, "dragend", this), pe(Me, "dragstart", this._onDragStart));
    try {
      document.selection ? Bn(function() {
        document.selection.empty();
      }) : window.getSelection().removeAllRanges();
    } catch {
    }
  },
  _dragStarted: function(e, t) {
    if (Ls = !1, Me && F) {
      _t("dragStarted", this, {
        evt: t
      }), this.nativeDraggable && pe(document, "dragover", CD);
      var s = this.options;
      !e && Oe(F, s.dragClass, !1), Oe(F, s.ghostClass, !0), ee.active = this, e && this._appendGhost(), ft({
        sortable: this,
        name: "start",
        originalEvent: t
      });
    } else
      this._nulling();
  },
  _emulateDragOver: function() {
    if (zt) {
      this._lastX = zt.clientX, this._lastY = zt.clientY, uf();
      for (var e = document.elementFromPoint(zt.clientX, zt.clientY), t = e; e && e.shadowRoot && (e = e.shadowRoot.elementFromPoint(zt.clientX, zt.clientY), e !== t); )
        t = e;
      if (F.parentNode[at]._isOutsideThisEl(e), t)
        do {
          if (t[at]) {
            var s = void 0;
            if (s = t[at]._onDragOver({
              clientX: zt.clientX,
              clientY: zt.clientY,
              target: e,
              rootEl: t
            }), s && !this.options.dragoverBubble)
              break;
          }
          e = t;
        } while (t = t.parentNode);
      hf();
    }
  },
  _onTouchMove: function(e) {
    if (ts) {
      var t = this.options, s = t.fallbackTolerance, r = t.fallbackOffset, n = e.touches ? e.touches[0] : e, a = ae && gs(ae, !0), o = ae && a && a.a, l = ae && a && a.d, u = Tn && rt && Sh(rt), h = (n.clientX - ts.clientX + r.x) / (o || 1) + (u ? u[0] - Ao[0] : 0) / (o || 1), c = (n.clientY - ts.clientY + r.y) / (l || 1) + (u ? u[1] - Ao[1] : 0) / (l || 1);
      if (!ee.active && !Ls) {
        if (s && Math.max(Math.abs(n.clientX - this._lastX), Math.abs(n.clientY - this._lastY)) < s)
          return;
        this._onDragStart(e, !0);
      }
      if (ae) {
        a ? (a.e += h - (Mo || 0), a.f += c - (Oo || 0)) : a = {
          a: 1,
          b: 0,
          c: 0,
          d: 1,
          e: h,
          f: c
        };
        var d = "matrix(".concat(a.a, ",").concat(a.b, ",").concat(a.c, ",").concat(a.d, ",").concat(a.e, ",").concat(a.f, ")");
        G(ae, "webkitTransform", d), G(ae, "mozTransform", d), G(ae, "msTransform", d), G(ae, "transform", d), Mo = h, Oo = c, zt = n;
      }
      e.cancelable && e.preventDefault();
    }
  },
  _appendGhost: function() {
    if (!ae) {
      var e = this.options.fallbackOnBody ? document.body : Me, t = Re(F, !0, Tn, !0, e), s = this.options;
      if (Tn) {
        for (rt = e; G(rt, "position") === "static" && G(rt, "transform") === "none" && rt !== document; )
          rt = rt.parentNode;
        rt !== document.body && rt !== document.documentElement ? (rt === document && (rt = ii()), t.top += rt.scrollTop, t.left += rt.scrollLeft) : rt = ii(), Ao = Sh(rt);
      }
      ae = F.cloneNode(!0), Oe(ae, s.ghostClass, !1), Oe(ae, s.fallbackClass, !0), Oe(ae, s.dragClass, !0), G(ae, "transition", ""), G(ae, "transform", ""), G(ae, "box-sizing", "border-box"), G(ae, "margin", 0), G(ae, "top", t.top), G(ae, "left", t.left), G(ae, "width", t.width), G(ae, "height", t.height), G(ae, "opacity", "0.8"), G(ae, "position", Tn ? "absolute" : "fixed"), G(ae, "zIndex", "100000"), G(ae, "pointerEvents", "none"), ee.ghost = ae, e.appendChild(ae), G(ae, "transform-origin", Ph / parseInt(ae.style.width) * 100 + "% " + Th / parseInt(ae.style.height) * 100 + "%");
    }
  },
  _onDragStart: function(e, t) {
    var s = this, r = e.dataTransfer, n = s.options;
    if (_t("dragStart", this, {
      evt: e
    }), ee.eventCanceled) {
      this._onDrop();
      return;
    }
    _t("setupClone", this), ee.eventCanceled || (Le = Tu(F), Le.draggable = !1, Le.style["will-change"] = "", this._hideClone(), Oe(Le, this.options.chosenClass, !1), ee.clone = Le), s.cloneId = Bn(function() {
      _t("clone", s), !ee.eventCanceled && (s.options.removeCloneOnHide || Me.insertBefore(Le, F), s._hideClone(), ft({
        sortable: s,
        name: "clone"
      }));
    }), !t && Oe(F, n.dragClass, !0), t ? (Ea = !0, s._loopId = setInterval(s._emulateDragOver, 50)) : (ce(document, "mouseup", s._onDrop), ce(document, "touchend", s._onDrop), ce(document, "touchcancel", s._onDrop), r && (r.effectAllowed = "move", n.setData && n.setData.call(s, r, F)), pe(document, "drop", s), G(F, "transform", "translateZ(0)")), Ls = !0, s._dragStartId = Bn(s._dragStarted.bind(s, t, e)), pe(document, "selectstart", s), kr = !0, bl && G(document.body, "user-select", "none");
  },
  // Returns true - if no further action is needed (either inserted or another condition)
  _onDragOver: function(e) {
    var t = this.el, s = e.target, r, n, a, o = this.options, l = o.group, u = ee.active, h = Dn === l, c = o.sort, d = et || u, f, g = this, p = !1;
    if (yl)
      return;
    function m(Y, U) {
      _t(Y, g, Ki({
        evt: e,
        isOwner: h,
        axis: f ? "vertical" : "horizontal",
        revert: a,
        dragRect: r,
        targetRect: n,
        canSort: c,
        fromSortable: d,
        target: s,
        completed: v,
        onMove: function(ue, O) {
          return Lo(Me, t, F, r, ue, Re(ue), e, O);
        },
        changed: b
      }, U));
    }
    function _() {
      m("dragOverAnimationCapture"), g.captureAnimationState(), g !== d && d.captureAnimationState();
    }
    function v(Y) {
      return m("dragOverCompleted", {
        insertion: Y
      }), Y && (h ? u._hideClone() : u._showClone(g), g !== d && (Oe(F, et ? et.options.ghostClass : u.options.ghostClass, !1), Oe(F, o.ghostClass, !0)), et !== g && g !== ee.active ? et = g : g === ee.active && et && (et = null), d === g && (g._ignoreWhileAnimating = s), g.animateAll(function() {
        m("dragOverAnimationComplete"), g._ignoreWhileAnimating = null;
      }), g !== d && (d.animateAll(), d._ignoreWhileAnimating = null)), (s === F && !F.animated || s === t && !s.animated) && (Cs = null), !o.dragoverBubble && !e.rootEl && s !== document && (F.parentNode[at]._isOutsideThisEl(e.target), !Y && is(e)), !o.dragoverBubble && e.stopPropagation && e.stopPropagation(), p = !0;
    }
    function b() {
      Ct = Ee(F), Pi = Ee(F, o.draggable), ft({
        sortable: g,
        name: "change",
        toEl: t,
        newIndex: Ct,
        newDraggableIndex: Pi,
        originalEvent: e
      });
    }
    if (e.preventDefault !== void 0 && e.cancelable && e.preventDefault(), s = Vt(s, o.draggable, t, !0), m("dragOver"), ee.eventCanceled)
      return p;
    if (F.contains(e.target) || s.animated && s.animatingX && s.animatingY || g._ignoreWhileAnimating === s)
      return v(!1);
    if (Ea = !1, u && !o.disabled && (h ? c || (a = !Me.contains(F)) : et === this || (this.lastPutMode = Dn.checkPull(this, u, F, e)) && l.checkPut(this, u, F, e))) {
      if (f = this._getDirection(e, s) === "vertical", r = Re(F), m("dragOverValid"), ee.eventCanceled)
        return p;
      if (a)
        return ze = Me, _(), this._hideClone(), m("revert"), ee.eventCanceled || (os ? Me.insertBefore(F, os) : Me.appendChild(F)), v(!0);
      var y = Pu(t, o.draggable);
      if (!y || AD(e, f, this) && !y.animated) {
        if (y === F)
          return v(!1);
        if (y && t === e.target && (s = y), s && (n = Re(s)), Lo(Me, t, F, r, s, n, e, !!s) !== !1)
          return _(), t.appendChild(F), ze = t, b(), v(!0);
      } else if (s.parentNode === t) {
        n = Re(s);
        var w = 0, D, A = F.parentNode !== t, T = !TD(F.animated && F.toRect || r, s.animated && s.toRect || n, f), j = f ? "top" : "left", C = wh(s, "top", "top") || wh(F, "top", "top"), L = C ? C.scrollTop : void 0;
        Cs !== s && (D = n[j], $r = !1, Pn = !T && o.invertSwap || A), w = LD(e, s, n, f, T ? 1 : o.swapThreshold, o.invertedSwapThreshold == null ? o.swapThreshold : o.invertedSwapThreshold, Pn, Cs === s);
        var E;
        if (w !== 0) {
          var N = Ee(F);
          do
            N -= w, E = ze.children[N];
          while (E && (G(E, "display") === "none" || E === ae));
        }
        if (w === 0 || E === s)
          return v(!1);
        Cs = s, Nr = w;
        var J = s.nextElementSibling, z = !1;
        z = w === 1;
        var H = Lo(Me, t, F, r, s, n, e, z);
        if (H !== !1)
          return (H === 1 || H === -1) && (z = H === 1), yl = !0, setTimeout(OD, 30), _(), z && !J ? t.appendChild(F) : s.parentNode.insertBefore(F, z ? J : s), C && nf(C, 0, L - C.scrollTop), ze = F.parentNode, D !== void 0 && !Pn && (Fn = Math.abs(D - Re(s)[j])), b(), v(!0);
      }
      if (t.contains(F))
        return v(!1);
    }
    return !1;
  },
  _ignoreWhileAnimating: null,
  _offMoveEvents: function() {
    ce(document, "mousemove", this._onTouchMove), ce(document, "touchmove", this._onTouchMove), ce(document, "pointermove", this._onTouchMove), ce(document, "dragover", is), ce(document, "mousemove", is), ce(document, "touchmove", is);
  },
  _offUpEvents: function() {
    var e = this.el.ownerDocument;
    ce(e, "mouseup", this._onDrop), ce(e, "touchend", this._onDrop), ce(e, "pointerup", this._onDrop), ce(e, "touchcancel", this._onDrop), ce(document, "selectstart", this);
  },
  _onDrop: function(e) {
    var t = this.el, s = this.options;
    if (Ct = Ee(F), Pi = Ee(F, s.draggable), _t("drop", this, {
      evt: e
    }), ze = F && F.parentNode, Ct = Ee(F), Pi = Ee(F, s.draggable), ee.eventCanceled) {
      this._nulling();
      return;
    }
    Ls = !1, Pn = !1, $r = !1, clearInterval(this._loopId), clearTimeout(this._dragStartTimer), vl(this.cloneId), vl(this._dragStartId), this.nativeDraggable && (ce(document, "drop", this), ce(t, "dragstart", this._onDragStart)), this._offMoveEvents(), this._offUpEvents(), bl && G(document.body, "user-select", ""), G(F, "transform", ""), e && (kr && (e.cancelable && e.preventDefault(), !s.dropBubble && e.stopPropagation()), ae && ae.parentNode && ae.parentNode.removeChild(ae), (Me === ze || et && et.lastPutMode !== "clone") && Le && Le.parentNode && Le.parentNode.removeChild(Le), F && (this.nativeDraggable && ce(F, "dragend", this), jo(F), F.style["will-change"] = "", kr && !Ls && Oe(F, et ? et.options.ghostClass : this.options.ghostClass, !1), Oe(F, this.options.chosenClass, !1), ft({
      sortable: this,
      name: "unchoose",
      toEl: ze,
      newIndex: null,
      newDraggableIndex: null,
      originalEvent: e
    }), Me !== ze ? (Ct >= 0 && (ft({
      rootEl: ze,
      name: "add",
      toEl: ze,
      fromEl: Me,
      originalEvent: e
    }), ft({
      sortable: this,
      name: "remove",
      toEl: ze,
      originalEvent: e
    }), ft({
      rootEl: ze,
      name: "sort",
      toEl: ze,
      fromEl: Me,
      originalEvent: e
    }), ft({
      sortable: this,
      name: "sort",
      toEl: ze,
      originalEvent: e
    })), et && et.save()) : Ct !== $s && Ct >= 0 && (ft({
      sortable: this,
      name: "update",
      toEl: ze,
      originalEvent: e
    }), ft({
      sortable: this,
      name: "sort",
      toEl: ze,
      originalEvent: e
    })), ee.active && ((Ct == null || Ct === -1) && (Ct = $s, Pi = Yr), ft({
      sortable: this,
      name: "end",
      toEl: ze,
      originalEvent: e
    }), this.save()))), this._nulling();
  },
  _nulling: function() {
    _t("nulling", this), Me = F = ze = ae = os = Le = $n = Ti = ts = zt = kr = Ct = Pi = $s = Yr = Cs = Nr = et = Dn = ee.dragged = ee.ghost = ee.clone = ee.active = null, Ra.forEach(function(e) {
      e.checked = !0;
    }), Ra.length = Mo = Oo = 0;
  },
  handleEvent: function(e) {
    switch (e.type) {
      case "drop":
      case "dragend":
        this._onDrop(e);
        break;
      case "dragenter":
      case "dragover":
        F && (this._onDragOver(e), MD(e));
        break;
      case "selectstart":
        e.preventDefault();
        break;
    }
  },
  /**
   * Serializes the item into an array of string.
   * @returns {String[]}
   */
  toArray: function() {
    for (var e = [], t, s = this.el.children, r = 0, n = s.length, a = this.options; r < n; r++)
      t = s[r], Vt(t, a.draggable, this.el, !1) && e.push(t.getAttribute(a.dataIdAttr) || ED(t));
    return e;
  },
  /**
   * Sorts the elements according to the array.
   * @param  {String[]}  order  order of the items
   */
  sort: function(e) {
    var t = {}, s = this.el;
    this.toArray().forEach(function(r, n) {
      var a = s.children[n];
      Vt(a, this.options.draggable, s, !1) && (t[r] = a);
    }, this), e.forEach(function(r) {
      t[r] && (s.removeChild(t[r]), s.appendChild(t[r]));
    });
  },
  /**
   * Save the current sorting
   */
  save: function() {
    var e = this.options.store;
    e && e.set && e.set(this);
  },
  /**
   * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
   * @param   {HTMLElement}  el
   * @param   {String}       [selector]  default: `options.draggable`
   * @returns {HTMLElement|null}
   */
  closest: function(e, t) {
    return Vt(e, t || this.options.draggable, this.el, !1);
  },
  /**
   * Set/get option
   * @param   {string} name
   * @param   {*}      [value]
   * @returns {*}
   */
  option: function(e, t) {
    var s = this.options;
    if (t === void 0)
      return s[e];
    var r = fn.modifyOption(this, e, t);
    typeof r < "u" ? s[e] = r : s[e] = t, e === "group" && lf(s);
  },
  /**
   * Destroy
   */
  destroy: function() {
    _t("destroy", this);
    var e = this.el;
    e[at] = null, ce(e, "mousedown", this._onTapStart), ce(e, "touchstart", this._onTapStart), ce(e, "pointerdown", this._onTapStart), this.nativeDraggable && (ce(e, "dragover", this), ce(e, "dragenter", this)), Array.prototype.forEach.call(e.querySelectorAll("[draggable]"), function(t) {
      t.removeAttribute("draggable");
    }), this._onDrop(), this._disableDelayedDragEvents(), Ia.splice(Ia.indexOf(this.el), 1), this.el = e = null;
  },
  _hideClone: function() {
    if (!Ti) {
      if (_t("hideClone", this), ee.eventCanceled)
        return;
      G(Le, "display", "none"), this.options.removeCloneOnHide && Le.parentNode && Le.parentNode.removeChild(Le), Ti = !0;
    }
  },
  _showClone: function(e) {
    if (e.lastPutMode !== "clone") {
      this._hideClone();
      return;
    }
    if (Ti) {
      if (_t("showClone", this), ee.eventCanceled)
        return;
      Me.contains(F) && !this.options.group.revertClone ? Me.insertBefore(Le, F) : os ? Me.insertBefore(Le, os) : Me.appendChild(Le), this.options.group.revertClone && this.animate(F, Le), G(Le, "display", ""), Ti = !1;
    }
  }
};
function MD(i) {
  i.dataTransfer && (i.dataTransfer.dropEffect = "move"), i.cancelable && i.preventDefault();
}
function Lo(i, e, t, s, r, n, a, o) {
  var l, u = i[at], h = u.options.onMove, c;
  return window.CustomEvent && !Si && !dn ? l = new CustomEvent("move", {
    bubbles: !0,
    cancelable: !0
  }) : (l = document.createEvent("Event"), l.initEvent("move", !0, !0)), l.to = e, l.from = i, l.dragged = t, l.draggedRect = s, l.related = r || e, l.relatedRect = n || Re(e), l.willInsertAfter = o, l.originalEvent = a, i.dispatchEvent(l), h && (c = h.call(u, l, a)), c;
}
function jo(i) {
  i.draggable = !1;
}
function OD() {
  yl = !1;
}
function AD(i, e, t) {
  var s = Re(Pu(t.el, t.options.draggable)), r = 10;
  return e ? i.clientX > s.right + r || i.clientX <= s.right && i.clientY > s.bottom && i.clientX >= s.left : i.clientX > s.right && i.clientY > s.top || i.clientX <= s.right && i.clientY > s.bottom + r;
}
function LD(i, e, t, s, r, n, a, o) {
  var l = s ? i.clientY : i.clientX, u = s ? t.height : t.width, h = s ? t.top : t.left, c = s ? t.bottom : t.right, d = !1;
  if (!a) {
    if (o && Fn < u * r) {
      if (!$r && (Nr === 1 ? l > h + u * n / 2 : l < c - u * n / 2) && ($r = !0), $r)
        d = !0;
      else if (Nr === 1 ? l < h + Fn : l > c - Fn)
        return -Nr;
    } else if (l > h + u * (1 - r) / 2 && l < c - u * (1 - r) / 2)
      return jD(e);
  }
  return d = d || a, d && (l < h + u * n / 2 || l > c - u * n / 2) ? l > h + u / 2 ? 1 : -1 : 0;
}
function jD(i) {
  return Ee(F) < Ee(i) ? 1 : -1;
}
function ED(i) {
  for (var e = i.tagName + i.className + i.src + i.href + i.textContent, t = e.length, s = 0; t--; )
    s += e.charCodeAt(t);
  return s.toString(36);
}
function ID(i) {
  Ra.length = 0;
  for (var e = i.getElementsByTagName("input"), t = e.length; t--; ) {
    var s = e[t];
    s.checked && Ra.push(s);
  }
}
function Bn(i) {
  return setTimeout(i, 0);
}
function vl(i) {
  return clearTimeout(i);
}
lo && pe(document, "touchmove", function(i) {
  (ee.active || Ls) && i.cancelable && i.preventDefault();
});
ee.utils = {
  on: pe,
  off: ce,
  css: G,
  find: sf,
  is: function(e, t) {
    return !!Vt(e, t, e, !1);
  },
  extend: vD,
  throttle: rf,
  closest: Vt,
  toggleClass: Oe,
  clone: Tu,
  index: Ee,
  nextTick: Bn,
  cancelNextTick: vl,
  detectDirection: of,
  getChild: ja
};
ee.get = function(i) {
  return i[at];
};
ee.mount = function() {
  for (var i = arguments.length, e = new Array(i), t = 0; t < i; t++)
    e[t] = arguments[t];
  e[0].constructor === Array && (e = e[0]), e.forEach(function(s) {
    if (!s.prototype || !s.prototype.constructor)
      throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(s));
    s.utils && (ee.utils = Ki({}, ee.utils, s.utils)), fn.mount(s);
  });
};
ee.create = function(i, e) {
  return new ee(i, e);
};
ee.version = mD;
var Xe = [], Cr, xl, wl = !1, Eo, Io, Ya, Mr;
function RD() {
  function i() {
    this.defaults = {
      scroll: !0,
      scrollSensitivity: 30,
      scrollSpeed: 10,
      bubbleScroll: !0
    };
    for (var e in this)
      e.charAt(0) === "_" && typeof this[e] == "function" && (this[e] = this[e].bind(this));
  }
  return i.prototype = {
    dragStarted: function(t) {
      var s = t.originalEvent;
      this.sortable.nativeDraggable ? pe(document, "dragover", this._handleAutoScroll) : this.options.supportPointer ? pe(document, "pointermove", this._handleFallbackAutoScroll) : s.touches ? pe(document, "touchmove", this._handleFallbackAutoScroll) : pe(document, "mousemove", this._handleFallbackAutoScroll);
    },
    dragOverCompleted: function(t) {
      var s = t.originalEvent;
      !this.options.dragOverBubble && !s.rootEl && this._handleAutoScroll(s);
    },
    drop: function() {
      this.sortable.nativeDraggable ? ce(document, "dragover", this._handleAutoScroll) : (ce(document, "pointermove", this._handleFallbackAutoScroll), ce(document, "touchmove", this._handleFallbackAutoScroll), ce(document, "mousemove", this._handleFallbackAutoScroll)), Ch(), Hn(), xD();
    },
    nulling: function() {
      Ya = xl = Cr = wl = Mr = Eo = Io = null, Xe.length = 0;
    },
    _handleFallbackAutoScroll: function(t) {
      this._handleAutoScroll(t, !0);
    },
    _handleAutoScroll: function(t, s) {
      var r = this, n = (t.touches ? t.touches[0] : t).clientX, a = (t.touches ? t.touches[0] : t).clientY, o = document.elementFromPoint(n, a);
      if (Ya = t, s || dn || Si || bl) {
        Ro(t, this.options, o, s);
        var l = Ai(o, !0);
        wl && (!Mr || n !== Eo || a !== Io) && (Mr && Ch(), Mr = setInterval(function() {
          var u = Ai(document.elementFromPoint(n, a), !0);
          u !== l && (l = u, Hn()), Ro(t, r.options, u, s);
        }, 10), Eo = n, Io = a);
      } else {
        if (!this.options.bubbleScroll || Ai(o, !0) === ii()) {
          Hn();
          return;
        }
        Ro(t, this.options, Ai(o, !1), !1);
      }
    }
  }, Ft(i, {
    pluginName: "scroll",
    initializeByDefault: !0
  });
}
function Hn() {
  Xe.forEach(function(i) {
    clearInterval(i.pid);
  }), Xe = [];
}
function Ch() {
  clearInterval(Mr);
}
var Ro = rf(function(i, e, t, s) {
  if (e.scroll) {
    var r = (i.touches ? i.touches[0] : i).clientX, n = (i.touches ? i.touches[0] : i).clientY, a = e.scrollSensitivity, o = e.scrollSpeed, l = ii(), u = !1, h;
    xl !== t && (xl = t, Hn(), Cr = e.scroll, h = e.scrollFn, Cr === !0 && (Cr = Ai(t, !0)));
    var c = 0, d = Cr;
    do {
      var f = d, g = Re(f), p = g.top, m = g.bottom, _ = g.left, v = g.right, b = g.width, y = g.height, w = void 0, D = void 0, A = f.scrollWidth, T = f.scrollHeight, j = G(f), C = f.scrollLeft, L = f.scrollTop;
      f === l ? (w = b < A && (j.overflowX === "auto" || j.overflowX === "scroll" || j.overflowX === "visible"), D = y < T && (j.overflowY === "auto" || j.overflowY === "scroll" || j.overflowY === "visible")) : (w = b < A && (j.overflowX === "auto" || j.overflowX === "scroll"), D = y < T && (j.overflowY === "auto" || j.overflowY === "scroll"));
      var E = w && (Math.abs(v - r) <= a && C + b < A) - (Math.abs(_ - r) <= a && !!C), N = D && (Math.abs(m - n) <= a && L + y < T) - (Math.abs(p - n) <= a && !!L);
      if (!Xe[c])
        for (var J = 0; J <= c; J++)
          Xe[J] || (Xe[J] = {});
      (Xe[c].vx != E || Xe[c].vy != N || Xe[c].el !== f) && (Xe[c].el = f, Xe[c].vx = E, Xe[c].vy = N, clearInterval(Xe[c].pid), (E != 0 || N != 0) && (u = !0, Xe[c].pid = setInterval(function() {
        s && this.layer === 0 && ee.active._onTouchMove(Ya);
        var z = Xe[this.layer].vy ? Xe[this.layer].vy * o : 0, H = Xe[this.layer].vx ? Xe[this.layer].vx * o : 0;
        typeof h == "function" && h.call(ee.dragged.parentNode[at], H, z, i, Ya, Xe[this.layer].el) !== "continue" || nf(Xe[this.layer].el, H, z);
      }.bind({
        layer: c
      }), 24))), c++;
    } while (e.bubbleScroll && d !== l && (d = Ai(d, !1)));
    wl = u;
  }
}, 30), cf = function(e) {
  var t = e.originalEvent, s = e.putSortable, r = e.dragEl, n = e.activeSortable, a = e.dispatchSortableEvent, o = e.hideGhostForTarget, l = e.unhideGhostForTarget;
  if (t) {
    var u = s || n;
    o();
    var h = t.changedTouches && t.changedTouches.length ? t.changedTouches[0] : t, c = document.elementFromPoint(h.clientX, h.clientY);
    l(), u && !u.el.contains(c) && (a("spill"), this.onSpill({
      dragEl: r,
      putSortable: s
    }));
  }
};
function ku() {
}
ku.prototype = {
  startIndex: null,
  dragStart: function(e) {
    var t = e.oldDraggableIndex;
    this.startIndex = t;
  },
  onSpill: function(e) {
    var t = e.dragEl, s = e.putSortable;
    this.sortable.captureAnimationState(), s && s.captureAnimationState();
    var r = ja(this.sortable.el, this.startIndex, this.options);
    r ? this.sortable.el.insertBefore(t, r) : this.sortable.el.appendChild(t), this.sortable.animateAll(), s && s.animateAll();
  },
  drop: cf
};
Ft(ku, {
  pluginName: "revertOnSpill"
});
function Cu() {
}
Cu.prototype = {
  onSpill: function(e) {
    var t = e.dragEl, s = e.putSortable, r = s || this.sortable;
    r.captureAnimationState(), t.parentNode && t.parentNode.removeChild(t), r.animateAll();
  },
  drop: cf
};
Ft(Cu, {
  pluginName: "removeOnSpill"
});
var Rt;
function YD() {
  function i() {
    this.defaults = {
      swapClass: "sortable-swap-highlight"
    };
  }
  return i.prototype = {
    dragStart: function(t) {
      var s = t.dragEl;
      Rt = s;
    },
    dragOverValid: function(t) {
      var s = t.completed, r = t.target, n = t.onMove, a = t.activeSortable, o = t.changed, l = t.cancel;
      if (a.options.swap) {
        var u = this.sortable.el, h = this.options;
        if (r && r !== u) {
          var c = Rt;
          n(r) !== !1 ? (Oe(r, h.swapClass, !0), Rt = r) : Rt = null, c && c !== Rt && Oe(c, h.swapClass, !1);
        }
        o(), s(!0), l();
      }
    },
    drop: function(t) {
      var s = t.activeSortable, r = t.putSortable, n = t.dragEl, a = r || this.sortable, o = this.options;
      Rt && Oe(Rt, o.swapClass, !1), Rt && (o.swap || r && r.options.swap) && n !== Rt && (a.captureAnimationState(), a !== s && s.captureAnimationState(), ND(n, Rt), a.animateAll(), a !== s && s.animateAll());
    },
    nulling: function() {
      Rt = null;
    }
  }, Ft(i, {
    pluginName: "swap",
    eventProperties: function() {
      return {
        swapItem: Rt
      };
    }
  });
}
function ND(i, e) {
  var t = i.parentNode, s = e.parentNode, r, n;
  !t || !s || t.isEqualNode(e) || s.isEqualNode(i) || (r = Ee(i), n = Ee(e), t.isEqualNode(s) && r < n && n++, t.insertBefore(e, t.children[r]), s.insertBefore(i, s.children[n]));
}
var re = [], kt = [], br, Xt, yr = !1, Tt = !1, Ms = !1, Se, vr, kn;
function $D() {
  function i(e) {
    for (var t in this)
      t.charAt(0) === "_" && typeof this[t] == "function" && (this[t] = this[t].bind(this));
    e.options.supportPointer ? pe(document, "pointerup", this._deselectMultiDrag) : (pe(document, "mouseup", this._deselectMultiDrag), pe(document, "touchend", this._deselectMultiDrag)), pe(document, "keydown", this._checkKeyDown), pe(document, "keyup", this._checkKeyUp), this.defaults = {
      selectedClass: "sortable-selected",
      multiDragKey: null,
      setData: function(r, n) {
        var a = "";
        re.length && Xt === e ? re.forEach(function(o, l) {
          a += (l ? ", " : "") + o.textContent;
        }) : a = n.textContent, r.setData("Text", a);
      }
    };
  }
  return i.prototype = {
    multiDragKeyDown: !1,
    isMultiDrag: !1,
    delayStartGlobal: function(t) {
      var s = t.dragEl;
      Se = s;
    },
    delayEnded: function() {
      this.isMultiDrag = ~re.indexOf(Se);
    },
    setupClone: function(t) {
      var s = t.sortable, r = t.cancel;
      if (this.isMultiDrag) {
        for (var n = 0; n < re.length; n++)
          kt.push(Tu(re[n])), kt[n].sortableIndex = re[n].sortableIndex, kt[n].draggable = !1, kt[n].style["will-change"] = "", Oe(kt[n], this.options.selectedClass, !1), re[n] === Se && Oe(kt[n], this.options.chosenClass, !1);
        s._hideClone(), r();
      }
    },
    clone: function(t) {
      var s = t.sortable, r = t.rootEl, n = t.dispatchSortableEvent, a = t.cancel;
      this.isMultiDrag && (this.options.removeCloneOnHide || re.length && Xt === s && (Mh(!0, r), n("clone"), a()));
    },
    showClone: function(t) {
      var s = t.cloneNowShown, r = t.rootEl, n = t.cancel;
      this.isMultiDrag && (Mh(!1, r), kt.forEach(function(a) {
        G(a, "display", "");
      }), s(), kn = !1, n());
    },
    hideClone: function(t) {
      var s = this;
      t.sortable;
      var r = t.cloneNowHidden, n = t.cancel;
      this.isMultiDrag && (kt.forEach(function(a) {
        G(a, "display", "none"), s.options.removeCloneOnHide && a.parentNode && a.parentNode.removeChild(a);
      }), r(), kn = !0, n());
    },
    dragStartGlobal: function(t) {
      t.sortable, !this.isMultiDrag && Xt && Xt.multiDrag._deselectMultiDrag(), re.forEach(function(s) {
        s.sortableIndex = Ee(s);
      }), re = re.sort(function(s, r) {
        return s.sortableIndex - r.sortableIndex;
      }), Ms = !0;
    },
    dragStarted: function(t) {
      var s = this, r = t.sortable;
      if (this.isMultiDrag) {
        if (this.options.sort && (r.captureAnimationState(), this.options.animation)) {
          re.forEach(function(a) {
            a !== Se && G(a, "position", "absolute");
          });
          var n = Re(Se, !1, !0, !0);
          re.forEach(function(a) {
            a !== Se && Dh(a, n);
          }), Tt = !0, yr = !0;
        }
        r.animateAll(function() {
          Tt = !1, yr = !1, s.options.animation && re.forEach(function(a) {
            ko(a);
          }), s.options.sort && Cn();
        });
      }
    },
    dragOver: function(t) {
      var s = t.target, r = t.completed, n = t.cancel;
      Tt && ~re.indexOf(s) && (r(!1), n());
    },
    revert: function(t) {
      var s = t.fromSortable, r = t.rootEl, n = t.sortable, a = t.dragRect;
      re.length > 1 && (re.forEach(function(o) {
        n.addAnimationState({
          target: o,
          rect: Tt ? Re(o) : a
        }), ko(o), o.fromRect = a, s.removeAnimationState(o);
      }), Tt = !1, FD(!this.options.removeCloneOnHide, r));
    },
    dragOverCompleted: function(t) {
      var s = t.sortable, r = t.isOwner, n = t.insertion, a = t.activeSortable, o = t.parentEl, l = t.putSortable, u = this.options;
      if (n) {
        if (r && a._hideClone(), yr = !1, u.animation && re.length > 1 && (Tt || !r && !a.options.sort && !l)) {
          var h = Re(Se, !1, !0, !0);
          re.forEach(function(d) {
            d !== Se && (Dh(d, h), o.appendChild(d));
          }), Tt = !0;
        }
        if (!r)
          if (Tt || Cn(), re.length > 1) {
            var c = kn;
            a._showClone(s), a.options.animation && !kn && c && kt.forEach(function(d) {
              a.addAnimationState({
                target: d,
                rect: vr
              }), d.fromRect = vr, d.thisAnimationDuration = null;
            });
          } else
            a._showClone(s);
      }
    },
    dragOverAnimationCapture: function(t) {
      var s = t.dragRect, r = t.isOwner, n = t.activeSortable;
      if (re.forEach(function(o) {
        o.thisAnimationDuration = null;
      }), n.options.animation && !r && n.multiDrag.isMultiDrag) {
        vr = Ft({}, s);
        var a = gs(Se, !0);
        vr.top -= a.f, vr.left -= a.e;
      }
    },
    dragOverAnimationComplete: function() {
      Tt && (Tt = !1, Cn());
    },
    drop: function(t) {
      var s = t.originalEvent, r = t.rootEl, n = t.parentEl, a = t.sortable, o = t.dispatchSortableEvent, l = t.oldIndex, u = t.putSortable, h = u || this.sortable;
      if (s) {
        var c = this.options, d = n.children;
        if (!Ms)
          if (c.multiDragKey && !this.multiDragKeyDown && this._deselectMultiDrag(), Oe(Se, c.selectedClass, !~re.indexOf(Se)), ~re.indexOf(Se))
            re.splice(re.indexOf(Se), 1), br = null, Tr({
              sortable: a,
              rootEl: r,
              name: "deselect",
              targetEl: Se,
              originalEvt: s
            });
          else {
            if (re.push(Se), Tr({
              sortable: a,
              rootEl: r,
              name: "select",
              targetEl: Se,
              originalEvt: s
            }), s.shiftKey && br && a.el.contains(br)) {
              var f = Ee(br), g = Ee(Se);
              if (~f && ~g && f !== g) {
                var p, m;
                for (g > f ? (m = f, p = g) : (m = g, p = f + 1); m < p; m++)
                  ~re.indexOf(d[m]) || (Oe(d[m], c.selectedClass, !0), re.push(d[m]), Tr({
                    sortable: a,
                    rootEl: r,
                    name: "select",
                    targetEl: d[m],
                    originalEvt: s
                  }));
              }
            } else
              br = Se;
            Xt = h;
          }
        if (Ms && this.isMultiDrag) {
          if ((n[at].options.sort || n !== r) && re.length > 1) {
            var _ = Re(Se), v = Ee(Se, ":not(." + this.options.selectedClass + ")");
            if (!yr && c.animation && (Se.thisAnimationDuration = null), h.captureAnimationState(), !yr && (c.animation && (Se.fromRect = _, re.forEach(function(y) {
              if (y.thisAnimationDuration = null, y !== Se) {
                var w = Tt ? Re(y) : _;
                y.fromRect = w, h.addAnimationState({
                  target: y,
                  rect: w
                });
              }
            })), Cn(), re.forEach(function(y) {
              d[v] ? n.insertBefore(y, d[v]) : n.appendChild(y), v++;
            }), l === Ee(Se))) {
              var b = !1;
              re.forEach(function(y) {
                if (y.sortableIndex !== Ee(y)) {
                  b = !0;
                  return;
                }
              }), b && o("update");
            }
            re.forEach(function(y) {
              ko(y);
            }), h.animateAll();
          }
          Xt = h;
        }
        (r === n || u && u.lastPutMode !== "clone") && kt.forEach(function(y) {
          y.parentNode && y.parentNode.removeChild(y);
        });
      }
    },
    nullingGlobal: function() {
      this.isMultiDrag = Ms = !1, kt.length = 0;
    },
    destroyGlobal: function() {
      this._deselectMultiDrag(), ce(document, "pointerup", this._deselectMultiDrag), ce(document, "mouseup", this._deselectMultiDrag), ce(document, "touchend", this._deselectMultiDrag), ce(document, "keydown", this._checkKeyDown), ce(document, "keyup", this._checkKeyUp);
    },
    _deselectMultiDrag: function(t) {
      if (!(typeof Ms < "u" && Ms) && Xt === this.sortable && !(t && Vt(t.target, this.options.draggable, this.sortable.el, !1)) && !(t && t.button !== 0))
        for (; re.length; ) {
          var s = re[0];
          Oe(s, this.options.selectedClass, !1), re.shift(), Tr({
            sortable: this.sortable,
            rootEl: this.sortable.el,
            name: "deselect",
            targetEl: s,
            originalEvt: t
          });
        }
    },
    _checkKeyDown: function(t) {
      t.key === this.options.multiDragKey && (this.multiDragKeyDown = !0);
    },
    _checkKeyUp: function(t) {
      t.key === this.options.multiDragKey && (this.multiDragKeyDown = !1);
    }
  }, Ft(i, {
    // Static methods & properties
    pluginName: "multiDrag",
    utils: {
      /**
       * Selects the provided multi-drag item
       * @param  {HTMLElement} el    The element to be selected
       */
      select: function(t) {
        var s = t.parentNode[at];
        !s || !s.options.multiDrag || ~re.indexOf(t) || (Xt && Xt !== s && (Xt.multiDrag._deselectMultiDrag(), Xt = s), Oe(t, s.options.selectedClass, !0), re.push(t));
      },
      /**
       * Deselects the provided multi-drag item
       * @param  {HTMLElement} el    The element to be deselected
       */
      deselect: function(t) {
        var s = t.parentNode[at], r = re.indexOf(t);
        !s || !s.options.multiDrag || !~r || (Oe(t, s.options.selectedClass, !1), re.splice(r, 1));
      }
    },
    eventProperties: function() {
      var t = this, s = [], r = [];
      return re.forEach(function(n) {
        s.push({
          multiDragElement: n,
          index: n.sortableIndex
        });
        var a;
        Tt && n !== Se ? a = -1 : Tt ? a = Ee(n, ":not(." + t.options.selectedClass + ")") : a = Ee(n), r.push({
          multiDragElement: n,
          index: a
        });
      }), {
        items: dD(re),
        clones: [].concat(kt),
        oldIndicies: s,
        newIndicies: r
      };
    },
    optionListeners: {
      multiDragKey: function(t) {
        return t = t.toLowerCase(), t === "ctrl" ? t = "Control" : t.length > 1 && (t = t.charAt(0).toUpperCase() + t.substr(1)), t;
      }
    }
  });
}
function FD(i, e) {
  re.forEach(function(t, s) {
    var r = e.children[t.sortableIndex + (i ? Number(s) : 0)];
    r ? e.insertBefore(t, r) : e.appendChild(t);
  });
}
function Mh(i, e) {
  kt.forEach(function(t, s) {
    var r = e.children[t.sortableIndex + (i ? Number(s) : 0)];
    r ? e.insertBefore(t, r) : e.appendChild(t);
  });
}
function Cn() {
  re.forEach(function(i) {
    i !== Se && i.parentNode && i.parentNode.removeChild(i);
  });
}
ee.mount(new RD());
ee.mount(Cu, ku);
const BD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  MultiDrag: $D,
  Sortable: ee,
  Swap: YD,
  default: ee
}, Symbol.toStringTag, { value: "Module" })), HD = /* @__PURE__ */ lS(BD);
(function(i, e) {
  (function(s, r) {
    i.exports = r(HD);
  })(typeof self < "u" ? self : aS, function(t) {
    return (
      /******/
      function(s) {
        var r = {};
        function n(a) {
          if (r[a])
            return r[a].exports;
          var o = r[a] = {
            /******/
            i: a,
            /******/
            l: !1,
            /******/
            exports: {}
            /******/
          };
          return s[a].call(o.exports, o, o.exports, n), o.l = !0, o.exports;
        }
        return n.m = s, n.c = r, n.d = function(a, o, l) {
          n.o(a, o) || Object.defineProperty(a, o, { enumerable: !0, get: l });
        }, n.r = function(a) {
          typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(a, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(a, "__esModule", { value: !0 });
        }, n.t = function(a, o) {
          if (o & 1 && (a = n(a)), o & 8 || o & 4 && typeof a == "object" && a && a.__esModule)
            return a;
          var l = /* @__PURE__ */ Object.create(null);
          if (n.r(l), Object.defineProperty(l, "default", { enumerable: !0, value: a }), o & 2 && typeof a != "string")
            for (var u in a)
              n.d(l, u, function(h) {
                return a[h];
              }.bind(null, u));
          return l;
        }, n.n = function(a) {
          var o = a && a.__esModule ? (
            /******/
            function() {
              return a.default;
            }
          ) : (
            /******/
            function() {
              return a;
            }
          );
          return n.d(o, "a", o), o;
        }, n.o = function(a, o) {
          return Object.prototype.hasOwnProperty.call(a, o);
        }, n.p = "", n(n.s = "fb15");
      }({
        /***/
        "01f9": (
          /***/
          function(s, r, n) {
            var a = n("2d00"), o = n("5ca1"), l = n("2aba"), u = n("32e9"), h = n("84f2"), c = n("41a0"), d = n("7f20"), f = n("38fd"), g = n("2b4c")("iterator"), p = !([].keys && "next" in [].keys()), m = "@@iterator", _ = "keys", v = "values", b = function() {
              return this;
            };
            s.exports = function(y, w, D, A, T, j, C) {
              c(D, w, A);
              var L = function(M) {
                if (!p && M in z)
                  return z[M];
                switch (M) {
                  case _:
                    return function() {
                      return new D(this, M);
                    };
                  case v:
                    return function() {
                      return new D(this, M);
                    };
                }
                return function() {
                  return new D(this, M);
                };
              }, E = w + " Iterator", N = T == v, J = !1, z = y.prototype, H = z[g] || z[m] || T && z[T], Y = H || L(T), U = T ? N ? L("entries") : Y : void 0, B = w == "Array" && z.entries || H, ue, O, k;
              if (B && (k = f(B.call(new y())), k !== Object.prototype && k.next && (d(k, E, !0), !a && typeof k[g] != "function" && u(k, g, b))), N && H && H.name !== v && (J = !0, Y = function() {
                return H.call(this);
              }), (!a || C) && (p || J || !z[g]) && u(z, g, Y), h[w] = Y, h[E] = b, T)
                if (ue = {
                  values: N ? Y : L(v),
                  keys: j ? Y : L(_),
                  entries: U
                }, C)
                  for (O in ue)
                    O in z || l(z, O, ue[O]);
                else
                  o(o.P + o.F * (p || J), w, ue);
              return ue;
            };
          }
        ),
        /***/
        "02f4": (
          /***/
          function(s, r, n) {
            var a = n("4588"), o = n("be13");
            s.exports = function(l) {
              return function(u, h) {
                var c = String(o(u)), d = a(h), f = c.length, g, p;
                return d < 0 || d >= f ? l ? "" : void 0 : (g = c.charCodeAt(d), g < 55296 || g > 56319 || d + 1 === f || (p = c.charCodeAt(d + 1)) < 56320 || p > 57343 ? l ? c.charAt(d) : g : l ? c.slice(d, d + 2) : (g - 55296 << 10) + (p - 56320) + 65536);
              };
            };
          }
        ),
        /***/
        "0390": (
          /***/
          function(s, r, n) {
            var a = n("02f4")(!0);
            s.exports = function(o, l, u) {
              return l + (u ? a(o, l).length : 1);
            };
          }
        ),
        /***/
        "0bfb": (
          /***/
          function(s, r, n) {
            var a = n("cb7c");
            s.exports = function() {
              var o = a(this), l = "";
              return o.global && (l += "g"), o.ignoreCase && (l += "i"), o.multiline && (l += "m"), o.unicode && (l += "u"), o.sticky && (l += "y"), l;
            };
          }
        ),
        /***/
        "0d58": (
          /***/
          function(s, r, n) {
            var a = n("ce10"), o = n("e11e");
            s.exports = Object.keys || function(u) {
              return a(u, o);
            };
          }
        ),
        /***/
        1495: (
          /***/
          function(s, r, n) {
            var a = n("86cc"), o = n("cb7c"), l = n("0d58");
            s.exports = n("9e1e") ? Object.defineProperties : function(h, c) {
              o(h);
              for (var d = l(c), f = d.length, g = 0, p; f > g; )
                a.f(h, p = d[g++], c[p]);
              return h;
            };
          }
        ),
        /***/
        "214f": (
          /***/
          function(s, r, n) {
            n("b0c5");
            var a = n("2aba"), o = n("32e9"), l = n("79e5"), u = n("be13"), h = n("2b4c"), c = n("520a"), d = h("species"), f = !l(function() {
              var p = /./;
              return p.exec = function() {
                var m = [];
                return m.groups = { a: "7" }, m;
              }, "".replace(p, "$<a>") !== "7";
            }), g = function() {
              var p = /(?:)/, m = p.exec;
              p.exec = function() {
                return m.apply(this, arguments);
              };
              var _ = "ab".split(p);
              return _.length === 2 && _[0] === "a" && _[1] === "b";
            }();
            s.exports = function(p, m, _) {
              var v = h(p), b = !l(function() {
                var j = {};
                return j[v] = function() {
                  return 7;
                }, ""[p](j) != 7;
              }), y = b ? !l(function() {
                var j = !1, C = /a/;
                return C.exec = function() {
                  return j = !0, null;
                }, p === "split" && (C.constructor = {}, C.constructor[d] = function() {
                  return C;
                }), C[v](""), !j;
              }) : void 0;
              if (!b || !y || p === "replace" && !f || p === "split" && !g) {
                var w = /./[v], D = _(
                  u,
                  v,
                  ""[p],
                  function(C, L, E, N, J) {
                    return L.exec === c ? b && !J ? { done: !0, value: w.call(L, E, N) } : { done: !0, value: C.call(E, L, N) } : { done: !1 };
                  }
                ), A = D[0], T = D[1];
                a(String.prototype, p, A), o(
                  RegExp.prototype,
                  v,
                  m == 2 ? function(j, C) {
                    return T.call(j, this, C);
                  } : function(j) {
                    return T.call(j, this);
                  }
                );
              }
            };
          }
        ),
        /***/
        "230e": (
          /***/
          function(s, r, n) {
            var a = n("d3f4"), o = n("7726").document, l = a(o) && a(o.createElement);
            s.exports = function(u) {
              return l ? o.createElement(u) : {};
            };
          }
        ),
        /***/
        "23c6": (
          /***/
          function(s, r, n) {
            var a = n("2d95"), o = n("2b4c")("toStringTag"), l = a(function() {
              return arguments;
            }()) == "Arguments", u = function(h, c) {
              try {
                return h[c];
              } catch {
              }
            };
            s.exports = function(h) {
              var c, d, f;
              return h === void 0 ? "Undefined" : h === null ? "Null" : typeof (d = u(c = Object(h), o)) == "string" ? d : l ? a(c) : (f = a(c)) == "Object" && typeof c.callee == "function" ? "Arguments" : f;
            };
          }
        ),
        /***/
        2621: (
          /***/
          function(s, r) {
            r.f = Object.getOwnPropertySymbols;
          }
        ),
        /***/
        "2aba": (
          /***/
          function(s, r, n) {
            var a = n("7726"), o = n("32e9"), l = n("69a8"), u = n("ca5a")("src"), h = n("fa5b"), c = "toString", d = ("" + h).split(c);
            n("8378").inspectSource = function(f) {
              return h.call(f);
            }, (s.exports = function(f, g, p, m) {
              var _ = typeof p == "function";
              _ && (l(p, "name") || o(p, "name", g)), f[g] !== p && (_ && (l(p, u) || o(p, u, f[g] ? "" + f[g] : d.join(String(g)))), f === a ? f[g] = p : m ? f[g] ? f[g] = p : o(f, g, p) : (delete f[g], o(f, g, p)));
            })(Function.prototype, c, function() {
              return typeof this == "function" && this[u] || h.call(this);
            });
          }
        ),
        /***/
        "2aeb": (
          /***/
          function(s, r, n) {
            var a = n("cb7c"), o = n("1495"), l = n("e11e"), u = n("613b")("IE_PROTO"), h = function() {
            }, c = "prototype", d = function() {
              var f = n("230e")("iframe"), g = l.length, p = "<", m = ">", _;
              for (f.style.display = "none", n("fab2").appendChild(f), f.src = "javascript:", _ = f.contentWindow.document, _.open(), _.write(p + "script" + m + "document.F=Object" + p + "/script" + m), _.close(), d = _.F; g--; )
                delete d[c][l[g]];
              return d();
            };
            s.exports = Object.create || function(g, p) {
              var m;
              return g !== null ? (h[c] = a(g), m = new h(), h[c] = null, m[u] = g) : m = d(), p === void 0 ? m : o(m, p);
            };
          }
        ),
        /***/
        "2b4c": (
          /***/
          function(s, r, n) {
            var a = n("5537")("wks"), o = n("ca5a"), l = n("7726").Symbol, u = typeof l == "function", h = s.exports = function(c) {
              return a[c] || (a[c] = u && l[c] || (u ? l : o)("Symbol." + c));
            };
            h.store = a;
          }
        ),
        /***/
        "2d00": (
          /***/
          function(s, r) {
            s.exports = !1;
          }
        ),
        /***/
        "2d95": (
          /***/
          function(s, r) {
            var n = {}.toString;
            s.exports = function(a) {
              return n.call(a).slice(8, -1);
            };
          }
        ),
        /***/
        "2fdb": (
          /***/
          function(s, r, n) {
            var a = n("5ca1"), o = n("d2c8"), l = "includes";
            a(a.P + a.F * n("5147")(l), "String", {
              includes: function(h) {
                return !!~o(this, h, l).indexOf(h, arguments.length > 1 ? arguments[1] : void 0);
              }
            });
          }
        ),
        /***/
        "32e9": (
          /***/
          function(s, r, n) {
            var a = n("86cc"), o = n("4630");
            s.exports = n("9e1e") ? function(l, u, h) {
              return a.f(l, u, o(1, h));
            } : function(l, u, h) {
              return l[u] = h, l;
            };
          }
        ),
        /***/
        "38fd": (
          /***/
          function(s, r, n) {
            var a = n("69a8"), o = n("4bf8"), l = n("613b")("IE_PROTO"), u = Object.prototype;
            s.exports = Object.getPrototypeOf || function(h) {
              return h = o(h), a(h, l) ? h[l] : typeof h.constructor == "function" && h instanceof h.constructor ? h.constructor.prototype : h instanceof Object ? u : null;
            };
          }
        ),
        /***/
        "41a0": (
          /***/
          function(s, r, n) {
            var a = n("2aeb"), o = n("4630"), l = n("7f20"), u = {};
            n("32e9")(u, n("2b4c")("iterator"), function() {
              return this;
            }), s.exports = function(h, c, d) {
              h.prototype = a(u, { next: o(1, d) }), l(h, c + " Iterator");
            };
          }
        ),
        /***/
        "456d": (
          /***/
          function(s, r, n) {
            var a = n("4bf8"), o = n("0d58");
            n("5eda")("keys", function() {
              return function(u) {
                return o(a(u));
              };
            });
          }
        ),
        /***/
        4588: (
          /***/
          function(s, r) {
            var n = Math.ceil, a = Math.floor;
            s.exports = function(o) {
              return isNaN(o = +o) ? 0 : (o > 0 ? a : n)(o);
            };
          }
        ),
        /***/
        4630: (
          /***/
          function(s, r) {
            s.exports = function(n, a) {
              return {
                enumerable: !(n & 1),
                configurable: !(n & 2),
                writable: !(n & 4),
                value: a
              };
            };
          }
        ),
        /***/
        "4bf8": (
          /***/
          function(s, r, n) {
            var a = n("be13");
            s.exports = function(o) {
              return Object(a(o));
            };
          }
        ),
        /***/
        5147: (
          /***/
          function(s, r, n) {
            var a = n("2b4c")("match");
            s.exports = function(o) {
              var l = /./;
              try {
                "/./"[o](l);
              } catch {
                try {
                  return l[a] = !1, !"/./"[o](l);
                } catch {
                }
              }
              return !0;
            };
          }
        ),
        /***/
        "520a": (
          /***/
          function(s, r, n) {
            var a = n("0bfb"), o = RegExp.prototype.exec, l = String.prototype.replace, u = o, h = "lastIndex", c = function() {
              var g = /a/, p = /b*/g;
              return o.call(g, "a"), o.call(p, "a"), g[h] !== 0 || p[h] !== 0;
            }(), d = /()??/.exec("")[1] !== void 0, f = c || d;
            f && (u = function(p) {
              var m = this, _, v, b, y;
              return d && (v = new RegExp("^" + m.source + "$(?!\\s)", a.call(m))), c && (_ = m[h]), b = o.call(m, p), c && b && (m[h] = m.global ? b.index + b[0].length : _), d && b && b.length > 1 && l.call(b[0], v, function() {
                for (y = 1; y < arguments.length - 2; y++)
                  arguments[y] === void 0 && (b[y] = void 0);
              }), b;
            }), s.exports = u;
          }
        ),
        /***/
        "52a7": (
          /***/
          function(s, r) {
            r.f = {}.propertyIsEnumerable;
          }
        ),
        /***/
        5537: (
          /***/
          function(s, r, n) {
            var a = n("8378"), o = n("7726"), l = "__core-js_shared__", u = o[l] || (o[l] = {});
            (s.exports = function(h, c) {
              return u[h] || (u[h] = c !== void 0 ? c : {});
            })("versions", []).push({
              version: a.version,
              mode: n("2d00") ? "pure" : "global",
              copyright: "© 2019 Denis Pushkarev (zloirock.ru)"
            });
          }
        ),
        /***/
        "5ca1": (
          /***/
          function(s, r, n) {
            var a = n("7726"), o = n("8378"), l = n("32e9"), u = n("2aba"), h = n("9b43"), c = "prototype", d = function(f, g, p) {
              var m = f & d.F, _ = f & d.G, v = f & d.S, b = f & d.P, y = f & d.B, w = _ ? a : v ? a[g] || (a[g] = {}) : (a[g] || {})[c], D = _ ? o : o[g] || (o[g] = {}), A = D[c] || (D[c] = {}), T, j, C, L;
              _ && (p = g);
              for (T in p)
                j = !m && w && w[T] !== void 0, C = (j ? w : p)[T], L = y && j ? h(C, a) : b && typeof C == "function" ? h(Function.call, C) : C, w && u(w, T, C, f & d.U), D[T] != C && l(D, T, L), b && A[T] != C && (A[T] = C);
            };
            a.core = o, d.F = 1, d.G = 2, d.S = 4, d.P = 8, d.B = 16, d.W = 32, d.U = 64, d.R = 128, s.exports = d;
          }
        ),
        /***/
        "5eda": (
          /***/
          function(s, r, n) {
            var a = n("5ca1"), o = n("8378"), l = n("79e5");
            s.exports = function(u, h) {
              var c = (o.Object || {})[u] || Object[u], d = {};
              d[u] = h(c), a(a.S + a.F * l(function() {
                c(1);
              }), "Object", d);
            };
          }
        ),
        /***/
        "5f1b": (
          /***/
          function(s, r, n) {
            var a = n("23c6"), o = RegExp.prototype.exec;
            s.exports = function(l, u) {
              var h = l.exec;
              if (typeof h == "function") {
                var c = h.call(l, u);
                if (typeof c != "object")
                  throw new TypeError("RegExp exec method returned something other than an Object or null");
                return c;
              }
              if (a(l) !== "RegExp")
                throw new TypeError("RegExp#exec called on incompatible receiver");
              return o.call(l, u);
            };
          }
        ),
        /***/
        "613b": (
          /***/
          function(s, r, n) {
            var a = n("5537")("keys"), o = n("ca5a");
            s.exports = function(l) {
              return a[l] || (a[l] = o(l));
            };
          }
        ),
        /***/
        "626a": (
          /***/
          function(s, r, n) {
            var a = n("2d95");
            s.exports = Object("z").propertyIsEnumerable(0) ? Object : function(o) {
              return a(o) == "String" ? o.split("") : Object(o);
            };
          }
        ),
        /***/
        6762: (
          /***/
          function(s, r, n) {
            var a = n("5ca1"), o = n("c366")(!0);
            a(a.P, "Array", {
              includes: function(u) {
                return o(this, u, arguments.length > 1 ? arguments[1] : void 0);
              }
            }), n("9c6c")("includes");
          }
        ),
        /***/
        6821: (
          /***/
          function(s, r, n) {
            var a = n("626a"), o = n("be13");
            s.exports = function(l) {
              return a(o(l));
            };
          }
        ),
        /***/
        "69a8": (
          /***/
          function(s, r) {
            var n = {}.hasOwnProperty;
            s.exports = function(a, o) {
              return n.call(a, o);
            };
          }
        ),
        /***/
        "6a99": (
          /***/
          function(s, r, n) {
            var a = n("d3f4");
            s.exports = function(o, l) {
              if (!a(o))
                return o;
              var u, h;
              if (l && typeof (u = o.toString) == "function" && !a(h = u.call(o)) || typeof (u = o.valueOf) == "function" && !a(h = u.call(o)) || !l && typeof (u = o.toString) == "function" && !a(h = u.call(o)))
                return h;
              throw TypeError("Can't convert object to primitive value");
            };
          }
        ),
        /***/
        7333: (
          /***/
          function(s, r, n) {
            var a = n("0d58"), o = n("2621"), l = n("52a7"), u = n("4bf8"), h = n("626a"), c = Object.assign;
            s.exports = !c || n("79e5")(function() {
              var d = {}, f = {}, g = Symbol(), p = "abcdefghijklmnopqrst";
              return d[g] = 7, p.split("").forEach(function(m) {
                f[m] = m;
              }), c({}, d)[g] != 7 || Object.keys(c({}, f)).join("") != p;
            }) ? function(f, g) {
              for (var p = u(f), m = arguments.length, _ = 1, v = o.f, b = l.f; m > _; )
                for (var y = h(arguments[_++]), w = v ? a(y).concat(v(y)) : a(y), D = w.length, A = 0, T; D > A; )
                  b.call(y, T = w[A++]) && (p[T] = y[T]);
              return p;
            } : c;
          }
        ),
        /***/
        7726: (
          /***/
          function(s, r) {
            var n = s.exports = typeof window < "u" && window.Math == Math ? window : typeof self < "u" && self.Math == Math ? self : Function("return this")();
            typeof __g == "number" && (__g = n);
          }
        ),
        /***/
        "77f1": (
          /***/
          function(s, r, n) {
            var a = n("4588"), o = Math.max, l = Math.min;
            s.exports = function(u, h) {
              return u = a(u), u < 0 ? o(u + h, 0) : l(u, h);
            };
          }
        ),
        /***/
        "79e5": (
          /***/
          function(s, r) {
            s.exports = function(n) {
              try {
                return !!n();
              } catch {
                return !0;
              }
            };
          }
        ),
        /***/
        "7f20": (
          /***/
          function(s, r, n) {
            var a = n("86cc").f, o = n("69a8"), l = n("2b4c")("toStringTag");
            s.exports = function(u, h, c) {
              u && !o(u = c ? u : u.prototype, l) && a(u, l, { configurable: !0, value: h });
            };
          }
        ),
        /***/
        8378: (
          /***/
          function(s, r) {
            var n = s.exports = { version: "2.6.5" };
            typeof __e == "number" && (__e = n);
          }
        ),
        /***/
        "84f2": (
          /***/
          function(s, r) {
            s.exports = {};
          }
        ),
        /***/
        "86cc": (
          /***/
          function(s, r, n) {
            var a = n("cb7c"), o = n("c69a"), l = n("6a99"), u = Object.defineProperty;
            r.f = n("9e1e") ? Object.defineProperty : function(c, d, f) {
              if (a(c), d = l(d, !0), a(f), o)
                try {
                  return u(c, d, f);
                } catch {
                }
              if ("get" in f || "set" in f)
                throw TypeError("Accessors not supported!");
              return "value" in f && (c[d] = f.value), c;
            };
          }
        ),
        /***/
        "9b43": (
          /***/
          function(s, r, n) {
            var a = n("d8e8");
            s.exports = function(o, l, u) {
              if (a(o), l === void 0)
                return o;
              switch (u) {
                case 1:
                  return function(h) {
                    return o.call(l, h);
                  };
                case 2:
                  return function(h, c) {
                    return o.call(l, h, c);
                  };
                case 3:
                  return function(h, c, d) {
                    return o.call(l, h, c, d);
                  };
              }
              return function() {
                return o.apply(l, arguments);
              };
            };
          }
        ),
        /***/
        "9c6c": (
          /***/
          function(s, r, n) {
            var a = n("2b4c")("unscopables"), o = Array.prototype;
            o[a] == null && n("32e9")(o, a, {}), s.exports = function(l) {
              o[a][l] = !0;
            };
          }
        ),
        /***/
        "9def": (
          /***/
          function(s, r, n) {
            var a = n("4588"), o = Math.min;
            s.exports = function(l) {
              return l > 0 ? o(a(l), 9007199254740991) : 0;
            };
          }
        ),
        /***/
        "9e1e": (
          /***/
          function(s, r, n) {
            s.exports = !n("79e5")(function() {
              return Object.defineProperty({}, "a", { get: function() {
                return 7;
              } }).a != 7;
            });
          }
        ),
        /***/
        a352: (
          /***/
          function(s, r) {
            s.exports = t;
          }
        ),
        /***/
        a481: (
          /***/
          function(s, r, n) {
            var a = n("cb7c"), o = n("4bf8"), l = n("9def"), u = n("4588"), h = n("0390"), c = n("5f1b"), d = Math.max, f = Math.min, g = Math.floor, p = /\$([$&`']|\d\d?|<[^>]*>)/g, m = /\$([$&`']|\d\d?)/g, _ = function(v) {
              return v === void 0 ? v : String(v);
            };
            n("214f")("replace", 2, function(v, b, y, w) {
              return [
                // `String.prototype.replace` method
                // https://tc39.github.io/ecma262/#sec-string.prototype.replace
                function(T, j) {
                  var C = v(this), L = T == null ? void 0 : T[b];
                  return L !== void 0 ? L.call(T, C, j) : y.call(String(C), T, j);
                },
                // `RegExp.prototype[@@replace]` method
                // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
                function(A, T) {
                  var j = w(y, A, this, T);
                  if (j.done)
                    return j.value;
                  var C = a(A), L = String(this), E = typeof T == "function";
                  E || (T = String(T));
                  var N = C.global;
                  if (N) {
                    var J = C.unicode;
                    C.lastIndex = 0;
                  }
                  for (var z = []; ; ) {
                    var H = c(C, L);
                    if (H === null || (z.push(H), !N))
                      break;
                    var Y = String(H[0]);
                    Y === "" && (C.lastIndex = h(L, l(C.lastIndex), J));
                  }
                  for (var U = "", B = 0, ue = 0; ue < z.length; ue++) {
                    H = z[ue];
                    for (var O = String(H[0]), k = d(f(u(H.index), L.length), 0), M = [], $ = 1; $ < H.length; $++)
                      M.push(_(H[$]));
                    var q = H.groups;
                    if (E) {
                      var W = [O].concat(M, k, L);
                      q !== void 0 && W.push(q);
                      var fe = String(T.apply(void 0, W));
                    } else
                      fe = D(O, L, k, M, q, T);
                    k >= B && (U += L.slice(B, k) + fe, B = k + O.length);
                  }
                  return U + L.slice(B);
                }
              ];
              function D(A, T, j, C, L, E) {
                var N = j + A.length, J = C.length, z = m;
                return L !== void 0 && (L = o(L), z = p), y.call(E, z, function(H, Y) {
                  var U;
                  switch (Y.charAt(0)) {
                    case "$":
                      return "$";
                    case "&":
                      return A;
                    case "`":
                      return T.slice(0, j);
                    case "'":
                      return T.slice(N);
                    case "<":
                      U = L[Y.slice(1, -1)];
                      break;
                    default:
                      var B = +Y;
                      if (B === 0)
                        return H;
                      if (B > J) {
                        var ue = g(B / 10);
                        return ue === 0 ? H : ue <= J ? C[ue - 1] === void 0 ? Y.charAt(1) : C[ue - 1] + Y.charAt(1) : H;
                      }
                      U = C[B - 1];
                  }
                  return U === void 0 ? "" : U;
                });
              }
            });
          }
        ),
        /***/
        aae3: (
          /***/
          function(s, r, n) {
            var a = n("d3f4"), o = n("2d95"), l = n("2b4c")("match");
            s.exports = function(u) {
              var h;
              return a(u) && ((h = u[l]) !== void 0 ? !!h : o(u) == "RegExp");
            };
          }
        ),
        /***/
        ac6a: (
          /***/
          function(s, r, n) {
            for (var a = n("cadf"), o = n("0d58"), l = n("2aba"), u = n("7726"), h = n("32e9"), c = n("84f2"), d = n("2b4c"), f = d("iterator"), g = d("toStringTag"), p = c.Array, m = {
              CSSRuleList: !0,
              // TODO: Not spec compliant, should be false.
              CSSStyleDeclaration: !1,
              CSSValueList: !1,
              ClientRectList: !1,
              DOMRectList: !1,
              DOMStringList: !1,
              DOMTokenList: !0,
              DataTransferItemList: !1,
              FileList: !1,
              HTMLAllCollection: !1,
              HTMLCollection: !1,
              HTMLFormElement: !1,
              HTMLSelectElement: !1,
              MediaList: !0,
              // TODO: Not spec compliant, should be false.
              MimeTypeArray: !1,
              NamedNodeMap: !1,
              NodeList: !0,
              PaintRequestList: !1,
              Plugin: !1,
              PluginArray: !1,
              SVGLengthList: !1,
              SVGNumberList: !1,
              SVGPathSegList: !1,
              SVGPointList: !1,
              SVGStringList: !1,
              SVGTransformList: !1,
              SourceBufferList: !1,
              StyleSheetList: !0,
              // TODO: Not spec compliant, should be false.
              TextTrackCueList: !1,
              TextTrackList: !1,
              TouchList: !1
            }, _ = o(m), v = 0; v < _.length; v++) {
              var b = _[v], y = m[b], w = u[b], D = w && w.prototype, A;
              if (D && (D[f] || h(D, f, p), D[g] || h(D, g, b), c[b] = p, y))
                for (A in a)
                  D[A] || l(D, A, a[A], !0);
            }
          }
        ),
        /***/
        b0c5: (
          /***/
          function(s, r, n) {
            var a = n("520a");
            n("5ca1")({
              target: "RegExp",
              proto: !0,
              forced: a !== /./.exec
            }, {
              exec: a
            });
          }
        ),
        /***/
        be13: (
          /***/
          function(s, r) {
            s.exports = function(n) {
              if (n == null)
                throw TypeError("Can't call method on  " + n);
              return n;
            };
          }
        ),
        /***/
        c366: (
          /***/
          function(s, r, n) {
            var a = n("6821"), o = n("9def"), l = n("77f1");
            s.exports = function(u) {
              return function(h, c, d) {
                var f = a(h), g = o(f.length), p = l(d, g), m;
                if (u && c != c) {
                  for (; g > p; )
                    if (m = f[p++], m != m)
                      return !0;
                } else
                  for (; g > p; p++)
                    if ((u || p in f) && f[p] === c)
                      return u || p || 0;
                return !u && -1;
              };
            };
          }
        ),
        /***/
        c649: (
          /***/
          function(s, r, n) {
            (function(a) {
              n.d(r, "c", function() {
                return f;
              }), n.d(r, "a", function() {
                return c;
              }), n.d(r, "b", function() {
                return l;
              }), n.d(r, "d", function() {
                return d;
              }), n("a481");
              function o() {
                return typeof window < "u" ? window.console : a.console;
              }
              var l = o();
              function u(g) {
                var p = /* @__PURE__ */ Object.create(null);
                return function(_) {
                  var v = p[_];
                  return v || (p[_] = g(_));
                };
              }
              var h = /-(\w)/g, c = u(function(g) {
                return g.replace(h, function(p, m) {
                  return m ? m.toUpperCase() : "";
                });
              });
              function d(g) {
                g.parentElement !== null && g.parentElement.removeChild(g);
              }
              function f(g, p, m) {
                var _ = m === 0 ? g.children[0] : g.children[m - 1].nextSibling;
                g.insertBefore(p, _);
              }
            }).call(this, n("c8ba"));
          }
        ),
        /***/
        c69a: (
          /***/
          function(s, r, n) {
            s.exports = !n("9e1e") && !n("79e5")(function() {
              return Object.defineProperty(n("230e")("div"), "a", { get: function() {
                return 7;
              } }).a != 7;
            });
          }
        ),
        /***/
        c8ba: (
          /***/
          function(s, r) {
            var n;
            n = function() {
              return this;
            }();
            try {
              n = n || new Function("return this")();
            } catch {
              typeof window == "object" && (n = window);
            }
            s.exports = n;
          }
        ),
        /***/
        ca5a: (
          /***/
          function(s, r) {
            var n = 0, a = Math.random();
            s.exports = function(o) {
              return "Symbol(".concat(o === void 0 ? "" : o, ")_", (++n + a).toString(36));
            };
          }
        ),
        /***/
        cadf: (
          /***/
          function(s, r, n) {
            var a = n("9c6c"), o = n("d53b"), l = n("84f2"), u = n("6821");
            s.exports = n("01f9")(Array, "Array", function(h, c) {
              this._t = u(h), this._i = 0, this._k = c;
            }, function() {
              var h = this._t, c = this._k, d = this._i++;
              return !h || d >= h.length ? (this._t = void 0, o(1)) : c == "keys" ? o(0, d) : c == "values" ? o(0, h[d]) : o(0, [d, h[d]]);
            }, "values"), l.Arguments = l.Array, a("keys"), a("values"), a("entries");
          }
        ),
        /***/
        cb7c: (
          /***/
          function(s, r, n) {
            var a = n("d3f4");
            s.exports = function(o) {
              if (!a(o))
                throw TypeError(o + " is not an object!");
              return o;
            };
          }
        ),
        /***/
        ce10: (
          /***/
          function(s, r, n) {
            var a = n("69a8"), o = n("6821"), l = n("c366")(!1), u = n("613b")("IE_PROTO");
            s.exports = function(h, c) {
              var d = o(h), f = 0, g = [], p;
              for (p in d)
                p != u && a(d, p) && g.push(p);
              for (; c.length > f; )
                a(d, p = c[f++]) && (~l(g, p) || g.push(p));
              return g;
            };
          }
        ),
        /***/
        d2c8: (
          /***/
          function(s, r, n) {
            var a = n("aae3"), o = n("be13");
            s.exports = function(l, u, h) {
              if (a(u))
                throw TypeError("String#" + h + " doesn't accept regex!");
              return String(o(l));
            };
          }
        ),
        /***/
        d3f4: (
          /***/
          function(s, r) {
            s.exports = function(n) {
              return typeof n == "object" ? n !== null : typeof n == "function";
            };
          }
        ),
        /***/
        d53b: (
          /***/
          function(s, r) {
            s.exports = function(n, a) {
              return { value: a, done: !!n };
            };
          }
        ),
        /***/
        d8e8: (
          /***/
          function(s, r) {
            s.exports = function(n) {
              if (typeof n != "function")
                throw TypeError(n + " is not a function!");
              return n;
            };
          }
        ),
        /***/
        e11e: (
          /***/
          function(s, r) {
            s.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",");
          }
        ),
        /***/
        f559: (
          /***/
          function(s, r, n) {
            var a = n("5ca1"), o = n("9def"), l = n("d2c8"), u = "startsWith", h = ""[u];
            a(a.P + a.F * n("5147")(u), "String", {
              startsWith: function(d) {
                var f = l(this, d, u), g = o(Math.min(arguments.length > 1 ? arguments[1] : void 0, f.length)), p = String(d);
                return h ? h.call(f, p, g) : f.slice(g, g + p.length) === p;
              }
            });
          }
        ),
        /***/
        f6fd: (
          /***/
          function(s, r) {
            (function(n) {
              var a = "currentScript", o = n.getElementsByTagName("script");
              a in n || Object.defineProperty(n, a, {
                get: function() {
                  try {
                    throw new Error();
                  } catch (h) {
                    var l, u = (/.*at [^\(]*\((.*):.+:.+\)$/ig.exec(h.stack) || [!1])[1];
                    for (l in o)
                      if (o[l].src == u || o[l].readyState == "interactive")
                        return o[l];
                    return null;
                  }
                }
              });
            })(document);
          }
        ),
        /***/
        f751: (
          /***/
          function(s, r, n) {
            var a = n("5ca1");
            a(a.S + a.F, "Object", { assign: n("7333") });
          }
        ),
        /***/
        fa5b: (
          /***/
          function(s, r, n) {
            s.exports = n("5537")("native-function-to-string", Function.toString);
          }
        ),
        /***/
        fab2: (
          /***/
          function(s, r, n) {
            var a = n("7726").document;
            s.exports = a && a.documentElement;
          }
        ),
        /***/
        fb15: (
          /***/
          function(s, r, n) {
            if (n.r(r), typeof window < "u") {
              n("f6fd");
              var a;
              (a = window.document.currentScript) && (a = a.src.match(/(.+\/)[^/]+\.js(\?.*)?$/)) && (n.p = a[1]);
            }
            n("f751"), n("f559"), n("ac6a"), n("cadf"), n("456d");
            function o(O) {
              if (Array.isArray(O))
                return O;
            }
            function l(O, k) {
              if (!(typeof Symbol > "u" || !(Symbol.iterator in Object(O)))) {
                var M = [], $ = !0, q = !1, W = void 0;
                try {
                  for (var fe = O[Symbol.iterator](), ve; !($ = (ve = fe.next()).done) && (M.push(ve.value), !(k && M.length === k)); $ = !0)
                    ;
                } catch (Dt) {
                  q = !0, W = Dt;
                } finally {
                  try {
                    !$ && fe.return != null && fe.return();
                  } finally {
                    if (q)
                      throw W;
                  }
                }
                return M;
              }
            }
            function u(O, k) {
              (k == null || k > O.length) && (k = O.length);
              for (var M = 0, $ = new Array(k); M < k; M++)
                $[M] = O[M];
              return $;
            }
            function h(O, k) {
              if (O) {
                if (typeof O == "string")
                  return u(O, k);
                var M = Object.prototype.toString.call(O).slice(8, -1);
                if (M === "Object" && O.constructor && (M = O.constructor.name), M === "Map" || M === "Set")
                  return Array.from(O);
                if (M === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(M))
                  return u(O, k);
              }
            }
            function c() {
              throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            function d(O, k) {
              return o(O) || l(O, k) || h(O, k) || c();
            }
            n("6762"), n("2fdb");
            function f(O) {
              if (Array.isArray(O))
                return u(O);
            }
            function g(O) {
              if (typeof Symbol < "u" && Symbol.iterator in Object(O))
                return Array.from(O);
            }
            function p() {
              throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            function m(O) {
              return f(O) || g(O) || h(O) || p();
            }
            var _ = n("a352"), v = /* @__PURE__ */ n.n(_), b = n("c649");
            function y(O, k, M) {
              return M === void 0 || (O = O || {}, O[k] = M), O;
            }
            function w(O, k) {
              return O.map(function(M) {
                return M.elm;
              }).indexOf(k);
            }
            function D(O, k, M, $) {
              if (!O)
                return [];
              var q = O.map(function(ve) {
                return ve.elm;
              }), W = k.length - $, fe = m(k).map(function(ve, Dt) {
                return Dt >= W ? q.length : q.indexOf(ve);
              });
              return M ? fe.filter(function(ve) {
                return ve !== -1;
              }) : fe;
            }
            function A(O, k) {
              var M = this;
              this.$nextTick(function() {
                return M.$emit(O.toLowerCase(), k);
              });
            }
            function T(O) {
              var k = this;
              return function(M) {
                k.realList !== null && k["onDrag" + O](M), A.call(k, O, M);
              };
            }
            function j(O) {
              return ["transition-group", "TransitionGroup"].includes(O);
            }
            function C(O) {
              if (!O || O.length !== 1)
                return !1;
              var k = d(O, 1), M = k[0].componentOptions;
              return M ? j(M.tag) : !1;
            }
            function L(O, k, M) {
              return O[M] || (k[M] ? k[M]() : void 0);
            }
            function E(O, k, M) {
              var $ = 0, q = 0, W = L(k, M, "header");
              W && ($ = W.length, O = O ? [].concat(m(W), m(O)) : m(W));
              var fe = L(k, M, "footer");
              return fe && (q = fe.length, O = O ? [].concat(m(O), m(fe)) : m(fe)), {
                children: O,
                headerOffset: $,
                footerOffset: q
              };
            }
            function N(O, k) {
              var M = null, $ = function(Qi, pf) {
                M = y(M, Qi, pf);
              }, q = Object.keys(O).filter(function(Dt) {
                return Dt === "id" || Dt.startsWith("data-");
              }).reduce(function(Dt, Qi) {
                return Dt[Qi] = O[Qi], Dt;
              }, {});
              if ($("attrs", q), !k)
                return M;
              var W = k.on, fe = k.props, ve = k.attrs;
              return $("on", W), $("props", fe), Object.assign(M.attrs, ve), M;
            }
            var J = ["Start", "Add", "Remove", "Update", "End"], z = ["Choose", "Unchoose", "Sort", "Filter", "Clone"], H = ["Move"].concat(J, z).map(function(O) {
              return "on" + O;
            }), Y = null, U = {
              options: Object,
              list: {
                type: Array,
                required: !1,
                default: null
              },
              value: {
                type: Array,
                required: !1,
                default: null
              },
              noTransitionOnDrag: {
                type: Boolean,
                default: !1
              },
              clone: {
                type: Function,
                default: function(k) {
                  return k;
                }
              },
              element: {
                type: String,
                default: "div"
              },
              tag: {
                type: String,
                default: null
              },
              move: {
                type: Function,
                default: null
              },
              componentData: {
                type: Object,
                required: !1,
                default: null
              }
            }, B = {
              name: "draggable",
              inheritAttrs: !1,
              props: U,
              data: function() {
                return {
                  transitionMode: !1,
                  noneFunctionalComponentMode: !1
                };
              },
              render: function(k) {
                var M = this.$slots.default;
                this.transitionMode = C(M);
                var $ = E(M, this.$slots, this.$scopedSlots), q = $.children, W = $.headerOffset, fe = $.footerOffset;
                this.headerOffset = W, this.footerOffset = fe;
                var ve = N(this.$attrs, this.componentData);
                return k(this.getTag(), ve, q);
              },
              created: function() {
                this.list !== null && this.value !== null && b.b.error("Value and list props are mutually exclusive! Please set one or another."), this.element !== "div" && b.b.warn("Element props is deprecated please use tag props instead. See https://github.com/SortableJS/Vue.Draggable/blob/master/documentation/migrate.md#element-props"), this.options !== void 0 && b.b.warn("Options props is deprecated, add sortable options directly as vue.draggable item, or use v-bind. See https://github.com/SortableJS/Vue.Draggable/blob/master/documentation/migrate.md#options-props");
              },
              mounted: function() {
                var k = this;
                if (this.noneFunctionalComponentMode = this.getTag().toLowerCase() !== this.$el.nodeName.toLowerCase() && !this.getIsFunctional(), this.noneFunctionalComponentMode && this.transitionMode)
                  throw new Error("Transition-group inside component is not supported. Please alter tag value or remove transition-group. Current tag value: ".concat(this.getTag()));
                var M = {};
                J.forEach(function(W) {
                  M["on" + W] = T.call(k, W);
                }), z.forEach(function(W) {
                  M["on" + W] = A.bind(k, W);
                });
                var $ = Object.keys(this.$attrs).reduce(function(W, fe) {
                  return W[Object(b.a)(fe)] = k.$attrs[fe], W;
                }, {}), q = Object.assign({}, this.options, $, M, {
                  onMove: function(fe, ve) {
                    return k.onDragMove(fe, ve);
                  }
                });
                !("draggable" in q) && (q.draggable = ">*"), this._sortable = new v.a(this.rootContainer, q), this.computeIndexes();
              },
              beforeDestroy: function() {
                this._sortable !== void 0 && this._sortable.destroy();
              },
              computed: {
                rootContainer: function() {
                  return this.transitionMode ? this.$el.children[0] : this.$el;
                },
                realList: function() {
                  return this.list ? this.list : this.value;
                }
              },
              watch: {
                options: {
                  handler: function(k) {
                    this.updateOptions(k);
                  },
                  deep: !0
                },
                $attrs: {
                  handler: function(k) {
                    this.updateOptions(k);
                  },
                  deep: !0
                },
                realList: function() {
                  this.computeIndexes();
                }
              },
              methods: {
                getIsFunctional: function() {
                  var k = this._vnode.fnOptions;
                  return k && k.functional;
                },
                getTag: function() {
                  return this.tag || this.element;
                },
                updateOptions: function(k) {
                  for (var M in k) {
                    var $ = Object(b.a)(M);
                    H.indexOf($) === -1 && this._sortable.option($, k[M]);
                  }
                },
                getChildrenNodes: function() {
                  if (this.noneFunctionalComponentMode)
                    return this.$children[0].$slots.default;
                  var k = this.$slots.default;
                  return this.transitionMode ? k[0].child.$slots.default : k;
                },
                computeIndexes: function() {
                  var k = this;
                  this.$nextTick(function() {
                    k.visibleIndexes = D(k.getChildrenNodes(), k.rootContainer.children, k.transitionMode, k.footerOffset);
                  });
                },
                getUnderlyingVm: function(k) {
                  var M = w(this.getChildrenNodes() || [], k);
                  if (M === -1)
                    return null;
                  var $ = this.realList[M];
                  return {
                    index: M,
                    element: $
                  };
                },
                getUnderlyingPotencialDraggableComponent: function(k) {
                  var M = k.__vue__;
                  return !M || !M.$options || !j(M.$options._componentTag) ? !("realList" in M) && M.$children.length === 1 && "realList" in M.$children[0] ? M.$children[0] : M : M.$parent;
                },
                emitChanges: function(k) {
                  var M = this;
                  this.$nextTick(function() {
                    M.$emit("change", k);
                  });
                },
                alterList: function(k) {
                  if (this.list) {
                    k(this.list);
                    return;
                  }
                  var M = m(this.value);
                  k(M), this.$emit("input", M);
                },
                spliceList: function() {
                  var k = arguments, M = function(q) {
                    return q.splice.apply(q, m(k));
                  };
                  this.alterList(M);
                },
                updatePosition: function(k, M) {
                  var $ = function(W) {
                    return W.splice(M, 0, W.splice(k, 1)[0]);
                  };
                  this.alterList($);
                },
                getRelatedContextFromMoveEvent: function(k) {
                  var M = k.to, $ = k.related, q = this.getUnderlyingPotencialDraggableComponent(M);
                  if (!q)
                    return {
                      component: q
                    };
                  var W = q.realList, fe = {
                    list: W,
                    component: q
                  };
                  if (M !== $ && W && q.getUnderlyingVm) {
                    var ve = q.getUnderlyingVm($);
                    if (ve)
                      return Object.assign(ve, fe);
                  }
                  return fe;
                },
                getVmIndex: function(k) {
                  var M = this.visibleIndexes, $ = M.length;
                  return k > $ - 1 ? $ : M[k];
                },
                getComponent: function() {
                  return this.$slots.default[0].componentInstance;
                },
                resetTransitionData: function(k) {
                  if (!(!this.noTransitionOnDrag || !this.transitionMode)) {
                    var M = this.getChildrenNodes();
                    M[k].data = null;
                    var $ = this.getComponent();
                    $.children = [], $.kept = void 0;
                  }
                },
                onDragStart: function(k) {
                  this.context = this.getUnderlyingVm(k.item), k.item._underlying_vm_ = this.clone(this.context.element), Y = k.item;
                },
                onDragAdd: function(k) {
                  var M = k.item._underlying_vm_;
                  if (M !== void 0) {
                    Object(b.d)(k.item);
                    var $ = this.getVmIndex(k.newIndex);
                    this.spliceList($, 0, M), this.computeIndexes();
                    var q = {
                      element: M,
                      newIndex: $
                    };
                    this.emitChanges({
                      added: q
                    });
                  }
                },
                onDragRemove: function(k) {
                  if (Object(b.c)(this.rootContainer, k.item, k.oldIndex), k.pullMode === "clone") {
                    Object(b.d)(k.clone);
                    return;
                  }
                  var M = this.context.index;
                  this.spliceList(M, 1);
                  var $ = {
                    element: this.context.element,
                    oldIndex: M
                  };
                  this.resetTransitionData(M), this.emitChanges({
                    removed: $
                  });
                },
                onDragUpdate: function(k) {
                  Object(b.d)(k.item), Object(b.c)(k.from, k.item, k.oldIndex);
                  var M = this.context.index, $ = this.getVmIndex(k.newIndex);
                  this.updatePosition(M, $);
                  var q = {
                    element: this.context.element,
                    oldIndex: M,
                    newIndex: $
                  };
                  this.emitChanges({
                    moved: q
                  });
                },
                updateProperty: function(k, M) {
                  k.hasOwnProperty(M) && (k[M] += this.headerOffset);
                },
                computeFutureIndex: function(k, M) {
                  if (!k.element)
                    return 0;
                  var $ = m(M.to.children).filter(function(ve) {
                    return ve.style.display !== "none";
                  }), q = $.indexOf(M.related), W = k.component.getVmIndex(q), fe = $.indexOf(Y) !== -1;
                  return fe || !M.willInsertAfter ? W : W + 1;
                },
                onDragMove: function(k, M) {
                  var $ = this.move;
                  if (!$ || !this.realList)
                    return !0;
                  var q = this.getRelatedContextFromMoveEvent(k), W = this.context, fe = this.computeFutureIndex(q, k);
                  Object.assign(W, {
                    futureIndex: fe
                  });
                  var ve = Object.assign({}, k, {
                    relatedContext: q,
                    draggedContext: W
                  });
                  return $(ve, M);
                },
                onDragEnd: function() {
                  this.computeIndexes(), Y = null;
                }
              }
            };
            typeof window < "u" && "Vue" in window && window.Vue.component("draggable", B);
            var ue = B;
            r.default = ue;
          }
        )
        /******/
      }).default
    );
  });
})(lD);
const zD = /* @__PURE__ */ oS(_l), XD = {
  components: { CtaButton: $a, SearchBar: Du, draggable: zD },
  props: {
    styleProps: {
      type: String,
      default: ""
    },
    itemList: {
      type: Array,
      default: []
    },
    setResult: Function
  },
  data() {
    return {
      availableList: [],
      selectedList: []
    };
  },
  computed: {
    selectedListComputed() {
      return 10 - Number(this.selectedList.length);
    }
  },
  methods: {
    setInitialData() {
      var i;
      this.availableList = this.itemList.map((e) => ({
        ...e,
        display: !0
      })), this.selectedList = (i = this.itemList) == null ? void 0 : i.filter((e) => e.default === !0).slice(0, 10);
    },
    setSearchCompleteKeyword(i) {
      if (!i) {
        this.availableList = this.availableList.map((e) => ({
          ...e,
          display: !0
        }));
        return;
      }
      this.availableList = this.availableList.map((e) => {
        let t = i.split(" ").join("").toLowerCase();
        return e.title.split(" ").join("").toLowerCase().includes(t) ? {
          ...e,
          display: !0
        } : {
          ...e,
          display: !1
        };
      });
    },
    selectItem(i) {
      this.selectedList.length !== 10 && (this.selectedList.push({ ...i, selected: !0 }), this.availableList = this.availableList.map(
        (e) => e.id === i.id ? { ...e, selected: !0 } : e
      ));
    },
    unselectItem(i) {
      this.selectedList = this.selectedList.filter(
        (e) => e.id !== i.id
      ), this.availableList = this.availableList.map(
        (e) => e.id === i.id ? { ...e, selected: !1 } : e
      );
    },
    isDraggable(i) {
      const { index: e, futureIndex: t } = i;
      return !(this.selectedList[e].fixed || this.selectedList[t].fixed);
    },
    checkMove(i) {
      return this.isDraggable(i.draggedContext);
    }
  },
  mounted() {
    this.setInitialData();
  },
  watch: {
    selectedList() {
      this.setResult && this.setResult(this.selectedList);
    }
  }
};
var VD = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    class: i.$style.custom_list_container,
    style: i.styleProps
  }, [t("div", {
    class: i.$style.available_side
  }, [t("div", {
    class: i.$style.available_side_header
  }, [t("p", [i._v("Available Columns")])]), t("search-bar", {
    attrs: {
      setSearchCompleteKeyword: i.setSearchCompleteKeyword,
      "placeholder-text": "Search Available Columns"
    }
  }), t("div", {
    class: i.$style.available_side_contents
  }, i._l(i.availableList, function(s) {
    return s.display ? t("div", {
      key: s.id,
      class: i.$style.available_content
    }, [t("div", {
      attrs: {
        selected: s.selected
      }
    }, [i._v(i._s(s.title))]), t("span", {
      class: i.$style.list_plus_icon,
      style: {
        visibility: s.selected ? "hidden" : "visible"
      },
      on: {
        click: function() {
          return i.selectItem(s);
        }
      }
    })]) : i._e();
  }), 0)], 1), t("div", {
    class: i.$style.selected_side
  }, [t("div", {
    class: i.$style.selected_side_header
  }, [t("p", [i._v("Selected Columns")]), t("cta-button", {
    attrs: {
      "click-handler": i.setInitialData,
      "button-type": "text",
      "style-props": "font-size: 14px; padding: 0;"
    }
  }, [i._v("Reset To Default ")])], 1), t("draggable", {
    attrs: {
      move: i.checkMove
    },
    model: {
      value: i.selectedList,
      callback: function(s) {
        i.selectedList = s;
      },
      expression: "selectedList"
    }
  }, [t("transition-group", i._l(i.selectedList, function(s, r) {
    return t("div", {
      key: s.id,
      class: i.$style.selected_content
    }, [t("span", [i._v(i._s(r + 1))]), t("div", {
      attrs: {
        selected: s.selected,
        fixed: s.fixed
      }
    }, [i._v(" " + i._s(s.title) + " ")]), t("span", {
      class: i.$style.list_minus_icon,
      style: {
        visibility: !s.selected || s.fixed ? "hidden" : "visible"
      },
      on: {
        click: function() {
          return i.unselectItem(s);
        }
      }
    })]);
  }), 0)], 1), i._l(i.selectedListComputed, function(s) {
    return t("div", {
      key: s,
      class: i.$style.selected_content,
      staticStyle: {
        cursor: "default"
      }
    }, [t("span", [i._v(i._s(s + i.selectedList.length))]), t("div", {
      class: i.$style.empty_content
    }), t("span", {
      class: i.$style.empty_content_icon_area
    })]);
  })], 2)]);
}, WD = [];
const UD = "_custom_list_container_127sh_1", GD = "_available_side_127sh_32", ZD = "_available_side_header_127sh_39", KD = "_available_side_contents_127sh_46", QD = "_available_content_127sh_57", JD = "_list_plus_icon_127sh_78", qD = "_selected_side_127sh_120", e1 = "_selected_side_header_127sh_127", t1 = "_selected_content_127sh_142", i1 = "_empty_content_127sh_195", s1 = "_list_minus_icon_127sh_203", r1 = "_empty_content_icon_area_127sh_240", n1 = "_sortable_ghost_127sh_246", a1 = {
  custom_list_container: UD,
  available_side: GD,
  available_side_header: ZD,
  available_side_contents: KD,
  available_content: QD,
  list_plus_icon: JD,
  selected_side: qD,
  selected_side_header: e1,
  selected_content: t1,
  empty_content: i1,
  list_minus_icon: s1,
  empty_content_icon_area: r1,
  sortable_ghost: n1
}, Sl = {};
Sl.$style = a1;
var o1 = /* @__PURE__ */ te(
  XD,
  VD,
  WD,
  !1,
  l1,
  null,
  null,
  null
);
function l1(i) {
  for (let e in Sl)
    this[e] = Sl[e];
}
const nA = /* @__PURE__ */ function() {
  return o1.exports;
}(), u1 = {
  props: {
    styleProps: {
      type: String,
      default: ""
    },
    bgColor: {
      type: String,
      default: "#F5F8FF"
    },
    bodyHeight: {
      type: String,
      default: "156px"
    },
    columnWidthArray: Array
  },
  data() {
    return {
      hasScroll: !1
    };
  },
  computed: {
    bgColorComputed() {
      return {
        "--data-table-bg-color": this.bgColor
      };
    }
  },
  methods: {
    isOverflowing() {
      let i = this.$refs.bodyRef;
      this.$refs.bodyRef && i.clientHeight < i.scrollHeight && (this.hasScroll = !0);
    }
  },
  mounted() {
    this.isOverflowing();
  }
};
var h1 = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    staticClass: "data-table-container",
    style: i.styleProps
  }, [t("div", {
    staticClass: "data-table-header",
    class: {
      scrollbar: i.hasScroll
    },
    style: i.bgColorComputed
  }, [t("table", [t("colgroup", i._l(i.columnWidthArray, function(s, r) {
    return t("col", {
      key: r,
      style: {
        width: s
      }
    });
  }), 0), t("thead", [i._t("header")], 2)])]), t("div", {
    ref: "bodyRef",
    staticClass: "data-table-body",
    style: [i.bgColorComputed, {
      maxHeight: i.bodyHeight
    }]
  }, [t("table", [t("colgroup", i._l(i.columnWidthArray, function(s, r) {
    return t("col", {
      key: r,
      style: {
        width: s
      }
    });
  }), 0), t("tbody", [i._t("body")], 2)])]), i.$slots.footer ? t("div", [i._t("footer")], 2) : i._e()]);
}, c1 = [];
const Oh = {};
var d1 = /* @__PURE__ */ te(
  u1,
  h1,
  c1,
  !1,
  f1,
  "ccfbd2b4",
  null,
  null
);
function f1(i) {
  for (let e in Oh)
    this[e] = Oh[e];
}
const aA = /* @__PURE__ */ function() {
  return d1.exports;
}(), p1 = {
  components: {
    CheckboxButton: Gh
  },
  props: {
    columnWidthArray: Array,
    rows: Array,
    selectedRows: Array,
    checkboxes: {
      type: Boolean,
      default: !0
    }
  },
  data() {
    return {
      ascending: !1,
      sortColumn: ""
    };
  },
  created() {
    this.AddCheckboxes();
  },
  watch: {
    checkboxes(i) {
      this.AddCheckboxes(i);
    }
  },
  methods: {
    AddCheckboxes(i) {
      i && (this.rows = this.rows.map((e) => ({ checkbox: !1, ...e })));
    },
    handleHeading(i) {
      const e = i.replace(/([A-Z])/g, " $1");
      return e.charAt(0).toUpperCase() + e.slice(1);
    },
    handleAllCheckboxes(i) {
      this.rows.map((e) => e.checkbox = i), i ? this.selectedRows = this.rows : this.selectedRows = [];
    },
    handleEachSelection(i, e) {
      e.checkbox = !e.checkbox;
      var t = this.rows.filter((s) => s.checkbox == !0);
      this.selectedRows = t;
    },
    sortTable: function(e) {
      this.sortColumn === e ? this.ascending = !this.ascending : (this.ascending = !0, this.sortColumn = e);
      var t = this.ascending;
      this.rows.sort(function(s, r) {
        return s[e] > r[e] ? t ? 1 : -1 : s[e] < r[e] ? t ? -1 : 1 : 0;
      });
    }
  },
  computed: {
    columns: function() {
      return this.rows.length == 0 ? [] : Object.keys(this.rows[0]);
    }
  }
};
var g1 = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", [t("table", {
    attrs: {
      id: "fifthTable"
    }
  }, [t("colgroup", [i.checkboxes ? t("col", {
    staticStyle: {
      width: "10px"
    }
  }) : i._e(), i._l(i.columnWidthArray, function(s, r) {
    return t("col", {
      key: r,
      style: {
        width: s
      }
    });
  })], 2), t("thead", [t("tr", i._l(i.columns, function(s, r) {
    return t("th", {
      key: r,
      on: {
        click: function(n) {
          return i.sortTable(s);
        }
      }
    }, [s == "checkbox" && i.checkboxes ? t("div", [t("CheckboxButton", {
      attrs: {
        "button-type": "checkbox",
        "click-handler": function(n) {
          return i.handleAllCheckboxes(n);
        }
      }
    })], 1) : s !== "checkbox" ? t("div", {
      staticClass: "heading"
    }, [t("span", [i._v(i._s(i.handleHeading(s)))]), s == i.sortColumn ? t("div", {
      staticClass: "arrow",
      class: i.ascending ? "arrow_up" : "arrow_down"
    }) : i._e()]) : i._e()]);
  }), 0)]), t("tbody", i._l(i.rows, function(s, r) {
    return t("tr", {
      key: r
    }, i._l(i.columns, function(n, a) {
      return t("td", {
        key: a
      }, [n == "checkbox" && i.checkboxes ? t("div", [t("CheckboxButton", {
        attrs: {
          "button-type": "checkbox",
          active: s.checkbox,
          "click-handler": function(o) {
            return i.handleEachSelection(o, s);
          }
        }
      })], 1) : n !== "checkbox" ? t("div", [Array.isArray(s[n]) ? t("div", {
        staticClass: "arrayDiv"
      }, [t("span", [i._v(i._s(s[n][0]))]), t("span", [i._v(i._s(s[n][1]))])]) : t("div", [t("span", {
        staticClass: "singleDiv"
      }, [i._v(i._s(s[n]))])])]) : i._e()]);
    }), 0);
  }), 0)])]);
}, m1 = [];
const Ah = {};
var _1 = /* @__PURE__ */ te(
  p1,
  g1,
  m1,
  !1,
  b1,
  "5fef0d94",
  null,
  null
);
function b1(i) {
  for (let e in Ah)
    this[e] = Ah[e];
}
const oA = /* @__PURE__ */ function() {
  return _1.exports;
}(), y1 = {
  name: "common-popover",
  props: {
    visible: {
      type: Boolean,
      default: !1
    },
    classes: {
      type: String,
      default: ""
    },
    position: {
      type: Object,
      default: () => ({ top: "", left: "", right: "", bottom: "" })
    }
  },
  methods: {
    handleClickOutside(i) {
      const e = this.$refs.commonPopover;
      e === i.target || e != null && e.contains(i.target) || this.handleClose();
    },
    handleClose() {
      this.$emit("close");
    }
  },
  watch: {
    visible(i) {
      i ? window.addEventListener("click", this.handleClickOutside) : window.removeEventListener("click", this.handleClickOutside);
    }
  }
};
var v1 = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return i.visible ? t("div", {
    ref: "commonPopover",
    class: [i.visible ? i.$style.show : "", i.$style.common_popover],
    style: {
      left: i.position.left,
      right: i.position.right,
      top: i.position.top,
      bottom: i.position.bottom
    }
  }, [i._t("default")], 2) : i._e();
}, x1 = [];
const w1 = "_common_popover_15eam_7", S1 = "_show_15eam_16", D1 = {
  common_popover: w1,
  show: S1
}, Dl = {};
Dl.$style = D1;
var P1 = /* @__PURE__ */ te(
  y1,
  v1,
  x1,
  !1,
  T1,
  null,
  null,
  null
);
function T1(i) {
  for (let e in Dl)
    this[e] = Dl[e];
}
const df = /* @__PURE__ */ function() {
  return P1.exports;
}(), k1 = {
  name: "Dropdown",
  props: {
    titleName: {
      type: String,
      default: "title"
    },
    // props for popover
    visible: Boolean,
    items: Array,
    // option list (title: name to be displayed in option list, image: option image) (ex: {title: 'option1', [image: imageUrl, ...]})
    // On close dropdown when you click outside
    onClose: Function,
    setResult: {
      // Save the final result. (When using checkboxes)
      type: Function,
      default: () => 1
    },
    clickHandler: Function,
    // Click handler (if using list click without using checkbox)
    checkbox: Boolean,
    // // Set whether checkbox or no
    styleProps: {
      // type: String as PropType<StyleValue>,
      // default: "" as StyleValue,
      type: String,
      default: ""
    },
    // Set whether dropdown-list wrap-style or not (ex: {top: '10px', left: '10px', width: '10px'})
    placeholder: String,
    // Set whether placeholder or not
    infoText: {
      Type: String,
      default: ""
    },
    id: String
    // Set whether checkbox-id or not
  },
  // alice component
  components: {
    "search-bar": Du,
    "common-popover": df
  },
  data() {
    return {
      filteredDependency: 1,
      logTest: !1,
      inputContent: "",
      // The input value. Shows the input list searched through filtered.
      isHover: !1,
      requestParam: {
        query: ""
      }
    };
  },
  computed: {
    // Filter your search terms
    filtered() {
      if (this.items && this.filteredDependency) {
        const i = this.inputContent.trim();
        return !i || i == "" ? this.items : this.items != null ? this.items.filter((s) => s[this.titleName] != null && s[this.titleName].toUpperCase().includes(i.toUpperCase())).sort((s, r) => s[this.titleName].toUpperCase() > r[this.titleName].toUpperCase() ? 1 : -1) : this.items;
      } else
        return this.items;
    },
    checkedArray() {
      let i = this.filtered.filter((e) => {
        if (e != null && e.checked)
          return e.checked === !0;
      });
      return this.setResult(i), i;
    }
  },
  methods: {
    getComputedStyle(i) {
      let e = "";
      return i.icon == "pie" ? e = "pie-icon" : i.icon == "tree" ? e = "tree-icon" : i.icon == "bar" ? e = "bar-icon" : i.icon == "line" && (e = "line-icon"), e;
    },
    search(i) {
      this.inputContent = i;
    },
    truncateText(i, e) {
      return i && i.length > e ? i.substring(0, e) + "..." : i;
    },
    changeHandler(i, e) {
      this.filtered[e] !== void 0 && (this.filtered[e].checked = i.target.checked, this.$set(this.filtered, e, this.filtered[e]), this.filteredDependency += 1);
    },
    // Click on option. If there is a click handler, the click handler is executed, and if there is no click handler, the checklist is saved.
    optionClick(i) {
      this.$nextTick(() => {
        this.clickHandler && this.clickHandler(i);
      });
    },
    // Full selection function. If you want to use it in the parent component, set refs and use this.$refs.locationDropdown.selectAll("location"); It can be used in the same format as
    // See OeeCenter.vue.
    selectAll() {
      let i = this.filtered.slice();
      this.filtered.splice(0), i == null || i.map((e) => {
        e.disabled || (e.checked = !0), this.filtered.push(e);
      }), this.filteredDependency += 1;
    },
    // Deselect all.
    unselectAll() {
      let i = this.filtered.slice();
      this.filtered.splice(0), i == null || i.map((e) => {
        e.default !== !0 && (e.checked = !1), this.filtered.push(e);
      }), this.filteredDependency += 1;
    },
    // handler for popover
    handleClose() {
      this.$nextTick(() => {
        this.onClose ? this.onClose() : this.visible = !1;
      });
    }
  }
};
var C1 = function() {
  var i, e, t, s, r = this, n = r.$createElement, a = r._self._c || n;
  return a("common-popover", {
    style: r.styleProps,
    attrs: {
      visible: r.visible
    },
    on: {
      close: r.handleClose
    }
  }, [a("div", {
    class: r.$style.dropdown_wrap,
    style: r.styleProps
  }, [r.items.length >= 5 ? a("div", [a("search-bar", {
    attrs: {
      "placeholder-text": r.placeholder || "Search",
      "request-param": r.requestParam,
      "set-search-complete-keyword": r.search
    }
  }), a("div", {
    class: r.$style.focus_border
  })], 1) : r._e(), a("ul", {
    class: r.$style.dropdown_list
  }, [r.checkbox && ((i = r.filtered) === null || i === void 0 ? void 0 : i.length) >= 5 ? a("li", {
    class: r.$style.all_select_list
  }, [a("div", {
    attrs: {
      disabled: ((e = r.checkedArray) === null || e === void 0 ? void 0 : e.length) === ((t = r.filtered) === null || t === void 0 ? void 0 : t.length)
    },
    on: {
      click: function(o) {
        return r.selectAll();
      }
    }
  }, [r._v(" Select All ")]), a("div", {
    attrs: {
      disabled: ((s = r.checkedArray) === null || s === void 0 ? void 0 : s.length) === 0
    },
    on: {
      click: function(o) {
        return r.unselectAll();
      }
    }
  }, [r._v(" Unselect All ")])]) : r._e(), r.infoText ? a("li", {
    class: r.$style.info_text
  }, [r._v(r._s(r.infoText))]) : r._e(), r._l(r.filtered, function(o, l) {
    return [o ? a("li", {
      key: l
    }, [a("label", {
      class: [r.checkbox ? "" : r.$style.list_hover_dropdown],
      attrs: {
        for: `dropdown-input-${l}-${r.id}`,
        disabled: o == null ? void 0 : o.disabled
      },
      on: {
        click: function(u) {
          return r.optionClick(o);
        }
      }
    }, [r.checkbox ? [a("input", {
      directives: [{
        name: "model",
        rawName: "v-model",
        value: o.checked,
        expression: "item.checked"
      }],
      attrs: {
        id: `dropdown-input-${l}-${r.id}`,
        type: "checkbox"
      },
      domProps: {
        value: JSON.stringify(o),
        checked: Array.isArray(o.checked) ? r._i(o.checked, JSON.stringify(o)) > -1 : o.checked
      },
      on: {
        input: function(u) {
          return r.changeHandler(u, l);
        },
        change: function(u) {
          var h = o.checked, c = u.target, d = !!c.checked;
          if (Array.isArray(h)) {
            var f = JSON.stringify(o), g = r._i(h, f);
            c.checked ? g < 0 && r.$set(o, "checked", h.concat([f])) : g > -1 && r.$set(o, "checked", h.slice(0, g).concat(h.slice(g + 1)));
          } else
            r.$set(o, "checked", d);
        }
      }
    }), a("div", {
      class: r.$style.checkbox_custom
    })] : r._e(), o != null && o.icon ? a("div", {
      class: [r.getComputedStyle(o), r.$style.defualt_style]
    }, [a("img", {
      attrs: {
        src: o.icon,
        alt: "dropdown-icon"
      }
    })]) : r._e(), r._v(" " + r._s(r.truncateText(o[r.titleName], 40)) + " ")], 2)]) : r._e()];
  })], 2)])]);
}, M1 = [];
const O1 = "_dropdown_wrap_xdaez_7", A1 = "_dropdown_list_xdaez_24", L1 = "_checkbox_custom_xdaez_44", j1 = "_all_select_list_xdaez_77", E1 = "_info_text_xdaez_96", I1 = "_list_hover_dropdown_xdaez_102", R1 = {
  dropdown_wrap: O1,
  dropdown_list: A1,
  checkbox_custom: L1,
  all_select_list: j1,
  info_text: E1,
  list_hover_dropdown: I1
}, Pl = {};
Pl.$style = R1;
var Y1 = /* @__PURE__ */ te(
  k1,
  C1,
  M1,
  !1,
  N1,
  "242cc473",
  null,
  null
);
function N1(i) {
  for (let e in Pl)
    this[e] = Pl[e];
}
const lA = /* @__PURE__ */ function() {
  return Y1.exports;
}(), $1 = {
  name: "DoubleDropdown",
  props: {
    visible: {
      default: !1,
      Type: Boolean
    },
    items: Array,
    clickHandler: Function,
    styleProp: String,
    // Set whether dropdown-list wrap-style or not (ex: {top: '10px', left: '10px', width: '10px'})
    placeholder: String,
    // Set whether placeholder or not
    id: String,
    applyHandler: Function,
    resetHandler: Function,
    onClose: Function,
    position: {
      type: Object,
      default: () => ({ top: "", left: "", right: "", bottom: "" })
    }
  },
  // component alies
  components: {
    CtaButton: $a,
    "common-popover": df
  },
  data() {
    return {
      colorType: "blue-fill",
      inputContent: "",
      // The input value. Shows the input list searched through filtered.
      checkedArray: []
      // The checked list is saved. Passed to the parent component through the setResult function
    };
  },
  mounted() {
    setTimeout(() => {
      this.filtered.forEach((i) => {
        this.selectAll(i, i, i.title);
      });
    }, 1e3);
  },
  computed: {
    // Filter your search terms
    filtered() {
      if (this.items) {
        const i = this.inputContent.trim();
        return !i || i == "" ? this.items : this.items != null ? this.items.filter((s) => s.title != null && s.title.toUpperCase().includes(i.toUpperCase())).sort((s, r) => s.title.toUpperCase() > r.title.toUpperCase() ? 1 : -1) : this.items;
      } else
        return this.items;
    }
  },
  methods: {
    toggleCheckValue(i, e, t) {
      e.checked = !e.checked, e.title == "All" && e.checked == !0 ? this.selectAllCheckBox(i, t, !0) : e.title == "All" && e.checked == !1 && this.selectAllCheckBox(i, t, !1), this.SyncCheckedArray();
      let s = this.checkedArray.find(
        (r) => r.title == i.title
      );
      s !== void 0 && (s == null ? void 0 : s.childrens.length) == this.filtered[t].childrens.length - 1 && this.selectOrDeselectAllbox(i, t), this.SyncCheckedArray();
    },
    selectOrDeselectAllbox(i) {
      let e = i.title, t = JSON.parse(JSON.stringify(this.filtered));
      this.filtered.splice(0), this.$nextTick(() => {
        t.map((s) => {
          let r = { id: s.id, title: s.title, childrens: [] };
          s.childrens.map((n) => {
            r.childrens.push({ title: n.title, code: n.code });
          }), this.filtered.push(r);
        }), this.filtered.map((s, r) => {
          this.selectAllBox(s, t[r], e);
        });
      });
    },
    selectAllBox(i, e, t) {
      i.childrens.forEach((s, r) => {
        i.title == t && s.title == "All" ? s.checked = !e.childrens[r].checked : s.checked = e.childrens[r].checked;
      }), this.$forceUpdate();
    },
    // Click on option. If there is a click handler, the click handler is executed, and if there is no click handler, the checklist is saved.
    applyHandlerMethod() {
      this.$nextTick(() => {
        this.applyHandler && (this.SyncCheckedArray(), this.applyHandler(this.checkedArray));
      }), this.$forceUpdate();
    },
    /* eslint-disable  no-unused-vars */
    selectAllCheckBox(i, e, t) {
      let s = i.title, r = JSON.parse(JSON.stringify(this.filtered));
      this.filtered.splice(0), this.$nextTick(() => {
        r.map((n) => {
          let a = { id: n.id, title: n.title }, o = [];
          n == null || n.childrens.map((l) => {
            o.push({ title: l.title, code: l.code });
          }), a.childrens = o, this.filtered.push(a);
        }), this.filtered.map((n, a) => {
          t ? this.selectAll(n, r[a], s) : this.unselectAll(n, r[a], s);
        });
      }), this.$forceUpdate();
    },
    // select all
    selectAll(i, e, t) {
      t == i.title ? i == null || i.childrens.forEach((s) => {
        s.checked = !0;
      }) : i == null || i.childrens.forEach((s, r) => {
        s.checked = e.childrens[r].checked;
      }), this.$forceUpdate();
    },
    // Deselect all.
    unselectAll(i, e, t) {
      t == i.title ? i == null || i.childrens.forEach((s) => {
        s.checked = !1;
      }) : i == null || i.childrens.forEach((s, r) => {
        s.checked = e.childrens[r].checked;
      }), this.$forceUpdate();
    },
    resetAllCheckBox() {
      let i = JSON.parse(JSON.stringify(this.filtered));
      this.filtered.splice(0), this.$nextTick(() => {
        i.map((e) => {
          let t = { id: e.id, title: e.title }, s = [];
          e == null || e.childrens.map((r) => {
            s.push({ title: r.title, code: r.code });
          }), t.childrens = s, this.filtered.push(t);
        }), this.filtered.map((e, t) => {
          this.selectAll(e, i[t], e.title);
        });
      }), this.$forceUpdate();
    },
    resetDataHandler() {
      this.resetAllCheckBox(), this.$nextTick(() => {
        this.resetHandler && this.resetHandler(this.checkedArray);
      }), this.$forceUpdate();
    },
    // Save checked array.
    SyncCheckedArray() {
      const i = JSON.parse(JSON.stringify(this.filtered)), e = [];
      i.forEach((t) => {
        const s = t.childrens.filter((r) => r.checked === !0);
        t.childrens = s, e.push(t);
      }), this.checkedArray = e;
    },
    handleClose() {
      this.$nextTick(() => {
        this.onClose ? this.onClose() : this.visible = !1;
      });
    }
  }
};
var F1 = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("common-popover", {
    attrs: {
      visible: i.visible,
      position: i.position
    },
    on: {
      close: i.handleClose
    }
  }, [t("div", {
    class: i.$style.dropdown_wrap,
    style: i.styleProp
  }, [t("ul", {
    class: [i.$style.parent_item, i.$style.row]
  }, i._l(i.filtered, function(s, r) {
    return t("li", {
      key: r,
      class: [i.$style.col_md, i.$style.custom_padding]
    }, [t("label", {
      class: i.$style.label_height
    }, [t("h5", {
      class: i.$style.font_setting
    }, [i._v(i._s(s.title))])]), t("ul", {
      class: i.$style.child_item
    }, i._l(s.childrens, function(n, a) {
      return t("li", {
        key: `${a}-${r}`
      }, [t("label", {
        attrs: {
          for: `dropdown-input-${r}-${a}-${i.id}`
        },
        on: {
          mouseup: function(o) {
            return i.toggleCheckValue(s, n, r);
          }
        }
      }, [[t("input", {
        directives: [{
          name: "model",
          rawName: "v-model",
          value: n.checked,
          expression: "subItem.checked"
        }],
        attrs: {
          id: `dropdown-input-${r}-${a}-${i.id}`,
          type: "checkbox"
        },
        domProps: {
          value: JSON.stringify(n),
          checked: n.checked,
          checked: Array.isArray(n.checked) ? i._i(n.checked, JSON.stringify(n)) > -1 : n.checked
        },
        on: {
          change: function(o) {
            var l = n.checked, u = o.target, h = !!u.checked;
            if (Array.isArray(l)) {
              var c = JSON.stringify(n), d = i._i(l, c);
              u.checked ? d < 0 && i.$set(n, "checked", l.concat([c])) : d > -1 && i.$set(n, "checked", l.slice(0, d).concat(l.slice(d + 1)));
            } else
              i.$set(n, "checked", h);
          }
        }
      }), t("div", {
        class: i.$style.checkbox_custom
      })], n.image ? t("div", [t("img", {
        attrs: {
          src: n.image,
          alt: ""
        }
      })]) : i._e(), i._v(" " + i._s(n.title) + " ")], 2)]);
    }), 0), t("span", {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: r != i.items.length - 1,
        expression: "index != items.length - 1"
      }],
      class: i.$style.vertical_line
    })]);
  }), 0), t("div", {
    class: [i.$style.buttons_custom, i.$style.w_100, i.$style.align_items_center, i.$style.d_flex, i.$style.justify_content_between]
  }, [t("div", {
    class: [i.$style.all_select_list, i.$style.reset_styles]
  }, [t("div", {
    class: i.$style.reset_btn_styles,
    on: {
      click: function(s) {
        return i.resetDataHandler();
      }
    }
  }, [i._v(" Reset to Default ")])]), t("div", [t("CtaButton", {
    class: [i.$style.btn_custom, i.$style.btn_custom_primary, i.$style.animationPrimary],
    attrs: {
      type: "link",
      "click-handler": i.applyHandlerMethod,
      colorType: i.colorType
    }
  }, [t("span", [i._v("Apply")])])], 1)])])]);
}, B1 = [];
const H1 = "_dropdown_wrap_1ahj7_7", z1 = "_parent_item_1ahj7_25", X1 = "_row_1ahj7_34", V1 = "_col_md_1ahj7_38", W1 = "_custom_padding_1ahj7_47", U1 = "_font_setting_1ahj7_55", G1 = "_child_item_1ahj7_68", Z1 = "_checkbox_custom_1ahj7_88", K1 = "_vertical_line_1ahj7_110", Q1 = "_buttons_custom_1ahj7_117", J1 = "_w_100_1ahj7_121", q1 = "_align_items_center_1ahj7_124", eP = "_d_flex_1ahj7_127", tP = "_justify_content_between_1ahj7_130", iP = "_reset_styles_1ahj7_133", sP = "_all_select_list_1ahj7_140", rP = "_reset_btn_styles_1ahj7_153", nP = "_btn_custom_1ahj7_157", aP = {
  dropdown_wrap: H1,
  parent_item: z1,
  row: X1,
  col_md: V1,
  custom_padding: W1,
  font_setting: U1,
  child_item: G1,
  checkbox_custom: Z1,
  vertical_line: K1,
  buttons_custom: Q1,
  w_100: J1,
  align_items_center: q1,
  d_flex: eP,
  justify_content_between: tP,
  reset_styles: iP,
  all_select_list: sP,
  reset_btn_styles: rP,
  btn_custom: nP
}, Tl = {};
Tl.$style = aP;
var oP = /* @__PURE__ */ te(
  $1,
  F1,
  B1,
  !1,
  lP,
  "0144e24b",
  null,
  null
);
function lP(i) {
  for (let e in Tl)
    this[e] = Tl[e];
}
const uA = /* @__PURE__ */ function() {
  return oP.exports;
}(), uP = {
  props: {
    id: String,
    styleProps: {
      type: String,
      default: ""
    },
    placeholderText: {
      type: String,
      default: "Enter Number "
    },
    checkmark: {
      type: String,
      default: "outside"
    },
    active: Boolean,
    disabled: Boolean,
    error: {
      type: Boolean,
      default: !1
    },
    iconUrl: {
      type: Object,
      default: null
    },
    min: Number,
    max: Number,
    step: Number,
    changeHandler: Function,
    errorMessage: String,
    required: Boolean,
    readonly: Boolean
  },
  data() {
    return {
      text: "",
      validData: !1,
      keypressed: !1
    };
  },
  watch: {
    text() {
      var i, e;
      if (this.changeHandler && this.changeHandler({ value: this.text, id: this.id }), ((i = this.max) == null ? void 0 : i.length) < 1)
        parseInt(this.text) > this.min ? this.validData = !0 : this.validData = !1;
      else if (((e = this.min) == null ? void 0 : e.length) < 1)
        parseInt(this.text) < this.max ? this.validData = !0 : this.validData = !1;
      else {
        (parseInt(this.text) > this.min || parseInt(this.text) < this.max) && (this.validData = !0), (parseInt(this.text) < this.min || parseInt(this.text) > this.max) && (this.validData = !1);
        let t = parseInt(this.text);
        isNaN(t) && (this.validData = !1);
      }
    }
  },
  methods: {
    keyPressed() {
      this.keypressed || (this.keypressed = !0);
    }
  },
  computed: {
    positionComputed() {
      var i, e;
      return this.iconUrl && this.error === !1 && this.disabled === !1 ? `${this.$style[(i = this.iconUrl) == null ? void 0 : i.position]} ` : this.error === !0 && this.iconUrl ? `${this.$style[(e = this.iconUrl) == null ? void 0 : e.position]} ${this.$style.error}` : this.error === !0 ? `${this.$style.error}` : this.disabled === !0 && this.iconUrl ? `${this.$style.disable} ` : this.disabled === !0 ? `${this.$style.disable} ` : "";
    },
    textBoxClassComputed() {
      return this.error == !1 ? `${this.$style.base_input}` : this.error == !0 ? `${this.$style.base_input} ${this.$style.base_input_error} ` : "";
    },
    iconBorderComputed() {
      var i, e;
      return this.error === !0 && ((i = this.iconUrl) == null ? void 0 : i.position) == "left" ? `${this.$style.base_input__icon_error_left} ` : this.error === !0 && ((e = this.iconUrl) == null ? void 0 : e.position) == "right" ? `${this.$style.base_input__icon_error_right} ` : "";
    }
  }
};
var hP = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    class: i.$style.container
  }, [t("div", [t("div", {
    class: [i.$style.container_input, i.positionComputed]
  }, [i.iconUrl ? t("span", {
    class: [i.iconBorderComputed, i.$style.base_input__icon]
  }, [t("span", {
    class: i.$style.base_input_icon_img
  }, [t("img", {
    attrs: {
      src: i.iconUrl.url
    }
  })])]) : i._e(), t("input", {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: i.text,
      expression: "text"
    }],
    class: [i.textBoxClassComputed, i.$style.base_input, i.keypressed ? i.$style.caret_color : ""],
    style: i.styleProps,
    attrs: {
      id: i.id,
      placeholder: i.placeholderText,
      type: "number",
      active: i.active,
      disabled: i.disabled,
      error: i.error,
      min: i.min,
      max: i.max,
      step: i.step,
      required: i.required,
      readonly: i.readonly,
      "error-message": i.errorMessage
    },
    domProps: {
      value: i.text
    },
    on: {
      keyup: function(s) {
        return i.keyPressed();
      },
      input: function(s) {
        s.target.composing || (i.text = s.target.value);
      }
    }
  }), i.checkmark === "inside" ? t("span", {
    class: [i.validData ? i.$style.inside1 : i.$style.inside, i.$style.validity]
  }) : i._e()]), i.checkmark == "outside" ? t("span", {
    class: [i.validData ? i.$style.outside1 : i.$style.outside, i.$style.validity]
  }) : i._e()]), i.error ? t("div", [t("span", {
    class: i.$style.error_message
  }, [i._v(i._s(i.errorMessage))])]) : i._e()]);
}, cP = [];
const dP = "_container_1871l_1", fP = "_caret_color_1871l_1", pP = "_container_input_1871l_4", gP = "_base_input__icon_1871l_41", mP = "_base_input__icon_img_1871l_49", _P = "_base_input__icon_error_left_1871l_58", bP = "_base_input__icon_error_right_1871l_61", yP = "_validity_1871l_64", vP = "_inside_1871l_67", xP = "_inside1_1871l_72", wP = "_base_input_1871l_41", SP = "_base_input_error_1871l_98", DP = "_outside1_1871l_107", PP = "_outside_1871l_107", TP = "_error_1871l_117", kP = "_disable_1871l_124", CP = "_right_1871l_129", MP = "_left_1871l_132", OP = "_error_message_1871l_135", AP = {
  container: dP,
  caret_color: fP,
  container_input: pP,
  base_input__icon: gP,
  base_input__icon_img: mP,
  base_input__icon_error_left: _P,
  base_input__icon_error_right: bP,
  validity: yP,
  inside: vP,
  inside1: xP,
  base_input: wP,
  base_input_error: SP,
  outside1: DP,
  outside: PP,
  error: TP,
  disable: kP,
  right: CP,
  left: MP,
  error_message: OP
}, kl = {};
kl.$style = AP;
var LP = /* @__PURE__ */ te(
  uP,
  hP,
  cP,
  !1,
  jP,
  "29bed24a",
  null,
  null
);
function jP(i) {
  for (let e in kl)
    this[e] = kl[e];
}
const hA = /* @__PURE__ */ function() {
  return LP.exports;
}(), EP = {
  props: {
    id: String,
    styleProps: String,
    placeholderText: {
      type: String,
      default: "Memo"
    },
    active: Boolean,
    disabled: Boolean,
    error: Boolean,
    errorMessage: {
      type: String,
      default: "Error Message Here"
    },
    minlength: String,
    // minimum character
    maxlength: String,
    // maximum character
    cols: Number,
    readonly: Boolean,
    changeHandler: Function,
    required: Boolean
  },
  data() {
    return {
      text: "",
      inputHeight: "0",
      keypressed: !1
    };
  },
  watch: {
    text() {
      this.changeHandler && this.changeHandler({ value: this.value, id: this.id }), this.resize(), this.$emit("input", this.text);
    }
  },
  computed: {
    textBoxClassComputed() {
      return this.error == !0 ? `${this.$style.textarea_box_error}` : `${this.$style.textarea_box}`;
    }
  },
  methods: {
    keyPressed() {
      this.keypressed || (this.keypressed = !0);
    },
    resize() {
      this.inputHeight = `${this.$refs.input.scrollHeight}px`;
    }
  },
  mounted() {
    this.resize();
  }
};
var IP = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", [t("div", {
    class: i.$style.container
  }, [t("div", {
    class: i.$style.textarea_box_container
  }, [t("textarea", {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: i.text,
      expression: "text"
    }],
    ref: "input",
    class: [i.textBoxClassComputed, i.keypressed ? i.$style.caret_color : ""],
    style: i.styleProps,
    attrs: {
      id: i.id,
      placeholder: i.placeholderText,
      type: "text",
      active: i.active,
      disabled: i.disabled,
      minlength: i.minlength,
      maxlength: i.maxlength,
      readonly: i.readonly,
      cols: i.cols,
      error: i.error,
      required: i.required,
      "error-message": i.errorMessage
    },
    domProps: {
      value: i.text
    },
    on: {
      keyup: function(s) {
        return i.keyPressed();
      },
      input: function(s) {
        s.target.composing || (i.text = s.target.value);
      }
    }
  })]), i.error ? t("div", {
    class: i.$style.error_message
  }, [t("span", [i._v(i._s(i.errorMessage))])]) : i._e()])]);
}, RP = [];
const YP = "_container_d5fjq_1", NP = "_caret_color_d5fjq_1", $P = "_textarea_box_container_d5fjq_4", FP = "_textarea_box_d5fjq_4", BP = "_textarea_box_error_d5fjq_64", HP = "_error_message_d5fjq_81", zP = {
  container: YP,
  caret_color: NP,
  textarea_box_container: $P,
  textarea_box: FP,
  textarea_box_error: BP,
  error_message: HP
}, Cl = {};
Cl.$style = zP;
var XP = /* @__PURE__ */ te(
  EP,
  IP,
  RP,
  !1,
  VP,
  "60fbe7d8",
  null,
  null
);
function VP(i) {
  for (let e in Cl)
    this[e] = Cl[e];
}
const cA = /* @__PURE__ */ function() {
  return XP.exports;
}(), WP = "_container_1t5m0_1", UP = "_container_input_1t5m0_1", GP = "_base_input__icon_1t5m0_38", ZP = "_base_input_icon_img_1t5m0_46", KP = "_base_input__icon_error_left_1t5m0_55", QP = "_base_input__icon_error_right_1t5m0_58", JP = "_validity_1t5m0_61", qP = "_inside_1t5m0_64", eT = "_inside1_1t5m0_69", tT = "_base_input_1t5m0_38", iT = "_caret_color_1t5m0_88", sT = "_base_input_error_1t5m0_97", rT = "_outside1_1t5m0_106", nT = "_outside_1t5m0_106", aT = "_error_1t5m0_116", oT = "_disable_1t5m0_123", lT = "_right_1t5m0_128", uT = "_left_1t5m0_131", hT = "_error_message_1t5m0_134", ss = {
  container: WP,
  container_input: UP,
  base_input__icon: GP,
  base_input_icon_img: ZP,
  base_input__icon_error_left: KP,
  base_input__icon_error_right: QP,
  validity: JP,
  inside: qP,
  inside1: eT,
  base_input: tT,
  caret_color: iT,
  base_input_error: sT,
  outside1: rT,
  outside: nT,
  error: aT,
  disable: oT,
  right: lT,
  left: uT,
  error_message: hT
}, cT = {
  props: {
    id: String,
    styleProps: String,
    placeholderText: {
      type: String,
      default: "Enter Text Here"
    },
    checkmark: String,
    active: Boolean,
    disabled: Boolean,
    error: {
      type: Boolean,
      default: !1
    },
    required: Boolean,
    iconUrl: {
      type: Object
    },
    minlength: {
      type: Number,
      default: 1
    },
    // minimum character
    maxlength: Number,
    // maximum character
    errorMessage: String,
    readonly: Boolean
  },
  data() {
    return {
      validData: !1,
      text: "",
      keyPressed: !1
    };
  },
  methods: {
    isValid(i) {
      const e = i.length;
      return !(e < this.minlength || this.maxlength && e > this.maxlength);
    },
    onKeyPressed() {
      this.keyPressed || (this.keyPressed = !0), this.validData = this.isValid(this.text);
    }
  },
  computed: {
    positionComputed() {
      var t;
      let i = "";
      const e = (t = this.iconUrl) == null ? void 0 : t.position;
      return e && (i += `${ss[e]} `), this.error && (i += `${ss.error} `), this.disabled && (i += `${ss.disable} `), i;
    },
    textBoxClassComputed() {
      let i = `${ss.base_input} `;
      return this.error && (i += `${ss.base_input_error} `), i;
    },
    iconBorderComputed() {
      var e;
      return !this.error || !((e = this.iconUrl) != null && e.position) ? "" : this.iconUrl.position === "left" ? `${ss.base_input__icon_error_left} ` : `${ss.base_input__icon_error_right} `;
    }
  }
};
var dT = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    class: i.$style.container
  }, [t("div", {
    staticStyle: {
      display: "flex"
    }
  }, [t("div", {
    class: [i.$style.container_input, i.$style.search_bar__input, i.positionComputed],
    style: i.styleProps,
    attrs: {
      tabindex: "0"
    }
  }, [i.iconUrl ? t("span", {
    class: [i.iconBorderComputed, i.$style.base_input__icon]
  }, [t("span", {
    class: i.$style.base_input_icon_img
  }, [t("img", {
    attrs: {
      src: i.iconUrl.url
    }
  })])]) : i._e(), t("input", {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: i.text,
      expression: "text"
    }],
    class: [i.textBoxClassComputed, i.$style.base_input, i.keyPressed ? i.$style.caret_color : ""],
    attrs: {
      id: i.id,
      placeholder: i.placeholderText,
      type: "text",
      active: i.active,
      disabled: i.disabled,
      error: i.error,
      minlength: i.minlength,
      maxlength: i.maxlength,
      checkmark: i.checkmark,
      readonly: i.readonly,
      required: i.required
    },
    domProps: {
      value: i.text
    },
    on: {
      keyup: function(s) {
        return i.onKeyPressed();
      },
      input: function(s) {
        s.target.composing || (i.text = s.target.value);
      }
    }
  }), i.checkmark === "inside" ? t("span", {
    class: [i.validData ? i.$style.inside1 : i.$style.inside, i.$style.validity]
  }) : i._e()]), i.checkmark == "outside" ? t("span", {
    class: [i.validData ? i.$style.outside1 : i.$style.outside, i.$style.validity]
  }) : i._e()]), i.error ? t("div", [t("span", {
    class: i.$style.error_message
  }, [i._v(i._s(i.errorMessage))])]) : i._e()]);
}, fT = [];
const pT = "_container_1t5m0_1", gT = "_container_input_1t5m0_1", mT = "_base_input__icon_1t5m0_38", _T = "_base_input_icon_img_1t5m0_46", bT = "_base_input__icon_error_left_1t5m0_55", yT = "_base_input__icon_error_right_1t5m0_58", vT = "_validity_1t5m0_61", xT = "_inside_1t5m0_64", wT = "_inside1_1t5m0_69", ST = "_base_input_1t5m0_38", DT = "_caret_color_1t5m0_88", PT = "_base_input_error_1t5m0_97", TT = "_outside1_1t5m0_106", kT = "_outside_1t5m0_106", CT = "_error_1t5m0_116", MT = "_disable_1t5m0_123", OT = "_right_1t5m0_128", AT = "_left_1t5m0_131", LT = "_error_message_1t5m0_134", jT = {
  container: pT,
  container_input: gT,
  base_input__icon: mT,
  base_input_icon_img: _T,
  base_input__icon_error_left: bT,
  base_input__icon_error_right: yT,
  validity: vT,
  inside: xT,
  inside1: wT,
  base_input: ST,
  caret_color: DT,
  base_input_error: PT,
  outside1: TT,
  outside: kT,
  error: CT,
  disable: MT,
  right: OT,
  left: AT,
  error_message: LT
}, Ml = {};
Ml.$style = jT;
var ET = /* @__PURE__ */ te(
  cT,
  dT,
  fT,
  !1,
  IT,
  "2c66a39e",
  null,
  null
);
function IT(i) {
  for (let e in Ml)
    this[e] = Ml[e];
}
const dA = /* @__PURE__ */ function() {
  return ET.exports;
}(), RT = "_container_abd4a_7", YT = "_inputs_abd4a_35", Mn = {
  container: RT,
  "input-wrapper": "_input-wrapper_abd4a_14",
  "-focus": "_-focus_abd4a_27",
  "-disabled": "_-disabled_abd4a_31",
  inputs: YT,
  "-error": "_-error_abd4a_39",
  "error-message": "_error-message_abd4a_73"
}, NT = {
  props: {
    styleProps: String,
    errorMessage: {
      type: String,
      default: "Enter a valid IP Address (ex. 0.0.0.0)"
    },
    id: {
      type: String,
      default: "input-id"
    },
    disabled: {
      type: Boolean,
      default: !1
    },
    initialValue: String,
    setResult: Function
  },
  data() {
    return {
      octets: [{ value: "" }, { value: "" }, { value: "" }, { value: "" }],
      isFocused: !1,
      ipAddress: "",
      error: !1
    };
  },
  watch: {
    octets: {
      handler(i) {
        this.ipAddress = i.map((e) => e.value).join("."), this.validateIpAddress(), this.setIpAddress();
      },
      deep: !0,
      immediate: !0
    }
  },
  methods: {
    validateIpAddress() {
      const i = /^(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;
      this.ipAddress.length < 4 || (this.error = this.octets.some((e) => !i.test(e.value)));
    },
    inputHandler(i) {
      for (let e = i; e < this.octets.length; e++) {
        const t = this.octets[e];
        if (t.value && t.value.toString().length >= 3)
          t.value = t.value.toString().substring(0, 3), this.$refs[`octet-${i + 2}`] && this.$refs[`octet-${i + 2}`][0].focus();
        else
          return;
      }
    },
    setIpAddress() {
      var i;
      (i = this.setResult) == null || i.call(this, this.id, this.ipAddress, this.error);
    }
  },
  computed: {
    inputWrapperClass() {
      return `${Mn["input-wrapper"]} ${this.isFocused ? Mn["-focus"] : ""} ${this.disabled ? Mn["-disabled"] : ""} ${this.error ? Mn["-error"] : ""}`;
    }
  },
  mounted() {
    this.initialValue && (this.octets = this.initialValue.split(".").map((i) => ({
      value: i
    })));
  }
};
var $T = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    class: i.$style.container,
    attrs: {
      id: i.id
    }
  }, [t("div", {
    class: i.inputWrapperClass,
    style: i.styleProps
  }, i._l(i.octets, function(s, r) {
    return t("div", {
      class: i.$style.inputs
    }, [t("input", {
      directives: [{
        name: "model",
        rawName: "v-model.number",
        value: s.value,
        expression: "octet.value",
        modifiers: {
          number: !0
        }
      }],
      key: r,
      ref: `octet-${r + 1}`,
      refInFor: !0,
      style: s.value.length === 0 ? "border-bottom: 1px solid #c9c9c9" : "",
      attrs: {
        autocomplete: "off",
        type: "number",
        id: `octet-${r + 1}`,
        disabled: i.disabled
      },
      domProps: {
        value: s.value
      },
      on: {
        input: [function(n) {
          n.target.composing || i.$set(s, "value", i._n(n.target.value));
        }, function(n) {
          return i.inputHandler(r);
        }],
        focusin: function(n) {
          i.isFocused = !0;
        },
        focusout: function(n) {
          i.isFocused = !1;
        },
        blur: function(n) {
          return i.$forceUpdate();
        }
      }
    }), r < 3 ? t("span", [i._v(".")]) : i._e()]);
  }), 0), i.error ? t("p", {
    class: i.$style["error-message"]
  }, [i._v(" " + i._s(i.errorMessage) + " ")]) : i._e()]);
}, FT = [];
const BT = "_container_abd4a_7", HT = "_inputs_abd4a_35", zT = {
  container: BT,
  "input-wrapper": "_input-wrapper_abd4a_14",
  "-focus": "_-focus_abd4a_27",
  "-disabled": "_-disabled_abd4a_31",
  inputs: HT,
  "-error": "_-error_abd4a_39",
  "error-message": "_error-message_abd4a_73"
}, Ol = {};
Ol.$style = zT;
var XT = /* @__PURE__ */ te(
  NT,
  $T,
  FT,
  !1,
  VT,
  "67dbd7e2",
  null,
  null
);
function VT(i) {
  for (let e in Ol)
    this[e] = Ol[e];
}
const fA = /* @__PURE__ */ function() {
  return XT.exports;
}(), WT = {
  name: "list-group",
  props: {
    list: {
      type: Array
    },
    setResult: Function,
    styleProps: {
      default: "",
      Type: String
    },
    itemId: {
      type: Boolean,
      default: () => !1
    },
    isSelected: {
      type: Boolean,
      default: () => !1
    }
  },
  computed: {
    selectedStyle() {
      return this.isSelected ? "assignedListItem" : "availableListItem";
    },
    listGroupClassComputed() {
      return `${this.$style[this.selectedStyle]}`;
    }
  },
  methods: {
    availableItem(i) {
      i.enable = !0, this.$nextTick(() => {
        this.setResult && this.setResult(i);
      });
    },
    selectedItem(i) {
      var t, s;
      let e = (t = this.list) == null ? void 0 : t[i];
      this.$nextTick(() => {
        this.setResult && this.setResult(e);
      }), (s = this.list) == null || s.splice(i, 1);
    }
  }
};
var UT = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    style: i.styleProps
  }, i._l(i.list, function(s, r) {
    return t("div", {
      key: r,
      class: i.$style.selected_item
    }, [i.itemId ? t("div", {
      class: i.listGroupClassComputed,
      attrs: {
        disabled: s.enable
      }
    }, [i._v(" " + i._s(s.id) + " ")]) : i._e(), t("div", {
      class: i.listGroupClassComputed,
      attrs: {
        disabled: s.enable
      }
    }, [i._v(" " + i._s(s.name) + " ")]), i.isSelected ? t("div", {
      class: i.$style.minus_item,
      on: {
        click: function(n) {
          return i.selectedItem(r);
        }
      }
    }, [t("svg", {
      class: i.$style.minus_item_default,
      attrs: {
        xmlns: "http://www.w3.org/2000/svg",
        width: "9.844",
        height: "1.641",
        viewBox: "0 0 9.844 1.641"
      }
    }, [t("g", {
      attrs: {
        id: "Group_8891",
        "data-name": "Group 8891",
        transform: "translate(0.861 -3.24)"
      }
    }, [t("rect", {
      attrs: {
        id: "Rectangle_10",
        "data-name": "Rectangle 10",
        width: "1.641",
        height: "9.843",
        transform: "translate(8.982 3.24) rotate(90)",
        fill: "#ddd"
      }
    }), t("rect", {
      attrs: {
        id: "Rectangle_11",
        "data-name": "Rectangle 11",
        width: "1.641",
        height: "9.843",
        transform: "translate(-0.861 4.88) rotate(-90)",
        fill: "#ddd"
      }
    })])]), t("svg", {
      class: i.$style.minus_item_hover,
      attrs: {
        xmlns: "http://www.w3.org/2000/svg",
        width: "9.844",
        height: "1.641",
        viewBox: "0 0 9.844 1.641"
      }
    }, [t("g", {
      attrs: {
        id: "Group_8891",
        "data-name": "Group 8891",
        transform: "translate(0.861 -3.24)"
      }
    }, [t("rect", {
      attrs: {
        id: "Rectangle_10",
        "data-name": "Rectangle 10",
        width: "1.641",
        height: "9.843",
        transform: "translate(8.982 3.24) rotate(90)",
        fill: "#3491ff"
      }
    }), t("rect", {
      attrs: {
        id: "Rectangle_11",
        "data-name": "Rectangle 11",
        width: "1.641",
        height: "9.843",
        transform: "translate(-0.861 4.88) rotate(-90)",
        fill: "#3491ff"
      }
    })])])]) : t("div", {
      class: i.$style.minus_item,
      attrs: {
        disabled: s.enable
      },
      on: {
        click: function(n) {
          return i.availableItem(s);
        }
      }
    }, [t("svg", {
      class: i.$style.minus_item_default,
      attrs: {
        xmlns: "http://www.w3.org/2000/svg",
        width: "9.843",
        height: "9.843",
        viewBox: "0 0 9.843 9.843"
      }
    }, [t("g", {
      attrs: {
        id: "Group_8883",
        "data-name": "Group 8883",
        transform: "translate(0.861 0.862)"
      }
    }, [t("rect", {
      attrs: {
        id: "Rectangle_10",
        "data-name": "Rectangle 10",
        width: "1.641",
        height: "9.843",
        transform: "translate(8.982 3.24) rotate(90)",
        fill: "#9d9d9d"
      }
    }), t("rect", {
      attrs: {
        id: "Rectangle_11",
        "data-name": "Rectangle 11",
        width: "1.641",
        height: "9.843",
        transform: "translate(4.881 8.982) rotate(180)",
        fill: "#9d9d9d"
      }
    })])]), t("svg", {
      class: i.$style.minus_item_hover,
      attrs: {
        xmlns: "http://www.w3.org/2000/svg",
        width: "9.843",
        height: "9.843",
        viewBox: "0 0 9.843 9.843"
      }
    }, [t("g", {
      attrs: {
        id: "Group_8883",
        "data-name": "Group 8883",
        transform: "translate(0.861 0.862)"
      }
    }, [t("rect", {
      attrs: {
        id: "Rectangle_10",
        "data-name": "Rectangle 10",
        width: "1.641",
        height: "9.843",
        transform: "translate(8.982 3.24) rotate(90)",
        fill: "#3491ff"
      }
    }), t("rect", {
      attrs: {
        id: "Rectangle_11",
        "data-name": "Rectangle 11",
        width: "1.641",
        height: "9.843",
        transform: "translate(4.881 8.982) rotate(180)",
        fill: "#3491ff"
      }
    })])])])]);
  }), 0);
}, GT = [];
const ZT = "_selected_item_xjqhp_17", KT = "_drag_icon_xjqhp_34", QT = "_assignedListItem_xjqhp_38", JT = "_availableListItem_xjqhp_54", qT = "_minus_item_xjqhp_73", ek = "_minus_item_default_xjqhp_90", tk = "_minus_item_hover_xjqhp_93", ik = "_primary_active_switch_xjqhp_1", sk = {
  selected_item: ZT,
  drag_icon: KT,
  assignedListItem: QT,
  availableListItem: JT,
  minus_item: qT,
  minus_item_default: ek,
  minus_item_hover: tk,
  primary_active_switch: ik
}, Al = {};
Al.$style = sk;
var rk = /* @__PURE__ */ te(
  WT,
  UT,
  GT,
  !1,
  nk,
  null,
  null,
  null
);
function nk(i) {
  for (let e in Al)
    this[e] = Al[e];
}
const pA = /* @__PURE__ */ function() {
  return rk.exports;
}(), ak = {
  props: {
    list: Array,
    removeListItem: Function,
    // responsible for remove item
    addListItem: Function
    // responsible for add item
  }
}, ok = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjUiIGhlaWdodD0iMjUiIHZpZXdCb3g9IjAgMCAyNSAyNSIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4NCiAgICA8cmVjdCB3aWR0aD0iMjUiIGhlaWdodD0iMjUiIHJ4PSIzIiBmaWxsPSIjRDlEOUQ5Ii8+DQogICAgPHBhdGggZD0iTTE3LjU1NiA3LjcwOEgxNC45TDE0LjY5NCA3LjI5NEMxNC42NDk5IDcuMjA1NTUgMTQuNTgyIDcuMTMxMTcgMTQuNDk3OSA3LjA3OTIzQzE0LjQxMzggNy4wMjcyOSAxNC4zMTY4IDYuOTk5ODUgMTQuMjE4IDdIMTEuNjlDMTEuNTkxNSA2Ljk5OTcxIDExLjQ5NDkgNy4wMjcxMyAxMS40MTEzIDcuMDc5MTFDMTEuMzI3NyA3LjEzMTEgMTEuMjYwMyA3LjIwNTU3IDExLjIxNyA3LjI5NEwxMS4wMDggNy43MDhIOC4zNTRDOC4yNjAxMSA3LjcwOCA4LjE3MDA3IDcuNzQ1MyA4LjEwMzY4IDcuODExNjlDOC4wMzczIDcuODc4MDcgOCA3Ljk2ODEyIDggOC4wNjJWOC43N0M4IDguODYzODkgOC4wMzczIDguOTUzOTMgOC4xMDM2OCA5LjAyMDMyQzguMTcwMDcgOS4wODY3MSA4LjI2MDExIDkuMTI0IDguMzU0IDkuMTI0SDE3LjU1NEMxNy42MDA3IDkuMTI0MjcgMTcuNjQ2OSA5LjExNTMgMTcuNjkwMSA5LjA5NzYzQzE3LjczMzMgOS4wNzk5NiAxNy43NzI1IDkuMDUzOTMgMTcuODA1NiA5LjAyMTAzQzE3LjgzODcgOC45ODgxMyAxNy44NjQ5IDguOTQ5MDIgMTcuODgyOSA4LjkwNTk0QzE3LjkwMDggOC44NjI4NiAxNy45MSA4LjgxNjY2IDE3LjkxIDguNzdWOC4wNjJDMTcuOTEgOC4wMTU1MSAxNy45MDA4IDcuOTY5NDggMTcuODgzMSA3LjkyNjUzQzE3Ljg2NTMgNy44ODM1OCAxNy44MzkyIDcuODQ0NTYgMTcuODA2MyA3LjgxMTY5QzE3Ljc3MzQgNy43Nzg4MSAxNy43MzQ0IDcuNzUyNzQgMTcuNjkxNSA3LjczNDk1QzE3LjY0ODUgNy43MTcxNiAxNy42MDI1IDcuNzA4IDE3LjU1NiA3LjcwOFY3LjcwOFpNOS4xNzcgMTcuMzNDOS4xOTI4MSAxNy42MDA0IDkuMzExMzggMTcuODU0NiA5LjUwODQyIDE4LjA0MDVDOS43MDU0NyAxOC4yMjY0IDkuOTY2MTEgMTguMzMgMTAuMjM3IDE4LjMzSDE1LjY3NEMxNS45NDQ5IDE4LjMzIDE2LjIwNTUgMTguMjI2NCAxNi40MDI2IDE4LjA0MDVDMTYuNTk5NiAxNy44NTQ2IDE2LjcxODIgMTcuNjAwNCAxNi43MzQgMTcuMzNMMTcuMjAzIDkuODNIOC43MDhMOS4xNzcgMTcuMzNaIiBmaWxsPSIjNTk1OTU5Ii8+DQo8L3N2Zz4NCg==";
var lk = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    class: i.$style.main
  }, [i._l(i.list, function(s, r) {
    return t("div", {
      key: `detailInput-${r}`,
      class: i.$style["form-inline"]
    }, [t("input", {
      directives: [{
        name: "model",
        rawName: "v-model",
        value: s.description,
        expression: "input.description"
      }],
      class: i.$style["custom-input"],
      attrs: {
        type: "text",
        id: `item-${r}`
      },
      domProps: {
        value: s.description
      },
      on: {
        input: function(n) {
          n.target.composing || i.$set(s, "description", n.target.value);
        }
      }
    }), i.list.length > 1 ? t("span", {
      class: i.$style["remove-item"],
      on: {
        click: function(n) {
          return i.removeListItem(r, i.list);
        }
      }
    }, [t("img", {
      class: i.$style["trash-custom-icon"],
      attrs: {
        src: ok,
        alt: "closeIcon"
      }
    })]) : i._e()]);
  }), t("div", {
    class: i.$style["add-items"]
  }, [t("span", {
    class: i.$style["add-more-item"],
    staticStyle: {
      cursor: "pointer"
    },
    on: {
      click: function(s) {
        return i.addListItem(i.list);
      }
    }
  }, [i._v(" + Add more ")])])], 2);
}, uk = [];
const hk = "_main_9uoce_1", ck = {
  main: hk,
  "form-inline": "_form-inline_9uoce_4",
  "remove-item": "_remove-item_9uoce_13",
  "trash-custom-icon": "_trash-custom-icon_9uoce_16",
  "custom-input": "_custom-input_9uoce_28",
  "add-items": "_add-items_9uoce_56",
  "add-more-item": "_add-more-item_9uoce_56"
}, Ll = {};
Ll.$style = ck;
var dk = /* @__PURE__ */ te(
  ak,
  lk,
  uk,
  !1,
  fk,
  "0a0cdad6",
  null,
  null
);
function fk(i) {
  for (let e in Ll)
    this[e] = Ll[e];
}
const gA = /* @__PURE__ */ function() {
  return dk.exports;
}(), pk = {
  props: {
    styleProps: {
      type: String,
      default: ""
    },
    modalType: {
      type: String
    },
    headingText: {
      type: String,
      default: "Header"
    },
    subHeadingText: {
      type: String
    },
    modalHandler: Function,
    isOpened: Boolean
  },
  data() {
    return {
      hide: !this.isOpened
    };
  },
  methods: {
    handleModal() {
      var i;
      this.hide = !this.hide, (i = this.modalHandler) == null || i.call(this);
    }
  },
  mounted() {
    document.body.style.cssText = "height: 100vh; overflow: hidden;";
  },
  unmounted() {
    document.body.style.cssText = "";
  },
  computed: {
    modalPositionComputed() {
      return this.modalType === "slide-in" ? "right" : "center";
    },
    modalSubHeaderComputed() {
      return this.subHeadingText ?? "";
    },
    modalClassComputed() {
      return `modal-default ${this.modalSubHeaderComputed} ${this.modalType ?? ""} `;
    },
    modalTransitionComputed() {
      return this.modalType === "slide-in" ? "slide-fade" : "fade";
    }
  }
}, gk = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTQiIGhlaWdodD0iMTQiIHZpZXdCb3g9IjAgMCAxNCAxNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4NCiAgICA8cGF0aCBkPSJNMTQgMS40MUwxMi41OSAwTDcgNS41OUwxLjQxIDBMMCAxLjQxTDUuNTkgN0wwIDEyLjU5TDEuNDEgMTRMNyA4LjQxTDEyLjU5IDE0TDE0IDEyLjU5TDguNDEgN0wxNCAxLjQxWiIgZmlsbD0iIzRCNEI0QiIvPg0KICAgIDwvc3ZnPg0KICAgIA==";
var mk = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("transition", {
    attrs: {
      name: "bg"
    }
  }, [i.isOpened ? t("div", {
    staticClass: "emdn-modal-wrapper"
  }, [t("div", {
    staticClass: "modal-background",
    class: i.modalPositionComputed,
    on: {
      click: i.handleModal
    }
  }, [t("transition", {
    attrs: {
      name: i.modalTransitionComputed
    }
  }, [i.isOpened ? t("div", {
    class: i.modalClassComputed,
    style: i.styleProps,
    on: {
      click: function(s) {
        s.stopPropagation();
      }
    }
  }, [t("section", [t("div", {
    staticClass: "modal-header-line"
  }), t("div", {
    staticClass: "modal-header-contents"
  }, [t("div", {
    staticClass: "modal-header-contents-left"
  }, [t("h1", [i._v(i._s(i.headingText))]), i._t("switch-tab")], 2), t("button", {
    attrs: {
      type: "button"
    },
    on: {
      click: i.handleModal
    }
  }, [t("img", {
    attrs: {
      src: gk
    }
  })])]), i.subHeadingText ? t("div", {
    staticClass: "modal-sub-header"
  }, [t("h2", [i._v(i._s(i.subHeadingText))])]) : i._e()]), t("section", {
    staticClass: "modal-body-area"
  }, [t("div", [i._t("body")], 2)]), t("section", {
    staticClass: "modal-footer-area"
  }, [i._t("footer")], 2)]) : i._e()])], 1)]) : i._e()]);
}, _k = [];
const Lh = {};
var bk = /* @__PURE__ */ te(
  pk,
  mk,
  _k,
  !1,
  yk,
  "e2361e66",
  null,
  null
);
function yk(i) {
  for (let e in Lh)
    this[e] = Lh[e];
}
const mA = /* @__PURE__ */ function() {
  return bk.exports;
}(), vk = {
  props: {
    head: String,
    body: String,
    range: Number,
    step: Number,
    multipleSteps: Boolean,
    clickHandler: Function,
    handleClose: Function,
    styleProp: Object,
    active: Boolean
  },
  components: {
    CtaButton: $a
  },
  methods: {
    applyHandlerMethod() {
      this.$nextTick(() => {
        this.clickHandler && this.clickHandler();
      }), this.step == this.range && this.close();
    },
    close() {
      this.handleClose();
    }
  }
}, jh = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTQiIGhlaWdodD0iMTQiIHZpZXdCb3g9IjAgMCAxNCAxNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4NCiAgICA8cGF0aCBkPSJNMTQgMS40MUwxMi41OSAwTDcgNS41OUwxLjQxIDBMMCAxLjQxTDUuNTkgN0wwIDEyLjU5TDEuNDEgMTRMNyA4LjQxTDEyLjU5IDE0TDE0IDEyLjU5TDguNDEgN0wxNCAxLjQxWiIgZmlsbD0iI0YwRjFGMyIvPg0KPC9zdmc+DQo=";
var xk = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return i.active ? t("div", {
    class: i.$style.tooltipMain
  }, [t("div", {
    class: i.$style.tooltip
  }, [i.multipleSteps ? t("span", {
    class: [i.step <= 1 ? i.$style.stepOne : "", i.step == 2 ? i.$style.stepTwo : "", i.step == 3 ? i.$style.stepThree : "", i.step == 4 ? i.$style.stepFour : "", i.step > 4 ? i.$style.stepOne : ""],
    style: i.styleProp
  }, [t("div", {
    class: i.$style.main
  }, [t("div", {
    class: i.$style.customTitle
  }, [t("div", {
    class: i.$style.head
  }, [i._v(i._s(i.head))]), t("div", {
    class: i.$style.crossImage,
    on: {
      click: i.close
    }
  }, [t("img", {
    attrs: {
      src: jh,
      alt: "icon"
    }
  })])]), t("div", {
    class: i.$style.body
  }, [i._t("body")], 2), i.range >= 2 && i.range >= i.step && i.step >= 1 ? t("div", {
    staticStyle: {
      display: "flex"
    }
  }, [t("div", {
    class: i.$style.step
  }, [i._v("Step " + i._s(i.step) + " of " + i._s(i.range))]), t("div", {
    class: i.$style.button
  }, [t("CtaButton", {
    staticClass: "btn-custom btn-custom-primary animationPrimary",
    staticStyle: {
      background: "#ffffff"
    },
    attrs: {
      type: "link",
      "color-type": "blue",
      "click-handler": i.applyHandlerMethod
    }
  }, [i.step != i.range ? t("span", [i._v("Next")]) : t("span", [i._v("Done")])])], 1)]) : i._e()])]) : i._e(), i.multipleSteps == !1 ? t("span", {
    class: i.$style.stepOne,
    style: i.styleProp
  }, [t("div", {
    class: i.$style.main
  }, [t("div", {
    class: i.$style.customTitle
  }, [t("div", {
    class: i.$style.head
  }, [i._v(i._s(i.head))]), t("div", {
    class: i.$style.crossImage,
    on: {
      click: i.close
    }
  }, [t("img", {
    attrs: {
      src: jh
    }
  })])]), t("div", {
    class: i.$style.body
  }, [i._t("body")], 2)])]) : i._e()])]) : i._e();
}, wk = [];
const Sk = "_tooltipMain_qr8l8_1", Dk = "_tooltip_qr8l8_1", Pk = "_main_qr8l8_18", Tk = "_customTitle_qr8l8_21", kk = "_head_qr8l8_24", Ck = "_crossImage_qr8l8_31", Mk = "_body_qr8l8_36", Ok = "_step_qr8l8_44", Ak = "_button_qr8l8_50", Lk = "_stepOne_qr8l8_55", jk = "_stepTwo_qr8l8_65", Ek = "_stepThree_qr8l8_87", Ik = "_stepFour_qr8l8_106", Rk = {
  tooltipMain: Sk,
  tooltip: Dk,
  main: Pk,
  customTitle: Tk,
  head: kk,
  crossImage: Ck,
  body: Mk,
  step: Ok,
  button: Ak,
  stepOne: Lk,
  stepTwo: jk,
  stepThree: Ek,
  stepFour: Ik
}, jl = {};
jl.$style = Rk;
var Yk = /* @__PURE__ */ te(
  vk,
  xk,
  wk,
  !1,
  Nk,
  "1fe46990",
  null,
  null
);
function Nk(i) {
  for (let e in jl)
    this[e] = jl[e];
}
const _A = /* @__PURE__ */ function() {
  return Yk.exports;
}(), $k = {
  props: {
    src: {
      type: String,
      default: ""
    },
    styleData: {
      type: String,
      default: ""
    },
    preview: Boolean
  },
  methods: {
    chooseImage() {
      this.$refs.fileInput.click();
    },
    onSelectFile() {
      const e = this.$refs.fileInput.files;
      if (e && e[0]) {
        const t = new FileReader();
        t.onload = (s) => {
          this.src = s.target.result;
        }, t.readAsDataURL(e[0]), this.$emit("input", e[0]);
      }
    }
  }
}, Fk = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTQ2IiBoZWlnaHQ9IjExMiIgdmlld0JveD0iMCAwIDE0NiAxMTIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+DQo8cmVjdCB3aWR0aD0iMTQ2IiBoZWlnaHQ9IjExMiIgcng9IjEwIiBmaWxsPSIjQzRDNEM0Ii8+DQo8cGF0aCBkPSJNMTM2IDlIOVY3NS41TDQyLjM3OTggMzUuMzU5N0M0NS41NjgyIDMxLjUyNTUgNTEuNDQ5MiAzMS41MTEgNTQuNjU2NiAzNS4zMjkyTDkwLjUgNzhMMTA3LjU5NyA2MC4xNDMyQzExMC42MDEgNTcuMDA1MSAxMTUuNTYxIDU2LjgzODUgMTE4Ljc3IDU5Ljc2NzlMMTM2IDc1LjVWOVoiIGZpbGw9IiNGMEYxRjMiLz4NCjxjaXJjbGUgY3g9IjExMCIgY3k9IjMxIiByPSIxMyIgZmlsbD0iI0M0QzRDNCIvPg0KPC9zdmc+DQo=";
var Bk = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    style: i.styleData
  }, [t("div", {
    class: i.preview ? i.$style.main_image : i.$style.slider_image,
    style: {
      "background-image": `url(${i.src})`
    },
    attrs: {
      tabindex: "0"
    }
  }, [i.src ? i._e() : t("span", {
    class: i.$style.placeholder
  }, [t("div", {
    class: i.$style.imagesSpacing
  }, [t("img", {
    attrs: {
      src: Fk,
      alt: ""
    }
  })])])])]);
}, Hk = [];
const zk = "_main_image_1tnor_1", Xk = "_slider_image_1tnor_11", Vk = "_placeholder_1tnor_28", Wk = "_imagesSpacing_1tnor_39", Uk = {
  main_image: zk,
  slider_image: Xk,
  placeholder: Vk,
  imagesSpacing: Wk
}, El = {};
El.$style = Uk;
var Gk = /* @__PURE__ */ te(
  $k,
  Bk,
  Hk,
  !1,
  Zk,
  null,
  null,
  null
);
function Zk(i) {
  for (let e in El)
    this[e] = El[e];
}
const ff = /* @__PURE__ */ function() {
  return Gk.exports;
}(), Kk = {
  components: {
    ImageViewer: ff
  },
  props: {
    slides: Array,
    SelectedImage: Function,
    preview: Boolean,
    numberOfSlides: Number
  },
  data() {
    return {
      current: 0,
      direction: 1,
      transitionName: "fade",
      show: !1,
      chunkSize: this.numberOfSlides,
      data: this.slides
    };
  },
  methods: {
    slide(i) {
      this.direction = i, i === 1 ? this.transitionName = "slide_next" : this.transitionName = "slide_prev";
      var e = this.data.length;
      this.current = (this.current + i % e + e) % e;
    },
    handleChunk() {
      var i = [];
      for (let e = 0; e < this.data.length; e += this.chunkSize) {
        const t = this.data.slice(e, e + this.chunkSize);
        i = [...i, t];
      }
      this.data = i;
    }
  },
  watch: {
    slides(i) {
      var e = [];
      for (let t = 0; t < i.length; t += this.chunkSize) {
        const s = i.slice(t, t + this.chunkSize);
        e = [...e, s];
      }
      this.data = e;
    }
  },
  beforeMount() {
    this.handleChunk();
  },
  mounted() {
    this.show = !0;
  }
};
var Qk = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", [t("div", {
    attrs: {
      id: i.$style.slider
    }
  }, [t("transition-group", {
    class: i.$style.slides_group,
    attrs: {
      tag: "div",
      name: i.transitionName,
      "enter-class": i.$style[`${i.transitionName}_enter`],
      "enter-active-class": i.$style[`${i.transitionName}_enter_active`],
      "leave-active-class": i.$style[`${i.transitionName}_leave_active`],
      "leave-to-class": i.$style[`${i.transitionName}_leave_to`]
    }
  }, [i.show ? t("div", {
    key: i.current,
    class: i.$style.slide
  }, i._l(i.data[i.current], function(s, r) {
    return t("div", {
      key: r,
      class: i.$style.slider_body,
      attrs: {
        id: "slide1"
      }
    }, [t("div", {
      on: {
        click: function() {
          return i.SelectedImage(s);
        }
      }
    }, [t("ImageViewer", {
      class: i.$style.slider_content,
      attrs: {
        preview: i.preview,
        src: s
      }
    })], 1)]);
  }), 0) : i._e()]), t("div", {
    class: [i.$style.btn, i.$style.btn_prev],
    attrs: {
      "aria-label": "Previous slide"
    },
    on: {
      click: function(s) {
        return i.slide(-1);
      }
    }
  }, [t("div", {
    class: i.$style.button_left
  })]), t("div", {
    class: [i.$style.btn, i.$style.btn_next],
    attrs: {
      "aria-label": "Next slide"
    },
    on: {
      click: function(s) {
        return i.slide(1);
      }
    }
  }, [t("div", {
    class: i.$style.button_right
  })])], 1)]);
}, Jk = [];
const qk = "_slider_4xxlz_53", eC = "_slides_group_4xxlz_11", tC = "_fade_enter_active_4xxlz_18", iC = "_fade_enter_4xxlz_18", sC = "_slide_next_enter_active_4xxlz_24", rC = "_slide_next_leave_active_4xxlz_25", nC = "_slide_next_enter_4xxlz_24", aC = "_slide_next_leave_to_4xxlz_31", oC = "_slide_prev_enter_active_4xxlz_34", lC = "_slide_prev_leave_active_4xxlz_35", uC = "_slide_prev_enter_4xxlz_34", hC = "_slide_prev_leave_to_4xxlz_41", cC = "_slide_4xxlz_11", dC = "_slider_body_4xxlz_53", fC = "_slider_content_4xxlz_61", pC = "_btn_4xxlz_71", gC = "_btn_next_4xxlz_87", mC = "_button_right_4xxlz_91", _C = "_button_left_4xxlz_96", bC = {
  slider: qk,
  slides_group: eC,
  fade_enter_active: tC,
  fade_enter: iC,
  slide_next_enter_active: sC,
  slide_next_leave_active: rC,
  slide_next_enter: nC,
  slide_next_leave_to: aC,
  slide_prev_enter_active: oC,
  slide_prev_leave_active: lC,
  slide_prev_enter: uC,
  slide_prev_leave_to: hC,
  slide: cC,
  slider_body: dC,
  slider_content: fC,
  btn: pC,
  btn_next: gC,
  button_right: mC,
  button_left: _C
}, Il = {};
Il.$style = bC;
var yC = /* @__PURE__ */ te(
  Kk,
  Qk,
  Jk,
  !1,
  vC,
  null,
  null,
  null
);
function vC(i) {
  for (let e in Il)
    this[e] = Il[e];
}
const xC = /* @__PURE__ */ function() {
  return yC.exports;
}(), wC = {
  components: {
    ImageViewer: ff,
    Slider: xC
  },
  props: {
    src: {
      type: String,
      default: ""
    },
    allSlides: {
      type: Array
    },
    showImageViewer: {
      type: Boolean
    },
    showSlider: {
      type: Boolean
    },
    numberOfSlides: {
      type: Number,
      default: 4
    },
    styleProps: {
      type: String,
      default: "width: 331px; height: 230px"
    }
  },
  computed: {},
  data() {
    return {
      selectedImage: ""
    };
  },
  methods: {
    handleImage(i) {
      this.selectedImage = i;
    }
  }
};
var SC = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", [i.showImageViewer ? t("ImageViewer", {
    attrs: {
      preview: !0,
      styleData: i.styleProps,
      src: i.src ? i.src : i.selectedImage
    }
  }) : i._e(), i.showSlider ? t("Slider", {
    style: {
      width: i.showImageViewer ? "" : "331px"
    },
    attrs: {
      numberOfSlides: i.numberOfSlides,
      preview: !1,
      slides: i.allSlides,
      "selected-image": i.handleImage
    }
  }) : i._e()], 1);
}, DC = [];
const Eh = {};
var PC = /* @__PURE__ */ te(
  wC,
  SC,
  DC,
  !1,
  TC,
  null,
  null,
  null
);
function TC(i) {
  for (let e in Eh)
    this[e] = Eh[e];
}
const bA = /* @__PURE__ */ function() {
  return PC.exports;
}(), kC = {
  props: {
    snackBarTitle: String,
    snackBarMessage: String
  },
  data() {
    return {
      active: !1
    };
  },
  mounted() {
    this.active = !0, setTimeout(() => {
      this.active = !1;
    }, 6e3);
  },
  watch: {
    active(i) {
      i && window.addEventListener("click", this.onClose);
    }
  },
  methods: {
    onClose() {
      this.active = !1;
    }
  }
}, CC = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI4IiBoZWlnaHQ9IjgiIHZpZXdCb3g9IjAgMCA4IDgiPg0KICA8cGF0aCBpZD0iUGF0aF8xOTU1IiBkYXRhLW5hbWU9IlBhdGggMTk1NSIgZD0iTTQuNzA4LDQsNy44NTMuODU1QS41LjUsMCwwLDAsNy4xNDYuMTQ4TDQsMy4yOTMuODU0LjE0OEEuNS41LDAsMCwwLC4xNDcuODU1TDMuMjkzLDQsLjE0Nyw3LjE0N2EuNS41LDAsMSwwLC43MDcuNzA3TDQsNC43MDgsNy4xNDYsNy44NTRhLjUuNSwwLDEsMCwuNzA3LS43MDdaIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwIC0wLjAwMSkiLz4NCjwvc3ZnPg0K";
var MC = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return i.active ? t("div", {
    class: i.$style.dialogbox
  }, [t("div", {
    class: i.$style.heading
  }, [i._v(i._s(i.snackBarTitle))]), t("p", [i._v(i._s(i.snackBarMessage))]), t("div", {
    class: i.$style.close,
    on: {
      click: i.onClose
    }
  }, [t("img", {
    attrs: {
      width: "11px",
      height: "11px",
      src: CC,
      alt: "cross icon"
    }
  })])]) : i._e();
}, OC = [];
const AC = "_customClose_1oeoq_41", LC = "_fadein_1oeoq_1", jC = "_fadeout_1oeoq_1", EC = "_dialogbox_1oeoq_46", IC = "_close_1oeoq_60", RC = "_heading_1oeoq_65", YC = {
  customClose: AC,
  fadein: LC,
  fadeout: jC,
  dialogbox: EC,
  close: IC,
  heading: RC
}, Rl = {};
Rl.$style = YC;
var NC = /* @__PURE__ */ te(
  kC,
  MC,
  OC,
  !1,
  $C,
  "a68fe790",
  null,
  null
);
function $C(i) {
  for (let e in Rl)
    this[e] = Rl[e];
}
const yA = /* @__PURE__ */ function() {
  return NC.exports;
}(), FC = "_parent_xglzj_7", BC = "_center_xglzj_27", HC = "_horizontal_secondary_last_tab_xglzj_60", zC = "_horizontal_secondary_first_tab_xglzj_63", rs = {
  default: "_default_xglzj_7",
  parent: FC,
  "vertical-style-secondary-tab": "_vertical-style-secondary-tab_xglzj_7",
  "horizontal-style-secondary-tab": "_horizontal-style-secondary-tab_xglzj_7",
  center: BC,
  "secondary-tab": "_secondary-tab_xglzj_33",
  "blue-border-show": "_blue-border-show_xglzj_1",
  horizontal_secondary_last_tab: HC,
  horizontal_secondary_first_tab: zC,
  "default-vertical": "_default-vertical_xglzj_67",
  "horizontal-style-primary-tab": "_horizontal-style-primary-tab_xglzj_67",
  "vertical-style-primary-tab": "_vertical-style-primary-tab_xglzj_67",
  "primary-tab": "_primary-tab_xglzj_93"
}, XC = {
  name: "tab-ui",
  props: {
    tabButtons: {
      type: Array,
      default: []
    },
    clickHandler: Function,
    tabType: {
      type: String,
      default: "primary-tab"
    },
    tabStyle: {
      type: String,
      default: "horizontal"
    }
  },
  computed: {
    buttonClassStyle() {
      return `${rs.default} ${rs[this.tabStyle]} ${rs[this.tabType]} ${rs.center}`;
    },
    buttonComputedTabStyle() {
      return `${rs[this.computedTabStyle]}`;
    },
    computedTabStyle() {
      return `${this.tabStyle}-style-${this.tabType}`;
    }
  },
  methods: {
    onClick(i) {
      this.tabButtons.forEach((e) => {
        e.title === i.title ? e.active = !0 : e.active = !1;
      }), this.clickHandler && this.clickHandler(i), this.$emit("tab-buttons-emit", this.tabButtons), this.$forceUpdate();
    },
    getTabStyle({ index: i, isLast: e = !1 }) {
      return this.tabStyle === "vertical" || this.tabType === "primary-tab" ? "" : i === 0 ? rs.horizontal_secondary_first_tab : e ? rs.horizontal_secondary_last_tab : "";
    }
  }
};
var VC = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    class: i.$style.parent
  }, [t("div", {
    class: i.buttonComputedTabStyle
  }, i._l(i.tabButtons, function(s, r) {
    return t("div", {
      key: r,
      class: [i.buttonClassStyle, i.getTabStyle({
        index: r,
        isLast: r === i.tabButtons.length - 1
      })],
      attrs: {
        active: s.active
      },
      on: {
        click: function() {
          return i.onClick(s);
        }
      }
    }, [i._v(" " + i._s(s.title) + " ")]);
  }), 0)]);
}, WC = [];
const UC = "_parent_xglzj_7", GC = "_center_xglzj_27", ZC = "_horizontal_secondary_last_tab_xglzj_60", KC = "_horizontal_secondary_first_tab_xglzj_63", QC = {
  default: "_default_xglzj_7",
  parent: UC,
  "vertical-style-secondary-tab": "_vertical-style-secondary-tab_xglzj_7",
  "horizontal-style-secondary-tab": "_horizontal-style-secondary-tab_xglzj_7",
  center: GC,
  "secondary-tab": "_secondary-tab_xglzj_33",
  "blue-border-show": "_blue-border-show_xglzj_1",
  horizontal_secondary_last_tab: ZC,
  horizontal_secondary_first_tab: KC,
  "default-vertical": "_default-vertical_xglzj_67",
  "horizontal-style-primary-tab": "_horizontal-style-primary-tab_xglzj_67",
  "vertical-style-primary-tab": "_vertical-style-primary-tab_xglzj_67",
  "primary-tab": "_primary-tab_xglzj_93"
}, Yl = {};
Yl.$style = QC;
var JC = /* @__PURE__ */ te(
  XC,
  VC,
  WC,
  !1,
  qC,
  "4941a060",
  null,
  null
);
function qC(i) {
  for (let e in Yl)
    this[e] = Yl[e];
}
const vA = /* @__PURE__ */ function() {
  return JC.exports;
}(), eM = {
  name: "tab-module",
  props: {
    tabButtons: Array,
    styleProps: {
      type: String,
      default: ""
    },
    clickHandler: Function,
    tabStyle: {
      type: String,
      default: ""
    },
    tabType: String
  },
  computed: {
    buttonClassComputed() {
      return `${this.$style[this.tabType]}`;
    },
    computedClassTabStyle() {
      return `${this.$style[this.computedTabStyle]}`;
    },
    computedTabStyle() {
      return `${this.tabStyle}-style-icon-tab`;
    }
  },
  data() {
    return {
      hover: !1
    };
  },
  methods: {
    executor(i) {
      this.tabButtons.forEach((e) => {
        e.active = !1;
      }), i.active = !0, this.clickHandler && this.clickHandler(i), this.$forceUpdate();
    }
  }
};
var tM = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", [t("div", {
    class: i.computedClassTabStyle,
    staticStyle: {
      "flex-wrap": "wrap",
      width: "100%"
    }
  }, i._l(i.tabButtons, function(s, r) {
    return t("div", {
      key: r,
      class: i.buttonClassComputed,
      attrs: {
        active: s.active,
        id: s.title
      },
      on: {
        mouseover: function(n) {
          i.hover = !0;
        },
        mouseleave: function(n) {
          i.hover = !1;
        }
      }
    }, [t("div", {
      class: i.$style.custom_style,
      on: {
        click: function(n) {
          return i.executor(s);
        }
      }
    }, [t("div", {
      class: [s.active || i.hover === !0 ? i.$style.img_zone_hover_background : "", i.$style.img_zone],
      attrs: {
        active: s.active
      }
    }, [t("img", {
      class: [s.active ? i.$style.hover_icon : ""],
      attrs: {
        src: s.icon,
        alt: ""
      }
    })]), t("div", {
      class: i.$style.chart_title
    }, [i._v(" " + i._s(s.title) + " ")])])]);
  }), 0)]);
}, iM = [];
const sM = "_img_zone_ttnic_27", rM = "_img_zone_hover_background_ttnic_45", nM = "_chart_title_ttnic_53", aM = "_custom_style_ttnic_87", oM = "_hover_icon_ttnic_138", lM = {
  "primary-tab": "_primary-tab_ttnic_8",
  "horizontal-style-icon-tab": "_horizontal-style-icon-tab_ttnic_8",
  "vertical-style-icon-tab": "_vertical-style-icon-tab_ttnic_8",
  img_zone: sM,
  img_zone_hover_background: rM,
  "hover-icon": "_hover-icon_ttnic_48",
  chart_title: nM,
  custom_style: aM,
  "secondary-tab": "_secondary-tab_ttnic_94",
  hover_icon: oM
}, Nl = {};
Nl.$style = lM;
var uM = /* @__PURE__ */ te(
  eM,
  tM,
  iM,
  !1,
  hM,
  "0cddebd6",
  null,
  null
);
function hM(i) {
  for (let e in Nl)
    this[e] = Nl[e];
}
const xA = /* @__PURE__ */ function() {
  return uM.exports;
}(), cM = {
  name: "tab-number",
  props: {
    tabButtons: Array,
    styleProps: {
      type: String,
      default: ""
    },
    clickHandler: Function,
    tabStyle: {
      type: String,
      default: ""
    },
    // '', 'small'
    size: {
      type: String,
      default: ""
    }
  },
  computed: {
    TabNumberClassComputed() {
      return `${this.$style[this.computedTabStyle]}`;
    },
    computedTabStyle() {
      return `${this.tabStyle}-style-icon-tab`;
    }
  },
  data() {
    return {
      hover: !1
    };
  },
  methods: {
    executor(i) {
      this.tabButtons.forEach((e) => {
        e.active = !1;
      }), i.active = !0, this.clickHandler && this.clickHandler(i), this.$forceUpdate();
    }
  }
};
var dM = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", [t("div", {
    class: i.TabNumberClassComputed,
    staticStyle: {
      "flex-wrap": "wrap",
      width: "100%"
    }
  }, i._l(i.tabButtons, function(s, r) {
    return t("div", {
      key: r,
      class: [i.size === "small" ? i.$style.small : "", i.$style.chart_wrapper],
      attrs: {
        active: s.active,
        id: s.title
      },
      on: {
        mouseover: function(n) {
          i.hover = !0;
        },
        mouseleave: function(n) {
          i.hover = !1;
        }
      }
    }, [t("div", {
      on: {
        click: function(n) {
          return i.executor(s);
        }
      }
    }, [t("div", {
      class: [s.active || i.hover === !0 ? i.$style.img_zone_hover_background : "", i.$style.img_zone],
      attrs: {
        active: s.active
      }
    }, [t("img", {
      class: [s.active ? i.$style.hover_icon : ""],
      attrs: {
        src: s.icon,
        alt: ""
      }
    })]), t("div", {
      class: i.$style.chart_title
    }, [t("b", [i._v(i._s(s.itemRate) + "%")]), t("span", [i._v(i._s(s.title))])])])]);
  }), 0)]);
}, fM = [];
const pM = "_chart_wrapper_16wo6_7", gM = "_img_zone_16wo6_26", mM = "_active_16wo6_38", _M = "_hover_icon_16wo6_41", bM = "_img_zone_hover_background_16wo6_45", yM = "_small_16wo6_51", vM = "_chart_title_16wo6_62", xM = {
  chart_wrapper: pM,
  "horizontal-style-icon-tab": "_horizontal-style-icon-tab_16wo6_7",
  "vertical-style-icon-tab": "_vertical-style-icon-tab_16wo6_7",
  img_zone: gM,
  active: mM,
  hover_icon: _M,
  img_zone_hover_background: bM,
  small: yM,
  chart_title: vM
}, $l = {};
$l.$style = xM;
var wM = /* @__PURE__ */ te(
  cM,
  dM,
  fM,
  !1,
  SM,
  "c2cf3c4e",
  null,
  null
);
function SM(i) {
  for (let e in $l)
    this[e] = $l[e];
}
const wA = /* @__PURE__ */ function() {
  return wM.exports;
}(), DM = {
  name: "tab-overview",
  props: {
    position: {
      type: String,
      default: "top",
      validator(i) {
        return ["top", "bottom"].includes(i);
      }
    },
    labelAlign: {
      type: String,
      default: "top",
      validator(i) {
        return ["top", "bottom"].includes(i);
      }
    },
    isActive: Boolean,
    label: String,
    field: String,
    trend: [String, Number, Object],
    value: {
      type: [String, Number, Object],
      default: ""
    },
    valueFormatter: Function,
    trendFormatter: Function,
    clickHandler: Function
  },
  methods: {
    handleClick() {
      this.clickHandler && this.clickHandler();
    }
  },
  computed: {
    hasTrend() {
      return this.trend !== null;
    },
    isTrendPositive() {
      const i = Ke(this.trend) ? ho(this.trend) : this.trend;
      return this.hasTrend ? Number(i) >= 0 : !1;
    },
    formattedValue() {
      const i = Ke(this == null ? void 0 : this.value) ? ho(this == null ? void 0 : this.value) : this == null ? void 0 : this.value;
      return this.valueFormatter ? this.valueFormatter(i) : "";
    },
    formattedTrend() {
      const i = Ke(this.trend) ? ho(this.trend) : this.trend;
      return this.hasTrend && (this != null && this.trendFormatter) ? i >= 0 ? `+${this.trendFormatter(i)}` : `${this.trendFormatter(i)}` : "";
    }
  }
};
var PM = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    class: [i.$style.tab_overview, i.$style[i.position]],
    attrs: {
      active: i.isActive
    },
    on: {
      click: i.handleClick
    }
  }, [t("div", {
    class: i.$style.tab_lead
  }, [t("div", {
    class: i.$style.lead_label
  }, [i._v(" " + i._s(i.label) + " ")]), i.hasTrend ? t("div", {
    class: [i.$style.lead_trail, i.isTrendPositive ? i.$style.positive : ""]
  }, [i._v(" " + i._s(i.formattedTrend) + " ")]) : i._e()]), t("div", {
    class: i.$style.tab_divider
  }), t("div", {
    class: i.$style.tab_content
  }, [i._v(" " + i._s(i.formattedValue) + " ")])]);
}, TM = [];
const kM = "_tab_overview_divzu_7", CM = "_top_divzu_44", MM = "_tab_lead_divzu_55", OM = "_bottom_divzu_59", AM = "_lead_label_divzu_80", LM = "_lead_trail_divzu_88", jM = "_positive_divzu_96", EM = "_tab_divider_divzu_104", IM = "_tab_content_divzu_108", RM = {
  tab_overview: kM,
  top: CM,
  tab_lead: MM,
  bottom: OM,
  lead_label: AM,
  lead_trail: LM,
  positive: jM,
  tab_divider: EM,
  tab_content: IM
}, Fl = {};
Fl.$style = RM;
var YM = /* @__PURE__ */ te(
  DM,
  PM,
  TM,
  !1,
  NM,
  "496e840b",
  null,
  null
);
function NM(i) {
  for (let e in Fl)
    this[e] = Fl[e];
}
const SA = /* @__PURE__ */ function() {
  return YM.exports;
}(), $M = {
  name: "tab-icon",
  props: {
    tabButtons: Array,
    styleProps: {
      type: String,
      default: ""
    },
    clickHandler: Function,
    tabStyle: {
      type: String,
      default: ""
    },
    // '', 'small'
    size: {
      type: String,
      default: ""
    }
  },
  computed: {
    TabIconClassComputed() {
      return `${this.$style[this.computedTabStyle]}`;
    },
    computedTabStyle() {
      return `${this.tabStyle}-style-icon-tab`;
    }
  },
  data() {
    return {
      hover: !1
    };
  },
  methods: {
    executor(i) {
      this.tabButtons.forEach((e) => {
        e.active = !1;
      }), i.active = !0, this.clickHandler && this.clickHandler(i), this.$forceUpdate();
    }
  }
};
var FM = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", [t("div", {
    class: i.TabIconClassComputed,
    staticStyle: {
      "flex-wrap": "wrap",
      width: "100%"
    }
  }, i._l(i.tabButtons, function(s, r) {
    return t("div", {
      key: r,
      class: [i.size === "small" ? i.$style.small : "", i.$style.chart_wrapper],
      attrs: {
        active: s.active,
        id: s.title
      },
      on: {
        mouseover: function(n) {
          i.hover = !0;
        },
        mouseleave: function(n) {
          i.hover = !1;
        }
      }
    }, [t("div", {
      on: {
        click: function(n) {
          return i.executor(s);
        }
      }
    }, [t("div", {
      class: [s.active || i.hover === !0 ? i.$style.img_zone_hover_background : "", i.$style.img_zone],
      attrs: {
        active: s.active
      }
    }, [t("img", {
      class: [s.active ? i.$style.hover_icon : ""],
      attrs: {
        src: s.icon,
        alt: ""
      }
    })]), t("div", {
      class: i.$style.chart_title
    }, [t("b", [i._v(i._s(s.title))])])])]);
  }), 0)]);
}, BM = [];
const HM = "_chart_wrapper_16wo6_7", zM = "_img_zone_16wo6_26", XM = "_active_16wo6_38", VM = "_hover_icon_16wo6_41", WM = "_img_zone_hover_background_16wo6_45", UM = "_small_16wo6_51", GM = "_chart_title_16wo6_62", ZM = {
  chart_wrapper: HM,
  "horizontal-style-icon-tab": "_horizontal-style-icon-tab_16wo6_7",
  "vertical-style-icon-tab": "_vertical-style-icon-tab_16wo6_7",
  img_zone: zM,
  active: XM,
  hover_icon: VM,
  img_zone_hover_background: WM,
  small: UM,
  chart_title: GM
}, Bl = {};
Bl.$style = ZM;
var KM = /* @__PURE__ */ te(
  $M,
  FM,
  BM,
  !1,
  QM,
  "2c12bbac",
  null,
  null
);
function QM(i) {
  for (let e in Bl)
    this[e] = Bl[e];
}
const DA = /* @__PURE__ */ function() {
  return KM.exports;
}(), JM = {
  name: "time-picker",
  props: {
    changeTime: Function,
    submitTime: Function,
    id: {
      type: String,
      default: () => ""
    },
    minTime: {
      type: String,
      default: () => "0000"
    },
    maxTime: {
      type: String,
      default: () => "0000"
    },
    selectedTime: {
      type: Object,
      default: () => ({
        hour: 0,
        minute: 0,
        isAddDay: !1
      })
    },
    disabled: Boolean,
    enableMinute: {
      type: Boolean,
      default: () => !1
    },
    isRange: {
      type: Boolean,
      default: () => !1
    }
  },
  data() {
    return {
      visible: !1,
      dayStart: ""
    };
  },
  watch: {
    visible(i) {
      i ? window.addEventListener("click", this.handleClickOutside) : window.removeEventListener("click", this.handleClickOutside);
    },
    isRange() {
      this.isRange && (this.EnableMinute = !1);
    },
    disabled() {
      this.disabled && (this.visible = !1);
    }
  },
  computed: {
    getTitle() {
      return `${this.selectedTime.hour > 9 ? this.selectedTime.hour : "0" + parseInt(this.selectedTime.hour)}:${this.selectedTime.minute > 9 ? this.selectedTime.minute : "0" + parseInt(this.selectedTime.minute)}`;
    },
    getTimeRange() {
      let i = {
        hour: this.minTime.substr(0, 2),
        minute: this.minTime.substr(2, 2)
      }, e = {
        hour: this.maxTime.substr(0, 2),
        minute: this.maxTime.substr(2, 2)
      };
      return {
        min: i,
        max: e
      };
    },
    getHourRange() {
      let i = this.getTimeRange;
      return i.min.hour == i.max.hour ? 24 : +i.min.hour < +i.max.hour ? +i.max.hour - +i.min.hour : 24;
    }
  },
  methods: {
    addDay(i, e) {
      let t = this.getTimeRange, s = this.getTimeTitle(i, e), r = parseInt(t.min.hour);
      return s < r;
    },
    handleClickOutside(i) {
      const e = this.$refs.timePicker;
      e === i.target || e != null && e.contains(i.target) || this.closeTimeDropdownStart();
    },
    closeTimeDropdownStart() {
      this.visible && this.submitTime && this.submitTime(), this.visible = !1;
    },
    checkSelectedHour(i) {
      let e = this.getTimeRange;
      return this.selectedTime.isAddDay ? i == +this.selectedTime.hour + 1 - +e.min.hour + 24 : i == +this.selectedTime.hour + 1 - +e.min.hour;
    },
    getTimeTitle(i, e) {
      let t = i, s = this.getTimeRange;
      return e == "hour" && (t = parseInt(s.min.hour) + i, t > 24 && (t -= 24)), `${t - 1 >= 10 ? t - 1 : "0" + (t - 1)}`;
    },
    checkEnableMinute(i) {
      let e = this.getTimeRange;
      return !(this.selectedTime.isAddDay && this.selectedTime.hour == e.max.hour && i > e.max.minute);
    },
    handleChangeTime(i, e) {
      let t = i;
      if (e == "hour") {
        let s = this.getTimeRange;
        t = t + parseInt(s.min.hour), this.selectedTime.hour = t, this.selectedTime.hour >= 24 ? (this.selectedTime.hour -= 24, this.selectedTime.isAddDay = !0) : this.selectedTime.isAddDay = !1;
      } else
        this.getTimeRange, this.selectedTime.minute = t;
      this.changeTime(this.selectedTime, e);
    }
  },
  mounted() {
    this.isRange && (this.EnableMinute = !1);
  }
};
var qM = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    class: i.$style.dropdown_container,
    attrs: {
      id: i.id
    }
  }, [t("a", {
    class: [i.$style.time_dropdown, i.$style.time_dropdown_btn],
    attrs: {
      href: "javascript:void(0)",
      active: i.visible,
      disabled: i.disabled
    },
    on: {
      click: function(s) {
        s.stopPropagation(), i.visible = !0;
      }
    }
  }, [t("span", {
    class: i.$style.span_height
  }, [i._v(i._s(i.getTitle))]), t("span", {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: i.selectedTime.isAddDay,
      expression: "selectedTime.isAddDay"
    }],
    class: i.$style.bonus_time
  }, [i._v(i._s("+1"))])]), t("div", {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: i.visible,
      expression: "visible"
    }],
    class: [i.visible ? i.$style.show : "", i.$style.dropdown_menu],
    staticStyle: {
      left: "auto !important",
      width: "105px",
      transform: "translate(0px, 10px)",
      "overflow-y": "unset"
    }
  }, [t("div", {
    staticStyle: {
      display: "flex"
    }
  }, [t("div", {
    class: i.$style.hour_dropdown_col
  }, [t("ul", {
    class: i.$style.hour_dropdown
  }, i._l(i.getHourRange, function(s) {
    return t("li", {
      key: s,
      class: [i.checkSelectedHour(s) ? i.$style.selected_item : ""]
    }, [t("span", {
      class: i.$style.dropdown_item,
      attrs: {
        onmouseover: "this.style.color='black';",
        onmouseout: "this.style.color='black';"
      },
      on: {
        click: function(r) {
          return i.handleChangeTime(s - 1, "hour");
        }
      }
    }, [i._v(" " + i._s(i.getTimeTitle(s, "hour")) + " "), t("span", {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: i.isRange && i.addDay(s, "hour"),
        expression: "isRange && addDay(index, 'hour')"
      }],
      class: i.$style.day_plus
    }, [i._v(i._s("+1"))])])]);
  }), 0)]), t("div", {
    class: i.$style.hour_dropdown_col
  }, [t("ul", {
    class: i.$style.hour_dropdown
  }, i._l(i.enableMinute ? 60 : 1, function(s) {
    return t("li", {
      key: s,
      class: [s == +i.selectedTime.minute + 1 ? i.$style.selected_item : ""]
    }, [t("span", {
      class: [i.checkEnableMinute(s - 1) ? "" : i.$style.disable_item, i.$style.dropdown_item],
      attrs: {
        onmouseover: "this.style.color='black';",
        onmouseout: "this.style.color='black';"
      },
      on: {
        click: function(r) {
          return i.handleChangeTime(s - 1, "minute");
        }
      }
    }, [i._v(" " + i._s(i.getTimeTitle(s, "minute")) + " ")])]);
  }), 0)])])])]);
}, eO = [];
const tO = "_dropdown_container_4jkp7_1", iO = "_time_dropdown_4jkp7_4", sO = "_span_height_4jkp7_21", rO = "_bonus_time_4jkp7_26", nO = "_time_dropdown_btn_4jkp7_37", aO = "_dropdown_menu_4jkp7_66", oO = "_hour_dropdown_col_4jkp7_82", lO = "_hour_dropdown_4jkp7_82", uO = "_selected_item_4jkp7_104", hO = "_dropdown_item_4jkp7_107", cO = "_day_plus_4jkp7_117", dO = {
  dropdown_container: tO,
  time_dropdown: iO,
  span_height: sO,
  bonus_time: rO,
  time_dropdown_btn: nO,
  dropdown_menu: aO,
  hour_dropdown_col: oO,
  hour_dropdown: lO,
  selected_item: uO,
  dropdown_item: hO,
  day_plus: cO
}, Hl = {};
Hl.$style = dO;
var fO = /* @__PURE__ */ te(
  JM,
  qM,
  eO,
  !1,
  pO,
  "4180949f",
  null,
  null
);
function pO(i) {
  for (let e in Hl)
    this[e] = Hl[e];
}
const PA = /* @__PURE__ */ function() {
  return fO.exports;
}(), gO = {
  name: "toggle-button",
  props: {
    /**
     * @deprecated Use `value` instead.
     */
    toggle: Boolean,
    value: Boolean,
    disabled: Boolean,
    size: {
      type: String,
      default: "default"
    },
    /**
     * @deprecated Use `onChanged` instead.
     */
    clickHandler: Function,
    onChanged: Function
  },
  data() {
    return {
      checked: this.value ?? this.toggle
    };
  },
  watch: {
    toggle(i) {
      this.checked = i;
    },
    value(i) {
      this.checked = i;
    }
  },
  methods: {
    toggleValue() {
      return this.onChanged ? this.onChanged(!this.value) : this.handleToggle();
    },
    /**
     * @deprecated This will be removed in the next major version.
     */
    handleToggle() {
      if (this.clickHandler && !this.disabled)
        return this.clickHandler(), this.checked = !this.checked, this.checked;
    }
  }
};
var mO = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    class: i.$style.d_flex
  }, [t("p", {
    class: [i.checked ? i.$style.btn_off : i.$style.btn_on, i.disabled && i.$style.default_off]
  }, [i._v(" Off ")]), t("div", {
    on: {
      click: i.toggleValue
    }
  }, [t("input", {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: i.checked,
      expression: "checked"
    }],
    attrs: {
      type: "checkbox",
      disabled: i.disabled
    },
    domProps: {
      checked: Array.isArray(i.checked) ? i._i(i.checked, null) > -1 : i.checked
    },
    on: {
      change: function(s) {
        var r = i.checked, n = s.target, a = !!n.checked;
        if (Array.isArray(r)) {
          var o = null, l = i._i(r, o);
          n.checked ? l < 0 && (i.checked = r.concat([o])) : l > -1 && (i.checked = r.slice(0, l).concat(r.slice(l + 1)));
        } else
          i.checked = a;
      }
    }
  }), t("label", {
    class: [i.disabled ? i.$style.disable_label : "", i.size === "default" ? i.$style.default_size_label : i.$style.large_size_label]
  }, [i._v(" Toggle ")])]), t("p", {
    class: [i.checked ? i.$style.btn_on : i.$style.btn_off, i.disabled && i.$style.default_off]
  }, [i._v(" On ")])]);
}, _O = [];
const bO = "_d_flex_19yvh_1", yO = "_btn_off_19yvh_46", vO = "_btn_on_19yvh_52", xO = "_default_off_19yvh_58", wO = "_disable_label_19yvh_61", SO = "_default_size_label_19yvh_69", DO = "_large_size_label_19yvh_81", PO = {
  d_flex: bO,
  btn_off: yO,
  btn_on: vO,
  default_off: xO,
  disable_label: wO,
  default_size_label: SO,
  large_size_label: DO
}, zl = {};
zl.$style = PO;
var TO = /* @__PURE__ */ te(
  gO,
  mO,
  _O,
  !1,
  kO,
  "55dd6a93",
  null,
  null
);
function kO(i) {
  for (let e in zl)
    this[e] = zl[e];
}
const TA = /* @__PURE__ */ function() {
  return TO.exports;
}(), CO = {
  name: "listSearchBar",
  props: {
    searchHandler: Function,
    // returns search string
    titleName: {
      type: String,
      default: "title"
    },
    items: Array,
    // option list (title: name to be displayed in option list, image: option image) (ex: {title: 'option1', [image: imageUrl, ...]})
    // On close dropdown when you click outside
    clickHandler: Function,
    // Click handler (if using list click without using checkbox)
    styleProps: {
      // type: String as PropType<StyleValue>,
      // default: "" as StyleValue,
      type: String,
      default: ""
    },
    // Set whether dropdown-list wrap-style or not (ex: {top: '10px', left: '10px', width: '10px'})
    placeholder: String,
    // Set whether placeholder or not
    id: String
    // Set whether checkbox-id or not
  },
  // alice component
  components: {
    "search-bar": Du
  },
  data() {
    return {};
  },
  methods: {
    search(i) {
      var e;
      (e = this.searchHandler) == null || e.call(this, i);
    },
    truncateText(i, e) {
      return i.length <= e ? i : i.substring(0, e) + "...";
    },
    // Click on option. If there is a click handler, the click handler is executed, and if there is no click handler, the checklist is saved.
    optionClick(i) {
      var e;
      (e = this.items) == null || e.forEach((t) => {
        t.active = !1;
      }), this.$nextTick(() => {
        var t;
        i.active = !0, (t = this.clickHandler) == null || t.call(this, i);
      });
    }
  }
};
var MO = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    class: i.$style.list_wrap,
    style: i.styleProps
  }, [t("search-bar", {
    attrs: {
      "placeholder-text": i.placeholder || "Search",
      "set-search-complete-keyword": i.search,
      "style-props": "width:100%; margin-bottom: 6px;"
    }
  }), i._l(i.items, function(s, r) {
    return t("div", {
      key: r,
      class: i.$style.list_item_style
    }, [t("div", {
      class: i.$style.list_item,
      attrs: {
        active: s.active
      },
      on: {
        click: function(n) {
          return i.optionClick(s);
        }
      }
    }, [t("label", [i._v(i._s(i.truncateText(s.title, 40)))]), s.isLow ? t("div", {
      class: i.$style.triangle
    }, [t("svg", {
      attrs: {
        width: "59",
        height: "17",
        viewBox: "0 0 59 17",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
      }
    }, [t("path", {
      attrs: {
        d: "M0 0V17H52.5129L59 0H0Z",
        fill: "#E34537"
      }
    })]), t("label", [i._v("Low Comp.")])]) : i._e()])]);
  })], 2);
}, OO = [];
const AO = "_list_wrap_1tkvl_7", LO = "_list_item_style_1tkvl_23", jO = "_list_item_1tkvl_23", EO = "_triangle_1tkvl_64", IO = {
  list_wrap: AO,
  list_item_style: LO,
  list_item: jO,
  triangle: EO
}, Xl = {};
Xl.$style = IO;
var RO = /* @__PURE__ */ te(
  CO,
  MO,
  OO,
  !1,
  YO,
  "31e97a22",
  null,
  null
);
function YO(i) {
  for (let e in Xl)
    this[e] = Xl[e];
}
const kA = /* @__PURE__ */ function() {
  return RO.exports;
}(), NO = {
  components: {
    "icon-button": gu
  },
  props: {
    styleProps: String,
    // currentPge
    currentPage: {
      type: Number,
      default: 1
    },
    totalPage: {
      type: Number,
      default: 1
    },
    disabled: {
      type: Boolean,
      default: !1
    },
    previousClickHandler: Function,
    nextClickHandler: Function
  },
  data() {
    return {
      disableNext: !1,
      disablePrevious: !1
    };
  },
  computed: {
    computeNextDisabled() {
      return this.currentPage == this.totalPage || this.disabled;
    },
    computePreviousDisabled() {
      return this.currentPage == 1 || this.disabled;
    }
  },
  methods: {
    nextHandler() {
      this.currentPage < this.totalPage && (this.currentPage += 1), this.nextClickHandler && this.nextClickHandler({
        currentPage: this.currentPage,
        totalPage: this.totalPage
      });
    },
    previousHandler() {
      this.currentPage > 1 && (this.currentPage -= 1), this.previousClickHandler && this.previousClickHandler({
        currentPage: this.currentPage,
        totalPage: this.totalPage
      });
    }
  }
};
var $O = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    class: i.$style.pagination_container,
    style: i.styleProps
  }, [t("span", {
    class: i.$style.pagination_label
  }, [i._v(i._s(i.currentPage) + " of " + i._s(i.totalPage))]), t("icon-button", {
    attrs: {
      "button-type": "previous",
      "click-handler": i.previousHandler,
      disabled: i.computePreviousDisabled
    }
  }), t("icon-button", {
    attrs: {
      "button-type": "next",
      "click-handler": i.nextHandler,
      disabled: i.computeNextDisabled
    }
  })], 1);
}, FO = [];
const BO = "_pagination_container_1t89v_7", HO = "_pagination_label_1t89v_15", zO = {
  pagination_container: BO,
  pagination_label: HO
}, Vl = {};
Vl.$style = zO;
var XO = /* @__PURE__ */ te(
  NO,
  $O,
  FO,
  !1,
  VO,
  "6777be4b",
  null,
  null
);
function VO(i) {
  for (let e in Vl)
    this[e] = Vl[e];
}
const CA = /* @__PURE__ */ function() {
  return XO.exports;
}();
export {
  GO as Accordion,
  KO as AlertBox,
  QO as Calendar,
  WO as ChartJS,
  sA as CheckList,
  Gh as CheckboxButton,
  rA as Chips,
  $a as CtaButton,
  nA as CustomList,
  aA as DataTable,
  oA as DataTablev2,
  uA as DoubleDropdown,
  lA as Dropdown,
  gu as IconButton,
  fA as InputIpAddress,
  hA as InputNumber,
  dA as InputText,
  pA as ListGroup,
  gA as ListItem,
  kA as ListSearchBar,
  mA as Modal,
  _A as Onboarding,
  tA as OverallXYChart,
  CA as Pagination,
  iA as PieChart,
  df as Popover,
  Du as SearchBar,
  UO as SearchJS,
  bA as Slider,
  yA as Snackbar,
  vA as TabButton,
  DA as TabIcon,
  xA as TabModule,
  wA as TabNumber,
  SA as TabOverview,
  ZO as TableActionbarButton,
  cA as Textarea,
  PA as TimePicker,
  TA as ToggleButton,
  mx as Tooltip,
  JO as Widget,
  CS as XYChart
};
