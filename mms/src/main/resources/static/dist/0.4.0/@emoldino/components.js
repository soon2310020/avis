var hl = function(i, e) {
  return hl = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, s) {
    t.__proto__ = s;
  } || function(t, s) {
    for (var r in s)
      Object.prototype.hasOwnProperty.call(s, r) && (t[r] = s[r]);
  }, hl(i, e);
};
function Hp(i, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
  hl(i, e);
  function t() {
    this.constructor = i;
  }
  i.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
}
var Ni = function() {
  return Ni = Object.assign || function(e) {
    for (var t, s = 1, r = arguments.length; s < r; s++) {
      t = arguments[s];
      for (var n in t)
        Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
    }
    return e;
  }, Ni.apply(this, arguments);
};
function bn(i) {
  var e = typeof Symbol == "function" && Symbol.iterator, t = e && i[e], s = 0;
  if (t)
    return t.call(i);
  if (i && typeof i.length == "number")
    return {
      next: function() {
        return i && s >= i.length && (i = void 0), { value: i && i[s++], done: !i };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function Hh(i, e) {
  var t = typeof Symbol == "function" && i[Symbol.iterator];
  if (!t)
    return i;
  var s = t.call(i), r, n = [], a;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = s.next()).done; )
      n.push(r.value);
  } catch (o) {
    a = { error: o };
  } finally {
    try {
      r && !r.done && (t = s.return) && t.call(s);
    } finally {
      if (a)
        throw a.error;
    }
  }
  return n;
}
function zh(i, e, t) {
  if (t || arguments.length === 2)
    for (var s = 0, r = e.length, n; s < r; s++)
      (n || !(s in e)) && (n || (n = Array.prototype.slice.call(e, 0, s)), n[s] = e[s]);
  return i.concat(n || Array.prototype.slice.call(e));
}
function Ou(i) {
  var e;
  ge(i, (e = ri()) === null || e === void 0 ? void 0 : e.proxy);
}
var or, On = [], Vh = (
  /** @class */
  function() {
    function i(e) {
      this.active = !0, this.effects = [], this.cleanups = [], this.vm = e;
    }
    return i.prototype.run = function(e) {
      if (this.active)
        try {
          return this.on(), e();
        } finally {
          this.off();
        }
      else
        ({}).NODE_ENV !== "production" && Ou("cannot run an inactive effect scope.");
    }, i.prototype.on = function() {
      this.active && (On.push(this), or = this);
    }, i.prototype.off = function() {
      this.active && (On.pop(), or = On[On.length - 1]);
    }, i.prototype.stop = function() {
      this.active && (this.vm.$destroy(), this.effects.forEach(function(e) {
        return e.stop();
      }), this.cleanups.forEach(function(e) {
        return e();
      }), this.active = !1);
    }, i;
  }()
), Xh = (
  /** @class */
  function(i) {
    Hp(e, i);
    function e(t) {
      t === void 0 && (t = !1);
      var s = this, r = void 0;
      return Zp(function() {
        r = wr(Ut());
      }), s = i.call(this, r) || this, t || zp(s), s;
    }
    return e;
  }(Vh)
);
function zp(i, e) {
  var t;
  if (e = e || or, e && e.active) {
    e.effects.push(i);
    return;
  }
  var s = (t = ri()) === null || t === void 0 ? void 0 : t.proxy;
  s && s.$on("hook:destroyed", function() {
    return i.stop();
  });
}
function Vp(i) {
  return new Xh(i);
}
function Wh() {
  return or;
}
function Xp(i) {
  or ? or.cleanups.push(i) : {}.NODE_ENV !== "production" && Ou("onScopeDispose() is called when there is no active effect scope to be associated with.");
}
function Uh() {
  var i, e;
  return ((i = Wh()) === null || i === void 0 ? void 0 : i.vm) || ((e = ri()) === null || e === void 0 ? void 0 : e.proxy);
}
function Wp(i) {
  if (!i.scope) {
    var e = new Vh(i.proxy);
    i.scope = e, i.proxy.$on("hook:destroyed", function() {
      return e.stop();
    });
  }
  return i.scope;
}
var dl = void 0;
try {
  var hs = require("vue");
  hs && vc(hs) ? dl = hs : hs && "default" in hs && vc(hs.default) && (dl = hs.default);
} catch {
}
var Ds = null, Xs = null, Gn = !0, Gh = "__composition_api_installed__";
function vc(i) {
  return i && Ct(i) && i.name === "Vue";
}
function Up(i) {
  return Ds && zt(i, Gh);
}
function Ut() {
  return {}.NODE_ENV !== "production" && lo(Ds, "must call Vue.use(VueCompositionAPI) before using any function."), Ds;
}
function Zh() {
  var i = Ds || dl;
  return {}.NODE_ENV !== "production" && lo(i, "No vue dependency found."), i;
}
function Gp(i) {
  ({}).NODE_ENV !== "production" && Ds && i.__proto__ !== Ds.__proto__ && ge("[vue-composition-api] another instance of Vue installed"), Ds = i, Object.defineProperty(i, Gh, {
    configurable: !0,
    writable: !0,
    value: !0
  });
}
function Zp(i) {
  var e = Gn;
  Gn = !1;
  try {
    i();
  } finally {
    Gn = e;
  }
}
function la(i) {
  if (Gn) {
    var e = Xs;
    e == null || e.scope.off(), Xs = i, Xs == null || Xs.scope.on();
  }
}
function ri() {
  return Xs;
}
var Ro = /* @__PURE__ */ new WeakMap();
function ua(i) {
  if (Ro.has(i))
    return Ro.get(i);
  var e = {
    proxy: i,
    update: i.$forceUpdate,
    type: i.$options,
    uid: i._uid,
    // $emit is defined on prototype and it expected to be bound
    emit: i.$emit.bind(i),
    parent: null,
    root: null
    // to be immediately set
  };
  Wp(e);
  var t = [
    "data",
    "props",
    "attrs",
    "refs",
    "vnode",
    "slots"
  ];
  return t.forEach(function(s) {
    qe(e, s, {
      get: function() {
        return i["$".concat(s)];
      }
    });
  }), qe(e, "isMounted", {
    get: function() {
      return i._isMounted;
    }
  }), qe(e, "isUnmounted", {
    get: function() {
      return i._isDestroyed;
    }
  }), qe(e, "isDeactivated", {
    get: function() {
      return i._inactive;
    }
  }), qe(e, "emitted", {
    get: function() {
      return i._events;
    }
  }), Ro.set(i, e), i.$parent && (e.parent = ua(i.$parent)), i.$root && (e.root = ua(i.$root)), e;
}
var Kp = function(i) {
  return Object.prototype.toString.call(i);
};
function xc(i) {
  return typeof i == "function" && /native code/.test(i.toString());
}
var Kh = typeof Symbol < "u" && xc(Symbol) && typeof Reflect < "u" && xc(Reflect.ownKeys), ci = function(i) {
  return i;
};
function qe(i, e, t) {
  var s = t.get, r = t.set;
  Object.defineProperty(i, e, {
    enumerable: !0,
    configurable: !0,
    get: s || ci,
    set: r || ci
  });
}
function oo(i, e, t, s) {
  Object.defineProperty(i, e, {
    value: t,
    enumerable: !!s,
    writable: !0,
    configurable: !0
  });
}
function zt(i, e) {
  return Object.hasOwnProperty.call(i, e);
}
function lo(i, e) {
  if (!i)
    throw new Error("[vue-composition-api] ".concat(e));
}
function qh(i) {
  return typeof i == "string" || typeof i == "number" || // $flow-disable-line
  typeof i == "symbol" || typeof i == "boolean";
}
function Tt(i) {
  return Array.isArray(i);
}
var qp = Object.prototype.toString, Qh = function(i) {
  return qp.call(i);
}, Qp = function(i) {
  return Qh(i) === "[object Map]";
}, Jp = function(i) {
  return Qh(i) === "[object Set]";
}, eg = 4294967295;
function Jh(i) {
  var e = parseFloat(String(i));
  return e >= 0 && Math.floor(e) === e && isFinite(i) && e <= eg;
}
function Ti(i) {
  return i !== null && typeof i == "object";
}
function Vt(i) {
  return Kp(i) === "[object Object]";
}
function Ct(i) {
  return typeof i == "function";
}
function ed(i) {
  return i == null;
}
function ge(i, e) {
  var t = Zh();
  !t || !t.util ? console.warn("[vue-composition-api] ".concat(i)) : t.util.warn(i, e);
}
function tg(i, e, t) {
  if ({}.NODE_ENV !== "production" && ge("Error in ".concat(t, ': "').concat(i.toString(), '"'), e), typeof window < "u" && typeof console < "u")
    console.error(i);
  else
    throw i;
}
function ig(i, e) {
  return i === e ? i !== 0 || 1 / i === 1 / e : i !== i && e !== e;
}
function td(i, e) {
  return e = e || ri(), {}.NODE_ENV !== "production" && !e && ge("".concat(i, " is called when there is no active component instance to be ") + "associated with. Lifecycle injection APIs can only be used during execution of setup()."), e;
}
function wr(i, e) {
  e === void 0 && (e = {});
  var t = i.config.silent;
  i.config.silent = !0;
  var s = new i(e);
  return i.config.silent = t, s;
}
function sg(i) {
  var e = Ut();
  return e && i instanceof e;
}
function rg(i, e) {
  return function() {
    for (var t = [], s = 0; s < arguments.length; s++)
      t[s] = arguments[s];
    return i.$scopedSlots[e] ? i.$scopedSlots[e].apply(i, t) : {}.NODE_ENV !== "production" ? ge("slots.".concat(e, '() got called outside of the "render()" scope'), i) : void 0;
  };
}
function ng(i, e) {
  var t;
  if (!i)
    t = {};
  else {
    if (i._normalized)
      return i._normalized;
    t = {};
    for (var s in i)
      i[s] && s[0] !== "$" && (t[s] = !0);
  }
  for (var s in e)
    s in t || (t[s] = !0);
  return t;
}
var $o, ag = function() {
  if (!$o) {
    var i = wr(Ut(), {
      computed: {
        value: function() {
          return 0;
        }
      }
    }), e = i._computedWatchers.value.constructor, t = i._data.__ob__.dep.constructor;
    $o = {
      Watcher: e,
      Dep: t
    }, i.$destroy();
  }
  return $o;
};
function id(i) {
  return Kh ? Symbol.for(i) : i;
}
var Js = id("composition-api.preFlushQueue"), Xr = id("composition-api.postFlushQueue"), nt = "composition-api.refKey", wc = /* @__PURE__ */ new WeakMap(), sd = /* @__PURE__ */ new WeakMap(), uo = /* @__PURE__ */ new WeakMap();
function rd(i, e, t) {
  var s = Ut(), r = s.util, n = r.warn, a = r.defineReactive;
  ({}).NODE_ENV !== "production" && (ed(i) || qh(i)) && n("Cannot set reactive property on undefined, null, or primitive value: ".concat(i));
  var o = i.__ob__;
  function l() {
    o && Ti(t) && !zt(t, "__ob__") && Lu(t);
  }
  if (Tt(i)) {
    if (Jh(e))
      return i.length = Math.max(i.length, e), i.splice(e, 1, t), l(), t;
    if (e === "length" && t !== i.length)
      return i.length = t, o == null || o.dep.notify(), t;
  }
  return e in i && !(e in Object.prototype) ? (i[e] = t, l(), t) : i._isVue || o && o.vmCount ? ({}.NODE_ENV !== "production" && n("Avoid adding reactive properties to a Vue instance or its root $data at runtime - declare it upfront in the data option."), t) : o ? (a(o.value, e, t), ld(i, e, t), l(), o.dep.notify(), t) : (i[e] = t, t);
}
var nd = !1;
function og() {
  return nd;
}
function Sc(i) {
  nd = i;
}
var Mu = (
  /** @class */
  function() {
    function i(e) {
      var t = e.get, s = e.set;
      qe(this, "value", {
        get: t,
        set: s
      });
    }
    return i;
  }()
);
function Sr(i, e, t) {
  e === void 0 && (e = !1), t === void 0 && (t = !1);
  var s = new Mu(i);
  t && (s.effect = !0);
  var r = Object.seal(s);
  return e && uo.set(r, !0), r;
}
function ca(i) {
  var e;
  if (De(i))
    return i;
  var t = yn((e = {}, e[nt] = i, e));
  return Sr({
    get: function() {
      return t[nt];
    },
    set: function(s) {
      return t[nt] = s;
    }
  });
}
function De(i) {
  return i instanceof Mu;
}
function er(i) {
  return De(i) ? i.value : i;
}
function ad(i) {
  if ({}.NODE_ENV !== "production" && !Bt(i) && ge("toRefs() expects a reactive object but received a plain one."), !Vt(i))
    return i;
  var e = {};
  for (var t in i)
    e[t] = od(i, t);
  return e;
}
function lg(i) {
  var e = ca(0);
  return Sr(i(function() {
    return void e.value;
  }, function() {
    ++e.value;
  }));
}
function od(i, e) {
  e in i || rd(i, e, void 0);
  var t = i[e];
  return De(t) ? t : Sr({
    get: function() {
      return i[e];
    },
    set: function(s) {
      return i[e] = s;
    }
  });
}
function ug(i) {
  var e;
  if (De(i))
    return i;
  var t = cd((e = {}, e[nt] = i, e));
  return Sr({
    get: function() {
      return t[nt];
    },
    set: function(s) {
      return t[nt] = s;
    }
  });
}
function cg(i) {
  De(i) && (Sc(!0), i.value = i.value, Sc(!1));
}
function hg(i) {
  var e, t, s;
  if (Bt(i))
    return i;
  var r = yn((e = {}, e[nt] = i, e));
  oo(r, nt, r[nt], !1);
  var n = function(u) {
    qe(r, u, {
      get: function() {
        return De(r[nt][u]) ? r[nt][u].value : r[nt][u];
      },
      set: function(h) {
        if (De(r[nt][u]))
          return r[nt][u].value = er(h);
        r[nt][u] = er(h);
      }
    });
  };
  try {
    for (var a = bn(Object.keys(i)), o = a.next(); !o.done; o = a.next()) {
      var l = o.value;
      n(l);
    }
  } catch (u) {
    t = { error: u };
  } finally {
    try {
      o && !o.done && (s = a.return) && s.call(a);
    } finally {
      if (t)
        throw t.error;
    }
  }
  return r;
}
var Au = "__v_skip";
function ki(i) {
  var e;
  return !!(i && zt(i, "__ob__") && typeof i.__ob__ == "object" && (!((e = i.__ob__) === null || e === void 0) && e[Au]));
}
function Bt(i) {
  var e;
  return !!(i && zt(i, "__ob__") && typeof i.__ob__ == "object" && !(!((e = i.__ob__) === null || e === void 0) && e[Au]));
}
function fl(i) {
  if (!(!Vt(i) || ki(i) || Tt(i) || De(i) || sg(i) || wc.has(i))) {
    wc.set(i, !0);
    for (var e = Object.keys(i), t = 0; t < e.length; t++)
      ld(i, e[t]);
  }
}
function ld(i, e, t) {
  if (e !== "__ob__" && !ki(i[e])) {
    var s, r, n = Object.getOwnPropertyDescriptor(i, e);
    if (n) {
      if (n.configurable === !1)
        return;
      s = n.get, r = n.set, (!s || r) && arguments.length === 2 && (t = i[e]);
    }
    fl(t), qe(i, e, {
      get: function() {
        var o = s ? s.call(i) : t;
        return e !== nt && De(o) ? o.value : o;
      },
      set: function(o) {
        s && !r || (e !== nt && De(t) && !De(o) ? t.value = o : (r && r.call(i, o), t = o), fl(o));
      }
    });
  }
}
function co(i) {
  var e = Zh(), t;
  if (e.observable)
    t = e.observable(i);
  else {
    var s = wr(e, {
      data: {
        $$state: i
      }
    });
    t = s._data.$$state;
  }
  return zt(t, "__ob__") || Lu(t), t;
}
function Lu(i, e) {
  var t, s;
  if (e === void 0 && (e = /* @__PURE__ */ new Set()), !(e.has(i) || zt(i, "__ob__") || !Object.isExtensible(i))) {
    oo(i, "__ob__", dg(i)), e.add(i);
    try {
      for (var r = bn(Object.keys(i)), n = r.next(); !n.done; n = r.next()) {
        var a = n.value, o = i[a];
        !(Vt(o) || Tt(o)) || ki(o) || !Object.isExtensible(o) || Lu(o, e);
      }
    } catch (l) {
      t = { error: l };
    } finally {
      try {
        n && !n.done && (s = r.return) && s.call(r);
      } finally {
        if (t)
          throw t.error;
      }
    }
  }
}
function dg(i) {
  return i === void 0 && (i = {}), {
    value: i,
    dep: {
      notify: ci,
      depend: ci,
      addSub: ci,
      removeSub: ci
    }
  };
}
function ud() {
  return co({}).__ob__;
}
function cd(i) {
  var e, t;
  if (!Ti(i))
    return {}.NODE_ENV !== "production" && ge('"shallowReactive()" must be called on an object.'), i;
  if (!(Vt(i) || Tt(i)) || ki(i) || !Object.isExtensible(i))
    return i;
  var s = co(Tt(i) ? [] : {}), r = s.__ob__, n = function(u) {
    var h = i[u], c, f, d = Object.getOwnPropertyDescriptor(i, u);
    if (d) {
      if (d.configurable === !1)
        return "continue";
      c = d.get, f = d.set;
    }
    qe(s, u, {
      get: function() {
        var p;
        return (p = r.dep) === null || p === void 0 || p.depend(), h;
      },
      set: function(p) {
        var _;
        c && !f || !og() && h === p || (f ? f.call(i, p) : h = p, (_ = r.dep) === null || _ === void 0 || _.notify());
      }
    });
  };
  try {
    for (var a = bn(Object.keys(i)), o = a.next(); !o.done; o = a.next()) {
      var l = o.value;
      n(l);
    }
  } catch (u) {
    e = { error: u };
  } finally {
    try {
      o && !o.done && (t = a.return) && t.call(a);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return s;
}
function yn(i) {
  if (!Ti(i))
    return {}.NODE_ENV !== "production" && ge('"reactive()" must be called on an object.'), i;
  if (!(Vt(i) || Tt(i)) || ki(i) || !Object.isExtensible(i))
    return i;
  var e = co(i);
  return fl(e), e;
}
function fg(i) {
  if (!(Vt(i) || Tt(i)) || !Object.isExtensible(i))
    return i;
  var e = ud();
  return e[Au] = !0, oo(i, "__ob__", e), sd.set(i, !0), i;
}
function pg(i) {
  var e;
  return ki(i) || !Object.isExtensible(i) ? i : ((e = i == null ? void 0 : i.__ob__) === null || e === void 0 ? void 0 : e.value) || i;
}
function gg(i) {
  return uo.has(i);
}
function _g(i) {
  return {}.NODE_ENV !== "production" && !Ti(i) ? ge("value cannot be made reactive: ".concat(String(i))) : uo.set(i, !0), i;
}
function mg(i) {
  var e, t;
  if (!Ti(i))
    return {}.NODE_ENV !== "production" && ge("value cannot be made reactive: ".concat(String(i))), i;
  if (!(Vt(i) || Tt(i)) || !Object.isExtensible(i) && !De(i))
    return i;
  var s = De(i) ? new Mu({}) : Bt(i) ? co({}) : {}, r = yn({}), n = r.__ob__, a = function(h) {
    var c = i[h], f, d = Object.getOwnPropertyDescriptor(i, h);
    if (d) {
      if (d.configurable === !1 && !De(i))
        return "continue";
      f = d.get;
    }
    qe(s, h, {
      get: function() {
        var p = f ? f.call(i) : c;
        return n.dep.depend(), p;
      },
      set: function(g) {
        ({}).NODE_ENV !== "production" && ge('Set operation on key "'.concat(h, '" failed: target is readonly.'));
      }
    });
  };
  try {
    for (var o = bn(Object.keys(i)), l = o.next(); !l.done; l = o.next()) {
      var u = l.value;
      a(u);
    }
  } catch (h) {
    e = { error: h };
  } finally {
    try {
      l && !l.done && (t = o.return) && t.call(o);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return uo.set(s, !0), s;
}
function bg(i, e) {
  var t = Ut(), s = t.util.warn;
  if ({}.NODE_ENV !== "production" && (ed(i) || qh(i)) && s("Cannot delete reactive property on undefined, null, or primitive value: ".concat(i)), Tt(i) && Jh(e)) {
    i.splice(e, 1);
    return;
  }
  var r = i.__ob__;
  if (i._isVue || r && r.vmCount) {
    ({}).NODE_ENV !== "production" && s("Avoid deleting properties on a Vue instance or its root $data - just set it to null.");
    return;
  }
  zt(i, e) && (delete i[e], r && r.dep.notify());
}
var yg = function(i) {
  return "on".concat(i[0].toUpperCase() + i.slice(1));
};
function _i(i) {
  return function(e, t) {
    var s = td(yg(i), t);
    return s && vg(Ut(), s, i, e);
  };
}
function vg(i, e, t, s) {
  var r = e.proxy.$options, n = i.config.optionMergeStrategies[t], a = xg(e, s);
  return r[t] = n(r[t], a), a;
}
function xg(i, e) {
  return function() {
    for (var t = [], s = 0; s < arguments.length; s++)
      t[s] = arguments[s];
    var r = ri();
    la(i);
    try {
      return e.apply(void 0, zh([], Hh(t), !1));
    } finally {
      la(r);
    }
  };
}
var wg = _i("beforeMount"), Sg = _i("mounted"), Dg = _i("beforeUpdate"), Cg = _i("updated"), Tg = _i("beforeDestroy"), kg = _i("destroyed"), Pg = _i("errorCaptured"), Og = _i("activated"), Mg = _i("deactivated"), Ag = _i("serverPrefetch"), Zn;
function Lg() {
  ha(this, Js);
}
function jg() {
  ha(this, Xr);
}
function Ig(i) {
  return i[Js] !== void 0;
}
function Eg(i) {
  i[Js] = [], i[Xr] = [], i.$on("hook:beforeUpdate", Lg), i.$on("hook:updated", jg);
}
function Rg(i) {
  return Ni({
    immediate: !1,
    deep: !1,
    flush: "pre"
  }, i);
}
function $g(i) {
  return Ni({
    flush: "pre"
  }, i);
}
function hd() {
  var i = Uh();
  return i ? Ig(i) || Eg(i) : (Zn || (Zn = wr(Ut())), i = Zn), i;
}
function ha(i, e) {
  for (var t = i[e], s = 0; s < t.length; s++)
    t[s]();
  t.length = 0;
}
function Ng(i, e, t) {
  var s = function() {
    i.$nextTick(function() {
      i[Js].length && ha(i, Js), i[Xr].length && ha(i, Xr);
    });
  };
  switch (t) {
    case "pre":
      s(), i[Js].push(e);
      break;
    case "post":
      s(), i[Xr].push(e);
      break;
    default:
      lo(!1, 'flush must be one of ["post", "pre", "sync"], but got '.concat(t));
      break;
  }
}
function Fg(i, e, t, s) {
  var r = i._watchers.length;
  return i.$watch(e, t, {
    immediate: s.immediateInvokeCallback,
    deep: s.deep,
    lazy: s.noRun,
    sync: s.sync,
    before: s.before
  }), i._watchers[r];
}
function Dc(i, e) {
  var t = i.teardown;
  i.teardown = function() {
    for (var s = [], r = 0; r < arguments.length; r++)
      s[r] = arguments[r];
    t.apply(i, s), e();
  };
}
function dd(i, e, t, s) {
  var r;
  ({}).NODE_ENV !== "production" && !t && (s.immediate !== void 0 && ge('watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.'), s.deep !== void 0 && ge('watch() "deep" option is only respected when using the watch(source, callback, options?) signature.'));
  var n = s.flush, a = n === "sync", o, l = function(O) {
    o = function() {
      try {
        O();
      } catch (T) {
        tg(T, i, "onCleanup()");
      }
    };
  }, u = function() {
    o && (o(), o = null);
  }, h = function(O) {
    return a || /* without a current active instance, ignore pre|post mode */
    i === Zn ? O : function() {
      for (var T = [], L = 0; L < arguments.length; L++)
        T[L] = arguments[L];
      return Ng(i, function() {
        O.apply(void 0, zh([], Hh(T), !1));
      }, n);
    };
  };
  if (t === null) {
    var c = !1, f = function() {
      if (!c)
        try {
          c = !0, e(l);
        } finally {
          c = !1;
        }
    }, d = Fg(i, f, ci, {
      deep: s.deep || !1,
      sync: a,
      before: u
    });
    Dc(d, u), d.lazy = !1;
    var g = d.get.bind(d);
    return d.get = h(g), function() {
      d.teardown();
    };
  }
  var p = s.deep, _ = !1, m;
  if (De(e) ? m = function() {
    return e.value;
  } : Bt(e) ? (m = function() {
    return e;
  }, p = !0) : Tt(e) ? (_ = !0, m = function() {
    return e.map(function(O) {
      return De(O) ? O.value : Bt(O) ? Zs(O) : Ct(O) ? O() : ({}.NODE_ENV !== "production" && ge("Invalid watch source: ".concat(JSON.stringify(O), `.
          A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.`), i), ci);
    });
  }) : Ct(e) ? m = e : (m = ci, {}.NODE_ENV !== "production" && ge("Invalid watch source: ".concat(JSON.stringify(e), `.
      A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.`), i)), p) {
    var v = m;
    m = function() {
      return Zs(v());
    };
  }
  var b = function(O, T) {
    if (!(!p && _ && O.every(function(L, j) {
      return ig(L, T[j]);
    })))
      return u(), t(O, T, l);
  }, y = h(b);
  if (s.immediate) {
    var x = y, D = function(O, T) {
      return D = x, b(O, Tt(O) ? [] : T);
    };
    y = function(O, T) {
      return D(O, T);
    };
  }
  var A = i.$watch(m, y, {
    immediate: s.immediate,
    deep: p,
    sync: a
  }), C = i._watchers[i._watchers.length - 1];
  return Bt(C.value) && (!((r = C.value.__ob__) === null || r === void 0) && r.dep) && p && C.value.__ob__.dep.addSub({
    update: function() {
      C.run();
    }
  }), Dc(C, u), function() {
    A();
  };
}
function ju(i, e) {
  var t = $g(e), s = hd();
  return dd(s, i, null, t);
}
function Yg(i) {
  return ju(i, { flush: "post" });
}
function Bg(i) {
  return ju(i, { flush: "sync" });
}
function Hg(i, e, t) {
  var s = null;
  Ct(e) ? s = e : ({}.NODE_ENV !== "production" && ge("`watch(fn, options?)` signature has been moved to a separate API. Use `watchEffect(fn, options?)` instead. `watch` now only supports `watch(source, cb, options?) signature."), t = e, s = null);
  var r = Rg(t), n = hd();
  return dd(n, i, s, r);
}
function Zs(i, e) {
  if (e === void 0 && (e = /* @__PURE__ */ new Set()), !Ti(i) || e.has(i) || sd.has(i))
    return i;
  if (e.add(i), De(i))
    Zs(i.value, e);
  else if (Tt(i))
    for (var t = 0; t < i.length; t++)
      Zs(i[t], e);
  else if (Jp(i) || Qp(i))
    i.forEach(function(r) {
      Zs(r, e);
    });
  else if (Vt(i))
    for (var s in i)
      Zs(i[s], e);
  return i;
}
function zg(i) {
  var e = Uh(), t, s;
  Ct(i) ? t = i : (t = i.get, s = i.set);
  var r, n;
  if (e && !e.$isServer) {
    var a = ag(), o = a.Watcher, l = a.Dep, u;
    n = function() {
      return u || (u = new o(e, t, ci, { lazy: !0 })), u.dirty && u.evaluate(), l.target && u.depend(), u.value;
    }, r = function(c) {
      if ({}.NODE_ENV !== "production" && !s) {
        ge("Write operation failed: computed value is readonly.", e);
        return;
      }
      s && s(c);
    };
  } else {
    var h = wr(Ut(), {
      computed: {
        $$state: {
          get: t,
          set: s
        }
      }
    });
    e && e.$on("hook:destroyed", function() {
      return h.$destroy();
    }), n = function() {
      return h.$$state;
    }, r = function(c) {
      if ({}.NODE_ENV !== "production" && !s) {
        ge("Write operation failed: computed value is readonly.", e);
        return;
      }
      h.$$state = c;
    };
  }
  return Sr({
    get: n,
    set: r
  }, !s, !0);
}
var fd = {};
function Vg(i, e) {
  for (var t = e; t; ) {
    if (t._provided && zt(t._provided, i))
      return t._provided[i];
    t = t.$parent;
  }
  return fd;
}
function Xg(i, e) {
  var t, s = (t = td("provide")) === null || t === void 0 ? void 0 : t.proxy;
  if (s) {
    if (!s._provided) {
      var r = {};
      qe(s, "_provided", {
        get: function() {
          return r;
        },
        set: function(n) {
          return Object.assign(r, n);
        }
      });
    }
    s._provided[i] = e;
  }
}
function Wg(i, e, t) {
  var s;
  t === void 0 && (t = !1);
  var r = (s = ri()) === null || s === void 0 ? void 0 : s.proxy;
  if (!r) {
    ({}).NODE_ENV !== "production" && ge("inject() can only be used inside setup() or functional components.");
    return;
  }
  if (!i)
    return {}.NODE_ENV !== "production" && ge('injection "'.concat(String(i), '" not found.'), r), e;
  var n = Vg(i, r);
  if (n !== fd)
    return n;
  if (arguments.length > 1)
    return t && Ct(e) ? e() : e;
  ({}).NODE_ENV !== "production" && ge('Injection "'.concat(String(i), '" not found.'), r);
}
var Cc = {}.NODE_ENV !== "production" ? Object.freeze({}) : {}, pd = function(i) {
  var e;
  i === void 0 && (i = "$style");
  var t = ri();
  if (!t)
    return {}.NODE_ENV !== "production" && ge("useCssModule must be called inside setup()"), Cc;
  var s = (e = t.proxy) === null || e === void 0 ? void 0 : e[i];
  return s || ({}.NODE_ENV !== "production" && ge('Current instance does not have CSS module named "'.concat(i, '".')), Cc);
}, Ug = pd;
function Gg(i, e) {
  e === void 0 && (e = void 0);
  var t = Ut(), s = void 0, r = {}, n = {
    config: t.config,
    use: t.use.bind(t),
    mixin: t.mixin.bind(t),
    component: t.component.bind(t),
    provide: function(a, o) {
      return r[a] = o, this;
    },
    directive: function(a, o) {
      return o ? (t.directive(a, o), n) : t.directive(a);
    },
    mount: function(a, o) {
      return s ? ({}.NODE_ENV !== "production" && ge("App has already been mounted.\nIf you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. `const createMyApp = () => createApp(App)`"), s) : (s = new t(Ni(Ni({ propsData: e }, i), { provide: Ni(Ni({}, r), i.provide) })), s.$mount(a, o), s);
    },
    unmount: function() {
      s ? (s.$destroy(), s = void 0) : {}.NODE_ENV !== "production" && ge("Cannot unmount an app that is not mounted.");
    }
  };
  return n;
}
var Zg = function() {
  for (var e, t = [], s = 0; s < arguments.length; s++)
    t[s] = arguments[s];
  return (e = Ut()) === null || e === void 0 ? void 0 : e.nextTick.apply(this, t);
}, Mn, Kg = function() {
  for (var e, t = [], s = 0; s < arguments.length; s++)
    t[s] = arguments[s];
  var r = (this === null || this === void 0 ? void 0 : this.proxy) || ((e = ri()) === null || e === void 0 ? void 0 : e.proxy);
  return r ? r.$createElement.apply(r, t) : ({}.NODE_ENV !== "production" && ge("`createElement()` has been called outside of render function."), Mn || (Mn = wr(Ut()).$createElement), Mn.apply(Mn, t));
};
function qg() {
  return gd().slots;
}
function Qg() {
  return gd().attrs;
}
function gd() {
  var i = ri();
  return {}.NODE_ENV !== "production" && !i && ge("useContext() called without active instance."), i.setupContext;
}
function Jg(i, e, t) {
  var s = i.__composition_api_state__ = i.__composition_api_state__ || {};
  s[e] = t;
}
function e_(i, e) {
  return (i.__composition_api_state__ || {})[e];
}
var Vi = {
  set: Jg,
  get: e_
};
function t_(i, e, t) {
  var s = i.$options.props;
  !(e in i) && !(s && zt(s, e)) ? (De(t) ? qe(i, e, {
    get: function() {
      return t.value;
    },
    set: function(r) {
      t.value = r;
    }
  }) : qe(i, e, {
    get: function() {
      return Bt(t) && t.__ob__.dep.depend(), t;
    },
    set: function(r) {
      t = r;
    }
  }), {}.NODE_ENV !== "production" && i.$nextTick(function() {
    Object.keys(i._data).indexOf(e) === -1 && (De(t) ? qe(i._data, e, {
      get: function() {
        return t.value;
      },
      set: function(r) {
        t.value = r;
      }
    }) : qe(i._data, e, {
      get: function() {
        return t;
      },
      set: function(r) {
        t = r;
      }
    }));
  })) : {}.NODE_ENV !== "production" && (s && zt(s, e) ? ge('The setup binding property "'.concat(e, '" is already declared as a prop.'), i) : ge('The setup binding property "'.concat(e, '" is already declared.'), i));
}
function i_(i) {
  var e = Vi.get(i, "rawBindings") || {};
  if (!(!e || !Object.keys(e).length)) {
    for (var t = i.$refs, s = Vi.get(i, "refs") || [], r = 0; r < s.length; r++) {
      var n = s[r], a = e[n];
      !t[n] && a && De(a) && (a.value = null);
    }
    for (var o = Object.keys(t), l = [], r = 0; r < o.length; r++) {
      var n = o[r], a = e[n];
      t[n] && a && De(a) && (a.value = t[n], l.push(n));
    }
    Vi.set(i, "refs", l);
  }
}
function Tc(i) {
  for (var e = [i._vnode]; e.length; ) {
    var t = e.pop();
    if (t && (t.context && i_(t.context), t.children))
      for (var s = 0; s < t.children.length; ++s)
        e.push(t.children[s]);
  }
}
function kc(i, e) {
  var t, s;
  if (i) {
    var r = Vi.get(i, "attrBindings");
    if (!(!r && !e)) {
      if (!r) {
        var n = yn({});
        r = { ctx: e, data: n }, Vi.set(i, "attrBindings", r), qe(e, "attrs", {
          get: function() {
            return r == null ? void 0 : r.data;
          },
          set: function() {
            ({}).NODE_ENV !== "production" && ge("Cannot assign to '$attrs' because it is a read-only property", i);
          }
        });
      }
      var a = i.$attrs, o = function(c) {
        zt(r.data, c) || qe(r.data, c, {
          get: function() {
            return i.$attrs[c];
          }
        });
      };
      try {
        for (var l = bn(Object.keys(a)), u = l.next(); !u.done; u = l.next()) {
          var h = u.value;
          o(h);
        }
      } catch (c) {
        t = { error: c };
      } finally {
        try {
          u && !u.done && (s = l.return) && s.call(l);
        } finally {
          if (t)
            throw t.error;
        }
      }
    }
  }
}
function Pc(i, e) {
  var t = i.$options._parentVnode;
  if (t) {
    for (var s = Vi.get(i, "slots") || [], r = ng(t.data.scopedSlots, i.$slots), n = 0; n < s.length; n++) {
      var a = s[n];
      r[a] || delete e[a];
    }
    for (var o = Object.keys(r), n = 0; n < o.length; n++) {
      var a = o[n];
      e[a] || (e[a] = rg(i, a));
    }
    Vi.set(i, "slots", o);
  }
}
function No(i, e, t) {
  var s = ri();
  la(i);
  try {
    return e(i);
  } catch (r) {
    if (t)
      t(r);
    else
      throw r;
  } finally {
    la(s);
  }
}
function s_(i) {
  i.mixin({
    beforeCreate: e,
    mounted: function() {
      Tc(this);
    },
    beforeUpdate: function() {
      kc(this);
    },
    updated: function() {
      Tc(this);
    }
  });
  function e() {
    var a = this, o = a.$options, l = o.setup, u = o.render;
    if (u && (o.render = function() {
      for (var c = this, f = [], d = 0; d < arguments.length; d++)
        f[d] = arguments[d];
      return No(ua(a), function() {
        return u.apply(c, f);
      });
    }), !!l) {
      if (!Ct(l)) {
        ({}).NODE_ENV !== "production" && ge('The "setup" option should be a function that returns a object in component definitions.', a);
        return;
      }
      var h = o.data;
      o.data = function() {
        return t(a, a.$props), Ct(h) ? h.call(a, a) : h || {};
      };
    }
  }
  function t(a, o) {
    o === void 0 && (o = {});
    var l = a.$options.setup, u = n(a), h = ua(a);
    h.setupContext = u, oo(o, "__ob__", ud()), Pc(a, u.slots);
    var c;
    if (No(h, function() {
      c = l(o, u);
    }), !!c) {
      if (Ct(c)) {
        var f = c;
        a.$options.render = function() {
          return Pc(a, u.slots), No(h, function() {
            return f();
          });
        };
        return;
      } else if (Ti(c)) {
        Bt(c) && (c = ad(c)), Vi.set(a, "rawBindings", c);
        var d = c;
        Object.keys(d).forEach(function(g) {
          var p = d[g];
          if (!De(p))
            if (Bt(p))
              Tt(p) && (p = ca(p));
            else if (Ct(p)) {
              var _ = p;
              p = p.bind(a), Object.keys(_).forEach(function(m) {
                p[m] = _[m];
              });
            } else
              Ti(p) ? r(p) && s(p) : p = ca(p);
          t_(a, g, p);
        });
        return;
      }
      ({}).NODE_ENV !== "production" && lo(!1, '"setup" must return a "Object" or a "Function", got "'.concat(Object.prototype.toString.call(c).slice(8, -1), '"'));
    }
  }
  function s(a, o) {
    if (o === void 0 && (o = /* @__PURE__ */ new Set()), !o.has(a) && !(!Vt(a) || De(a) || Bt(a) || ki(a))) {
      var l = Ut(), u = l.util.defineReactive;
      Object.keys(a).forEach(function(h) {
        var c = a[h];
        u(a, h, c), c && (o.add(c), s(c, o));
      });
    }
  }
  function r(a, o) {
    return o === void 0 && (o = /* @__PURE__ */ new Map()), o.has(a) ? o.get(a) : (o.set(a, !1), Tt(a) && Bt(a) ? (o.set(a, !0), !0) : !Vt(a) || ki(a) || De(a) ? !1 : Object.keys(a).some(function(l) {
      return r(a[l], o);
    }));
  }
  function n(a) {
    var o = { slots: {} }, l = [
      "root",
      "parent",
      "refs",
      "listeners",
      "isServer",
      "ssrContext"
    ], u = ["emit"];
    return l.forEach(function(h) {
      var c = "$".concat(h);
      qe(o, h, {
        get: function() {
          return a[c];
        },
        set: function() {
          ({}).NODE_ENV !== "production" && ge("Cannot assign to '".concat(h, "' because it is a read-only property"), a);
        }
      });
    }), kc(a, o), u.forEach(function(h) {
      var c = "$".concat(h);
      qe(o, h, {
        get: function() {
          return function() {
            for (var f = [], d = 0; d < arguments.length; d++)
              f[d] = arguments[d];
            var g = a[c];
            g.apply(a, f);
          };
        }
      });
    }), {}.NODE_ENV === "test" && (o._vm = a), o;
  }
}
function _d(i, e) {
  if (!i)
    return e;
  if (!e)
    return i;
  for (var t, s, r, n = Kh ? Reflect.ownKeys(i) : Object.keys(i), a = 0; a < n.length; a++)
    t = n[a], t !== "__ob__" && (s = e[t], r = i[t], zt(e, t) ? s !== r && Vt(s) && !De(s) && Vt(r) && !De(r) && _d(r, s) : e[t] = r);
  return e;
}
function r_(i) {
  if (Up(i)) {
    ({}).NODE_ENV !== "production" && ge("[vue-composition-api] already installed. Vue.use(VueCompositionAPI) should be called only once.");
    return;
  }
  ({}).NODE_ENV !== "production" && (i.version ? (i.version[0] !== "2" || i.version[1] !== ".") && ge("[vue-composition-api] only works with Vue 2, v".concat(i.version, " found.")) : ge("[vue-composition-api] no Vue version found")), i.config.optionMergeStrategies.setup = function(e, t) {
    return function(r, n) {
      return _d(Ct(e) ? e(r, n) || {} : void 0, Ct(t) ? t(r, n) || {} : void 0);
    };
  }, Gp(i), s_(i);
}
var md = {
  install: function(i) {
    return r_(i);
  }
};
function n_(i) {
  return i;
}
function a_(i) {
  Ct(i) && (i = { loader: i });
  var e = i.loader, t = i.loadingComponent, s = i.errorComponent, r = i.delay, n = r === void 0 ? 200 : r, a = i.timeout, o = i.suspensible, l = o === void 0 ? !1 : o, u = i.onError;
  ({}).NODE_ENV !== "production" && l && ge("The suspensiblbe option for async components is not supported in Vue2. It is ignored.");
  var h = null, c = 0, f = function() {
    return c++, h = null, d();
  }, d = function() {
    var g;
    return h || (g = h = e().catch(function(p) {
      if (p = p instanceof Error ? p : new Error(String(p)), u)
        return new Promise(function(_, m) {
          var v = function() {
            return _(f());
          }, b = function() {
            return m(p);
          };
          u(p, v, b, c + 1);
        });
      throw p;
    }).then(function(p) {
      if (g !== h && h)
        return h;
      if ({}.NODE_ENV !== "production" && !p && ge("Async component loader resolved to undefined. If you are using retry(), make sure to return its return value."), p && (p.__esModule || p[Symbol.toStringTag] === "Module") && (p = p.default), {}.NODE_ENV !== "production" && p && !Ti(p) && !Ct(p))
        throw new Error("Invalid async component load result: ".concat(p));
      return p;
    }));
  };
  return function() {
    var g = d();
    return {
      component: g,
      delay: n,
      timeout: a,
      error: s,
      loading: t
    };
  };
}
var o_ = "1.7.1";

const SN = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  EffectScope: Xh,
  computed: zg,
  createApp: Gg,
  createRef: Sr,
  customRef: lg,
  default: md,
  defineAsyncComponent: a_,
  defineComponent: n_,
  del: bg,
  effectScope: Vp,
  getCurrentInstance: ri,
  getCurrentScope: Wh,
  h: Kg,
  inject: Wg,
  isRaw: ki,
  isReactive: Bt,
  isReadonly: gg,
  isRef: De,
  markRaw: fg,
  nextTick: Zg,
  onActivated: Og,
  onBeforeMount: wg,
  onBeforeUnmount: Tg,
  onBeforeUpdate: Dg,
  onDeactivated: Mg,
  onErrorCaptured: Pg,
  onMounted: Sg,
  onScopeDispose: Xp,
  onServerPrefetch: Ag,
  onUnmounted: kg,
  onUpdated: Cg,
  provide: Xg,
  proxyRefs: hg,
  reactive: yn,
  readonly: _g,
  ref: ca,
  set: rd,
  shallowReactive: cd,
  shallowReadonly: mg,
  shallowRef: ug,
  toRaw: pg,
  toRef: od,
  toRefs: ad,
  triggerRef: cg,
  unref: er,
  useAttrs: Qg,
  useCSSModule: Ug,
  useCssModule: pd,
  useSlots: qg,
  version: o_,
  warn: Ou,
  watch: Hg,
  watchEffect: ju,
  watchPostEffect: Yg,
  watchSyncEffect: Bg
}, Symbol.toStringTag, { value: "Module" }));
function l_(i, e, t, s, r) {
  return t.trim().length > 0 && i.toLowerCase().includes(t) && !s.includes(e) ? (s.push(e), r(s), !0) : !1;
}
function u_(i, e, t, s, r) {
  let n = !1;
  s.length > 0 && s.indexOf(e) >= 0 && s.indexOf(e) === r - 1 && (n = !0);
  const a = new RegExp(t, "gi");
  return i.replace(
    a,
    (l, u) => String.raw`
      <span
        id="${e}-${u}"
        class="highlight ${n ? "focus" : ""}"
        tabindex="0"
      >
        ${l}
      </span>
    `
  );
}
const DN = {
  setHighlightJS: u_,
  getHasKeywordJS: l_
}, c_ = {
  name: "Accordion",
  props: {
    /** set the width of the accordion */
    styleProps: {
      type: [String, Object]
    }
  },
  data() {
    return {
      active: !1
    };
  },
  methods: {
    /**
     * Gets called when the user clicks on the accordion
     */
    openPannel() {
      this.active = !this.active;
      const i = this.$refs.panel;
      i.style.maxHeight = i.style.maxHeight ? "" : i.scrollHeight + "px";
    }
  }
}, h_ = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iOSIgaGVpZ2h0PSI1IiB2aWV3Qm94PSIwIDAgOSA1IiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgogICAgPHBhdGggZD0iTTQuNDI4ODMgMy41NDYzNUwxLjA4MDA4IDAuMzU0NTY5QzAuOTYxMTgyIDAuMjQxNjYzIDAuODAwMDU4IDAuMTc4MzY0IDAuNjMyMTU0IDAuMTc4NTk5QzAuNDY0MjUgMC4xNzg4MzMgMC4zMDMzMjEgMC4yNDI1ODEgMC4xODQ3NjkgMC4zNTU4MTlDMC4wNjYyMTc3IDAuNDY5MDU3IC0wLjAwMDI0NTY1MiAwLjYyMjUwOSA0Ljk2ODg2ZS0wNyAwLjc4MjQxN0MwLjAwMDI0NjY0NSAwLjk0MjMyNiAwLjA2NzE4MjEgMS4wOTU1OSAwLjE4NjA4MiAxLjIwODVMMy45Nzg4MyA0LjgyNDU3QzQuMDk0IDQuOTMzODIgNC4yNDg5NSA0Ljk5NjYxIDQuNDExNDYgNC45OTk4N0M0LjU3Mzk4IDUuMDAzMTMgNC43MzE1NiA0Ljk0NjYxIDQuODUxNDYgNC44NDIwN0w4LjY3MzgzIDEuMjExQzguNzkyNzMgMS4wOTgwOSA4Ljg1OTY3IDAuOTQ0ODI1IDguODU5OTEgMC43ODQ5MTdDOC44NjAxNiAwLjYyNTAwOSA4Ljc5MzcgMC40NzE1NTcgOC42NzUxNCAwLjM1ODMxOUM4LjU1NjU5IDAuMjQ1MDgxIDguMzk1NjYgMC4xODEzMzMgOC4yMjc3NiAwLjE4MTA5OEM4LjA1OTg2IDAuMTgwODY0IDcuODk4NzMgMC4yNDQxNjMgNy43Nzk4MyAwLjM1NzA2OUw0LjQyODgzIDMuNTQ2MzVaIiBmaWxsPSIjMzQ5MUZGIi8+CiAgICA8L3N2Zz4KICAgIA==";
var d_ = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    class: i.$style.accordion_main,
    style: i.styleProps
  }, [t("div", {
    class: i.$style.button_main
  }, [t("button", {
    class: i.$style.heading,
    on: {
      click: i.openPannel
    }
  }, [t("span", [i._t("header")], 2), t("span", {
    class: [i.active ? i.$style.icon_rotate : i.$style.icon, i.$style.accordion_icon]
  }, [t("img", {
    attrs: {
      src: h_,
      alt: "Accordion icon"
    }
  })])])]), t("div", {
    ref: "panel",
    class: i.$style.panel
  }, [i._t("body")], 2)]);
}, f_ = [];
const p_ = "_accordion_main_gflih_1", g_ = "_button_main_gflih_6", __ = "_heading_gflih_9", m_ = "_accordion_icon_gflih_29", b_ = "_icon_rotate_gflih_32", y_ = "_icon_gflih_32", v_ = "_panel_gflih_38", x_ = {
  accordion_main: p_,
  button_main: g_,
  heading: __,
  accordion_icon: m_,
  icon_rotate: b_,
  icon: y_,
  panel: v_
};
function X(i, e, t, s, r, n, a, o) {
  var l = typeof i == "function" ? i.options : i;
  e && (l.render = e, l.staticRenderFns = t, l._compiled = !0), s && (l.functional = !0), n && (l._scopeId = "data-v-" + n);
  var u;
  if (a ? (u = function(f) {
    f = f || // cached call
    this.$vnode && this.$vnode.ssrContext || // stateful
    this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext, !f && typeof __VUE_SSR_CONTEXT__ < "u" && (f = __VUE_SSR_CONTEXT__), r && r.call(this, f), f && f._registeredComponents && f._registeredComponents.add(a);
  }, l._ssrRegister = u) : r && (u = o ? function() {
    r.call(
      this,
      (l.functional ? this.parent : this).$root.$options.shadowRoot
    );
  } : r), u)
    if (l.functional) {
      l._injectStyles = u;
      var h = l.render;
      l.render = function(d, g) {
        return u.call(g), h(d, g);
      };
    } else {
      var c = l.beforeCreate;
      l.beforeCreate = c ? [].concat(c, u) : [u];
    }
  return {
    exports: i,
    options: l
  };
}
const pl = {};
pl.$style = x_;
var w_ = /* @__PURE__ */ X(
  c_,
  d_,
  f_,
  !1,
  S_,
  "acea1214",
  null,
  null
);
function S_(i) {
  for (let e in pl)
    this[e] = pl[e];
}
const CN = /* @__PURE__ */ function() {
  return w_.exports;
}(), D_ = "_center_align_zy9pq_4", C_ = "_default_btn_zy9pq_8", T_ = "_radio_button_zy9pq_21", k_ = "_small_zy9pq_30", P_ = "_radio_button_inner_zy9pq_41", O_ = "_check_list_zy9pq_58", M_ = "_check_list_inner_zy9pq_78", A_ = "_checkbox_zy9pq_96", L_ = "_icon_size_zy9pq_123", j_ = "_label_styles_zy9pq_135", I_ = "_large_zy9pq_141", An = {
  center_align: D_,
  default_btn: C_,
  radio_button: T_,
  default: "_default_zy9pq_8",
  small: k_,
  radio_button_inner: P_,
  check_list: O_,
  check_list_inner: M_,
  checkbox: A_,
  icon_size: L_,
  label_styles: j_,
  large: I_
}, E_ = {
  name: "CheckboxButton",
  props: {
    /** clickHandler accepts checked value true or false */
    clickHandler: Function,
    /** labelText set label of check box */
    labelText: {
      type: String,
      default: ""
    },
    /** set size of check box large or small */
    size: {
      type: String,
      default: "large"
    },
    /** active prop set check box in active state*/
    active: {
      type: Boolean,
      default: !0
    },
    /** disabled prop set check box disabled */
    disabled: Boolean,
    /** button type prop set type of button (radio or checkbox or check_list) */
    buttonType: {
      type: String,
      default: "check_list"
    }
  },
  watch: {
    active(i) {
      this.check = i;
    }
  },
  data() {
    return {
      hover: !1,
      check: !0
    };
  },
  computed: {
    buttonClassComputed() {
      return `${An.default_btn} ${An[this.buttonType]} ${An[this.size]} `;
    },
    innerShapeStyleComputed() {
      return An[this.buttonType + "_inner"];
    }
  },
  methods: {
    truncateText(i, e) {
      return i.length > e ? i.substring(0, e) + "..." : i;
    },
    executor() {
      this.clickHandler && (this.check = !this.check, this.clickHandler(this.check));
    }
  },
  mounted() {
    this.check = this.active;
  }
};
var R_ = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    class: i.$style.center_align
  }, [t("div", {
    class: i.buttonClassComputed,
    attrs: {
      active: i.check,
      disabled: i.disabled
    },
    on: {
      click: i.executor
    }
  }, [i.buttonType === "checkbox" && (i.hover || i.active) ? t("img", {
    class: i.$style.icon_size,
    attrs: {
      src: "#",
      alt: ""
    }
  }) : t("div", {
    class: i.innerShapeStyleComputed
  })]), i.labelText != "" ? t("label", [t("span", {
    class: [i.size ? i.$style[i.size] : "", i.$style.label_styles]
  }, [i._v(" " + i._s(i.truncateText(i.labelText, 40)) + " ")])]) : i._e()]);
}, $_ = [];
const N_ = "_center_align_zy9pq_4", F_ = "_default_btn_zy9pq_8", Y_ = "_radio_button_zy9pq_21", B_ = "_small_zy9pq_30", H_ = "_radio_button_inner_zy9pq_41", z_ = "_check_list_zy9pq_58", V_ = "_check_list_inner_zy9pq_78", X_ = "_checkbox_zy9pq_96", W_ = "_icon_size_zy9pq_123", U_ = "_label_styles_zy9pq_135", G_ = "_large_zy9pq_141", Z_ = {
  center_align: N_,
  default_btn: F_,
  radio_button: Y_,
  default: "_default_zy9pq_8",
  small: B_,
  radio_button_inner: H_,
  check_list: z_,
  check_list_inner: V_,
  checkbox: X_,
  icon_size: W_,
  label_styles: U_,
  large: G_
}, gl = {};
gl.$style = Z_;
var K_ = /* @__PURE__ */ X(
  E_,
  R_,
  $_,
  !1,
  q_,
  null,
  null,
  null
);
function q_(i) {
  for (let e in gl)
    this[e] = gl[e];
}
const bd = /* @__PURE__ */ function() {
  return K_.exports;
}(), Q_ = "_title_10jad_81", J_ = "_footer_10jad_119", Oc = {
  "show-alert-box": "_show-alert-box_10jad_1",
  "emdn-alert-box-modal-root": "_emdn-alert-box-modal-root_10jad_5",
  "alert-box-modal-mask": "_alert-box-modal-mask_10jad_8",
  "alert-box-modal-wrap": "_alert-box-modal-wrap_10jad_21",
  "alert-box-modal-centered": "_alert-box-modal-centered_10jad_24",
  "alert-box-modal": "_alert-box-modal_10jad_8",
  "alert-box-indexed": "_alert-box-indexed_10jad_30",
  "custom-modal-body-user": "_custom-modal-body-user_10jad_35",
  "close-btn": "_close-btn_10jad_42",
  "show-close-button": "_show-close-button_10jad_48",
  "t-close-button": "_t-close-button_10jad_51",
  "t-icon-close": "_t-icon-close_10jad_58",
  "modal-body": "_modal-body_10jad_65",
  "content-div": "_content-div_10jad_73",
  "main-title": "_main-title_10jad_76",
  "title-icon": "_title-icon_10jad_81",
  "title-icon-warning": "_title-icon-warning_10jad_81",
  "title-icon-info": "_title-icon-info_10jad_87",
  title: Q_,
  "message-and-btn": "_message-and-btn_10jad_102",
  "message-style": "_message-style_10jad_108",
  "check-box-styles": "_check-box-styles_10jad_116",
  footer: J_,
  "btn-styles": "_btn-styles_10jad_122",
  "btn-ind-style": "_btn-ind-style_10jad_126"
}, em = ["warning", "info"], tm = {
  name: "alertBox",
  props: {
    /**
     * checkbox click handler
     */
    checkBoxHandler: Function,
    /**
     * true: show alert box, false: hide alert box
     */
    showAlertBox: {
      type: Boolean,
      default: !0
    },
    /**
     * title of alert box
     */
    title: String,
    /**
     * true: display checkbox, false: remove checkbox
     */
    checkbox: {
      type: Boolean,
      default: !1
    },
    /**
     * label value of checkbox
     */
    checkboxLabel: {
      type: String,
      default: "Don't show this warning again."
    },
    /**
     * true: show close button, false: hide close button
     */
    showCloseButton: {
      type: Boolean,
      default: !1
    },
    styleProps: String,
    /**
     * set title icon (warning, info,'URL')
     */
    titleIconUrl: {
      type: String,
      default: "warning"
    },
    /**
     * close button click handler
     */
    onClose: Function
  },
  components: {
    CheckboxButton: bd
  },
  computed: {
    /**
     *  return style for title icon (warning, info)
     */
    computeTitleIcon() {
      return `title-icon title-icon-${this.titleIconUrl}`;
    },
    /**
     * this will return url other than warning and info
     */
    getIconUrl() {
      return em.includes(this.titleIconUrl.toLowerCase()) ? "" : this.titleIconUrl;
    },
    /**
     * returns class for display/hide alert box
     */
    showAlertBoxStyle() {
      return this.showAlertBox ? null : Oc["show-alert-box"];
    },
    /**
     * returns class for display/hide close button in alert box
     */
    showCloseButtonStyle() {
      return this.showCloseButton ? null : Oc["show-close-button"];
    }
  },
  data() {
    return {
      active: !1
    };
  },
  methods: {
    /**
     * on close handler hides
     */
    handleClose() {
      this.$nextTick(() => {
        var i;
        (i = this.onClose) == null || i.call(this);
      });
    },
    /**
     * check box click handler
     */
    handleCheckboxClick() {
      this.$nextTick(() => {
        var i;
        this.active = !this.active, (i = this.checkBoxHandler) == null || i.call(this, this.active);
      });
    }
  }
};
var im = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    class: [i.$style["emdn-alert-box-modal-root"], i.showAlertBoxStyle]
  }, [t("div", {
    class: [i.$style["alert-box-modal-mask"], i.showAlertBoxStyle],
    on: {
      click: function(s) {
        return s.target !== s.currentTarget ? null : i.handleClose.apply(null, arguments);
      }
    }
  }, [t("div", {
    class: [i.$style["alert-box-modal-wrap"], i.$style["alert-box-modal-centered"], i.showAlertBoxStyle],
    attrs: {
      tabindex: "-1",
      role: "dialog"
    }
  }, [t("div", {
    class: i.$style["alert-box-modal"],
    style: i.styleProps,
    attrs: {
      role: "document"
    }
  }, [t("div", {
    class: i.$style["alert-box-indexed"],
    attrs: {
      tabindex: "0",
      "aria-hidden": "true"
    }
  }), t("div", {
    class: i.$style["custom-modal-body-user"]
  }, [t("div", {
    class: [i.$style["close-btn"], i.showCloseButtonStyle]
  }, [t("div", {
    class: [i.$style["t-close-button"], i.$style["close-button"]],
    attrs: {
      "aria-hidden": "true"
    },
    on: {
      click: function(s) {
        return s.stopPropagation(), i.handleClose.apply(null, arguments);
      }
    }
  }, [t("span", {
    class: i.$style["t-icon-close"]
  })])]), t("div", {
    class: i.$style["modal-body"]
  }, [t("div", {
    class: i.$style["content-div"]
  }, [t("div", {
    class: i.$style["main-title"]
  }, [t("img", {
    class: [i.$style["title-icon"], i.$style[`title-icon-${i.titleIconUrl}`]],
    attrs: {
      src: i.getIconUrl
    }
  }), t("span", {
    class: i.$style.title
  }, [i._v(i._s(i.title))])]), t("div", {
    class: i.$style["message-and-btn"]
  }, [t("div", [t("span", {
    class: i.$style["message-style"]
  }, [i._t("messagebody")], 2), i.checkbox ? t("div", {
    class: i.$style["check-box-styles"]
  }, [t("checkbox-button", {
    attrs: {
      "button-type": "check_list",
      "label-text": i.checkboxLabel,
      size: "small",
      "click-handler": i.handleCheckboxClick,
      active: i.active
    }
  })], 1) : i._e()])])]), t("div", {
    class: i.$style.footer
  }, [t("div", {
    class: i.$style["btn-styles"]
  }, [t("div", {
    class: i.$style["btn-ind-style"]
  }, [i._t("successbutton")], 2), t("div", {
    class: i.$style["btn-ind-style"]
  }, [i._t("rejectbutton")], 2)])])])])])])])]);
}, sm = [];
const rm = "_title_10jad_81", nm = "_footer_10jad_119", am = {
  "show-alert-box": "_show-alert-box_10jad_1",
  "emdn-alert-box-modal-root": "_emdn-alert-box-modal-root_10jad_5",
  "alert-box-modal-mask": "_alert-box-modal-mask_10jad_8",
  "alert-box-modal-wrap": "_alert-box-modal-wrap_10jad_21",
  "alert-box-modal-centered": "_alert-box-modal-centered_10jad_24",
  "alert-box-modal": "_alert-box-modal_10jad_8",
  "alert-box-indexed": "_alert-box-indexed_10jad_30",
  "custom-modal-body-user": "_custom-modal-body-user_10jad_35",
  "close-btn": "_close-btn_10jad_42",
  "show-close-button": "_show-close-button_10jad_48",
  "t-close-button": "_t-close-button_10jad_51",
  "t-icon-close": "_t-icon-close_10jad_58",
  "modal-body": "_modal-body_10jad_65",
  "content-div": "_content-div_10jad_73",
  "main-title": "_main-title_10jad_76",
  "title-icon": "_title-icon_10jad_81",
  "title-icon-warning": "_title-icon-warning_10jad_81",
  "title-icon-info": "_title-icon-info_10jad_87",
  title: rm,
  "message-and-btn": "_message-and-btn_10jad_102",
  "message-style": "_message-style_10jad_108",
  "check-box-styles": "_check-box-styles_10jad_116",
  footer: nm,
  "btn-styles": "_btn-styles_10jad_122",
  "btn-ind-style": "_btn-ind-style_10jad_126"
}, _l = {};
_l.$style = am;
var om = /* @__PURE__ */ X(
  tm,
  im,
  sm,
  !1,
  lm,
  null,
  null,
  null
);
function lm(i) {
  for (let e in _l)
    this[e] = _l[e];
}
const TN = /* @__PURE__ */ function() {
  return om.exports;
}();
//! moment.js
//! version : 2.29.4
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com
var yd;
function I() {
  return yd.apply(null, arguments);
}
function um(i) {
  yd = i;
}
function ii(i) {
  return i instanceof Array || Object.prototype.toString.call(i) === "[object Array]";
}
function Cs(i) {
  return i != null && Object.prototype.toString.call(i) === "[object Object]";
}
function xe(i, e) {
  return Object.prototype.hasOwnProperty.call(i, e);
}
function Iu(i) {
  if (Object.getOwnPropertyNames)
    return Object.getOwnPropertyNames(i).length === 0;
  var e;
  for (e in i)
    if (xe(i, e))
      return !1;
  return !0;
}
function wt(i) {
  return i === void 0;
}
function Pi(i) {
  return typeof i == "number" || Object.prototype.toString.call(i) === "[object Number]";
}
function vn(i) {
  return i instanceof Date || Object.prototype.toString.call(i) === "[object Date]";
}
function vd(i, e) {
  var t = [], s, r = i.length;
  for (s = 0; s < r; ++s)
    t.push(e(i[s], s));
  return t;
}
function Fi(i, e) {
  for (var t in e)
    xe(e, t) && (i[t] = e[t]);
  return xe(e, "toString") && (i.toString = e.toString), xe(e, "valueOf") && (i.valueOf = e.valueOf), i;
}
function mi(i, e, t, s) {
  return Vd(i, e, t, s, !0).utc();
}
function cm() {
  return {
    empty: !1,
    unusedTokens: [],
    unusedInput: [],
    overflow: -2,
    charsLeftOver: 0,
    nullInput: !1,
    invalidEra: null,
    invalidMonth: null,
    invalidFormat: !1,
    userInvalidated: !1,
    iso: !1,
    parsedDateParts: [],
    era: null,
    meridiem: null,
    rfc2822: !1,
    weekdayMismatch: !1
  };
}
function ue(i) {
  return i._pf == null && (i._pf = cm()), i._pf;
}
var ml;
Array.prototype.some ? ml = Array.prototype.some : ml = function(i) {
  var e = Object(this), t = e.length >>> 0, s;
  for (s = 0; s < t; s++)
    if (s in e && i.call(this, e[s], s, e))
      return !0;
  return !1;
};
function Eu(i) {
  if (i._isValid == null) {
    var e = ue(i), t = ml.call(e.parsedDateParts, function(r) {
      return r != null;
    }), s = !isNaN(i._d.getTime()) && e.overflow < 0 && !e.empty && !e.invalidEra && !e.invalidMonth && !e.invalidWeekday && !e.weekdayMismatch && !e.nullInput && !e.invalidFormat && !e.userInvalidated && (!e.meridiem || e.meridiem && t);
    if (i._strict && (s = s && e.charsLeftOver === 0 && e.unusedTokens.length === 0 && e.bigHour === void 0), Object.isFrozen == null || !Object.isFrozen(i))
      i._isValid = s;
    else
      return s;
  }
  return i._isValid;
}
function ho(i) {
  var e = mi(NaN);
  return i != null ? Fi(ue(e), i) : ue(e).userInvalidated = !0, e;
}
var Mc = I.momentProperties = [], Fo = !1;
function Ru(i, e) {
  var t, s, r, n = Mc.length;
  if (wt(e._isAMomentObject) || (i._isAMomentObject = e._isAMomentObject), wt(e._i) || (i._i = e._i), wt(e._f) || (i._f = e._f), wt(e._l) || (i._l = e._l), wt(e._strict) || (i._strict = e._strict), wt(e._tzm) || (i._tzm = e._tzm), wt(e._isUTC) || (i._isUTC = e._isUTC), wt(e._offset) || (i._offset = e._offset), wt(e._pf) || (i._pf = ue(e)), wt(e._locale) || (i._locale = e._locale), n > 0)
    for (t = 0; t < n; t++)
      s = Mc[t], r = e[s], wt(r) || (i[s] = r);
  return i;
}
function xn(i) {
  Ru(this, i), this._d = new Date(i._d != null ? i._d.getTime() : NaN), this.isValid() || (this._d = /* @__PURE__ */ new Date(NaN)), Fo === !1 && (Fo = !0, I.updateOffset(this), Fo = !1);
}
function si(i) {
  return i instanceof xn || i != null && i._isAMomentObject != null;
}
function xd(i) {
  I.suppressDeprecationWarnings === !1 && typeof console < "u" && console.warn && console.warn("Deprecation warning: " + i);
}
function Gt(i, e) {
  var t = !0;
  return Fi(function() {
    if (I.deprecationHandler != null && I.deprecationHandler(null, i), t) {
      var s = [], r, n, a, o = arguments.length;
      for (n = 0; n < o; n++) {
        if (r = "", typeof arguments[n] == "object") {
          r += `
[` + n + "] ";
          for (a in arguments[0])
            xe(arguments[0], a) && (r += a + ": " + arguments[0][a] + ", ");
          r = r.slice(0, -2);
        } else
          r = arguments[n];
        s.push(r);
      }
      xd(
        i + `
Arguments: ` + Array.prototype.slice.call(s).join("") + `
` + new Error().stack
      ), t = !1;
    }
    return e.apply(this, arguments);
  }, e);
}
var Ac = {};
function wd(i, e) {
  I.deprecationHandler != null && I.deprecationHandler(i, e), Ac[i] || (xd(e), Ac[i] = !0);
}
I.suppressDeprecationWarnings = !1;
I.deprecationHandler = null;
function bi(i) {
  return typeof Function < "u" && i instanceof Function || Object.prototype.toString.call(i) === "[object Function]";
}
function hm(i) {
  var e, t;
  for (t in i)
    xe(i, t) && (e = i[t], bi(e) ? this[t] = e : this["_" + t] = e);
  this._config = i, this._dayOfMonthOrdinalParseLenient = new RegExp(
    (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source
  );
}
function bl(i, e) {
  var t = Fi({}, i), s;
  for (s in e)
    xe(e, s) && (Cs(i[s]) && Cs(e[s]) ? (t[s] = {}, Fi(t[s], i[s]), Fi(t[s], e[s])) : e[s] != null ? t[s] = e[s] : delete t[s]);
  for (s in i)
    xe(i, s) && !xe(e, s) && Cs(i[s]) && (t[s] = Fi({}, t[s]));
  return t;
}
function $u(i) {
  i != null && this.set(i);
}
var yl;
Object.keys ? yl = Object.keys : yl = function(i) {
  var e, t = [];
  for (e in i)
    xe(i, e) && t.push(e);
  return t;
};
var dm = {
  sameDay: "[Today at] LT",
  nextDay: "[Tomorrow at] LT",
  nextWeek: "dddd [at] LT",
  lastDay: "[Yesterday at] LT",
  lastWeek: "[Last] dddd [at] LT",
  sameElse: "L"
};
function fm(i, e, t) {
  var s = this._calendar[i] || this._calendar.sameElse;
  return bi(s) ? s.call(e, t) : s;
}
function di(i, e, t) {
  var s = "" + Math.abs(i), r = e - s.length, n = i >= 0;
  return (n ? t ? "+" : "" : "-") + Math.pow(10, Math.max(0, r)).toString().substr(1) + s;
}
var Nu = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, Ln = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, Yo = {}, tr = {};
function J(i, e, t, s) {
  var r = s;
  typeof s == "string" && (r = function() {
    return this[s]();
  }), i && (tr[i] = r), e && (tr[e[0]] = function() {
    return di(r.apply(this, arguments), e[1], e[2]);
  }), t && (tr[t] = function() {
    return this.localeData().ordinal(
      r.apply(this, arguments),
      i
    );
  });
}
function pm(i) {
  return i.match(/\[[\s\S]/) ? i.replace(/^\[|\]$/g, "") : i.replace(/\\/g, "");
}
function gm(i) {
  var e = i.match(Nu), t, s;
  for (t = 0, s = e.length; t < s; t++)
    tr[e[t]] ? e[t] = tr[e[t]] : e[t] = pm(e[t]);
  return function(r) {
    var n = "", a;
    for (a = 0; a < s; a++)
      n += bi(e[a]) ? e[a].call(r, i) : e[a];
    return n;
  };
}
function Kn(i, e) {
  return i.isValid() ? (e = Sd(e, i.localeData()), Yo[e] = Yo[e] || gm(e), Yo[e](i)) : i.localeData().invalidDate();
}
function Sd(i, e) {
  var t = 5;
  function s(r) {
    return e.longDateFormat(r) || r;
  }
  for (Ln.lastIndex = 0; t >= 0 && Ln.test(i); )
    i = i.replace(
      Ln,
      s
    ), Ln.lastIndex = 0, t -= 1;
  return i;
}
var _m = {
  LTS: "h:mm:ss A",
  LT: "h:mm A",
  L: "MM/DD/YYYY",
  LL: "MMMM D, YYYY",
  LLL: "MMMM D, YYYY h:mm A",
  LLLL: "dddd, MMMM D, YYYY h:mm A"
};
function mm(i) {
  var e = this._longDateFormat[i], t = this._longDateFormat[i.toUpperCase()];
  return e || !t ? e : (this._longDateFormat[i] = t.match(Nu).map(function(s) {
    return s === "MMMM" || s === "MM" || s === "DD" || s === "dddd" ? s.slice(1) : s;
  }).join(""), this._longDateFormat[i]);
}
var bm = "Invalid date";
function ym() {
  return this._invalidDate;
}
var vm = "%d", xm = /\d{1,2}/;
function wm(i) {
  return this._ordinal.replace("%d", i);
}
var Sm = {
  future: "in %s",
  past: "%s ago",
  s: "a few seconds",
  ss: "%d seconds",
  m: "a minute",
  mm: "%d minutes",
  h: "an hour",
  hh: "%d hours",
  d: "a day",
  dd: "%d days",
  w: "a week",
  ww: "%d weeks",
  M: "a month",
  MM: "%d months",
  y: "a year",
  yy: "%d years"
};
function Dm(i, e, t, s) {
  var r = this._relativeTime[t];
  return bi(r) ? r(i, e, t, s) : r.replace(/%d/i, i);
}
function Cm(i, e) {
  var t = this._relativeTime[i > 0 ? "future" : "past"];
  return bi(t) ? t(e) : t.replace(/%s/i, e);
}
var Wr = {};
function _t(i, e) {
  var t = i.toLowerCase();
  Wr[t] = Wr[t + "s"] = Wr[e] = i;
}
function Zt(i) {
  return typeof i == "string" ? Wr[i] || Wr[i.toLowerCase()] : void 0;
}
function Fu(i) {
  var e = {}, t, s;
  for (s in i)
    xe(i, s) && (t = Zt(s), t && (e[t] = i[s]));
  return e;
}
var Dd = {};
function mt(i, e) {
  Dd[i] = e;
}
function Tm(i) {
  var e = [], t;
  for (t in i)
    xe(i, t) && e.push({ unit: t, priority: Dd[t] });
  return e.sort(function(s, r) {
    return s.priority - r.priority;
  }), e;
}
function fo(i) {
  return i % 4 === 0 && i % 100 !== 0 || i % 400 === 0;
}
function Yt(i) {
  return i < 0 ? Math.ceil(i) || 0 : Math.floor(i);
}
function pe(i) {
  var e = +i, t = 0;
  return e !== 0 && isFinite(e) && (t = Yt(e)), t;
}
function Dr(i, e) {
  return function(t) {
    return t != null ? (Cd(this, i, t), I.updateOffset(this, e), this) : da(this, i);
  };
}
function da(i, e) {
  return i.isValid() ? i._d["get" + (i._isUTC ? "UTC" : "") + e]() : NaN;
}
function Cd(i, e, t) {
  i.isValid() && !isNaN(t) && (e === "FullYear" && fo(i.year()) && i.month() === 1 && i.date() === 29 ? (t = pe(t), i._d["set" + (i._isUTC ? "UTC" : "") + e](
    t,
    i.month(),
    yo(t, i.month())
  )) : i._d["set" + (i._isUTC ? "UTC" : "") + e](t));
}
function km(i) {
  return i = Zt(i), bi(this[i]) ? this[i]() : this;
}
function Pm(i, e) {
  if (typeof i == "object") {
    i = Fu(i);
    var t = Tm(i), s, r = t.length;
    for (s = 0; s < r; s++)
      this[t[s].unit](i[t[s].unit]);
  } else if (i = Zt(i), bi(this[i]))
    return this[i](e);
  return this;
}
var Td = /\d/, Nt = /\d\d/, kd = /\d{3}/, Yu = /\d{4}/, po = /[+-]?\d{6}/, Le = /\d\d?/, Pd = /\d\d\d\d?/, Od = /\d\d\d\d\d\d?/, go = /\d{1,3}/, Bu = /\d{1,4}/, _o = /[+-]?\d{1,6}/, Cr = /\d+/, mo = /[+-]?\d+/, Om = /Z|[+-]\d\d:?\d\d/gi, bo = /Z|[+-]\d\d(?::?\d\d)?/gi, Mm = /[+-]?\d+(\.\d{1,3})?/, wn = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, fa;
fa = {};
function W(i, e, t) {
  fa[i] = bi(e) ? e : function(s, r) {
    return s && t ? t : e;
  };
}
function Am(i, e) {
  return xe(fa, i) ? fa[i](e._strict, e._locale) : new RegExp(Lm(i));
}
function Lm(i) {
  return Et(
    i.replace("\\", "").replace(
      /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
      function(e, t, s, r, n) {
        return t || s || r || n;
      }
    )
  );
}
function Et(i) {
  return i.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
}
var vl = {};
function Ce(i, e) {
  var t, s = e, r;
  for (typeof i == "string" && (i = [i]), Pi(e) && (s = function(n, a) {
    a[e] = pe(n);
  }), r = i.length, t = 0; t < r; t++)
    vl[i[t]] = s;
}
function Sn(i, e) {
  Ce(i, function(t, s, r, n) {
    r._w = r._w || {}, e(t, r._w, r, n);
  });
}
function jm(i, e, t) {
  e != null && xe(vl, i) && vl[i](e, t._a, t, i);
}
var ft = 0, xi = 1, ui = 2, Qe = 3, Jt = 4, wi = 5, ws = 6, Im = 7, Em = 8;
function Rm(i, e) {
  return (i % e + e) % e;
}
var He;
Array.prototype.indexOf ? He = Array.prototype.indexOf : He = function(i) {
  var e;
  for (e = 0; e < this.length; ++e)
    if (this[e] === i)
      return e;
  return -1;
};
function yo(i, e) {
  if (isNaN(i) || isNaN(e))
    return NaN;
  var t = Rm(e, 12);
  return i += (e - t) / 12, t === 1 ? fo(i) ? 29 : 28 : 31 - t % 7 % 2;
}
J("M", ["MM", 2], "Mo", function() {
  return this.month() + 1;
});
J("MMM", 0, 0, function(i) {
  return this.localeData().monthsShort(this, i);
});
J("MMMM", 0, 0, function(i) {
  return this.localeData().months(this, i);
});
_t("month", "M");
mt("month", 8);
W("M", Le);
W("MM", Le, Nt);
W("MMM", function(i, e) {
  return e.monthsShortRegex(i);
});
W("MMMM", function(i, e) {
  return e.monthsRegex(i);
});
Ce(["M", "MM"], function(i, e) {
  e[xi] = pe(i) - 1;
});
Ce(["MMM", "MMMM"], function(i, e, t, s) {
  var r = t._locale.monthsParse(i, s, t._strict);
  r != null ? e[xi] = r : ue(t).invalidMonth = i;
});
var $m = "January_February_March_April_May_June_July_August_September_October_November_December".split(
  "_"
), Md = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), Ad = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, Nm = wn, Fm = wn;
function Ym(i, e) {
  return i ? ii(this._months) ? this._months[i.month()] : this._months[(this._months.isFormat || Ad).test(e) ? "format" : "standalone"][i.month()] : ii(this._months) ? this._months : this._months.standalone;
}
function Bm(i, e) {
  return i ? ii(this._monthsShort) ? this._monthsShort[i.month()] : this._monthsShort[Ad.test(e) ? "format" : "standalone"][i.month()] : ii(this._monthsShort) ? this._monthsShort : this._monthsShort.standalone;
}
function Hm(i, e, t) {
  var s, r, n, a = i.toLocaleLowerCase();
  if (!this._monthsParse)
    for (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = [], s = 0; s < 12; ++s)
      n = mi([2e3, s]), this._shortMonthsParse[s] = this.monthsShort(
        n,
        ""
      ).toLocaleLowerCase(), this._longMonthsParse[s] = this.months(n, "").toLocaleLowerCase();
  return t ? e === "MMM" ? (r = He.call(this._shortMonthsParse, a), r !== -1 ? r : null) : (r = He.call(this._longMonthsParse, a), r !== -1 ? r : null) : e === "MMM" ? (r = He.call(this._shortMonthsParse, a), r !== -1 ? r : (r = He.call(this._longMonthsParse, a), r !== -1 ? r : null)) : (r = He.call(this._longMonthsParse, a), r !== -1 ? r : (r = He.call(this._shortMonthsParse, a), r !== -1 ? r : null));
}
function zm(i, e, t) {
  var s, r, n;
  if (this._monthsParseExact)
    return Hm.call(this, i, e, t);
  for (this._monthsParse || (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = []), s = 0; s < 12; s++) {
    if (r = mi([2e3, s]), t && !this._longMonthsParse[s] && (this._longMonthsParse[s] = new RegExp(
      "^" + this.months(r, "").replace(".", "") + "$",
      "i"
    ), this._shortMonthsParse[s] = new RegExp(
      "^" + this.monthsShort(r, "").replace(".", "") + "$",
      "i"
    )), !t && !this._monthsParse[s] && (n = "^" + this.months(r, "") + "|^" + this.monthsShort(r, ""), this._monthsParse[s] = new RegExp(n.replace(".", ""), "i")), t && e === "MMMM" && this._longMonthsParse[s].test(i))
      return s;
    if (t && e === "MMM" && this._shortMonthsParse[s].test(i))
      return s;
    if (!t && this._monthsParse[s].test(i))
      return s;
  }
}
function Ld(i, e) {
  var t;
  if (!i.isValid())
    return i;
  if (typeof e == "string") {
    if (/^\d+$/.test(e))
      e = pe(e);
    else if (e = i.localeData().monthsParse(e), !Pi(e))
      return i;
  }
  return t = Math.min(i.date(), yo(i.year(), e)), i._d["set" + (i._isUTC ? "UTC" : "") + "Month"](e, t), i;
}
function jd(i) {
  return i != null ? (Ld(this, i), I.updateOffset(this, !0), this) : da(this, "Month");
}
function Vm() {
  return yo(this.year(), this.month());
}
function Xm(i) {
  return this._monthsParseExact ? (xe(this, "_monthsRegex") || Id.call(this), i ? this._monthsShortStrictRegex : this._monthsShortRegex) : (xe(this, "_monthsShortRegex") || (this._monthsShortRegex = Nm), this._monthsShortStrictRegex && i ? this._monthsShortStrictRegex : this._monthsShortRegex);
}
function Wm(i) {
  return this._monthsParseExact ? (xe(this, "_monthsRegex") || Id.call(this), i ? this._monthsStrictRegex : this._monthsRegex) : (xe(this, "_monthsRegex") || (this._monthsRegex = Fm), this._monthsStrictRegex && i ? this._monthsStrictRegex : this._monthsRegex);
}
function Id() {
  function i(a, o) {
    return o.length - a.length;
  }
  var e = [], t = [], s = [], r, n;
  for (r = 0; r < 12; r++)
    n = mi([2e3, r]), e.push(this.monthsShort(n, "")), t.push(this.months(n, "")), s.push(this.months(n, "")), s.push(this.monthsShort(n, ""));
  for (e.sort(i), t.sort(i), s.sort(i), r = 0; r < 12; r++)
    e[r] = Et(e[r]), t[r] = Et(t[r]);
  for (r = 0; r < 24; r++)
    s[r] = Et(s[r]);
  this._monthsRegex = new RegExp("^(" + s.join("|") + ")", "i"), this._monthsShortRegex = this._monthsRegex, this._monthsStrictRegex = new RegExp(
    "^(" + t.join("|") + ")",
    "i"
  ), this._monthsShortStrictRegex = new RegExp(
    "^(" + e.join("|") + ")",
    "i"
  );
}
J("Y", 0, 0, function() {
  var i = this.year();
  return i <= 9999 ? di(i, 4) : "+" + i;
});
J(0, ["YY", 2], 0, function() {
  return this.year() % 100;
});
J(0, ["YYYY", 4], 0, "year");
J(0, ["YYYYY", 5], 0, "year");
J(0, ["YYYYYY", 6, !0], 0, "year");
_t("year", "y");
mt("year", 1);
W("Y", mo);
W("YY", Le, Nt);
W("YYYY", Bu, Yu);
W("YYYYY", _o, po);
W("YYYYYY", _o, po);
Ce(["YYYYY", "YYYYYY"], ft);
Ce("YYYY", function(i, e) {
  e[ft] = i.length === 2 ? I.parseTwoDigitYear(i) : pe(i);
});
Ce("YY", function(i, e) {
  e[ft] = I.parseTwoDigitYear(i);
});
Ce("Y", function(i, e) {
  e[ft] = parseInt(i, 10);
});
function Ur(i) {
  return fo(i) ? 366 : 365;
}
I.parseTwoDigitYear = function(i) {
  return pe(i) + (pe(i) > 68 ? 1900 : 2e3);
};
var Ed = Dr("FullYear", !0);
function Um() {
  return fo(this.year());
}
function Gm(i, e, t, s, r, n, a) {
  var o;
  return i < 100 && i >= 0 ? (o = new Date(i + 400, e, t, s, r, n, a), isFinite(o.getFullYear()) && o.setFullYear(i)) : o = new Date(i, e, t, s, r, n, a), o;
}
function tn(i) {
  var e, t;
  return i < 100 && i >= 0 ? (t = Array.prototype.slice.call(arguments), t[0] = i + 400, e = new Date(Date.UTC.apply(null, t)), isFinite(e.getUTCFullYear()) && e.setUTCFullYear(i)) : e = new Date(Date.UTC.apply(null, arguments)), e;
}
function pa(i, e, t) {
  var s = 7 + e - t, r = (7 + tn(i, 0, s).getUTCDay() - e) % 7;
  return -r + s - 1;
}
function Rd(i, e, t, s, r) {
  var n = (7 + t - s) % 7, a = pa(i, s, r), o = 1 + 7 * (e - 1) + n + a, l, u;
  return o <= 0 ? (l = i - 1, u = Ur(l) + o) : o > Ur(i) ? (l = i + 1, u = o - Ur(i)) : (l = i, u = o), {
    year: l,
    dayOfYear: u
  };
}
function sn(i, e, t) {
  var s = pa(i.year(), e, t), r = Math.floor((i.dayOfYear() - s - 1) / 7) + 1, n, a;
  return r < 1 ? (a = i.year() - 1, n = r + Si(a, e, t)) : r > Si(i.year(), e, t) ? (n = r - Si(i.year(), e, t), a = i.year() + 1) : (a = i.year(), n = r), {
    week: n,
    year: a
  };
}
function Si(i, e, t) {
  var s = pa(i, e, t), r = pa(i + 1, e, t);
  return (Ur(i) - s + r) / 7;
}
J("w", ["ww", 2], "wo", "week");
J("W", ["WW", 2], "Wo", "isoWeek");
_t("week", "w");
_t("isoWeek", "W");
mt("week", 5);
mt("isoWeek", 5);
W("w", Le);
W("ww", Le, Nt);
W("W", Le);
W("WW", Le, Nt);
Sn(
  ["w", "ww", "W", "WW"],
  function(i, e, t, s) {
    e[s.substr(0, 1)] = pe(i);
  }
);
function Zm(i) {
  return sn(i, this._week.dow, this._week.doy).week;
}
var Km = {
  dow: 0,
  // Sunday is the first day of the week.
  doy: 6
  // The week that contains Jan 6th is the first week of the year.
};
function qm() {
  return this._week.dow;
}
function Qm() {
  return this._week.doy;
}
function Jm(i) {
  var e = this.localeData().week(this);
  return i == null ? e : this.add((i - e) * 7, "d");
}
function eb(i) {
  var e = sn(this, 1, 4).week;
  return i == null ? e : this.add((i - e) * 7, "d");
}
J("d", 0, "do", "day");
J("dd", 0, 0, function(i) {
  return this.localeData().weekdaysMin(this, i);
});
J("ddd", 0, 0, function(i) {
  return this.localeData().weekdaysShort(this, i);
});
J("dddd", 0, 0, function(i) {
  return this.localeData().weekdays(this, i);
});
J("e", 0, 0, "weekday");
J("E", 0, 0, "isoWeekday");
_t("day", "d");
_t("weekday", "e");
_t("isoWeekday", "E");
mt("day", 11);
mt("weekday", 11);
mt("isoWeekday", 11);
W("d", Le);
W("e", Le);
W("E", Le);
W("dd", function(i, e) {
  return e.weekdaysMinRegex(i);
});
W("ddd", function(i, e) {
  return e.weekdaysShortRegex(i);
});
W("dddd", function(i, e) {
  return e.weekdaysRegex(i);
});
Sn(["dd", "ddd", "dddd"], function(i, e, t, s) {
  var r = t._locale.weekdaysParse(i, s, t._strict);
  r != null ? e.d = r : ue(t).invalidWeekday = i;
});
Sn(["d", "e", "E"], function(i, e, t, s) {
  e[s] = pe(i);
});
function tb(i, e) {
  return typeof i != "string" ? i : isNaN(i) ? (i = e.weekdaysParse(i), typeof i == "number" ? i : null) : parseInt(i, 10);
}
function ib(i, e) {
  return typeof i == "string" ? e.weekdaysParse(i) % 7 || 7 : isNaN(i) ? null : i;
}
function Hu(i, e) {
  return i.slice(e, 7).concat(i.slice(0, e));
}
var sb = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), $d = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), rb = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), nb = wn, ab = wn, ob = wn;
function lb(i, e) {
  var t = ii(this._weekdays) ? this._weekdays : this._weekdays[i && i !== !0 && this._weekdays.isFormat.test(e) ? "format" : "standalone"];
  return i === !0 ? Hu(t, this._week.dow) : i ? t[i.day()] : t;
}
function ub(i) {
  return i === !0 ? Hu(this._weekdaysShort, this._week.dow) : i ? this._weekdaysShort[i.day()] : this._weekdaysShort;
}
function cb(i) {
  return i === !0 ? Hu(this._weekdaysMin, this._week.dow) : i ? this._weekdaysMin[i.day()] : this._weekdaysMin;
}
function hb(i, e, t) {
  var s, r, n, a = i.toLocaleLowerCase();
  if (!this._weekdaysParse)
    for (this._weekdaysParse = [], this._shortWeekdaysParse = [], this._minWeekdaysParse = [], s = 0; s < 7; ++s)
      n = mi([2e3, 1]).day(s), this._minWeekdaysParse[s] = this.weekdaysMin(
        n,
        ""
      ).toLocaleLowerCase(), this._shortWeekdaysParse[s] = this.weekdaysShort(
        n,
        ""
      ).toLocaleLowerCase(), this._weekdaysParse[s] = this.weekdays(n, "").toLocaleLowerCase();
  return t ? e === "dddd" ? (r = He.call(this._weekdaysParse, a), r !== -1 ? r : null) : e === "ddd" ? (r = He.call(this._shortWeekdaysParse, a), r !== -1 ? r : null) : (r = He.call(this._minWeekdaysParse, a), r !== -1 ? r : null) : e === "dddd" ? (r = He.call(this._weekdaysParse, a), r !== -1 || (r = He.call(this._shortWeekdaysParse, a), r !== -1) ? r : (r = He.call(this._minWeekdaysParse, a), r !== -1 ? r : null)) : e === "ddd" ? (r = He.call(this._shortWeekdaysParse, a), r !== -1 || (r = He.call(this._weekdaysParse, a), r !== -1) ? r : (r = He.call(this._minWeekdaysParse, a), r !== -1 ? r : null)) : (r = He.call(this._minWeekdaysParse, a), r !== -1 || (r = He.call(this._weekdaysParse, a), r !== -1) ? r : (r = He.call(this._shortWeekdaysParse, a), r !== -1 ? r : null));
}
function db(i, e, t) {
  var s, r, n;
  if (this._weekdaysParseExact)
    return hb.call(this, i, e, t);
  for (this._weekdaysParse || (this._weekdaysParse = [], this._minWeekdaysParse = [], this._shortWeekdaysParse = [], this._fullWeekdaysParse = []), s = 0; s < 7; s++) {
    if (r = mi([2e3, 1]).day(s), t && !this._fullWeekdaysParse[s] && (this._fullWeekdaysParse[s] = new RegExp(
      "^" + this.weekdays(r, "").replace(".", "\\.?") + "$",
      "i"
    ), this._shortWeekdaysParse[s] = new RegExp(
      "^" + this.weekdaysShort(r, "").replace(".", "\\.?") + "$",
      "i"
    ), this._minWeekdaysParse[s] = new RegExp(
      "^" + this.weekdaysMin(r, "").replace(".", "\\.?") + "$",
      "i"
    )), this._weekdaysParse[s] || (n = "^" + this.weekdays(r, "") + "|^" + this.weekdaysShort(r, "") + "|^" + this.weekdaysMin(r, ""), this._weekdaysParse[s] = new RegExp(n.replace(".", ""), "i")), t && e === "dddd" && this._fullWeekdaysParse[s].test(i))
      return s;
    if (t && e === "ddd" && this._shortWeekdaysParse[s].test(i))
      return s;
    if (t && e === "dd" && this._minWeekdaysParse[s].test(i))
      return s;
    if (!t && this._weekdaysParse[s].test(i))
      return s;
  }
}
function fb(i) {
  if (!this.isValid())
    return i != null ? this : NaN;
  var e = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
  return i != null ? (i = tb(i, this.localeData()), this.add(i - e, "d")) : e;
}
function pb(i) {
  if (!this.isValid())
    return i != null ? this : NaN;
  var e = (this.day() + 7 - this.localeData()._week.dow) % 7;
  return i == null ? e : this.add(i - e, "d");
}
function gb(i) {
  if (!this.isValid())
    return i != null ? this : NaN;
  if (i != null) {
    var e = ib(i, this.localeData());
    return this.day(this.day() % 7 ? e : e - 7);
  } else
    return this.day() || 7;
}
function _b(i) {
  return this._weekdaysParseExact ? (xe(this, "_weekdaysRegex") || zu.call(this), i ? this._weekdaysStrictRegex : this._weekdaysRegex) : (xe(this, "_weekdaysRegex") || (this._weekdaysRegex = nb), this._weekdaysStrictRegex && i ? this._weekdaysStrictRegex : this._weekdaysRegex);
}
function mb(i) {
  return this._weekdaysParseExact ? (xe(this, "_weekdaysRegex") || zu.call(this), i ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex) : (xe(this, "_weekdaysShortRegex") || (this._weekdaysShortRegex = ab), this._weekdaysShortStrictRegex && i ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex);
}
function bb(i) {
  return this._weekdaysParseExact ? (xe(this, "_weekdaysRegex") || zu.call(this), i ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex) : (xe(this, "_weekdaysMinRegex") || (this._weekdaysMinRegex = ob), this._weekdaysMinStrictRegex && i ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex);
}
function zu() {
  function i(h, c) {
    return c.length - h.length;
  }
  var e = [], t = [], s = [], r = [], n, a, o, l, u;
  for (n = 0; n < 7; n++)
    a = mi([2e3, 1]).day(n), o = Et(this.weekdaysMin(a, "")), l = Et(this.weekdaysShort(a, "")), u = Et(this.weekdays(a, "")), e.push(o), t.push(l), s.push(u), r.push(o), r.push(l), r.push(u);
  e.sort(i), t.sort(i), s.sort(i), r.sort(i), this._weekdaysRegex = new RegExp("^(" + r.join("|") + ")", "i"), this._weekdaysShortRegex = this._weekdaysRegex, this._weekdaysMinRegex = this._weekdaysRegex, this._weekdaysStrictRegex = new RegExp(
    "^(" + s.join("|") + ")",
    "i"
  ), this._weekdaysShortStrictRegex = new RegExp(
    "^(" + t.join("|") + ")",
    "i"
  ), this._weekdaysMinStrictRegex = new RegExp(
    "^(" + e.join("|") + ")",
    "i"
  );
}
function Vu() {
  return this.hours() % 12 || 12;
}
function yb() {
  return this.hours() || 24;
}
J("H", ["HH", 2], 0, "hour");
J("h", ["hh", 2], 0, Vu);
J("k", ["kk", 2], 0, yb);
J("hmm", 0, 0, function() {
  return "" + Vu.apply(this) + di(this.minutes(), 2);
});
J("hmmss", 0, 0, function() {
  return "" + Vu.apply(this) + di(this.minutes(), 2) + di(this.seconds(), 2);
});
J("Hmm", 0, 0, function() {
  return "" + this.hours() + di(this.minutes(), 2);
});
J("Hmmss", 0, 0, function() {
  return "" + this.hours() + di(this.minutes(), 2) + di(this.seconds(), 2);
});
function Nd(i, e) {
  J(i, 0, 0, function() {
    return this.localeData().meridiem(
      this.hours(),
      this.minutes(),
      e
    );
  });
}
Nd("a", !0);
Nd("A", !1);
_t("hour", "h");
mt("hour", 13);
function Fd(i, e) {
  return e._meridiemParse;
}
W("a", Fd);
W("A", Fd);
W("H", Le);
W("h", Le);
W("k", Le);
W("HH", Le, Nt);
W("hh", Le, Nt);
W("kk", Le, Nt);
W("hmm", Pd);
W("hmmss", Od);
W("Hmm", Pd);
W("Hmmss", Od);
Ce(["H", "HH"], Qe);
Ce(["k", "kk"], function(i, e, t) {
  var s = pe(i);
  e[Qe] = s === 24 ? 0 : s;
});
Ce(["a", "A"], function(i, e, t) {
  t._isPm = t._locale.isPM(i), t._meridiem = i;
});
Ce(["h", "hh"], function(i, e, t) {
  e[Qe] = pe(i), ue(t).bigHour = !0;
});
Ce("hmm", function(i, e, t) {
  var s = i.length - 2;
  e[Qe] = pe(i.substr(0, s)), e[Jt] = pe(i.substr(s)), ue(t).bigHour = !0;
});
Ce("hmmss", function(i, e, t) {
  var s = i.length - 4, r = i.length - 2;
  e[Qe] = pe(i.substr(0, s)), e[Jt] = pe(i.substr(s, 2)), e[wi] = pe(i.substr(r)), ue(t).bigHour = !0;
});
Ce("Hmm", function(i, e, t) {
  var s = i.length - 2;
  e[Qe] = pe(i.substr(0, s)), e[Jt] = pe(i.substr(s));
});
Ce("Hmmss", function(i, e, t) {
  var s = i.length - 4, r = i.length - 2;
  e[Qe] = pe(i.substr(0, s)), e[Jt] = pe(i.substr(s, 2)), e[wi] = pe(i.substr(r));
});
function vb(i) {
  return (i + "").toLowerCase().charAt(0) === "p";
}
var xb = /[ap]\.?m?\.?/i, wb = Dr("Hours", !0);
function Sb(i, e, t) {
  return i > 11 ? t ? "pm" : "PM" : t ? "am" : "AM";
}
var Yd = {
  calendar: dm,
  longDateFormat: _m,
  invalidDate: bm,
  ordinal: vm,
  dayOfMonthOrdinalParse: xm,
  relativeTime: Sm,
  months: $m,
  monthsShort: Md,
  week: Km,
  weekdays: sb,
  weekdaysMin: rb,
  weekdaysShort: $d,
  meridiemParse: xb
}, je = {}, Mr = {}, rn;
function Db(i, e) {
  var t, s = Math.min(i.length, e.length);
  for (t = 0; t < s; t += 1)
    if (i[t] !== e[t])
      return t;
  return s;
}
function Lc(i) {
  return i && i.toLowerCase().replace("_", "-");
}
function Cb(i) {
  for (var e = 0, t, s, r, n; e < i.length; ) {
    for (n = Lc(i[e]).split("-"), t = n.length, s = Lc(i[e + 1]), s = s ? s.split("-") : null; t > 0; ) {
      if (r = vo(n.slice(0, t).join("-")), r)
        return r;
      if (s && s.length >= t && Db(n, s) >= t - 1)
        break;
      t--;
    }
    e++;
  }
  return rn;
}
function Tb(i) {
  return i.match("^[^/\\\\]*$") != null;
}
function vo(i) {
  var e = null, t;
  if (je[i] === void 0 && typeof module < "u" && module && module.exports && Tb(i))
    try {
      e = rn._abbr, t = require, t("./locale/" + i), Xi(e);
    } catch {
      je[i] = null;
    }
  return je[i];
}
function Xi(i, e) {
  var t;
  return i && (wt(e) ? t = Ai(i) : t = Xu(i, e), t ? rn = t : typeof console < "u" && console.warn && console.warn(
    "Locale " + i + " not found. Did you forget to load it?"
  )), rn._abbr;
}
function Xu(i, e) {
  if (e !== null) {
    var t, s = Yd;
    if (e.abbr = i, je[i] != null)
      wd(
        "defineLocaleOverride",
        "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
      ), s = je[i]._config;
    else if (e.parentLocale != null)
      if (je[e.parentLocale] != null)
        s = je[e.parentLocale]._config;
      else if (t = vo(e.parentLocale), t != null)
        s = t._config;
      else
        return Mr[e.parentLocale] || (Mr[e.parentLocale] = []), Mr[e.parentLocale].push({
          name: i,
          config: e
        }), null;
    return je[i] = new $u(bl(s, e)), Mr[i] && Mr[i].forEach(function(r) {
      Xu(r.name, r.config);
    }), Xi(i), je[i];
  } else
    return delete je[i], null;
}
function kb(i, e) {
  if (e != null) {
    var t, s, r = Yd;
    je[i] != null && je[i].parentLocale != null ? je[i].set(bl(je[i]._config, e)) : (s = vo(i), s != null && (r = s._config), e = bl(r, e), s == null && (e.abbr = i), t = new $u(e), t.parentLocale = je[i], je[i] = t), Xi(i);
  } else
    je[i] != null && (je[i].parentLocale != null ? (je[i] = je[i].parentLocale, i === Xi() && Xi(i)) : je[i] != null && delete je[i]);
  return je[i];
}
function Ai(i) {
  var e;
  if (i && i._locale && i._locale._abbr && (i = i._locale._abbr), !i)
    return rn;
  if (!ii(i)) {
    if (e = vo(i), e)
      return e;
    i = [i];
  }
  return Cb(i);
}
function Pb() {
  return yl(je);
}
function Wu(i) {
  var e, t = i._a;
  return t && ue(i).overflow === -2 && (e = t[xi] < 0 || t[xi] > 11 ? xi : t[ui] < 1 || t[ui] > yo(t[ft], t[xi]) ? ui : t[Qe] < 0 || t[Qe] > 24 || t[Qe] === 24 && (t[Jt] !== 0 || t[wi] !== 0 || t[ws] !== 0) ? Qe : t[Jt] < 0 || t[Jt] > 59 ? Jt : t[wi] < 0 || t[wi] > 59 ? wi : t[ws] < 0 || t[ws] > 999 ? ws : -1, ue(i)._overflowDayOfYear && (e < ft || e > ui) && (e = ui), ue(i)._overflowWeeks && e === -1 && (e = Im), ue(i)._overflowWeekday && e === -1 && (e = Em), ue(i).overflow = e), i;
}
var Ob = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, Mb = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, Ab = /Z|[+-]\d\d(?::?\d\d)?/, jn = [
  ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
  ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
  ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
  ["GGGG-[W]WW", /\d{4}-W\d\d/, !1],
  ["YYYY-DDD", /\d{4}-\d{3}/],
  ["YYYY-MM", /\d{4}-\d\d/, !1],
  ["YYYYYYMMDD", /[+-]\d{10}/],
  ["YYYYMMDD", /\d{8}/],
  ["GGGG[W]WWE", /\d{4}W\d{3}/],
  ["GGGG[W]WW", /\d{4}W\d{2}/, !1],
  ["YYYYDDD", /\d{7}/],
  ["YYYYMM", /\d{6}/, !1],
  ["YYYY", /\d{4}/, !1]
], Bo = [
  ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
  ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
  ["HH:mm:ss", /\d\d:\d\d:\d\d/],
  ["HH:mm", /\d\d:\d\d/],
  ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
  ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
  ["HHmmss", /\d\d\d\d\d\d/],
  ["HHmm", /\d\d\d\d/],
  ["HH", /\d\d/]
], Lb = /^\/?Date\((-?\d+)/i, jb = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, Ib = {
  UT: 0,
  GMT: 0,
  EDT: -4 * 60,
  EST: -5 * 60,
  CDT: -5 * 60,
  CST: -6 * 60,
  MDT: -6 * 60,
  MST: -7 * 60,
  PDT: -7 * 60,
  PST: -8 * 60
};
function Bd(i) {
  var e, t, s = i._i, r = Ob.exec(s) || Mb.exec(s), n, a, o, l, u = jn.length, h = Bo.length;
  if (r) {
    for (ue(i).iso = !0, e = 0, t = u; e < t; e++)
      if (jn[e][1].exec(r[1])) {
        a = jn[e][0], n = jn[e][2] !== !1;
        break;
      }
    if (a == null) {
      i._isValid = !1;
      return;
    }
    if (r[3]) {
      for (e = 0, t = h; e < t; e++)
        if (Bo[e][1].exec(r[3])) {
          o = (r[2] || " ") + Bo[e][0];
          break;
        }
      if (o == null) {
        i._isValid = !1;
        return;
      }
    }
    if (!n && o != null) {
      i._isValid = !1;
      return;
    }
    if (r[4])
      if (Ab.exec(r[4]))
        l = "Z";
      else {
        i._isValid = !1;
        return;
      }
    i._f = a + (o || "") + (l || ""), Gu(i);
  } else
    i._isValid = !1;
}
function Eb(i, e, t, s, r, n) {
  var a = [
    Rb(i),
    Md.indexOf(e),
    parseInt(t, 10),
    parseInt(s, 10),
    parseInt(r, 10)
  ];
  return n && a.push(parseInt(n, 10)), a;
}
function Rb(i) {
  var e = parseInt(i, 10);
  return e <= 49 ? 2e3 + e : e <= 999 ? 1900 + e : e;
}
function $b(i) {
  return i.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
}
function Nb(i, e, t) {
  if (i) {
    var s = $d.indexOf(i), r = new Date(
      e[0],
      e[1],
      e[2]
    ).getDay();
    if (s !== r)
      return ue(t).weekdayMismatch = !0, t._isValid = !1, !1;
  }
  return !0;
}
function Fb(i, e, t) {
  if (i)
    return Ib[i];
  if (e)
    return 0;
  var s = parseInt(t, 10), r = s % 100, n = (s - r) / 100;
  return n * 60 + r;
}
function Hd(i) {
  var e = jb.exec($b(i._i)), t;
  if (e) {
    if (t = Eb(
      e[4],
      e[3],
      e[2],
      e[5],
      e[6],
      e[7]
    ), !Nb(e[1], t, i))
      return;
    i._a = t, i._tzm = Fb(e[8], e[9], e[10]), i._d = tn.apply(null, i._a), i._d.setUTCMinutes(i._d.getUTCMinutes() - i._tzm), ue(i).rfc2822 = !0;
  } else
    i._isValid = !1;
}
function Yb(i) {
  var e = Lb.exec(i._i);
  if (e !== null) {
    i._d = /* @__PURE__ */ new Date(+e[1]);
    return;
  }
  if (Bd(i), i._isValid === !1)
    delete i._isValid;
  else
    return;
  if (Hd(i), i._isValid === !1)
    delete i._isValid;
  else
    return;
  i._strict ? i._isValid = !1 : I.createFromInputFallback(i);
}
I.createFromInputFallback = Gt(
  "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
  function(i) {
    i._d = /* @__PURE__ */ new Date(i._i + (i._useUTC ? " UTC" : ""));
  }
);
function Ws(i, e, t) {
  return i ?? e ?? t;
}
function Bb(i) {
  var e = new Date(I.now());
  return i._useUTC ? [
    e.getUTCFullYear(),
    e.getUTCMonth(),
    e.getUTCDate()
  ] : [e.getFullYear(), e.getMonth(), e.getDate()];
}
function Uu(i) {
  var e, t, s = [], r, n, a;
  if (!i._d) {
    for (r = Bb(i), i._w && i._a[ui] == null && i._a[xi] == null && Hb(i), i._dayOfYear != null && (a = Ws(i._a[ft], r[ft]), (i._dayOfYear > Ur(a) || i._dayOfYear === 0) && (ue(i)._overflowDayOfYear = !0), t = tn(a, 0, i._dayOfYear), i._a[xi] = t.getUTCMonth(), i._a[ui] = t.getUTCDate()), e = 0; e < 3 && i._a[e] == null; ++e)
      i._a[e] = s[e] = r[e];
    for (; e < 7; e++)
      i._a[e] = s[e] = i._a[e] == null ? e === 2 ? 1 : 0 : i._a[e];
    i._a[Qe] === 24 && i._a[Jt] === 0 && i._a[wi] === 0 && i._a[ws] === 0 && (i._nextDay = !0, i._a[Qe] = 0), i._d = (i._useUTC ? tn : Gm).apply(
      null,
      s
    ), n = i._useUTC ? i._d.getUTCDay() : i._d.getDay(), i._tzm != null && i._d.setUTCMinutes(i._d.getUTCMinutes() - i._tzm), i._nextDay && (i._a[Qe] = 24), i._w && typeof i._w.d < "u" && i._w.d !== n && (ue(i).weekdayMismatch = !0);
  }
}
function Hb(i) {
  var e, t, s, r, n, a, o, l, u;
  e = i._w, e.GG != null || e.W != null || e.E != null ? (n = 1, a = 4, t = Ws(
    e.GG,
    i._a[ft],
    sn(Ae(), 1, 4).year
  ), s = Ws(e.W, 1), r = Ws(e.E, 1), (r < 1 || r > 7) && (l = !0)) : (n = i._locale._week.dow, a = i._locale._week.doy, u = sn(Ae(), n, a), t = Ws(e.gg, i._a[ft], u.year), s = Ws(e.w, u.week), e.d != null ? (r = e.d, (r < 0 || r > 6) && (l = !0)) : e.e != null ? (r = e.e + n, (e.e < 0 || e.e > 6) && (l = !0)) : r = n), s < 1 || s > Si(t, n, a) ? ue(i)._overflowWeeks = !0 : l != null ? ue(i)._overflowWeekday = !0 : (o = Rd(t, s, r, n, a), i._a[ft] = o.year, i._dayOfYear = o.dayOfYear);
}
I.ISO_8601 = function() {
};
I.RFC_2822 = function() {
};
function Gu(i) {
  if (i._f === I.ISO_8601) {
    Bd(i);
    return;
  }
  if (i._f === I.RFC_2822) {
    Hd(i);
    return;
  }
  i._a = [], ue(i).empty = !0;
  var e = "" + i._i, t, s, r, n, a, o = e.length, l = 0, u, h;
  for (r = Sd(i._f, i._locale).match(Nu) || [], h = r.length, t = 0; t < h; t++)
    n = r[t], s = (e.match(Am(n, i)) || [])[0], s && (a = e.substr(0, e.indexOf(s)), a.length > 0 && ue(i).unusedInput.push(a), e = e.slice(
      e.indexOf(s) + s.length
    ), l += s.length), tr[n] ? (s ? ue(i).empty = !1 : ue(i).unusedTokens.push(n), jm(n, s, i)) : i._strict && !s && ue(i).unusedTokens.push(n);
  ue(i).charsLeftOver = o - l, e.length > 0 && ue(i).unusedInput.push(e), i._a[Qe] <= 12 && ue(i).bigHour === !0 && i._a[Qe] > 0 && (ue(i).bigHour = void 0), ue(i).parsedDateParts = i._a.slice(0), ue(i).meridiem = i._meridiem, i._a[Qe] = zb(
    i._locale,
    i._a[Qe],
    i._meridiem
  ), u = ue(i).era, u !== null && (i._a[ft] = i._locale.erasConvertYear(u, i._a[ft])), Uu(i), Wu(i);
}
function zb(i, e, t) {
  var s;
  return t == null ? e : i.meridiemHour != null ? i.meridiemHour(e, t) : (i.isPM != null && (s = i.isPM(t), s && e < 12 && (e += 12), !s && e === 12 && (e = 0)), e);
}
function Vb(i) {
  var e, t, s, r, n, a, o = !1, l = i._f.length;
  if (l === 0) {
    ue(i).invalidFormat = !0, i._d = /* @__PURE__ */ new Date(NaN);
    return;
  }
  for (r = 0; r < l; r++)
    n = 0, a = !1, e = Ru({}, i), i._useUTC != null && (e._useUTC = i._useUTC), e._f = i._f[r], Gu(e), Eu(e) && (a = !0), n += ue(e).charsLeftOver, n += ue(e).unusedTokens.length * 10, ue(e).score = n, o ? n < s && (s = n, t = e) : (s == null || n < s || a) && (s = n, t = e, a && (o = !0));
  Fi(i, t || e);
}
function Xb(i) {
  if (!i._d) {
    var e = Fu(i._i), t = e.day === void 0 ? e.date : e.day;
    i._a = vd(
      [e.year, e.month, t, e.hour, e.minute, e.second, e.millisecond],
      function(s) {
        return s && parseInt(s, 10);
      }
    ), Uu(i);
  }
}
function Wb(i) {
  var e = new xn(Wu(zd(i)));
  return e._nextDay && (e.add(1, "d"), e._nextDay = void 0), e;
}
function zd(i) {
  var e = i._i, t = i._f;
  return i._locale = i._locale || Ai(i._l), e === null || t === void 0 && e === "" ? ho({ nullInput: !0 }) : (typeof e == "string" && (i._i = e = i._locale.preparse(e)), si(e) ? new xn(Wu(e)) : (vn(e) ? i._d = e : ii(t) ? Vb(i) : t ? Gu(i) : Ub(i), Eu(i) || (i._d = null), i));
}
function Ub(i) {
  var e = i._i;
  wt(e) ? i._d = new Date(I.now()) : vn(e) ? i._d = new Date(e.valueOf()) : typeof e == "string" ? Yb(i) : ii(e) ? (i._a = vd(e.slice(0), function(t) {
    return parseInt(t, 10);
  }), Uu(i)) : Cs(e) ? Xb(i) : Pi(e) ? i._d = new Date(e) : I.createFromInputFallback(i);
}
function Vd(i, e, t, s, r) {
  var n = {};
  return (e === !0 || e === !1) && (s = e, e = void 0), (t === !0 || t === !1) && (s = t, t = void 0), (Cs(i) && Iu(i) || ii(i) && i.length === 0) && (i = void 0), n._isAMomentObject = !0, n._useUTC = n._isUTC = r, n._l = t, n._i = i, n._f = e, n._strict = s, Wb(n);
}
function Ae(i, e, t, s) {
  return Vd(i, e, t, s, !1);
}
var Gb = Gt(
  "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
  function() {
    var i = Ae.apply(null, arguments);
    return this.isValid() && i.isValid() ? i < this ? this : i : ho();
  }
), Zb = Gt(
  "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
  function() {
    var i = Ae.apply(null, arguments);
    return this.isValid() && i.isValid() ? i > this ? this : i : ho();
  }
);
function Xd(i, e) {
  var t, s;
  if (e.length === 1 && ii(e[0]) && (e = e[0]), !e.length)
    return Ae();
  for (t = e[0], s = 1; s < e.length; ++s)
    (!e[s].isValid() || e[s][i](t)) && (t = e[s]);
  return t;
}
function Kb() {
  var i = [].slice.call(arguments, 0);
  return Xd("isBefore", i);
}
function qb() {
  var i = [].slice.call(arguments, 0);
  return Xd("isAfter", i);
}
var Qb = function() {
  return Date.now ? Date.now() : +/* @__PURE__ */ new Date();
}, Ar = [
  "year",
  "quarter",
  "month",
  "week",
  "day",
  "hour",
  "minute",
  "second",
  "millisecond"
];
function Jb(i) {
  var e, t = !1, s, r = Ar.length;
  for (e in i)
    if (xe(i, e) && !(He.call(Ar, e) !== -1 && (i[e] == null || !isNaN(i[e]))))
      return !1;
  for (s = 0; s < r; ++s)
    if (i[Ar[s]]) {
      if (t)
        return !1;
      parseFloat(i[Ar[s]]) !== pe(i[Ar[s]]) && (t = !0);
    }
  return !0;
}
function ey() {
  return this._isValid;
}
function ty() {
  return ni(NaN);
}
function xo(i) {
  var e = Fu(i), t = e.year || 0, s = e.quarter || 0, r = e.month || 0, n = e.week || e.isoWeek || 0, a = e.day || 0, o = e.hour || 0, l = e.minute || 0, u = e.second || 0, h = e.millisecond || 0;
  this._isValid = Jb(e), this._milliseconds = +h + u * 1e3 + // 1000
  l * 6e4 + // 1000 * 60
  o * 1e3 * 60 * 60, this._days = +a + n * 7, this._months = +r + s * 3 + t * 12, this._data = {}, this._locale = Ai(), this._bubble();
}
function qn(i) {
  return i instanceof xo;
}
function xl(i) {
  return i < 0 ? Math.round(-1 * i) * -1 : Math.round(i);
}
function iy(i, e, t) {
  var s = Math.min(i.length, e.length), r = Math.abs(i.length - e.length), n = 0, a;
  for (a = 0; a < s; a++)
    (t && i[a] !== e[a] || !t && pe(i[a]) !== pe(e[a])) && n++;
  return n + r;
}
function Wd(i, e) {
  J(i, 0, 0, function() {
    var t = this.utcOffset(), s = "+";
    return t < 0 && (t = -t, s = "-"), s + di(~~(t / 60), 2) + e + di(~~t % 60, 2);
  });
}
Wd("Z", ":");
Wd("ZZ", "");
W("Z", bo);
W("ZZ", bo);
Ce(["Z", "ZZ"], function(i, e, t) {
  t._useUTC = !0, t._tzm = Zu(bo, i);
});
var sy = /([\+\-]|\d\d)/gi;
function Zu(i, e) {
  var t = (e || "").match(i), s, r, n;
  return t === null ? null : (s = t[t.length - 1] || [], r = (s + "").match(sy) || ["-", 0, 0], n = +(r[1] * 60) + pe(r[2]), n === 0 ? 0 : r[0] === "+" ? n : -n);
}
function Ku(i, e) {
  var t, s;
  return e._isUTC ? (t = e.clone(), s = (si(i) || vn(i) ? i.valueOf() : Ae(i).valueOf()) - t.valueOf(), t._d.setTime(t._d.valueOf() + s), I.updateOffset(t, !1), t) : Ae(i).local();
}
function wl(i) {
  return -Math.round(i._d.getTimezoneOffset());
}
I.updateOffset = function() {
};
function ry(i, e, t) {
  var s = this._offset || 0, r;
  if (!this.isValid())
    return i != null ? this : NaN;
  if (i != null) {
    if (typeof i == "string") {
      if (i = Zu(bo, i), i === null)
        return this;
    } else
      Math.abs(i) < 16 && !t && (i = i * 60);
    return !this._isUTC && e && (r = wl(this)), this._offset = i, this._isUTC = !0, r != null && this.add(r, "m"), s !== i && (!e || this._changeInProgress ? Zd(
      this,
      ni(i - s, "m"),
      1,
      !1
    ) : this._changeInProgress || (this._changeInProgress = !0, I.updateOffset(this, !0), this._changeInProgress = null)), this;
  } else
    return this._isUTC ? s : wl(this);
}
function ny(i, e) {
  return i != null ? (typeof i != "string" && (i = -i), this.utcOffset(i, e), this) : -this.utcOffset();
}
function ay(i) {
  return this.utcOffset(0, i);
}
function oy(i) {
  return this._isUTC && (this.utcOffset(0, i), this._isUTC = !1, i && this.subtract(wl(this), "m")), this;
}
function ly() {
  if (this._tzm != null)
    this.utcOffset(this._tzm, !1, !0);
  else if (typeof this._i == "string") {
    var i = Zu(Om, this._i);
    i != null ? this.utcOffset(i) : this.utcOffset(0, !0);
  }
  return this;
}
function uy(i) {
  return this.isValid() ? (i = i ? Ae(i).utcOffset() : 0, (this.utcOffset() - i) % 60 === 0) : !1;
}
function cy() {
  return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
}
function hy() {
  if (!wt(this._isDSTShifted))
    return this._isDSTShifted;
  var i = {}, e;
  return Ru(i, this), i = zd(i), i._a ? (e = i._isUTC ? mi(i._a) : Ae(i._a), this._isDSTShifted = this.isValid() && iy(i._a, e.toArray()) > 0) : this._isDSTShifted = !1, this._isDSTShifted;
}
function dy() {
  return this.isValid() ? !this._isUTC : !1;
}
function fy() {
  return this.isValid() ? this._isUTC : !1;
}
function Ud() {
  return this.isValid() ? this._isUTC && this._offset === 0 : !1;
}
var py = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, gy = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
function ni(i, e) {
  var t = i, s = null, r, n, a;
  return qn(i) ? t = {
    ms: i._milliseconds,
    d: i._days,
    M: i._months
  } : Pi(i) || !isNaN(+i) ? (t = {}, e ? t[e] = +i : t.milliseconds = +i) : (s = py.exec(i)) ? (r = s[1] === "-" ? -1 : 1, t = {
    y: 0,
    d: pe(s[ui]) * r,
    h: pe(s[Qe]) * r,
    m: pe(s[Jt]) * r,
    s: pe(s[wi]) * r,
    ms: pe(xl(s[ws] * 1e3)) * r
    // the millisecond decimal point is included in the match
  }) : (s = gy.exec(i)) ? (r = s[1] === "-" ? -1 : 1, t = {
    y: ds(s[2], r),
    M: ds(s[3], r),
    w: ds(s[4], r),
    d: ds(s[5], r),
    h: ds(s[6], r),
    m: ds(s[7], r),
    s: ds(s[8], r)
  }) : t == null ? t = {} : typeof t == "object" && ("from" in t || "to" in t) && (a = _y(
    Ae(t.from),
    Ae(t.to)
  ), t = {}, t.ms = a.milliseconds, t.M = a.months), n = new xo(t), qn(i) && xe(i, "_locale") && (n._locale = i._locale), qn(i) && xe(i, "_isValid") && (n._isValid = i._isValid), n;
}
ni.fn = xo.prototype;
ni.invalid = ty;
function ds(i, e) {
  var t = i && parseFloat(i.replace(",", "."));
  return (isNaN(t) ? 0 : t) * e;
}
function jc(i, e) {
  var t = {};
  return t.months = e.month() - i.month() + (e.year() - i.year()) * 12, i.clone().add(t.months, "M").isAfter(e) && --t.months, t.milliseconds = +e - +i.clone().add(t.months, "M"), t;
}
function _y(i, e) {
  var t;
  return i.isValid() && e.isValid() ? (e = Ku(e, i), i.isBefore(e) ? t = jc(i, e) : (t = jc(e, i), t.milliseconds = -t.milliseconds, t.months = -t.months), t) : { milliseconds: 0, months: 0 };
}
function Gd(i, e) {
  return function(t, s) {
    var r, n;
    return s !== null && !isNaN(+s) && (wd(
      e,
      "moment()." + e + "(period, number) is deprecated. Please use moment()." + e + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."
    ), n = t, t = s, s = n), r = ni(t, s), Zd(this, r, i), this;
  };
}
function Zd(i, e, t, s) {
  var r = e._milliseconds, n = xl(e._days), a = xl(e._months);
  i.isValid() && (s = s ?? !0, a && Ld(i, da(i, "Month") + a * t), n && Cd(i, "Date", da(i, "Date") + n * t), r && i._d.setTime(i._d.valueOf() + r * t), s && I.updateOffset(i, n || a));
}
var my = Gd(1, "add"), by = Gd(-1, "subtract");
function Kd(i) {
  return typeof i == "string" || i instanceof String;
}
function yy(i) {
  return si(i) || vn(i) || Kd(i) || Pi(i) || xy(i) || vy(i) || i === null || i === void 0;
}
function vy(i) {
  var e = Cs(i) && !Iu(i), t = !1, s = [
    "years",
    "year",
    "y",
    "months",
    "month",
    "M",
    "days",
    "day",
    "d",
    "dates",
    "date",
    "D",
    "hours",
    "hour",
    "h",
    "minutes",
    "minute",
    "m",
    "seconds",
    "second",
    "s",
    "milliseconds",
    "millisecond",
    "ms"
  ], r, n, a = s.length;
  for (r = 0; r < a; r += 1)
    n = s[r], t = t || xe(i, n);
  return e && t;
}
function xy(i) {
  var e = ii(i), t = !1;
  return e && (t = i.filter(function(s) {
    return !Pi(s) && Kd(i);
  }).length === 0), e && t;
}
function wy(i) {
  var e = Cs(i) && !Iu(i), t = !1, s = [
    "sameDay",
    "nextDay",
    "lastDay",
    "nextWeek",
    "lastWeek",
    "sameElse"
  ], r, n;
  for (r = 0; r < s.length; r += 1)
    n = s[r], t = t || xe(i, n);
  return e && t;
}
function Sy(i, e) {
  var t = i.diff(e, "days", !0);
  return t < -6 ? "sameElse" : t < -1 ? "lastWeek" : t < 0 ? "lastDay" : t < 1 ? "sameDay" : t < 2 ? "nextDay" : t < 7 ? "nextWeek" : "sameElse";
}
function Dy(i, e) {
  arguments.length === 1 && (arguments[0] ? yy(arguments[0]) ? (i = arguments[0], e = void 0) : wy(arguments[0]) && (e = arguments[0], i = void 0) : (i = void 0, e = void 0));
  var t = i || Ae(), s = Ku(t, this).startOf("day"), r = I.calendarFormat(this, s) || "sameElse", n = e && (bi(e[r]) ? e[r].call(this, t) : e[r]);
  return this.format(
    n || this.localeData().calendar(r, this, Ae(t))
  );
}
function Cy() {
  return new xn(this);
}
function Ty(i, e) {
  var t = si(i) ? i : Ae(i);
  return this.isValid() && t.isValid() ? (e = Zt(e) || "millisecond", e === "millisecond" ? this.valueOf() > t.valueOf() : t.valueOf() < this.clone().startOf(e).valueOf()) : !1;
}
function ky(i, e) {
  var t = si(i) ? i : Ae(i);
  return this.isValid() && t.isValid() ? (e = Zt(e) || "millisecond", e === "millisecond" ? this.valueOf() < t.valueOf() : this.clone().endOf(e).valueOf() < t.valueOf()) : !1;
}
function Py(i, e, t, s) {
  var r = si(i) ? i : Ae(i), n = si(e) ? e : Ae(e);
  return this.isValid() && r.isValid() && n.isValid() ? (s = s || "()", (s[0] === "(" ? this.isAfter(r, t) : !this.isBefore(r, t)) && (s[1] === ")" ? this.isBefore(n, t) : !this.isAfter(n, t))) : !1;
}
function Oy(i, e) {
  var t = si(i) ? i : Ae(i), s;
  return this.isValid() && t.isValid() ? (e = Zt(e) || "millisecond", e === "millisecond" ? this.valueOf() === t.valueOf() : (s = t.valueOf(), this.clone().startOf(e).valueOf() <= s && s <= this.clone().endOf(e).valueOf())) : !1;
}
function My(i, e) {
  return this.isSame(i, e) || this.isAfter(i, e);
}
function Ay(i, e) {
  return this.isSame(i, e) || this.isBefore(i, e);
}
function Ly(i, e, t) {
  var s, r, n;
  if (!this.isValid())
    return NaN;
  if (s = Ku(i, this), !s.isValid())
    return NaN;
  switch (r = (s.utcOffset() - this.utcOffset()) * 6e4, e = Zt(e), e) {
    case "year":
      n = Qn(this, s) / 12;
      break;
    case "month":
      n = Qn(this, s);
      break;
    case "quarter":
      n = Qn(this, s) / 3;
      break;
    case "second":
      n = (this - s) / 1e3;
      break;
    case "minute":
      n = (this - s) / 6e4;
      break;
    case "hour":
      n = (this - s) / 36e5;
      break;
    case "day":
      n = (this - s - r) / 864e5;
      break;
    case "week":
      n = (this - s - r) / 6048e5;
      break;
    default:
      n = this - s;
  }
  return t ? n : Yt(n);
}
function Qn(i, e) {
  if (i.date() < e.date())
    return -Qn(e, i);
  var t = (e.year() - i.year()) * 12 + (e.month() - i.month()), s = i.clone().add(t, "months"), r, n;
  return e - s < 0 ? (r = i.clone().add(t - 1, "months"), n = (e - s) / (s - r)) : (r = i.clone().add(t + 1, "months"), n = (e - s) / (r - s)), -(t + n) || 0;
}
I.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
I.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
function jy() {
  return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
}
function Iy(i) {
  if (!this.isValid())
    return null;
  var e = i !== !0, t = e ? this.clone().utc() : this;
  return t.year() < 0 || t.year() > 9999 ? Kn(
    t,
    e ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"
  ) : bi(Date.prototype.toISOString) ? e ? this.toDate().toISOString() : new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", Kn(t, "Z")) : Kn(
    t,
    e ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ"
  );
}
function Ey() {
  if (!this.isValid())
    return "moment.invalid(/* " + this._i + " */)";
  var i = "moment", e = "", t, s, r, n;
  return this.isLocal() || (i = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone", e = "Z"), t = "[" + i + '("]', s = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY", r = "-MM-DD[T]HH:mm:ss.SSS", n = e + '[")]', this.format(t + s + r + n);
}
function Ry(i) {
  i || (i = this.isUtc() ? I.defaultFormatUtc : I.defaultFormat);
  var e = Kn(this, i);
  return this.localeData().postformat(e);
}
function $y(i, e) {
  return this.isValid() && (si(i) && i.isValid() || Ae(i).isValid()) ? ni({ to: this, from: i }).locale(this.locale()).humanize(!e) : this.localeData().invalidDate();
}
function Ny(i) {
  return this.from(Ae(), i);
}
function Fy(i, e) {
  return this.isValid() && (si(i) && i.isValid() || Ae(i).isValid()) ? ni({ from: this, to: i }).locale(this.locale()).humanize(!e) : this.localeData().invalidDate();
}
function Yy(i) {
  return this.to(Ae(), i);
}
function qd(i) {
  var e;
  return i === void 0 ? this._locale._abbr : (e = Ai(i), e != null && (this._locale = e), this);
}
var Qd = Gt(
  "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
  function(i) {
    return i === void 0 ? this.localeData() : this.locale(i);
  }
);
function Jd() {
  return this._locale;
}
var ga = 1e3, ir = 60 * ga, _a = 60 * ir, ef = (365 * 400 + 97) * 24 * _a;
function sr(i, e) {
  return (i % e + e) % e;
}
function tf(i, e, t) {
  return i < 100 && i >= 0 ? new Date(i + 400, e, t) - ef : new Date(i, e, t).valueOf();
}
function sf(i, e, t) {
  return i < 100 && i >= 0 ? Date.UTC(i + 400, e, t) - ef : Date.UTC(i, e, t);
}
function By(i) {
  var e, t;
  if (i = Zt(i), i === void 0 || i === "millisecond" || !this.isValid())
    return this;
  switch (t = this._isUTC ? sf : tf, i) {
    case "year":
      e = t(this.year(), 0, 1);
      break;
    case "quarter":
      e = t(
        this.year(),
        this.month() - this.month() % 3,
        1
      );
      break;
    case "month":
      e = t(this.year(), this.month(), 1);
      break;
    case "week":
      e = t(
        this.year(),
        this.month(),
        this.date() - this.weekday()
      );
      break;
    case "isoWeek":
      e = t(
        this.year(),
        this.month(),
        this.date() - (this.isoWeekday() - 1)
      );
      break;
    case "day":
    case "date":
      e = t(this.year(), this.month(), this.date());
      break;
    case "hour":
      e = this._d.valueOf(), e -= sr(
        e + (this._isUTC ? 0 : this.utcOffset() * ir),
        _a
      );
      break;
    case "minute":
      e = this._d.valueOf(), e -= sr(e, ir);
      break;
    case "second":
      e = this._d.valueOf(), e -= sr(e, ga);
      break;
  }
  return this._d.setTime(e), I.updateOffset(this, !0), this;
}
function Hy(i) {
  var e, t;
  if (i = Zt(i), i === void 0 || i === "millisecond" || !this.isValid())
    return this;
  switch (t = this._isUTC ? sf : tf, i) {
    case "year":
      e = t(this.year() + 1, 0, 1) - 1;
      break;
    case "quarter":
      e = t(
        this.year(),
        this.month() - this.month() % 3 + 3,
        1
      ) - 1;
      break;
    case "month":
      e = t(this.year(), this.month() + 1, 1) - 1;
      break;
    case "week":
      e = t(
        this.year(),
        this.month(),
        this.date() - this.weekday() + 7
      ) - 1;
      break;
    case "isoWeek":
      e = t(
        this.year(),
        this.month(),
        this.date() - (this.isoWeekday() - 1) + 7
      ) - 1;
      break;
    case "day":
    case "date":
      e = t(this.year(), this.month(), this.date() + 1) - 1;
      break;
    case "hour":
      e = this._d.valueOf(), e += _a - sr(
        e + (this._isUTC ? 0 : this.utcOffset() * ir),
        _a
      ) - 1;
      break;
    case "minute":
      e = this._d.valueOf(), e += ir - sr(e, ir) - 1;
      break;
    case "second":
      e = this._d.valueOf(), e += ga - sr(e, ga) - 1;
      break;
  }
  return this._d.setTime(e), I.updateOffset(this, !0), this;
}
function zy() {
  return this._d.valueOf() - (this._offset || 0) * 6e4;
}
function Vy() {
  return Math.floor(this.valueOf() / 1e3);
}
function Xy() {
  return new Date(this.valueOf());
}
function Wy() {
  var i = this;
  return [
    i.year(),
    i.month(),
    i.date(),
    i.hour(),
    i.minute(),
    i.second(),
    i.millisecond()
  ];
}
function Uy() {
  var i = this;
  return {
    years: i.year(),
    months: i.month(),
    date: i.date(),
    hours: i.hours(),
    minutes: i.minutes(),
    seconds: i.seconds(),
    milliseconds: i.milliseconds()
  };
}
function Gy() {
  return this.isValid() ? this.toISOString() : null;
}
function Zy() {
  return Eu(this);
}
function Ky() {
  return Fi({}, ue(this));
}
function qy() {
  return ue(this).overflow;
}
function Qy() {
  return {
    input: this._i,
    format: this._f,
    locale: this._locale,
    isUTC: this._isUTC,
    strict: this._strict
  };
}
J("N", 0, 0, "eraAbbr");
J("NN", 0, 0, "eraAbbr");
J("NNN", 0, 0, "eraAbbr");
J("NNNN", 0, 0, "eraName");
J("NNNNN", 0, 0, "eraNarrow");
J("y", ["y", 1], "yo", "eraYear");
J("y", ["yy", 2], 0, "eraYear");
J("y", ["yyy", 3], 0, "eraYear");
J("y", ["yyyy", 4], 0, "eraYear");
W("N", qu);
W("NN", qu);
W("NNN", qu);
W("NNNN", uv);
W("NNNNN", cv);
Ce(
  ["N", "NN", "NNN", "NNNN", "NNNNN"],
  function(i, e, t, s) {
    var r = t._locale.erasParse(i, s, t._strict);
    r ? ue(t).era = r : ue(t).invalidEra = i;
  }
);
W("y", Cr);
W("yy", Cr);
W("yyy", Cr);
W("yyyy", Cr);
W("yo", hv);
Ce(["y", "yy", "yyy", "yyyy"], ft);
Ce(["yo"], function(i, e, t, s) {
  var r;
  t._locale._eraYearOrdinalRegex && (r = i.match(t._locale._eraYearOrdinalRegex)), t._locale.eraYearOrdinalParse ? e[ft] = t._locale.eraYearOrdinalParse(i, r) : e[ft] = parseInt(i, 10);
});
function Jy(i, e) {
  var t, s, r, n = this._eras || Ai("en")._eras;
  for (t = 0, s = n.length; t < s; ++t) {
    switch (typeof n[t].since) {
      case "string":
        r = I(n[t].since).startOf("day"), n[t].since = r.valueOf();
        break;
    }
    switch (typeof n[t].until) {
      case "undefined":
        n[t].until = 1 / 0;
        break;
      case "string":
        r = I(n[t].until).startOf("day").valueOf(), n[t].until = r.valueOf();
        break;
    }
  }
  return n;
}
function ev(i, e, t) {
  var s, r, n = this.eras(), a, o, l;
  for (i = i.toUpperCase(), s = 0, r = n.length; s < r; ++s)
    if (a = n[s].name.toUpperCase(), o = n[s].abbr.toUpperCase(), l = n[s].narrow.toUpperCase(), t)
      switch (e) {
        case "N":
        case "NN":
        case "NNN":
          if (o === i)
            return n[s];
          break;
        case "NNNN":
          if (a === i)
            return n[s];
          break;
        case "NNNNN":
          if (l === i)
            return n[s];
          break;
      }
    else if ([a, o, l].indexOf(i) >= 0)
      return n[s];
}
function tv(i, e) {
  var t = i.since <= i.until ? 1 : -1;
  return e === void 0 ? I(i.since).year() : I(i.since).year() + (e - i.offset) * t;
}
function iv() {
  var i, e, t, s = this.localeData().eras();
  for (i = 0, e = s.length; i < e; ++i)
    if (t = this.clone().startOf("day").valueOf(), s[i].since <= t && t <= s[i].until || s[i].until <= t && t <= s[i].since)
      return s[i].name;
  return "";
}
function sv() {
  var i, e, t, s = this.localeData().eras();
  for (i = 0, e = s.length; i < e; ++i)
    if (t = this.clone().startOf("day").valueOf(), s[i].since <= t && t <= s[i].until || s[i].until <= t && t <= s[i].since)
      return s[i].narrow;
  return "";
}
function rv() {
  var i, e, t, s = this.localeData().eras();
  for (i = 0, e = s.length; i < e; ++i)
    if (t = this.clone().startOf("day").valueOf(), s[i].since <= t && t <= s[i].until || s[i].until <= t && t <= s[i].since)
      return s[i].abbr;
  return "";
}
function nv() {
  var i, e, t, s, r = this.localeData().eras();
  for (i = 0, e = r.length; i < e; ++i)
    if (t = r[i].since <= r[i].until ? 1 : -1, s = this.clone().startOf("day").valueOf(), r[i].since <= s && s <= r[i].until || r[i].until <= s && s <= r[i].since)
      return (this.year() - I(r[i].since).year()) * t + r[i].offset;
  return this.year();
}
function av(i) {
  return xe(this, "_erasNameRegex") || Qu.call(this), i ? this._erasNameRegex : this._erasRegex;
}
function ov(i) {
  return xe(this, "_erasAbbrRegex") || Qu.call(this), i ? this._erasAbbrRegex : this._erasRegex;
}
function lv(i) {
  return xe(this, "_erasNarrowRegex") || Qu.call(this), i ? this._erasNarrowRegex : this._erasRegex;
}
function qu(i, e) {
  return e.erasAbbrRegex(i);
}
function uv(i, e) {
  return e.erasNameRegex(i);
}
function cv(i, e) {
  return e.erasNarrowRegex(i);
}
function hv(i, e) {
  return e._eraYearOrdinalRegex || Cr;
}
function Qu() {
  var i = [], e = [], t = [], s = [], r, n, a = this.eras();
  for (r = 0, n = a.length; r < n; ++r)
    e.push(Et(a[r].name)), i.push(Et(a[r].abbr)), t.push(Et(a[r].narrow)), s.push(Et(a[r].name)), s.push(Et(a[r].abbr)), s.push(Et(a[r].narrow));
  this._erasRegex = new RegExp("^(" + s.join("|") + ")", "i"), this._erasNameRegex = new RegExp("^(" + e.join("|") + ")", "i"), this._erasAbbrRegex = new RegExp("^(" + i.join("|") + ")", "i"), this._erasNarrowRegex = new RegExp(
    "^(" + t.join("|") + ")",
    "i"
  );
}
J(0, ["gg", 2], 0, function() {
  return this.weekYear() % 100;
});
J(0, ["GG", 2], 0, function() {
  return this.isoWeekYear() % 100;
});
function wo(i, e) {
  J(0, [i, i.length], 0, e);
}
wo("gggg", "weekYear");
wo("ggggg", "weekYear");
wo("GGGG", "isoWeekYear");
wo("GGGGG", "isoWeekYear");
_t("weekYear", "gg");
_t("isoWeekYear", "GG");
mt("weekYear", 1);
mt("isoWeekYear", 1);
W("G", mo);
W("g", mo);
W("GG", Le, Nt);
W("gg", Le, Nt);
W("GGGG", Bu, Yu);
W("gggg", Bu, Yu);
W("GGGGG", _o, po);
W("ggggg", _o, po);
Sn(
  ["gggg", "ggggg", "GGGG", "GGGGG"],
  function(i, e, t, s) {
    e[s.substr(0, 2)] = pe(i);
  }
);
Sn(["gg", "GG"], function(i, e, t, s) {
  e[s] = I.parseTwoDigitYear(i);
});
function dv(i) {
  return rf.call(
    this,
    i,
    this.week(),
    this.weekday(),
    this.localeData()._week.dow,
    this.localeData()._week.doy
  );
}
function fv(i) {
  return rf.call(
    this,
    i,
    this.isoWeek(),
    this.isoWeekday(),
    1,
    4
  );
}
function pv() {
  return Si(this.year(), 1, 4);
}
function gv() {
  return Si(this.isoWeekYear(), 1, 4);
}
function _v() {
  var i = this.localeData()._week;
  return Si(this.year(), i.dow, i.doy);
}
function mv() {
  var i = this.localeData()._week;
  return Si(this.weekYear(), i.dow, i.doy);
}
function rf(i, e, t, s, r) {
  var n;
  return i == null ? sn(this, s, r).year : (n = Si(i, s, r), e > n && (e = n), bv.call(this, i, e, t, s, r));
}
function bv(i, e, t, s, r) {
  var n = Rd(i, e, t, s, r), a = tn(n.year, 0, n.dayOfYear);
  return this.year(a.getUTCFullYear()), this.month(a.getUTCMonth()), this.date(a.getUTCDate()), this;
}
J("Q", 0, "Qo", "quarter");
_t("quarter", "Q");
mt("quarter", 7);
W("Q", Td);
Ce("Q", function(i, e) {
  e[xi] = (pe(i) - 1) * 3;
});
function yv(i) {
  return i == null ? Math.ceil((this.month() + 1) / 3) : this.month((i - 1) * 3 + this.month() % 3);
}
J("D", ["DD", 2], "Do", "date");
_t("date", "D");
mt("date", 9);
W("D", Le);
W("DD", Le, Nt);
W("Do", function(i, e) {
  return i ? e._dayOfMonthOrdinalParse || e._ordinalParse : e._dayOfMonthOrdinalParseLenient;
});
Ce(["D", "DD"], ui);
Ce("Do", function(i, e) {
  e[ui] = pe(i.match(Le)[0]);
});
var nf = Dr("Date", !0);
J("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
_t("dayOfYear", "DDD");
mt("dayOfYear", 4);
W("DDD", go);
W("DDDD", kd);
Ce(["DDD", "DDDD"], function(i, e, t) {
  t._dayOfYear = pe(i);
});
function vv(i) {
  var e = Math.round(
    (this.clone().startOf("day") - this.clone().startOf("year")) / 864e5
  ) + 1;
  return i == null ? e : this.add(i - e, "d");
}
J("m", ["mm", 2], 0, "minute");
_t("minute", "m");
mt("minute", 14);
W("m", Le);
W("mm", Le, Nt);
Ce(["m", "mm"], Jt);
var xv = Dr("Minutes", !1);
J("s", ["ss", 2], 0, "second");
_t("second", "s");
mt("second", 15);
W("s", Le);
W("ss", Le, Nt);
Ce(["s", "ss"], wi);
var wv = Dr("Seconds", !1);
J("S", 0, 0, function() {
  return ~~(this.millisecond() / 100);
});
J(0, ["SS", 2], 0, function() {
  return ~~(this.millisecond() / 10);
});
J(0, ["SSS", 3], 0, "millisecond");
J(0, ["SSSS", 4], 0, function() {
  return this.millisecond() * 10;
});
J(0, ["SSSSS", 5], 0, function() {
  return this.millisecond() * 100;
});
J(0, ["SSSSSS", 6], 0, function() {
  return this.millisecond() * 1e3;
});
J(0, ["SSSSSSS", 7], 0, function() {
  return this.millisecond() * 1e4;
});
J(0, ["SSSSSSSS", 8], 0, function() {
  return this.millisecond() * 1e5;
});
J(0, ["SSSSSSSSS", 9], 0, function() {
  return this.millisecond() * 1e6;
});
_t("millisecond", "ms");
mt("millisecond", 16);
W("S", go, Td);
W("SS", go, Nt);
W("SSS", go, kd);
var Yi, af;
for (Yi = "SSSS"; Yi.length <= 9; Yi += "S")
  W(Yi, Cr);
function Sv(i, e) {
  e[ws] = pe(("0." + i) * 1e3);
}
for (Yi = "S"; Yi.length <= 9; Yi += "S")
  Ce(Yi, Sv);
af = Dr("Milliseconds", !1);
J("z", 0, 0, "zoneAbbr");
J("zz", 0, 0, "zoneName");
function Dv() {
  return this._isUTC ? "UTC" : "";
}
function Cv() {
  return this._isUTC ? "Coordinated Universal Time" : "";
}
var E = xn.prototype;
E.add = my;
E.calendar = Dy;
E.clone = Cy;
E.diff = Ly;
E.endOf = Hy;
E.format = Ry;
E.from = $y;
E.fromNow = Ny;
E.to = Fy;
E.toNow = Yy;
E.get = km;
E.invalidAt = qy;
E.isAfter = Ty;
E.isBefore = ky;
E.isBetween = Py;
E.isSame = Oy;
E.isSameOrAfter = My;
E.isSameOrBefore = Ay;
E.isValid = Zy;
E.lang = Qd;
E.locale = qd;
E.localeData = Jd;
E.max = Zb;
E.min = Gb;
E.parsingFlags = Ky;
E.set = Pm;
E.startOf = By;
E.subtract = by;
E.toArray = Wy;
E.toObject = Uy;
E.toDate = Xy;
E.toISOString = Iy;
E.inspect = Ey;
typeof Symbol < "u" && Symbol.for != null && (E[Symbol.for("nodejs.util.inspect.custom")] = function() {
  return "Moment<" + this.format() + ">";
});
E.toJSON = Gy;
E.toString = jy;
E.unix = Vy;
E.valueOf = zy;
E.creationData = Qy;
E.eraName = iv;
E.eraNarrow = sv;
E.eraAbbr = rv;
E.eraYear = nv;
E.year = Ed;
E.isLeapYear = Um;
E.weekYear = dv;
E.isoWeekYear = fv;
E.quarter = E.quarters = yv;
E.month = jd;
E.daysInMonth = Vm;
E.week = E.weeks = Jm;
E.isoWeek = E.isoWeeks = eb;
E.weeksInYear = _v;
E.weeksInWeekYear = mv;
E.isoWeeksInYear = pv;
E.isoWeeksInISOWeekYear = gv;
E.date = nf;
E.day = E.days = fb;
E.weekday = pb;
E.isoWeekday = gb;
E.dayOfYear = vv;
E.hour = E.hours = wb;
E.minute = E.minutes = xv;
E.second = E.seconds = wv;
E.millisecond = E.milliseconds = af;
E.utcOffset = ry;
E.utc = ay;
E.local = oy;
E.parseZone = ly;
E.hasAlignedHourOffset = uy;
E.isDST = cy;
E.isLocal = dy;
E.isUtcOffset = fy;
E.isUtc = Ud;
E.isUTC = Ud;
E.zoneAbbr = Dv;
E.zoneName = Cv;
E.dates = Gt(
  "dates accessor is deprecated. Use date instead.",
  nf
);
E.months = Gt(
  "months accessor is deprecated. Use month instead",
  jd
);
E.years = Gt(
  "years accessor is deprecated. Use year instead",
  Ed
);
E.zone = Gt(
  "moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
  ny
);
E.isDSTShifted = Gt(
  "isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
  hy
);
function Tv(i) {
  return Ae(i * 1e3);
}
function kv() {
  return Ae.apply(null, arguments).parseZone();
}
function of(i) {
  return i;
}
var we = $u.prototype;
we.calendar = fm;
we.longDateFormat = mm;
we.invalidDate = ym;
we.ordinal = wm;
we.preparse = of;
we.postformat = of;
we.relativeTime = Dm;
we.pastFuture = Cm;
we.set = hm;
we.eras = Jy;
we.erasParse = ev;
we.erasConvertYear = tv;
we.erasAbbrRegex = ov;
we.erasNameRegex = av;
we.erasNarrowRegex = lv;
we.months = Ym;
we.monthsShort = Bm;
we.monthsParse = zm;
we.monthsRegex = Wm;
we.monthsShortRegex = Xm;
we.week = Zm;
we.firstDayOfYear = Qm;
we.firstDayOfWeek = qm;
we.weekdays = lb;
we.weekdaysMin = cb;
we.weekdaysShort = ub;
we.weekdaysParse = db;
we.weekdaysRegex = _b;
we.weekdaysShortRegex = mb;
we.weekdaysMinRegex = bb;
we.isPM = vb;
we.meridiem = Sb;
function ma(i, e, t, s) {
  var r = Ai(), n = mi().set(s, e);
  return r[t](n, i);
}
function lf(i, e, t) {
  if (Pi(i) && (e = i, i = void 0), i = i || "", e != null)
    return ma(i, e, t, "month");
  var s, r = [];
  for (s = 0; s < 12; s++)
    r[s] = ma(i, s, t, "month");
  return r;
}
function Ju(i, e, t, s) {
  typeof i == "boolean" ? (Pi(e) && (t = e, e = void 0), e = e || "") : (e = i, t = e, i = !1, Pi(e) && (t = e, e = void 0), e = e || "");
  var r = Ai(), n = i ? r._week.dow : 0, a, o = [];
  if (t != null)
    return ma(e, (t + n) % 7, s, "day");
  for (a = 0; a < 7; a++)
    o[a] = ma(e, (a + n) % 7, s, "day");
  return o;
}
function Pv(i, e) {
  return lf(i, e, "months");
}
function Ov(i, e) {
  return lf(i, e, "monthsShort");
}
function Mv(i, e, t) {
  return Ju(i, e, t, "weekdays");
}
function Av(i, e, t) {
  return Ju(i, e, t, "weekdaysShort");
}
function Lv(i, e, t) {
  return Ju(i, e, t, "weekdaysMin");
}
Xi("en", {
  eras: [
    {
      since: "0001-01-01",
      until: 1 / 0,
      offset: 1,
      name: "Anno Domini",
      narrow: "AD",
      abbr: "AD"
    },
    {
      since: "0000-12-31",
      until: -1 / 0,
      offset: 1,
      name: "Before Christ",
      narrow: "BC",
      abbr: "BC"
    }
  ],
  dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
  ordinal: function(i) {
    var e = i % 10, t = pe(i % 100 / 10) === 1 ? "th" : e === 1 ? "st" : e === 2 ? "nd" : e === 3 ? "rd" : "th";
    return i + t;
  }
});
I.lang = Gt(
  "moment.lang is deprecated. Use moment.locale instead.",
  Xi
);
I.langData = Gt(
  "moment.langData is deprecated. Use moment.localeData instead.",
  Ai
);
var yi = Math.abs;
function jv() {
  var i = this._data;
  return this._milliseconds = yi(this._milliseconds), this._days = yi(this._days), this._months = yi(this._months), i.milliseconds = yi(i.milliseconds), i.seconds = yi(i.seconds), i.minutes = yi(i.minutes), i.hours = yi(i.hours), i.months = yi(i.months), i.years = yi(i.years), this;
}
function uf(i, e, t, s) {
  var r = ni(e, t);
  return i._milliseconds += s * r._milliseconds, i._days += s * r._days, i._months += s * r._months, i._bubble();
}
function Iv(i, e) {
  return uf(this, i, e, 1);
}
function Ev(i, e) {
  return uf(this, i, e, -1);
}
function Ic(i) {
  return i < 0 ? Math.floor(i) : Math.ceil(i);
}
function Rv() {
  var i = this._milliseconds, e = this._days, t = this._months, s = this._data, r, n, a, o, l;
  return i >= 0 && e >= 0 && t >= 0 || i <= 0 && e <= 0 && t <= 0 || (i += Ic(Sl(t) + e) * 864e5, e = 0, t = 0), s.milliseconds = i % 1e3, r = Yt(i / 1e3), s.seconds = r % 60, n = Yt(r / 60), s.minutes = n % 60, a = Yt(n / 60), s.hours = a % 24, e += Yt(a / 24), l = Yt(cf(e)), t += l, e -= Ic(Sl(l)), o = Yt(t / 12), t %= 12, s.days = e, s.months = t, s.years = o, this;
}
function cf(i) {
  return i * 4800 / 146097;
}
function Sl(i) {
  return i * 146097 / 4800;
}
function $v(i) {
  if (!this.isValid())
    return NaN;
  var e, t, s = this._milliseconds;
  if (i = Zt(i), i === "month" || i === "quarter" || i === "year")
    switch (e = this._days + s / 864e5, t = this._months + cf(e), i) {
      case "month":
        return t;
      case "quarter":
        return t / 3;
      case "year":
        return t / 12;
    }
  else
    switch (e = this._days + Math.round(Sl(this._months)), i) {
      case "week":
        return e / 7 + s / 6048e5;
      case "day":
        return e + s / 864e5;
      case "hour":
        return e * 24 + s / 36e5;
      case "minute":
        return e * 1440 + s / 6e4;
      case "second":
        return e * 86400 + s / 1e3;
      case "millisecond":
        return Math.floor(e * 864e5) + s;
      default:
        throw new Error("Unknown unit " + i);
    }
}
function Nv() {
  return this.isValid() ? this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + pe(this._months / 12) * 31536e6 : NaN;
}
function Li(i) {
  return function() {
    return this.as(i);
  };
}
var Fv = Li("ms"), Yv = Li("s"), Bv = Li("m"), Hv = Li("h"), zv = Li("d"), Vv = Li("w"), Xv = Li("M"), Wv = Li("Q"), Uv = Li("y");
function Gv() {
  return ni(this);
}
function Zv(i) {
  return i = Zt(i), this.isValid() ? this[i + "s"]() : NaN;
}
function Ns(i) {
  return function() {
    return this.isValid() ? this._data[i] : NaN;
  };
}
var Kv = Ns("milliseconds"), qv = Ns("seconds"), Qv = Ns("minutes"), Jv = Ns("hours"), ex = Ns("days"), tx = Ns("months"), ix = Ns("years");
function sx() {
  return Yt(this.days() / 7);
}
var vi = Math.round, Ks = {
  ss: 44,
  // a few seconds to seconds
  s: 45,
  // seconds to minute
  m: 45,
  // minutes to hour
  h: 22,
  // hours to day
  d: 26,
  // days to month/week
  w: null,
  // weeks to month
  M: 11
  // months to year
};
function rx(i, e, t, s, r) {
  return r.relativeTime(e || 1, !!t, i, s);
}
function nx(i, e, t, s) {
  var r = ni(i).abs(), n = vi(r.as("s")), a = vi(r.as("m")), o = vi(r.as("h")), l = vi(r.as("d")), u = vi(r.as("M")), h = vi(r.as("w")), c = vi(r.as("y")), f = n <= t.ss && ["s", n] || n < t.s && ["ss", n] || a <= 1 && ["m"] || a < t.m && ["mm", a] || o <= 1 && ["h"] || o < t.h && ["hh", o] || l <= 1 && ["d"] || l < t.d && ["dd", l];
  return t.w != null && (f = f || h <= 1 && ["w"] || h < t.w && ["ww", h]), f = f || u <= 1 && ["M"] || u < t.M && ["MM", u] || c <= 1 && ["y"] || ["yy", c], f[2] = e, f[3] = +i > 0, f[4] = s, rx.apply(null, f);
}
function ax(i) {
  return i === void 0 ? vi : typeof i == "function" ? (vi = i, !0) : !1;
}
function ox(i, e) {
  return Ks[i] === void 0 ? !1 : e === void 0 ? Ks[i] : (Ks[i] = e, i === "s" && (Ks.ss = e - 1), !0);
}
function lx(i, e) {
  if (!this.isValid())
    return this.localeData().invalidDate();
  var t = !1, s = Ks, r, n;
  return typeof i == "object" && (e = i, i = !1), typeof i == "boolean" && (t = i), typeof e == "object" && (s = Object.assign({}, Ks, e), e.s != null && e.ss == null && (s.ss = e.s - 1)), r = this.localeData(), n = nx(this, !t, s, r), t && (n = r.pastFuture(+this, n)), r.postformat(n);
}
var Ho = Math.abs;
function Hs(i) {
  return (i > 0) - (i < 0) || +i;
}
function So() {
  if (!this.isValid())
    return this.localeData().invalidDate();
  var i = Ho(this._milliseconds) / 1e3, e = Ho(this._days), t = Ho(this._months), s, r, n, a, o = this.asSeconds(), l, u, h, c;
  return o ? (s = Yt(i / 60), r = Yt(s / 60), i %= 60, s %= 60, n = Yt(t / 12), t %= 12, a = i ? i.toFixed(3).replace(/\.?0+$/, "") : "", l = o < 0 ? "-" : "", u = Hs(this._months) !== Hs(o) ? "-" : "", h = Hs(this._days) !== Hs(o) ? "-" : "", c = Hs(this._milliseconds) !== Hs(o) ? "-" : "", l + "P" + (n ? u + n + "Y" : "") + (t ? u + t + "M" : "") + (e ? h + e + "D" : "") + (r || s || i ? "T" : "") + (r ? c + r + "H" : "") + (s ? c + s + "M" : "") + (i ? c + a + "S" : "")) : "P0D";
}
var ve = xo.prototype;
ve.isValid = ey;
ve.abs = jv;
ve.add = Iv;
ve.subtract = Ev;
ve.as = $v;
ve.asMilliseconds = Fv;
ve.asSeconds = Yv;
ve.asMinutes = Bv;
ve.asHours = Hv;
ve.asDays = zv;
ve.asWeeks = Vv;
ve.asMonths = Xv;
ve.asQuarters = Wv;
ve.asYears = Uv;
ve.valueOf = Nv;
ve._bubble = Rv;
ve.clone = Gv;
ve.get = Zv;
ve.milliseconds = Kv;
ve.seconds = qv;
ve.minutes = Qv;
ve.hours = Jv;
ve.days = ex;
ve.weeks = sx;
ve.months = tx;
ve.years = ix;
ve.humanize = lx;
ve.toISOString = So;
ve.toString = So;
ve.toJSON = So;
ve.locale = qd;
ve.localeData = Jd;
ve.toIsoString = Gt(
  "toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
  So
);
ve.lang = Qd;
J("X", 0, 0, "unix");
J("x", 0, 0, "valueOf");
W("x", mo);
W("X", Mm);
Ce("X", function(i, e, t) {
  t._d = new Date(parseFloat(i) * 1e3);
});
Ce("x", function(i, e, t) {
  t._d = new Date(pe(i));
});
//! moment.js
I.version = "2.29.4";
um(Ae);
I.fn = E;
I.min = Kb;
I.max = qb;
I.now = Qb;
I.utc = mi;
I.unix = Tv;
I.months = Pv;
I.isDate = vn;
I.locale = Xi;
I.invalid = ho;
I.duration = ni;
I.isMoment = si;
I.weekdays = Mv;
I.parseZone = kv;
I.localeData = Ai;
I.isDuration = qn;
I.monthsShort = Ov;
I.weekdaysMin = Lv;
I.defineLocale = Xu;
I.updateLocale = kb;
I.locales = Pb;
I.weekdaysShort = Av;
I.normalizeUnits = Zt;
I.relativeTimeRounding = ax;
I.relativeTimeThreshold = ox;
I.calendarFormat = Sy;
I.prototype = E;
I.HTML5_FMT = {
  DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
  // <input type="datetime-local" />
  DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
  // <input type="datetime-local" step="1" />
  DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
  // <input type="datetime-local" step="0.001" />
  DATE: "YYYY-MM-DD",
  // <input type="date" />
  TIME: "HH:mm",
  // <input type="time" />
  TIME_SECONDS: "HH:mm:ss",
  // <input type="time" step="1" />
  TIME_MS: "HH:mm:ss.SSS",
  // <input type="time" step="0.001" />
  WEEK: "GGGG-[W]WW",
  // <input type="week" />
  MONTH: "YYYY-MM"
  // <input type="month" />
};
var ux = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("transition", {
    attrs: {
      name: "fade-transition"
    }
  }, [i.isModal ? t("div", {
    ref: "calendarModalRef",
    class: i.$style["inner-modal-container"]
  }, [t("div", [t("span", {
    class: [i.$style["modal-arrow-icon"], i.$style["-left"], i.$style[i.getIsPrevBtnDisabled() ? "disabled" : ""]],
    on: {
      click: i.prevBtnHandler
    }
  })]), t("div", {
    class: i.$style["btn-group"]
  }, i._l(i.yearList, function(s) {
    return t("div", {
      key: s,
      class: [i.$style[i.getIsSelected(s) ? "selected" : ""], i.$style[i.getIsDisabled(s) ? "disabled" : ""]],
      on: {
        click: function(r) {
          return i.yearClickHandler(s);
        }
      }
    }, [i._v(" " + i._s(s) + " ")]);
  }), 0), t("div", [t("span", {
    class: [i.$style["modal-arrow-icon"], i.$style["-right"], i.$style[i.getIsNextBtnDisabled() ? "disabled" : ""]],
    on: {
      click: i.nextBtnHandler
    }
  })])]) : i._e()]);
}, cx = [];
const hx = "_selected_umere_43", dx = "_disabled_umere_51", fx = {
  "inner-modal-container": "_inner-modal-container_umere_1",
  "btn-group": "_btn-group_umere_15",
  selected: hx,
  disabled: dx,
  "modal-arrow-icon": "_modal-arrow-icon_umere_58",
  "-left": "_-left_umere_64",
  "-right": "_-right_umere_67"
};
const px = {
  name: "headerCalendarYearSelectModal",
  props: {
    isModal: Boolean,
    displayDate: Object,
    selectedRange: Object,
    maxDate: Object,
    minDate: Object,
    disabledList: Array
  },
  data() {
    return {
      choosingDate: null
    };
  },
  computed: {
    yearList() {
      console.log("yearList");
      let i = Number(this.choosingDate.format("YYYY")), e = [];
      for (let t = 0; t < 9; t++)
        e.unshift(i - t);
      return e;
    }
  },
  mounted() {
    this.choosingDate = this.displayDate.clone();
  },
  methods: {
    getIsPrevBtnDisabled() {
      console.log("yearList: ", this.yearList[0]);
      let i = I().set("year", this.yearList[0]);
      return this.minDate >= i;
    },
    getIsNextBtnDisabled() {
      console.log("yearList: ", this.yearList[this.yearList.length - 1]);
      let i = I().set("year", this.yearList[this.yearList.length - 1]);
      return this.maxDate <= i;
    },
    getIsSelected(i) {
      return i === Number(this.displayDate.format("YYYY"));
    },
    getIsDisabled(i) {
      let e = this.minDate ? i <= Number(this.minDate.format("YYYY")) : !1, t = this.maxDate ? i >= Number(this.maxDate.format("YYYY")) : !1, s = this.disabledList.filter((r) => Number(r.format("YYYY")) === i);
      return e || t || s.length;
    },
    yearClickHandler(i) {
      let e = this.displayDate.clone().set("year", i);
      this.$emit("getDisplayDate", e), this.$emit("getIsModal", !1);
    },
    prevBtnHandler() {
      this.cloneDate = this.choosingDate.clone().subtract("years", 9), this.choosingDate = null, this.choosingDate = this.cloneDate;
    },
    nextBtnHandler() {
      this.cloneDate = this.choosingDate.clone().add("years", 9), this.choosingDate = null, this.choosingDate = this.cloneDate;
    }
  }
}, Dl = {};
Dl.$style = fx;
var gx = /* @__PURE__ */ X(
  px,
  ux,
  cx,
  !1,
  _x,
  "4cfa4f62",
  null,
  null
);
function _x(i) {
  for (let e in Dl)
    this[e] = Dl[e];
}
const mx = /* @__PURE__ */ function() {
  return gx.exports;
}();
var bx = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    class: i.$style["calender-header-container"],
    style: i.styleProps
  }, [t("span", {
    class: [i.$style["arrow-icon"], i.$style["-left"]],
    attrs: {
      disabled: i.prevBtn.disabled
    },
    on: {
      click: i.prevBtnHandler
    }
  }), t("div", {
    ref: "calendarModalOpenBtn",
    class: i.$style["display-date"],
    on: {
      click: i.toggleModal
    }
  }, [i._t("default")], 2), t("span", {
    class: [i.$style["arrow-icon"], i.$style["-right"]],
    attrs: {
      disabled: i.nextBtn.disabled
    },
    on: {
      click: i.nextBtnHandler
    }
  }), t("yearSelectModal", {
    attrs: {
      "is-modal": i.isModal,
      "next-btn": i.nextBtn,
      "prev-btn": i.prevBtn,
      "max-date": i.maxDate,
      "min-date": i.minDate,
      "disabled-list": i.disabledList,
      "display-date": i.displayDate,
      "selected-range": i.selectedRange
    },
    on: {
      getDisplayDate: i.getDisplayDate,
      getIsModal: i.getIsModal
    }
  })], 1);
}, yx = [];
const vx = {
  "calender-header-container": "_calender-header-container_57pbs_1",
  "display-date": "_display-date_57pbs_12",
  "arrow-icon": "_arrow-icon_57pbs_18",
  "-left": "_-left_57pbs_25",
  "-right": "_-right_57pbs_28"
}, xx = {
  props: {
    styleProps: String,
    timeScale: String,
    nextBtn: {
      type: Object,
      default: () => ({
        disabled: !1,
        handler() {
          console.log("nextButton handler");
        }
      })
    },
    prevBtn: {
      type: Object,
      default: () => ({
        disabled: !1,
        handler() {
          console.log("previousButton handler");
        }
      })
    },
    maxDate: Object,
    minDate: Object,
    disabledList: Array,
    displayDate: Object,
    selectedRange: Object
  },
  components: {
    yearSelectModal: mx
  },
  data() {
    return {
      isModal: !1
    };
  },
  methods: {
    toggleModal() {
      this.timeScale !== "YEAR" && (this.isModal = !this.isModal);
    },
    prevBtnHandler() {
      this.prevBtn.handler(), this.isModal = !1;
    },
    nextBtnHandler() {
      this.nextBtn.handler(), this.isModal = !1;
    },
    getDisplayDate(i) {
      this.$emit("getDisplayDate", i);
    },
    getIsModal(i) {
      this.isModal = i;
    }
  }
}, Cl = {};
Cl.$style = vx;
var wx = /* @__PURE__ */ X(
  xx,
  bx,
  yx,
  !1,
  Sx,
  null,
  null,
  null
);
function Sx(i) {
  for (let e in Cl)
    this[e] = Cl[e];
}
const Dx = /* @__PURE__ */ function() {
  return wx.exports;
}();
var Cx = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    staticClass: "date-picker-body daily"
  }, [i._l(i.dayOfWeeks, function(s, r) {
    return t("div", {
      key: r,
      staticClass: "date-picker-dow"
    }, [i._v(" " + i._s(s) + " ")]);
  }), i._l(i.reverseKeys(i.firstDayOfWeek), function(s, r) {
    return t("div", {
      key: "lastMonth" + r,
      staticClass: "date-picker-item disabled"
    }, [t("span", {
      staticClass: "date-picker-number",
      staticStyle: {
        display: "none"
      }
    }, [i._v(" " + i._s(i.lastDayOfLastMonth - s) + " ")])]);
  }), i._l(i.monthLength, function(s, r) {
    return t("div", {
      key: "currentMonth" + r,
      class: `date-picker-item
    ${i.isDisabled(s) ? "disabled" : ""}`,
      on: {
        click: function(n) {
          return i.dateClickHandler(s);
        },
        mouseover: function(n) {
          return i.dateMouseOverHandler(s);
        }
      }
    }, [t("span", {
      class: `date-picker-number
      ${i.getIsToday(s) ? "today" : ""}
      ${i.getIsSelected(s) ? "selected" : ""}
      ${i.getIsSelectedStart(s) ? "selected-start" : ""}
      ${i.getIsSelectedEnd(s) ? "selected-end" : ""}
      ${i.getIsSelectedRange(s) ? "selected-range" : ""}
      ${i.getIsChoosing(s) ? "choosing" : ""}
      ${i.getIsChoosingStart(s) ? "choosing-start" : ""}
      ${i.getIsChoosingEnd(s) ? "choosing-end" : ""}
      ${i.getIsChoosingRange(s) ? "choosing-range" : ""}
      `
    }, [i._v(" " + i._s(s) + " ")]), t("div", {
      class: `
      ${i.getIsSelectedStart(s) ? "selected-start-range" : ""}
      ${i.getIsSelectedEnd(s) ? "selected-end-range" : ""}
      ${i.getIsChoosingStart(s) ? "choosing-start-range" : ""}
      ${i.getIsChoosingEnd(s) ? "choosing-end-range" : ""}
    `
    })]);
  }), i._l(i.nextMonthLength, function(s, r) {
    return t("div", {
      key: "nextMonth" + r,
      staticClass: "date-picker-item disabled"
    }, [t("span", {
      staticClass: "date-picker-number",
      staticStyle: {
        display: "none"
      }
    }, [i._v(i._s(s))])]);
  })], 2);
}, Tx = [];
const kx = {
  name: "EmdnCalendar",
  props: {
    displayDate: Object,
    selectedRange: Object,
    dateRange: Object,
    mode: String,
    minDate: [Date, Object],
    maxDate: [Date, Object],
    disabledList: Array
  },
  data() {
    return {
      // 선택중 범위
      choosingRange: {
        start: void 0,
        end: void 0
      },
      isChoosing: !1,
      // 선택중
      firstDayOfWeek: 0,
      // 이번달 첫날의 요일
      monthLength: 0,
      // 이번달 길이
      lastDayOfLastMonth: 0,
      // 저번달 마지막날짜
      nextMonthLength: 0,
      // 달력에 표시해야 하는 다음달 길이
      dayOfWeeks: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
    };
  },
  watch: {
    displayDate() {
      this.setCalendar();
    }
  },
  mounted() {
    this.setCalendar();
  },
  methods: {
    /**
     * 날짜에 마우스를 올렸을 때의 동작을 정의합니다.
     * hover 된 date를 choosingRange.end로 설정하여, choosing 및 choosing-end class 를 추가합니다.
     * @param {*} day
     */
    dateMouseOverHandler(i) {
      this.isChoosing && (this.choosingRange.end = null, this.choosingRange.end = this.displayDate.clone().set("date", i).endOf("day"));
    },
    /**
     * caledar의 내용을 설정한다.
     * displayDate (calendarHeader의 날짜: 연월) 이 변경될 경우 재설정한다.
     */
    setCalendar() {
      this.firstDayOfWeek = this.getFirstDayOfWeek(), this.monthLength = this.getMonthLength(), this.nextMonthLength = 42 - (this.firstDayOfWeek + this.monthLength), this.lastDayOfLastMonth = this.getLastDayOfLastMonth();
    },
    /**
     * 날짜를 클릭했을 때 동작할 핸들러
     * mode가 single 일 경우와 range일 경우로 구분된다.
     * @param {*} day
     */
    dateClickHandler(i) {
      if (this.mode === "single" && this.$emit("getSelectedRange", {
        start: I(this.displayDate).set("date", i).startOf("day"),
        end: I(this.displayDate).set("date", i).endOf("day")
      }), this.mode === "range")
        if (!this.choosingRange.start)
          this.choosingRange.start = I(this.displayDate).set("date", i).startOf("day"), this.choosingRange.end = I(this.displayDate).set("date", i).endOf("day"), this.isChoosing = !0;
        else {
          if (this.choosingRange.end < this.choosingRange.start) {
            let e = this.choosingRange.start.clone(), t = this.choosingRange.end.clone();
            this.choosingRange.end = e, this.choosingRange.start = t;
          }
          this.$emit("getSelectedRange", {
            start: this.choosingRange.start.startOf("day"),
            end: this.choosingRange.end.endOf("day")
          }), this.choosingRange.start = void 0, this.choosingRange.end = void 0, this.isChoosing = !1;
        }
    },
    /**
     * v-for 작업시에 item 들을 뒤집어준다.
     * 저번달 날짜들을 표시하기 위해 사용.
     * @param {*} number
     */
    reverseKeys(i) {
      return [...Array(i).keys()].slice().reverse();
    },
    /**
     * 현재 보여지는 달의 1일의 요일 (0: 일요일, 6: 토요일)
     * 달력에 몇요일부터 이번달 날짜를 뿌려줄 것인지를 정의하기 위해 사용.
     */
    getFirstDayOfWeek() {
      let i = I(this.displayDate).format("YYYY-MM-01");
      return I(i, "YYYY-MM-DD").day();
    },
    /**
     * 현재 보여지는 달의 마지막 날 (이번달의 길이)
     * 이번달 날짜를 몇개를 뿌릴지 정의하기 위해 사용.
     */
    getMonthLength() {
      return Number(I(this.displayDate).endOf("month").format("DD"));
    },
    /**
     * 저번달의 마지막 날
     * 저번달 날짜를 몇개 뿌러야 되는지는 위의 두 개의 함수로 유추가 가능함.
     * 42 - (이번달 날짜의 수 + 이번달 1일의 요일) => 42는 달력에 표시할 날짜의 수 (6주)
     * 마지막 날짜를 몇부터 표시해야되는지 알기 위해 사용
     */
    getLastDayOfLastMonth() {
      let i = I(this.displayDate).subtract(1, "months");
      return Number(I(i).endOf("month").format("DD"));
    },
    getMomentValue(i) {
      return Number(I(i).format("YYYYMMDD"));
    },
    // 넘어온 날짜가 현재날짜 맞는지 확인
    getIsToday(i) {
      let e = this.displayDate.clone().set("date", i);
      return this.getMomentValue(e) === this.getMomentValue();
    },
    /**
     * 넘어온 날짜가 선택된 날짜가 맞는지 확인.
     * displayDate와 selectedRange 를 비교.
     * @param {*} day
     */
    getIsSelected(i) {
      let e = this.displayDate.clone().set("date", i), t = !1, s = !1;
      if (this.selectedRange.start && this.selectedRange.end) {
        let r = this.getMomentValue(this.selectedRange.start), n = this.getMomentValue(this.selectedRange.end), a = this.getMomentValue(e);
        t = r === a, s = n === a;
      }
      return !this.isChoosing && this.mode === "range" ? t || s : t;
    },
    /**
     * 넘어온 날짜가 선택된 영역 사이의 날짜인지 확인
     * displayDate와 dateRange를 비교.
     * mode가 range일 경우 dateRange 의 start와 end 사이를 표시하기 위해 사용.
     * @param {*} day
     */
    getIsSelectedRange(i) {
      let e = this.displayDate.clone().set("date", i), t = !1;
      if (this.selectedRange.start && this.selectedRange.end) {
        let s = this.getMomentValue(this.selectedRange.start), r = this.getMomentValue(this.selectedRange.end), n = this.getMomentValue(e);
        t = s < n && r > n;
      }
      return !this.isChoosing && this.mode === "range" && t;
    },
    getIsSelectedStart(i) {
      let e = this.displayDate.clone().set("date", i), t = !1, s = !1;
      if (this.selectedRange.start && this.selectedRange.end) {
        let r = this.getMomentValue(this.selectedRange.start), n = this.getMomentValue(this.selectedRange.end), a = this.getMomentValue(e);
        t = r === a, s = r === n;
      }
      return !this.isChoosing && t && !s && this.mode === "range";
    },
    getIsSelectedEnd(i) {
      let e = this.displayDate.clone().set("date", i), t = !1, s = !1;
      if (this.selectedRange.start && this.selectedRange.end) {
        let r = this.getMomentValue(this.selectedRange.start), n = this.getMomentValue(this.selectedRange.end), a = this.getMomentValue(e);
        t = n === a, s = r === a;
      }
      return !this.isChoosing && t && !s && this.mode === "range";
    },
    /**
     * 넘어온 날짜가 선택중인 날짜가 맞는지 확인.
     * displayDate와 choosingRange.start를 비교.
     * @param {*} day
     */
    getIsChoosing(i) {
      let e = this.displayDate.clone().set("date", i), t = !1, s = !1;
      if (this.choosingRange.start && this.choosingRange.end) {
        let r = this.getMomentValue(this.choosingRange.start), n = this.getMomentValue(this.choosingRange.end), a = this.getMomentValue(e);
        t = r === a, s = n === a;
      }
      return this.isChoosing && (t || s);
    },
    getIsChoosingStart(i) {
      if (this.isChoosing) {
        let e = this.displayDate.clone().set("date", i), t = !1, s = !1, r = !1;
        if (this.choosingRange.start && this.choosingRange.end) {
          let a = this.getMomentValue(this.choosingRange.start), o = this.getMomentValue(this.choosingRange.end), l = this.getMomentValue(e);
          t = l === a, s = l === o, r = a === o;
        }
        let n = this.choosingRange.start > this.choosingRange.end ? s : t;
        return this.isChoosing && n && !r;
      }
    },
    getIsChoosingEnd(i) {
      if (this.isChoosing) {
        let e = this.displayDate.clone().set("date", i), t = !1, s = !1, r = !1;
        if (this.choosingRange.start && this.choosingRange.end) {
          let a = this.getMomentValue(this.choosingRange.start), o = this.getMomentValue(this.choosingRange.end), l = this.getMomentValue(e);
          t = l === a, s = l === o, r = a === o;
        }
        let n = this.choosingRange.start > this.choosingRange.end ? t : s;
        return this.isChoosing && n && !r;
      }
    },
    getIsChoosingRange(i) {
      let e = this.displayDate.clone().set("date", i), t = !1, s = !1;
      if (this.choosingRange.start && this.choosingRange.end) {
        let n = this.getMomentValue(this.choosingRange.start), a = this.getMomentValue(this.choosingRange.end), o = this.getMomentValue(e);
        t = n < o && a > o, s = a < o && n > o;
      }
      return this.mode === "range" && (t || s);
    },
    /**
     * diabled 처리
     * minDate 보다 낮거나, maxDate 보다 크거나, disabledList에 포함된 항목일 경우 disabled
     * @param {*} day
     */
    isDisabled(i) {
      let e = this.displayDate.clone().set("date", i), t = this.disabledList.filter((s) => this.getMomentValue(e) === this.getMomentValue(s));
      return e > this.maxDate || e < this.minDate || t.length;
    }
  }
}, Ec = {};
var Px = /* @__PURE__ */ X(
  kx,
  Cx,
  Tx,
  !1,
  Ox,
  null,
  null,
  null
);
function Ox(i) {
  for (let e in Ec)
    this[e] = Ec[e];
}
const Mx = /* @__PURE__ */ function() {
  return Px.exports;
}();
var Ax = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    staticClass: "date-picker-body weekly"
  }, i._l(i.numberOfWeek, function(s, r) {
    return t("div", {
      key: r + i.weekCalendarKey,
      class: `date-picker-item
    ${i.getIsDisabled(s) ? "disabled" : ""}`,
      on: {
        click: function(n) {
          return i.weekClickHandler(s);
        }
      }
    }, [t("span", {
      class: `date-picker-number
      ${i.getIsToday(s) ? "today" : ""}
      ${i.getIsSelected(s) ? "selected" : ""}`
    }, [i._v(" " + i._s(s) + " ")])]);
  }), 0);
}, Lx = [];
const jx = {
  props: {
    selectedRange: Object,
    displayDate: Object,
    minDate: [Object, Date],
    maxDate: [Object, Date],
    disabledList: Array
  },
  data() {
    return {
      weekCalendarKey: 0,
      numberOfWeek: 0
    };
  },
  watch: {
    displayDate() {
      this.getNumberOfWeek();
    }
  },
  mounted() {
    this.getNumberOfWeek();
  },
  methods: {
    weekClickHandler(i) {
      let e = this.displayDate.clone().set("isoWeek", i);
      this.$emit("getSelectedRange", {
        start: e.clone().startOf("isoWeek"),
        end: e.clone().endOf("isoWeek")
      }), this.$emit("getDisplayDate", e.clone().startOf("isoWeek"));
    },
    getIsSelected(i) {
      let e = this.displayDate.clone().set("isoWeek", i), t = (this.selectedRange.start.unix() + this.selectedRange.end.unix()) / 2;
      return I.unix(t).format("YYYYWW") === I(e).format("YYYYWW");
    },
    getIsDisabled(i) {
      let e = this.displayDate.clone().set("isoWeek", i), t = this.minDate ? e < this.minDate : !1, s = this.maxDate ? e > this.maxDate : !1, r = this.disabledList.filter((n) => n.format("YYYYWW") === e.format("YYYYWW"));
      return s || t || r.length;
    },
    getIsToday(i) {
      let e = this.displayDate.clone().set("isoWeek", i);
      return I().format("YYYYWW") === e.format("YYYYWW");
    },
    /**
     * 현재 년도에 몇주까지 있는지 구하기
     */
    getNumberOfWeek() {
      this.displayDate.clone().endOf("year").isoWeeks() === 1 ? this.numberOfWeek = Number(
        this.displayDate.clone().endOf("year").subtract(6, "days").format("WW")
      ) : this.numberOfWeek = Number(
        this.displayDate.clone().endOf("year").format("WW")
      );
    }
  }
}, Rc = {};
var Ix = /* @__PURE__ */ X(
  jx,
  Ax,
  Lx,
  !1,
  Ex,
  null,
  null,
  null
);
function Ex(i) {
  for (let e in Rc)
    this[e] = Rc[e];
}
const Rx = /* @__PURE__ */ function() {
  return Ix.exports;
}();
var $x = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    staticClass: "date-picker-body monthly"
  }, i._l(12, function(s, r) {
    return t("div", {
      key: r + i.monthlyCalendarKey,
      class: ["date-picker-item", i.getIsDisabledMonth(s) ? "disabled" : ""],
      on: {
        click: function(n) {
          return i.monthClickHandler(s);
        }
      }
    }, [t("span", {
      class: ["date-picker-number", i.getIsToday(s) ? "today" : "", i.getIsSelected(s) ? "selected" : "", i.getIsDisabledMonth(s) ? "disabled" : ""]
    }, [i._v(" " + i._s(i.displayMonthName(s)) + " ")])]);
  }), 0);
}, Nx = [];
const Fx = {
  props: {
    selectedRange: Object,
    displayDate: Object,
    minDate: [Object, Date],
    maxDate: [Object, Date],
    disabledList: Array
  },
  data() {
    return {
      monthlyCalendarKey: 0
    };
  },
  watch: {
    displayDate() {
      this.monthlyCalendarKey += 1;
    }
  },
  methods: {
    getIsToday(i) {
      let e = this.displayDate.clone().set("month", i - 1);
      return I().format("YYYYMM") === e.format("YYYYMM");
    },
    getIsSelected(i) {
      return this.displayDate.clone().set("month", i - 1).format("YYYYMM") === this.selectedRange.start.format("YYYYMM");
    },
    getIsDisabledMonth(i) {
      let e = this.displayDate.clone().set("month", i - 1), t = this.disabledList.filter((s) => s.format("YYYYMM") === e.format("YYYYMM"));
      return e > this.maxDate || e < this.minDate || t.length;
    },
    displayMonthName(i) {
      return I(i, "MM").format("MMM");
    },
    monthClickHandler(i) {
      let e = this.displayDate.set("month", i - 1);
      this.$emit("getSelectedRange", {
        start: e.clone().startOf("month"),
        end: e.clone().endOf("month")
      }), this.monthlyCalendarKey += 1;
    }
  }
}, $c = {};
var Yx = /* @__PURE__ */ X(
  Fx,
  $x,
  Nx,
  !1,
  Bx,
  null,
  null,
  null
);
function Bx(i) {
  for (let e in $c)
    this[e] = $c[e];
}
const Hx = /* @__PURE__ */ function() {
  return Yx.exports;
}();
var zx = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    staticClass: "date-picker-body quarterly-new"
  }, i._l(i.quarterLabelArr, function(s, r) {
    return t("div", {
      key: r + i.quarterlyCalendarKey,
      class: ["quarter-row", i.getIsSelected(r + 1) ? "selected" : "", i.getIsDisabled(r + 1) ? "disabled" : ""],
      on: {
        click: function(n) {
          return i.quarterClickHandler(r + 1);
        }
      }
    }, [t("span", [t("b", [i._v(i._s(s.header))])]), i._l(s.months, function(n, a) {
      return t("span", {
        class: [i.getIsToday(n) ? "today" : "", i.getIsDisabled(a + 1) ? "disabled" : ""]
      }, [i._v(i._s(i.displayMonth(n)))]);
    })], 2);
  }), 0);
}, Vx = [];
const Xx = {
  name: "quarterlyCalendar",
  props: {
    selectedRange: Object,
    displayDate: Object,
    minDate: [Object, Date],
    maxDate: [Object, Date],
    disabledList: Array
  },
  data() {
    return {
      quarterlyCalendarKey: 0,
      // quarterLabelArr: [
      //   { header: "Q1", months: ["Jan", "Feb", "Mar"] },
      //   { header: "Q2", months: ["Apr", "May", "Jun"] },
      //   { header: "Q3", months: ["Jul", "Aug", "Sep"] },
      //   { header: "Q4", months: ["Oct", "Nov", "Dec"] },
      // ],
      quarterLabelArr: [
        { header: "Q1", months: [1, 2, 3] },
        { header: "Q2", months: [4, 5, 6] },
        { header: "Q3", months: [7, 8, 9] },
        { header: "Q4", months: [10, 11, 12] }
      ]
    };
  },
  methods: {
    displayMonth(i) {
      let e = this.displayDate.clone().set("month", i - 1);
      return I(e).format("MMM");
    },
    getIsToday(i) {
      let e = this.displayDate.clone().set("month", i - 1);
      return I().format("YYYYMMM") === e.format("YYYYMMM");
    },
    getIsSelected(i) {
      return this.displayDate.clone().set("quarter", i).format("YYYYQ") === this.selectedRange.start.format("YYYYQ");
    },
    getIsDisabled(i) {
      let e = this.displayDate.clone().set("quarter", i), t = this.disabledList.filter((s) => s.format("YYYYQ") === e.format("YYYYQ"));
      return e > this.maxDate || e < this.minDate || t.length;
    },
    quarterClickHandler(i) {
      let e = this.displayDate.set("quarter", i);
      this.$emit("getSelectedRange", {
        start: e.clone().startOf("quarter"),
        end: e.clone().endOf("quarter")
      }), this.$emit("getDislayDate", e), this.quarterlyCalendarKey += 1;
    }
  }
}, Nc = {};
var Wx = /* @__PURE__ */ X(
  Xx,
  zx,
  Vx,
  !1,
  Ux,
  null,
  null,
  null
);
function Ux(i) {
  for (let e in Nc)
    this[e] = Nc[e];
}
const Gx = /* @__PURE__ */ function() {
  return Wx.exports;
}();
var Zx = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    staticClass: "date-picker-body yearly"
  }, i._l(12, function(s) {
    return t("div", {
      key: s,
      class: ["date-picker-item", i.getIsDisabled(i.diplayDateValue + s - 1) ? "disabled" : ""],
      on: {
        click: function(r) {
          return i.yearClickHandler(i.diplayDateValue + s - 1);
        }
      }
    }, [t("span", {
      class: ["date-picker-number", i.getIsToday(i.diplayDateValue + s - 1) ? "today" : "", i.getIsSelected(i.diplayDateValue + s - 1) ? "selected" : "", i.getIsDisabled(i.diplayDateValue + s - 1) ? "disabled" : ""]
    }, [i._v(" " + i._s(i.diplayDateValue + s - 1) + " ")])]);
  }), 0);
}, Kx = [];
const qx = {
  props: {
    minDate: [Object, Date],
    maxDate: [Object, Date],
    displayDate: Object,
    selectedRange: Object,
    disabledList: Array
  },
  computed: {
    diplayDateValue() {
      return Number(this.displayDate.format("YYYY"));
    }
  },
  methods: {
    yearClickHandler(i) {
      let e = this.displayDate.clone().set("year", i);
      this.$emit("getSelectedRange", {
        start: e.clone().startOf("year"),
        end: e.clone().endOf("year")
      });
    },
    getIsToday(i) {
      return this.displayDate.clone().set("year", i).format("YYYY") === I().format("YYYY");
    },
    getIsSelected(i) {
      return this.displayDate.clone().set("year", i).format("YYYY") === I(this.selectedRange.start).format("YYYY");
    },
    getIsDisabled(i) {
      let e = this.displayDate.clone().set("year", i), t = this.disabledList.filter((s) => s.format("YYYY") === e.format("YYYY"));
      return e > this.maxDate || e < this.minDate || t.length;
    }
  }
}, Fc = {};
var Qx = /* @__PURE__ */ X(
  qx,
  Zx,
  Kx,
  !1,
  Jx,
  null,
  null,
  null
);
function Jx(i) {
  for (let e in Fc)
    this[e] = Fc[e];
}
const e0 = /* @__PURE__ */ function() {
  return Qx.exports;
}();
var t0 = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", [i.timeScale === "DATE" || i.timeScale === "CUSTOM" || !i.timeScale ? t("Daily", {
    key: "DATE",
    attrs: {
      mode: i.timeScale === "CUSTOM" ? "range" : "single",
      "selected-range": i.selectedRange,
      "display-date": i.displayDate,
      "max-date": i.maxDate,
      "min-date": i.minDate,
      "disabled-list": i.disabledList
    },
    on: {
      getDisplayDate: i.getDisplayDate,
      getSelectedRange: i.getSelectedRange
    }
  }) : i._e(), i.timeScale === "MONTH" ? t("Monthly", {
    attrs: {
      "selected-range": i.selectedRange,
      "display-date": i.displayDate,
      "max-date": i.maxDate,
      "min-date": i.minDate,
      "disabled-list": i.disabledList
    },
    on: {
      getDisplayDate: i.getDisplayDate,
      getSelectedRange: i.getSelectedRange
    }
  }) : i._e(), i.timeScale === "WEEK" ? t("Weekly", {
    attrs: {
      "selected-range": i.selectedRange,
      "display-date": i.displayDate,
      "max-date": i.maxDate,
      "min-date": i.minDate,
      "disabled-list": i.disabledList
    },
    on: {
      getDisplayDate: i.getDisplayDate,
      getSelectedRange: i.getSelectedRange
    }
  }) : i._e(), i.timeScale === "QUARTER" ? t("Quarterly", {
    attrs: {
      "selected-range": i.selectedRange,
      "display-date": i.displayDate,
      "max-date": i.maxDate,
      "min-date": i.minDate,
      "disabled-list": i.disabledList
    },
    on: {
      getDisplayDate: i.getDisplayDate,
      getSelectedRange: i.getSelectedRange
    }
  }) : i._e(), i.timeScale === "YEAR" ? t("yearly", {
    attrs: {
      "selected-range": i.selectedRange,
      "display-date": i.displayDate,
      "max-date": i.maxDate,
      "min-date": i.minDate,
      "disabled-list": i.disabledList
    },
    on: {
      getDisplayDate: i.getDisplayDate,
      getSelectedRange: i.getSelectedRange
    }
  }) : i._e()], 1);
}, i0 = [];
const s0 = {
  name: "CalendarBody",
  components: {
    Daily: Mx,
    Weekly: Rx,
    Monthly: Hx,
    Quarterly: Gx,
    Yearly: e0
  },
  props: {
    timeScale: String,
    displayDate: Object,
    selectedRange: Object,
    dateRange: Object,
    mode: String,
    minDate: [Date, Object],
    maxDate: [Date, Object],
    disabledList: Array
  },
  methods: {
    getSelectedRange(i) {
      this.$emit("getSelectedRange", i);
    },
    getDisplayDate(i) {
      this.$emit("getDisplayDate", i);
    }
  }
}, Yc = {};
var r0 = /* @__PURE__ */ X(
  s0,
  t0,
  i0,
  !1,
  n0,
  null,
  null,
  null
);
function n0(i) {
  for (let e in Yc)
    this[e] = Yc[e];
}
const a0 = /* @__PURE__ */ function() {
  return r0.exports;
}();
var o0 = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    staticClass: "date-picker-input-container"
  }, [t("div", {
    staticClass: "input-box"
  }, [t("label", [i._v("From")]), t("input", {
    attrs: {
      placeholder: "yyyy-mm-dd",
      readonly: "",
      type: "text"
    },
    domProps: {
      value: i.selectedRange.start.format("YYYY-MM-DD")
    }
  })]), t("div", {
    staticClass: "input-box"
  }, [t("label", [i._v("To")]), t("input", {
    attrs: {
      placeholder: "yyyy-mm-dd",
      readonly: "",
      type: "text"
    },
    domProps: {
      value: i.selectedRange.end.format("YYYY-MM-DD")
    }
  })])]);
}, l0 = [];
const u0 = {
  name: "DatePickerInput",
  props: {
    selectedRange: Object
  }
}, Bc = {};
var c0 = /* @__PURE__ */ X(
  u0,
  o0,
  l0,
  !1,
  h0,
  null,
  null,
  null
);
function h0(i) {
  for (let e in Bc)
    this[e] = Bc[e];
}
const d0 = /* @__PURE__ */ function() {
  return c0.exports;
}(), f0 = "_center_1jmu6_80", p0 = "_normal_1jmu6_102", g0 = "_small_1jmu6_106", _0 = "_large_1jmu6_110", m0 = "_custom_1jmu6_114", b0 = "_text_1jmu6_117", y0 = "_blue_1jmu6_128", v0 = "_green_1jmu6_159", x0 = "_red_1jmu6_190", w0 = "_white_1jmu6_220", S0 = "_dropdown_1jmu6_238", D0 = "_upload_1jmu6_290", C0 = "_hyperlink_1jmu6_300", Ii = {
  default: "_default_1jmu6_66",
  center: f0,
  normal: p0,
  small: g0,
  large: _0,
  custom: m0,
  text: b0,
  blue: y0,
  "blue-border-show": "_blue-border-show_1jmu6_1",
  "blue-fill": "_blue-fill_1jmu6_145",
  "blue-fill-border-show": "_blue-fill-border-show_1jmu6_1",
  green: v0,
  "green-border-show": "_green-border-show_1jmu6_1",
  "green-fill": "_green-fill_1jmu6_175",
  "green-fill-border-show": "_green-fill-border-show_1jmu6_1",
  red: x0,
  "red-border-show": "_red-border-show_1jmu6_1",
  "red-fill": "_red-fill_1jmu6_205",
  "red-fill-border-show": "_red-fill-border-show_1jmu6_1",
  white: w0,
  "white-border-show": "_white-border-show_1jmu6_1",
  dropdown: S0,
  "date-picker": "_date-picker_1jmu6_269",
  export: "_export_1jmu6_283",
  upload: D0,
  hyperlink: C0
}, zo = ["text", "text dropdown", "text hyperlink"], T0 = {
  props: {
    /**
     * Set the styles for the element {ex: {width: 100, height: 100}}
     */
    styleProps: {
      type: [String, Object]
    },
    /**
     * Set active state for the element, applying transition
     */
    active: Boolean,
    /**
     * Set state for the element
     */
    disabled: Boolean,
    /**
     * Set color type of button {ex: blue, blue-fill}
     */
    colorType: String,
    /**
     * Set the type of the button
     */
    type: {
      type: String,
      default: "button"
    },
    /**
     * @deprecated Use variant instead.
     */
    buttonType: {
      type: String
    },
    /**
     * Set variant button type {ex: dropdown, upload}
     */
    variant: {
      type: String
    },
    /**
     * Set size varient for button
     */
    size: {
      type: String,
      default: "normal"
    },
    /**
     * Set clickhandler
     */
    clickHandler: Function
  },
  computed: {
    /**
     *
     * Calculates the computed color type for the button based on variant and buttonType.
     * @function
     * @memberof ButtonComponent
     */
    colorTypeComputed() {
      const i = this.colorType;
      return this.buttonType === "export" || this.variant === "export" ? "blue-fill" : i === void 0 ? "blue" : zo.includes(i) ? "" : i ?? "blue";
    },
    /**
     *
     * Calculates the computed type for the button based on buttonType.
     * @function
     * @memberof ButtonComponent
     */
    buttonTypeComputed() {
      var e, t;
      let i = `${Ii.default}`;
      return zo.includes(`${this.variant ?? this.buttonType}`) ? (i += ` ${(e = this.variant) == null ? void 0 : e.split(" ").map((s) => Ii[s]).join(" ")}`, i += ` ${(t = this.buttonType) == null ? void 0 : t.split(" ").map((s) => Ii[s]).join(" ")}`) : i += ` ${Ii[this.colorTypeComputed ? this.colorTypeComputed : ""]}`, i += ` ${Ii[this.size ? this.size : ""]}`, i += ` ${this.variant ? Ii[this.variant] : ""}`, i += ` ${this.buttonType ? Ii[this.buttonType] : ""}`, i;
    },
    /**
     *
     * Calculates the computed icon for the button based on variant.
     * @function
     * @memberof ButtonComponent
     */
    iconTypeComputed() {
      var i;
      return zo.includes(`${this.variant ?? this.buttonType}`) ? (i = this.variant) == null ? void 0 : i.split(" ").map((e) => Ii[e]).join(" ") : this.variant ?? this.buttonType ? this.variant ?? this.buttonType : "";
    },
    /**
     *
     * Make visiable viseversa for the icon.
     * @function
     * @memberof ButtonComponent
     */
    showIcon() {
      const i = this.variant ?? this.buttonType;
      return i === void 0 || i === "custom" ? !1 : i === "dropdown" ? this.colorType !== "red" && this.colorType !== "green" : i === "date-picker" ? this.colorType !== "red" && this.colorType !== "green" && this.colorType !== "white" : i !== "text";
    }
  }
};
var k0 = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("button", {
    class: i.buttonTypeComputed,
    style: i.styleProps,
    attrs: {
      type: i.type,
      active: i.active,
      disabled: i.disabled
    },
    on: {
      click: function(s) {
        return s.stopPropagation(), (function() {
          var r, n;
          return (r = (n = i).clickHandler) === null || r === void 0 ? void 0 : r.call(n);
        }).apply(null, arguments);
      }
    }
  }, [i._t("default"), t("img", {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: i.showIcon,
      expression: "showIcon"
    }],
    class: i.iconTypeComputed,
    attrs: {
      alt: "button-icon"
    }
  })], 2);
}, P0 = [];
const O0 = "_center_1jmu6_80", M0 = "_normal_1jmu6_102", A0 = "_small_1jmu6_106", L0 = "_large_1jmu6_110", j0 = "_custom_1jmu6_114", I0 = "_text_1jmu6_117", E0 = "_blue_1jmu6_128", R0 = "_green_1jmu6_159", $0 = "_red_1jmu6_190", N0 = "_white_1jmu6_220", F0 = "_dropdown_1jmu6_238", Y0 = "_upload_1jmu6_290", B0 = "_hyperlink_1jmu6_300", H0 = {
  default: "_default_1jmu6_66",
  center: O0,
  normal: M0,
  small: A0,
  large: L0,
  custom: j0,
  text: I0,
  blue: E0,
  "blue-border-show": "_blue-border-show_1jmu6_1",
  "blue-fill": "_blue-fill_1jmu6_145",
  "blue-fill-border-show": "_blue-fill-border-show_1jmu6_1",
  green: R0,
  "green-border-show": "_green-border-show_1jmu6_1",
  "green-fill": "_green-fill_1jmu6_175",
  "green-fill-border-show": "_green-fill-border-show_1jmu6_1",
  red: $0,
  "red-border-show": "_red-border-show_1jmu6_1",
  "red-fill": "_red-fill_1jmu6_205",
  "red-fill-border-show": "_red-fill-border-show_1jmu6_1",
  white: N0,
  "white-border-show": "_white-border-show_1jmu6_1",
  dropdown: F0,
  "date-picker": "_date-picker_1jmu6_269",
  export: "_export_1jmu6_283",
  upload: Y0,
  hyperlink: B0
}, Tl = {};
Tl.$style = H0;
var z0 = /* @__PURE__ */ X(
  T0,
  k0,
  P0,
  !1,
  V0,
  "24410c41",
  null,
  null
);
function V0(i) {
  for (let e in Tl)
    this[e] = Tl[e];
}
const Fs = /* @__PURE__ */ function() {
  return z0.exports;
}();
var X0 = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    staticStyle: {
      display: "flex",
      "flex-direction": "column",
      gap: "10px"
    }
  }, i._l(i.selectorOptions, function(s, r) {
    return t("CtaButton", {
      key: r,
      attrs: {
        "color-type": s === i.timeScale ? "blue-fill" : "white",
        "click-handler": function() {
          return i.executor(s);
        },
        "style-props": "width : 171px; height: 25px;"
      }
    }, [i._v(" " + i._s(i.capitalize(s)) + " ")]);
  }), 1);
}, W0 = [];
const U0 = {
  name: "SelectorCalendar",
  components: {
    CtaButton: Fs
  },
  props: {
    timeScale: String,
    selectorOptions: Array
  },
  methods: {
    executor(i) {
      this.$emit("getTimeScale", i);
    },
    capitalize(i) {
      return i.split(" ").map((e) => e.charAt(0).toUpperCase() + e.slice(1).toLowerCase()).join(" ");
    }
  }
}, Hc = {};
var G0 = /* @__PURE__ */ X(
  U0,
  X0,
  W0,
  !1,
  Z0,
  null,
  null,
  null
);
function Z0(i) {
  for (let e in Hc)
    this[e] = Hc[e];
}
const K0 = /* @__PURE__ */ function() {
  return G0.exports;
}();
var q0 = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    class: [i.$style["calendar-container"]],
    style: i.styleProps
  }, [t("div", {
    class: [i.$style["calendar-single"], i.$style[i.showSelector ? "" : "box-shadow"]]
  }, [t("CalendarHeader", {
    attrs: {
      "time-scale": i.timeScale,
      "next-btn": i.nextBtn,
      "prev-btn": i.prevBtn,
      "max-date": i.maxDate,
      "min-date": i.minDate,
      "disabled-list": i.disabledList,
      "display-date": i.displayDate,
      "selected-range": i.selectedRange
    },
    on: {
      getDisplayDate: i.getDisplayDate
    }
  }, [i.timeScale === "DATE" || i.timeScale === "CUSTOM" || !i.timeScale ? t("div", [t("span", {
    staticStyle: {
      "margin-right": "5px"
    }
  }, [i._v(" " + i._s(i.displayDate.format("MMMM")) + " ")]), t("span", {
    staticStyle: {
      color: "#3491ff"
    }
  }, [i._v(i._s(i.displayDate.format("YYYY")))])]) : i._e(), i.timeScale === "WEEK" || i.timeScale === "MONTH" || i.timeScale === "QUARTER" ? t("span", {
    staticStyle: {
      color: "#3491ff"
    }
  }, [i._v(" " + i._s(i.displayDate.format("YYYY")) + " ")]) : i._e(), i.timeScale === "YEAR" ? t("span", [i._v(" " + i._s(Number(i.displayDate.format("YYYY"))) + " - " + i._s(Number(i.displayDate.format("YYYY")) + 11) + " ")]) : i._e()]), t("CalendarBody", {
    attrs: {
      "time-scale": i.timeScale,
      "selected-range": i.selectedRange,
      "display-date": i.displayDate,
      "max-date": i.maxDate,
      "min-date": i.minDate,
      "disabled-list": i.disabledList
    },
    on: {
      getDisplayDate: i.getDisplayDate,
      getSelectedRange: i.getSelectedRange
    }
  }), i.showSelector ? t("CalendarInput", {
    attrs: {
      "selected-range": i.selectedRange
    }
  }) : i._e()], 1), i.showSelector ? t("Selector", {
    attrs: {
      "selector-options": i.selectorOptions,
      "time-scale": i.timeScale
    },
    on: {
      getTimeScale: i.getTimeScale
    }
  }) : i._e()], 1);
}, Q0 = [];
const J0 = {
  "calendar-container": "_calendar-container_w5i6x_1",
  "calendar-single": "_calendar-single_w5i6x_8",
  "box-shadow": "_box-shadow_w5i6x_13"
};
const ew = {
  name: "EmdnCalendar",
  components: {
    CalendarHeader: Dx,
    CalendarBody: a0,
    CalendarInput: d0,
    Selector: K0
  },
  data() {
    return {
      displayDate: I(),
      selectedRange: { start: I(), end: I() },
      prevBtn: {
        disabled: !1,
        handler: function() {
          console.log("prevBtn hanlder is not defined.");
        }
      },
      nextBtn: {
        disabled: !1,
        handler: function() {
          console.log("nextBtn hanlder is not defined.");
        }
      }
    };
  },
  props: {
    styleProps: String,
    maxDate: Object,
    minDate: Object,
    timeScale: String,
    showSelector: {
      type: Boolean,
      default: !1
    },
    selectorOptions: {
      type: Array,
      default: () => ["DATE", "WEEK", "MONTH", "QUARTER", "YEAR", "CUSTOM"]
    },
    dateRange: {
      type: Object,
      default: () => ({ start: I(/* @__PURE__ */ new Date()), end: I(/* @__PURE__ */ new Date()) })
    },
    disabledList: {
      type: Array,
      default: () => []
    }
  },
  watch: {
    timeScale() {
      switch (this.timeScale) {
        case "WEEK":
          this.setSelectedRangeByUnitOfTimeFromToday("isoWeek");
          break;
        case "MONTH":
          this.setSelectedRangeByUnitOfTimeFromToday("month");
          break;
        case "QUARTER":
          this.setSelectedRangeByUnitOfTimeFromToday("quarter");
          break;
        case "YEAR":
          this.setSelectedRangeByUnitOfTimeFromToday("year");
          break;
        default:
          this.setSelectedRangeByUnitOfTimeFromToday("day");
      }
    }
  },
  mounted() {
    this.displayDate = this.dateRange.start.clone(), this.selectedRange.start = this.dateRange.start.clone(), this.selectedRange.end = this.dateRange.end.clone(), this.nextBtn.handler = this.nextBtnHandler, this.prevBtn.handler = this.prevBtnHandler;
  },
  methods: {
    prevBtnHandler() {
      (this.timeScale === "DATE" || this.timeScale === "CUSTOM" || !this.timeScale) && (this.displayDate = I(this.displayDate).subtract(1, "months")), (this.timeScale === "WEEK" || this.timeScale === "MONTH" || this.timeScale === "QUARTER") && (this.displayDate = this.displayDate.clone().subtract(1, "years")), this.timeScale === "YEAR" && (this.displayDate = this.displayDate.clone().subtract(12, "years"));
    },
    nextBtnHandler() {
      (this.timeScale === "DATE" || this.timeScale === "CUSTOM" || !this.timeScale) && (this.displayDate = I(this.displayDate).add(1, "months")), (this.timeScale === "WEEK" || this.timeScale === "MONTH" || this.timeScale === "QUARTER") && (this.displayDate = this.displayDate.clone().add(1, "years")), this.timeScale === "YEAR" && (this.displayDate = this.displayDate.clone().add(12, "years"));
    },
    getDisplayDate(i) {
      this.displayDate = i;
    },
    getSelectedRange(i) {
      this.selectedRange = i, this.$emit("get-date-range", i);
    },
    getTimeScale(i) {
      this.$emit("get-time-scale", i);
    },
    // Selector가 있을 경우 timeScale을 변경할 때마다 현재 날짜를 기준으로 timeScale에 맞추어 날짜를 초기화
    setSelectedRangeByUnitOfTimeFromToday(i) {
      const e = I(), t = e.clone().startOf(i), s = e.clone().endOf(i);
      this.displayDate = e, this.selectedRange.start = t, this.selectedRange.end = s, this.getSelectedRange({
        start: t,
        end: s
      });
    }
  }
}, kl = {};
kl.$style = J0;
var tw = /* @__PURE__ */ X(
  ew,
  q0,
  Q0,
  !1,
  iw,
  null,
  null,
  null
);
function iw(i) {
  for (let e in kl)
    this[e] = kl[e];
}
const kN = /* @__PURE__ */ function() {
  return tw.exports;
}(), sw = {
  props: {
    isOpened: {
      type: Boolean,
      default: !1
    },
    title: {
      type: String,
      required: !0
    },
    onClose: Function,
    buttonText: {
      type: String,
      default: "Close"
    },
    width: {
      type: String,
      default: "100%"
    },
    height: {
      type: String,
      default: "100%"
    }
  },
  components: { CtaButton: Fs }
}, rw = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGcgY2xpcC1wYXRoPSJ1cmwoI2NsaXAwXzIyNTRfNTI2OTEpIj4KPHBhdGggZD0iTTE5IDYuNDFMMTcuNTkgNUwxMiAxMC41OUw2LjQxIDVMNSA2LjQxTDEwLjU5IDEyTDUgMTcuNTlMNi40MSAxOUwxMiAxMy40MUwxNy41OSAxOUwxOSAxNy41OUwxMy40MSAxMkwxOSA2LjQxWiIgZmlsbD0iIzM0OTFGRiIvPgo8L2c+CjxkZWZzPgo8Y2xpcFBhdGggaWQ9ImNsaXAwXzIyNTRfNTI2OTEiPgo8cmVjdCB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIGZpbGw9IndoaXRlIi8+CjwvY2xpcFBhdGg+CjwvZGVmcz4KPC9zdmc+Cg==";
var nw = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    style: {
      position: "absolute",
      display: i.isOpened ? "flex" : "none",
      flexDirection: "column",
      backgroundColor: "white",
      bottom: 0,
      right: 0,
      zIndex: 9999,
      width: i.width,
      height: i.height
    }
  }, [t("div", {
    style: {
      display: "flex",
      width: "100%",
      alignItems: "center",
      padding: "16px 20px",
      justifyContent: "space-between",
      backgroundColor: "#F5F8FF",
      boxSizing: "border-box"
    }
  }, [t("span", {
    style: {
      fontWeight: 700
    }
  }, [i._v(" " + i._s(i.title) + " ")]), t("button", {
    style: {
      all: "unset",
      cursor: "pointer"
    },
    on: {
      click: i.onClose
    }
  }, [t("div", {
    style: {
      display: "flex",
      alignItems: "center",
      color: "#3491FF"
    }
  }, [t("img", {
    attrs: {
      src: rw,
      alt: "close"
    }
  }), t("div", {
    staticStyle: {
      width: "4px"
    }
  }), i._v(" " + i._s(i.buttonText) + " ")])])]), t("div", {
    staticStyle: {
      "flex-grow": "1"
    }
  }, [i._t("default")], 2), i._t("footer")], 2);
}, aw = [];
const zc = {};
var ow = /* @__PURE__ */ X(
  sw,
  nw,
  aw,
  !1,
  lw,
  null,
  null,
  null
);
function lw(i) {
  for (let e in zc)
    this[e] = zc[e];
}
const PN = /* @__PURE__ */ function() {
  return ow.exports;
}(), uw = {
  props: {
    height: {
      type: Number,
      default: 16
    },
    width: {
      type: Number,
      default: 16
    }
  },
  data() {
    return {
      angle: 45,
      timeout: void 0
    };
  },
  mounted() {
    this.timeout = setInterval(() => {
      this.angle = (this.angle + 45) % 360;
    }, 150);
  },
  destroyed() {
    clearTimeout(this.timeout);
  }
}, cw = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTMiCiAgaGVpZ2h0PSIxMyIKICB2aWV3Qm94PSIwIDAgMTMgMTMiCiAgZmlsbD0ibm9uZSIKICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgogIDxjaXJjbGUgY3g9IjYuNSIKICAgIGN5PSIxLjUiCiAgICByPSIxLjUiCiAgICBmaWxsPSIjRjRGNEY0IgogICAgZmlsbC1vcGFjaXR5PSIwLjciIC8+CiAgPGNpcmNsZSBjeD0iNi41IgogICAgY3k9IjExLjUiCiAgICByPSIxLjUiCiAgICBmaWxsPSIjRTFFMUUxIiAvPgogIDxjaXJjbGUgY3g9IjExLjUiCiAgICBjeT0iNi41IgogICAgcj0iMS41IgogICAgZmlsbD0iI0Q4RDhEOCIKICAgIGZpbGwtb3BhY2l0eT0iMC44NSIgLz4KICA8Y2lyY2xlIGN4PSIxLjUiCiAgICBjeT0iNi41IgogICAgcj0iMS41IgogICAgZmlsbD0iI0VDRUNFQyIKICAgIGZpbGwtb3BhY2l0eT0iMC42IiAvPgogIDxjaXJjbGUgY3g9IjEwLjAzNTYiCiAgICBjeT0iMi45NjQ1OCIKICAgIHI9IjEuNSIKICAgIHRyYW5zZm9ybT0icm90YXRlKDQ1IDEwLjAzNTYgMi45NjQ1OCkiCiAgICBmaWxsPSIjRjdGN0Y3IgogICAgZmlsbC1vcGFjaXR5PSIwLjgiIC8+CiAgPGNpcmNsZSBjeD0iMi45NjQzNiIKICAgIGN5PSIxMC4wMzU0IgogICAgcj0iMS41IgogICAgdHJhbnNmb3JtPSJyb3RhdGUoNDUgMi45NjQzNiAxMC4wMzU0KSIKICAgIGZpbGw9IiNFQUVBRUEiCiAgICBmaWxsLW9wYWNpdHk9IjAuNTUiIC8+CiAgPGNpcmNsZSBjeD0iMTAuMDM1NiIKICAgIGN5PSIxMC4wMzU0IgogICAgcj0iMS41IgogICAgdHJhbnNmb3JtPSJyb3RhdGUoNDUgMTAuMDM1NiAxMC4wMzU0KSIKICAgIGZpbGw9IiNFMUUxRTEiCiAgICBmaWxsLW9wYWNpdHk9IjAuOCIgLz4KICA8Y2lyY2xlIGN4PSIyLjk2NDM2IgogICAgY3k9IjIuOTY0NTgiCiAgICByPSIxLjUiCiAgICB0cmFuc2Zvcm09InJvdGF0ZSg0NSAyLjk2NDM2IDIuOTY0NTgpIgogICAgZmlsbD0iI0YwRjBGMCIKICAgIGZpbGwtb3BhY2l0eT0iMC42NSIgLz4KPC9zdmc+";
var hw = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    style: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      transform: `rotate(${i.angle}deg)`
    }
  }, [t("img", {
    attrs: {
      height: i.height + "px",
      width: i.width + "px",
      src: cw,
      alt: "spinner"
    }
  })]);
}, dw = [];
const Vc = {};
var fw = /* @__PURE__ */ X(
  uw,
  hw,
  dw,
  !1,
  pw,
  null,
  null,
  null
);
function pw(i) {
  for (let e in Vc)
    this[e] = Vc[e];
}
const gw = /* @__PURE__ */ function() {
  return fw.exports;
}(), _w = {
  props: {
    height: {
      type: String,
      default: "20px"
    },
    width: {
      type: String,
      default: "20px"
    },
    text: String,
    textStyle: [String, Object]
  }
};
var mw = function() {
  var i, e = this, t = e.$createElement, s = e._self._c || t;
  return s("div", {
    class: e.$style.loading
  }, [s("div", {
    class: e.$style.spinner,
    style: {
      width: e.width,
      height: e.height
    }
  }), e.text ? s("div", {
    style: (i = e.textStyle) !== null && i !== void 0 ? i : {
      marginTop: "12px",
      fontSize: "18px",
      fontWeight: "bold",
      color: "rgba(0, 0, 0, 0.6)"
    }
  }, [e._v(" " + e._s(e.text) + " ")]) : e._e()]);
}, bw = [];
const yw = "_loading_1m4uu_41", vw = "_spinner_1m4uu_48", xw = "_spin_1m4uu_48", ww = {
  loading: yw,
  spinner: vw,
  spin: xw
}, Pl = {};
Pl.$style = ww;
var Sw = /* @__PURE__ */ X(
  _w,
  mw,
  bw,
  !1,
  Dw,
  null,
  null,
  null
);
function Dw(i) {
  for (let e in Pl)
    this[e] = Pl[e];
}
const ON = /* @__PURE__ */ function() {
  return Sw.exports;
}(), Cw = "_tooltip_4glrn_1", Tw = "_contextWrapper_4glrn_9", kw = "_main_tooltip_4glrn_13", Pw = "_tooltip_text_white_4glrn_13", Ow = "_top_4glrn_27", Mw = "_bottom_4glrn_38", Aw = "_left_4glrn_49", Lw = "_right_4glrn_60", jw = "_tooltip_text_black_4glrn_71", Iw = {
  tooltip: Cw,
  contextWrapper: Tw,
  main_tooltip: kw,
  tooltip_text_white: Pw,
  top: Ow,
  bottom: Mw,
  left: Aw,
  right: Lw,
  tooltip_text_black: jw
}, Xc = "left", Wc = "right", Ew = {
  name: "Tooltip",
  props: {
    /**
     * set tooltip style properties {e.g {width: 100rem; height 100rem}}
     */
    styleProps: [String, Object],
    /**
     * set tooltip position w.r.t to context {e.g left, right, top, bottom }
     */
    position: {
      type: String,
      default: "top"
    },
    /**
     * set tooltip color {e.g  black, white}
     */
    color: {
      type: String,
      default: "black"
    },
    /**
     * show and hide tail of tooltip {e.g  true, false}
     */
    hideTail: {
      type: Boolean,
      default: !1
    }
  },
  data() {
    return {
      isHover: !1,
      contextWrapper: null
    };
  },
  methods: {
    /** set the direction of tooltip tail */
    getTailDirection(i) {
      return i === Xc ? Wc : i === Wc ? Xc : i;
    },
    /** set the tooltip position */
    getTooltipStylePosition({
      position: i,
      width: e,
      height: t
    }) {
      return i === "top" ? `bottom: ${t + 8}px;` : i === "bottom" ? `top: ${t + 8}px;` : i === "left" ? `right: ${e + 12}px;` : `left: ${e + 12}px;`;
    },
    getElementSize(i) {
      if (!(i instanceof HTMLElement))
        throw new Error("Unexpected element");
      return {
        width: i.clientWidth,
        height: i.clientHeight
      };
    }
  },
  watch: {
    isHover() {
      this.contextWrapper = this.$refs.contextWrapper;
    }
  },
  computed: {
    tooltipStyle() {
      if (!this.hideTail)
        return Iw[this.getTailDirection(this.position)];
    },
    tooltipPosition() {
      if (!this.contextWrapper)
        return;
      const { width: i, height: e } = this.getElementSize(this.contextWrapper);
      return this.getTooltipStylePosition({
        position: this.position,
        width: i,
        height: e
      });
    }
  }
};
var Rw = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    class: i.$style.tooltip
  }, [t("div", {
    ref: "contextWrapper",
    class: i.$style.contextWrapper,
    on: {
      mouseover: function() {
        return i.isHover = !0;
      },
      mouseleave: function() {
        return i.isHover = !1;
      }
    }
  }, [i._t("context")], 2), t("div", {
    staticStyle: {
      position: "absolute"
    },
    style: i.tooltipPosition
  }, [t("div", {
    class: i.$style.main_tooltip,
    style: i.styleProps
  }, [t("span", {
    class: [i.tooltipStyle, i.color === "white" ? i.$style.tooltip_text_white : i.$style.tooltip_text_black]
  }, [i._t("body")], 2)])])]);
}, $w = [];
const Nw = "_tooltip_4glrn_1", Fw = "_contextWrapper_4glrn_9", Yw = "_main_tooltip_4glrn_13", Bw = "_tooltip_text_white_4glrn_13", Hw = "_top_4glrn_27", zw = "_bottom_4glrn_38", Vw = "_left_4glrn_49", Xw = "_right_4glrn_60", Ww = "_tooltip_text_black_4glrn_71", Uw = {
  tooltip: Nw,
  contextWrapper: Fw,
  main_tooltip: Yw,
  tooltip_text_white: Bw,
  top: Hw,
  bottom: zw,
  left: Vw,
  right: Xw,
  tooltip_text_black: Ww
}, Ol = {};
Ol.$style = Uw;
var Gw = /* @__PURE__ */ X(
  Ew,
  Rw,
  $w,
  !1,
  Zw,
  "fec4b7ae",
  null,
  null
);
function Zw(i) {
  for (let e in Ol)
    this[e] = Ol[e];
}
const ec = /* @__PURE__ */ function() {
  return Gw.exports;
}(), Kw = {
  props: {
    styleProps: {
      type: [String, Object]
    },
    /**
     * search bar place holder
     */
    placeholderText: {
      type: String,
      default: "placeholder-text"
    },
    /** 검색어와 일치한 list */
    searchList: {
      type: Array,
      default: () => []
    },
    /** searchList 중에 현재 어디에 focus 되어 있는 지 표시. */
    focusPosition: {
      type: Number,
      default: 0
    },
    /** 검색을 시작할 때 사용될 keyword */
    searchCompleteKeyword: {
      type: String,
      default: ""
    },
    /** 검색을 시작하기 전 검색할 검색어를 저장시켜준다. */
    setSearchCompleteKeyword: {
      type: Function,
      default: () => !0
    },
    /** 포커스의 위치를 정한다. */
    setFocusPosition: {
      type: Function,
      default: () => !0
    }
  },
  data() {
    return {
      keyword: "",
      timeout: null,
      focusOnSearchbar: 0
    };
  },
  methods: {
    /**
     * 검색된 keyword 를 complete keyword 로 저장한다.
     * 이미 키워드가 입력된 상태에서 함수를 실행했다면 next search handler 실행
     */
    searchHandler() {
      this.searchCompleteKeyword === this.keyword && this.nextSearchHandler(), this.setSearchCompleteKeyword(this.keyword), this.focusOnSearchbar += 1;
    },
    /** 다음 search list 로 focus를 이동. */
    nextSearchHandler() {
      this.focusPosition < this.searchList.length && this.setFocusPosition(this.focusPosition + 1), this.focusPosition === this.searchList.length && this.setFocusPosition(1), this.focusOnSearchbar += 1;
    },
    /** 이전 search list 로 focus 를 이동. */
    previousSearchHandler() {
      this.focusPosition > 1 && this.setFocusPosition(this.focusPosition - 1), this.focusOnSearchbar += 1;
    },
    searchDebounce() {
      clearTimeout(this.timeout), this.timeout = setTimeout(() => {
        this.searchHandler();
      }, 300);
    }
  },
  watch: {
    focusOnSearchbar() {
      this.$refs.searchInputRef && this.$refs.searchInputRef.focus();
    }
  }
};
var qw = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    staticClass: "search_bar_container",
    style: i.styleProps
  }, [t("div", {
    staticClass: "search_icon",
    on: {
      click: i.searchHandler
    }
  }, [t("img", {
    staticClass: "search_icon_svg",
    attrs: {
      alt: "search Icon"
    }
  })]), t("input", {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: i.keyword,
      expression: "keyword"
    }],
    ref: "searchInputRef",
    staticClass: "search_input",
    attrs: {
      placeholder: i.placeholderText,
      type: "text"
    },
    domProps: {
      value: i.keyword
    },
    on: {
      keyup: i.searchDebounce,
      input: function(s) {
        s.target.composing || (i.keyword = s.target.value);
      }
    }
  }), i.searchList.length && i.focusPosition ? t("div", {
    staticClass: "search_list_wrap"
  }, [t("div", {
    staticClass: "display_searchlist"
  }, [i._v(" " + i._s(i.focusPosition) + " of " + i._s(i.searchList.length) + " ")]), t("div", {
    staticClass: "search_btn"
  }, [t("button", {
    on: {
      click: i.previousSearchHandler
    }
  }, [t("img", {
    attrs: {
      alt: ""
    }
  })]), t("button", {
    on: {
      click: i.nextSearchHandler
    }
  }, [t("img", {
    attrs: {
      alt: ""
    }
  })])])]) : i._e()]);
}, Qw = [];
const Uc = {};
var Jw = /* @__PURE__ */ X(
  Kw,
  qw,
  Qw,
  !1,
  eS,
  "84c49b06",
  null,
  null
);
function eS(i) {
  for (let e in Uc)
    this[e] = Uc[e];
}
const Do = /* @__PURE__ */ function() {
  return Jw.exports;
}(), tS = {
  name: "commonPopover",
  props: {
    /** set visible popover false or true */
    visible: {
      type: Boolean,
      default: !1
    },
    /** Set the classes as string of popover */
    classes: {
      type: String,
      default: ""
    },
    /** set position to display popover */
    position: {
      type: Object,
      default: () => ({ top: "", left: "", right: "", bottom: "" })
    },
    /** close popover when we click outside */
    refName: {
      type: String,
      default: "commonPopover"
    }
  },
  methods: {
    /**
     * it will handle the event of outside click
     * @param event
     */
    handleClickOutside(i) {
      const e = this.$refs[this.refName];
      !((e == null ? void 0 : e.contains(i.target)) ?? !1) && this.visible && this.handleClose();
    },
    /** close handler */
    handleClose() {
      this.$emit("close");
    }
  },
  mounted() {
    window.addEventListener("click", this.handleClickOutside);
  },
  /** Remove click outside handler before instance of component is destroyed */
  beforeDestroy() {
    window.removeEventListener("click", this.handleClickOutside);
  }
};
var iS = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return i.visible ? t("div", {
    ref: i.refName,
    class: [i.visible ? i.$style.show : "", i.$style.common_popover],
    style: {
      left: i.position.left,
      right: i.position.right,
      top: i.position.top,
      bottom: i.position.bottom
    }
  }, [i._t("default")], 2) : i._e();
}, sS = [];
const rS = "_common_popover_1egvj_7", nS = "_show_1egvj_16", aS = {
  common_popover: rS,
  show: nS
}, Ml = {};
Ml.$style = aS;
var oS = /* @__PURE__ */ X(
  tS,
  iS,
  sS,
  !1,
  lS,
  null,
  null,
  null
);
function lS(i) {
  for (let e in Ml)
    this[e] = Ml[e];
}
const tc = /* @__PURE__ */ function() {
  return oS.exports;
}(), uS = "_dropdown_wrap_i13lk_7", cS = "_dropdown_list_i13lk_24", hS = "_checkbox_custom_i13lk_45", dS = "_all_select_list_i13lk_78", fS = "_info_text_i13lk_97", pS = "_list_hover_dropdown_i13lk_103", gS = "_spinner_wrapper_i13lk_106", _S = "_dropdown_footer_i13lk_122", mS = {
  dropdown_wrap: uS,
  dropdown_list: cS,
  checkbox_custom: hS,
  all_select_list: dS,
  info_text: fS,
  list_hover_dropdown: pS,
  spinner_wrapper: gS,
  dropdown_footer: _S
}, Gc = "No Matching Filter", bS = {
  name: "dropdown",
  props: {
    titleName: {
      type: String,
      default: "title"
    },
    /**
     * props for popover
     */
    visible: Boolean,
    /**
     * option list (title: name to be displayed in an option list, image: option image) (ex: {title: 'option1', [image: imageUrl, ...]})
     */
    items: {
      type: Array,
      default: []
    },
    /**
     * On close dropdown when you click outside
     */
    onClose: Function,
    /**
     * Save the final result. (When using checkboxes)
     */
    setResult: Function,
    /**
     * Click handler (if using list click without using checkbox)
     */
    clickHandler: Function,
    /**
     * Set whether checkbox or no
     */
    checkbox: Boolean,
    /**
     * Set whether dropdown-list wrap-style or not (ex: {top: '10px', left: '10px', width: '10px'})
     */
    styleProps: [String, Object],
    /**
     * Set whether placeholder or not
     */
    placeholder: String,
    infoText: {
      Type: String,
      default: ""
    },
    /**
     * Set whether checkbox-id or not
     */
    id: String,
    refName: String
  },
  // alice component
  components: {
    SearchBar: Do,
    CommonPopover: tc
  },
  data() {
    return {
      filteredDependency: 1,
      logTest: !1,
      /**
       * The input value. Shows the input list searched through filtered.
       */
      searchText: "",
      isHover: !1,
      requestParam: {
        query: ""
      },
      // TODO: need to update it by checking change by really value-change
      /** simple check if user has interacted with component or not */
      isInteracted: !1
    };
  },
  computed: {
    /**
     * Filters the items based on the search text.
     * If no items match the search, a special item indicating empty results is returned.
     * The filtered items are sorted alphabetically based on the specified title name.
     * @returns The filtered and sorted items.
     */
    filtered() {
      const i = this.searchText.trim();
      if (this.items.length === 0 || this.filteredDependency === 0 || i.length === 0)
        return this.items;
      const t = this.items.filter(
        (s) => {
          var r;
          return (r = s[this.titleName]) == null ? void 0 : r.toUpperCase().includes(i.toUpperCase());
        }
      );
      return t.length === 0 ? [{ [this.titleName]: Gc }] : t.sort(
        (s, r) => s[this.titleName].toUpperCase() > r[this.titleName].toUpperCase() ? 1 : -1
      );
    },
    checkedArray() {
      return this.filtered.filter((e) => e == null ? void 0 : e.checked);
    },
    /**
     * Determines the dropdown item style based on the checkbox and filtered items.
     * If the checkbox is truthy or any item in 'this.filtered' has 'this.titleName' equal to 'textWhenEmpty',
     * the function returns undefined.Otherwise, it returns 'styles.list_hover_dropdown'.
     * @returns The dropdown item style or undefined.
     */
    dropdownItemStyle() {
      if (!(this.checkbox || this.filtered.some((i) => i[this.titleName] === Gc)))
        return mS.list_hover_dropdown;
    }
  },
  methods: {
    getComputedStyle(i) {
      if (!i.icon)
        return `${i.icon}-icon`;
    },
    search(i) {
      this.searchText = i;
    },
    /**
     * Truncates a given text if its length exceeds a specified limit.
     * @param text - The text to truncate.
     * @param length - The maximum length of the truncated text.
     * @returns - The truncated text or the original text if it is within the length limit.
     */
    truncateText(i, e) {
      return i && i.length > e ? i.substring(0, e) + "..." : i;
    },
    /**
     * Event handler for handling changes to a checkbox.
     * @param event - The change event.
     * @param index - The index of the checkbox in the filtered array.
     */
    changeHandler(i, e) {
      if (this.isInteracted = !0, !this.filtered[e] || !i.target)
        return;
      const t = i.target;
      this.filtered[e].checked = t.checked, this.$set(this.filtered, e, this.filtered[e]), this.filteredDependency += 1;
    },
    onClickOption(i) {
      var e;
      this.checkbox || ((e = this.clickHandler) == null || e.call(this, i), this.handleClose());
    },
    /**
     * Selects all items in the filtered array by setting their 'checked' property to true,
     * if they are not disabled. Updates the filteredDependency counter.
     */
    selectAll() {
      this.isInteracted = !0;
      const i = [...this.filtered];
      this.filtered.length = 0, i.forEach((e) => {
        e.disabled || (e.checked = !0), this.filtered.push(e);
      }), this.filteredDependency += 1;
    },
    /**
     * Deselects all items in the filtered array by setting their 'checked' property to false,
     * if they are not marked as default. Updates the filteredDependency counter.
     */
    unselectAll() {
      this.isInteracted = !0;
      let i = this.filtered.slice();
      this.filtered.splice(0), i == null || i.map((e) => {
        e.default !== !0 && (e.checked = !1), this.filtered.push(e);
      }), this.filteredDependency += 1;
    },
    // handler for popover
    handleClose() {
      var i, e;
      this.isInteracted && this.checkbox && ((i = this == null ? void 0 : this.setResult) == null || i.call(this, this.filtered.filter((t) => t.checked)), this.isInteracted = !1), this.searchText = "", (e = this.onClose) == null || e.call(this);
    }
  }
};
var yS = function() {
  var i, e, t, s, r = this, n = r.$createElement, a = r._self._c || n;
  return a("common-popover", {
    attrs: {
      visible: r.visible,
      "ref-name": r.refName
    },
    on: {
      close: r.handleClose
    }
  }, [a("div", {
    class: r.$style.dropdown_wrap,
    style: r.styleProps
  }, [r.items.length >= 5 ? a("div", [a("search-bar", {
    attrs: {
      "placeholder-text": r.placeholder || "Search",
      "request-param": r.requestParam,
      "set-search-complete-keyword": r.search
    }
  }), a("div", {
    class: r.$style.focus_border
  })], 1) : r._e(), a("ul", {
    class: r.$style.dropdown_list
  }, [r.checkbox && ((i = r.filtered) === null || i === void 0 ? void 0 : i.length) >= 5 ? a("li", {
    class: r.$style.all_select_list
  }, [a("div", {
    attrs: {
      disabled: ((e = r.checkedArray) === null || e === void 0 ? void 0 : e.length) === ((t = r.filtered) === null || t === void 0 ? void 0 : t.length)
    },
    on: {
      click: function(o) {
        return r.selectAll();
      }
    }
  }, [r._v(" Select All ")]), a("div", {
    attrs: {
      disabled: ((s = r.checkedArray) === null || s === void 0 ? void 0 : s.length) === 0
    },
    on: {
      click: function(o) {
        return r.unselectAll();
      }
    }
  }, [r._v(" Unselect All ")])]) : r._e(), a("li", {
    class: r.$style.info_text
  }, [r._v(r._s(r.infoText))]), r._l(r.filtered, function(o, l) {
    return a("li", {
      key: l
    }, [a("label", {
      class: r.dropdownItemStyle,
      attrs: {
        for: `dropdown-input-${l}-${r.id}`,
        disabled: o == null ? void 0 : o.disabled
      },
      on: {
        click: function(u) {
          return u.stopPropagation(), r.onClickOption(o);
        }
      }
    }, [r.checkbox ? [a("input", {
      attrs: {
        id: `dropdown-input-${l}-${r.id}`,
        type: "checkbox"
      },
      domProps: {
        value: JSON.stringify(o),
        checked: o.checked
      },
      on: {
        input: function(u) {
          return u.stopPropagation(), (function(h) {
            return r.changeHandler(h, l);
          }).apply(null, arguments);
        }
      }
    }), a("div", {
      class: r.$style.checkbox_custom
    })] : r._e(), o != null && o.icon ? a("div", {
      class: [r.getComputedStyle(o), r.$style.defualt_style]
    }, [a("img", {
      attrs: {
        src: o.icon,
        alt: "dropdown-icon"
      }
    })]) : r._e(), r._v(" " + r._s(r.truncateText(o[r.titleName], 40)) + " ")], 2)]);
  })], 2)])]);
}, vS = [];
const xS = "_dropdown_wrap_i13lk_7", wS = "_dropdown_list_i13lk_24", SS = "_checkbox_custom_i13lk_45", DS = "_all_select_list_i13lk_78", CS = "_info_text_i13lk_97", TS = "_list_hover_dropdown_i13lk_103", kS = "_spinner_wrapper_i13lk_106", PS = "_dropdown_footer_i13lk_122", OS = {
  dropdown_wrap: xS,
  dropdown_list: wS,
  checkbox_custom: SS,
  all_select_list: DS,
  info_text: CS,
  list_hover_dropdown: TS,
  spinner_wrapper: kS,
  dropdown_footer: PS
}, Al = {};
Al.$style = OS;
var MS = /* @__PURE__ */ X(
  bS,
  yS,
  vS,
  !1,
  AS,
  "3145c6ea",
  null,
  null
);
function AS(i) {
  for (let e in Al)
    this[e] = Al[e];
}
const LS = /* @__PURE__ */ function() {
  return MS.exports;
}(), Vo = {
  default: "_default_18wqu_7",
  "customizing-data-table": "_customizing-data-table_18wqu_25",
  "cross-icon": "_cross-icon_18wqu_44",
  "sort-desc": "_sort-desc_18wqu_53",
  "sort-asce": "_sort-asce_18wqu_65",
  "restore-icon": "_restore-icon_18wqu_78",
  "kebab-menu": "_kebab-menu_18wqu_88",
  "information-icon": "_information-icon_18wqu_92"
}, jS = {
  "restore-icon": "customizing-data-table",
  "kebab-menu": "customizing-data-table"
}, IS = {
  name: "Icon",
  props: {
    /**
     * click handler for icon
     */
    clickHandler: Function,
    /**
     * set active interaction on icon
     */
    active: {
      type: Boolean,
      default: !1
    },
    /**
     * disable the icon active interaction
     */
    disabled: {
      type: Boolean,
      default: !1
    },
    /**
     * change the icon button type
     */
    buttonType: {
      type: String,
      default: "cross-icon"
    },
    /**
     * set icon button style properties {ex {width: 100px; height 100px}}
     */
    styleProps: {
      type: [String, Object]
    }
  },
  computed: {
    /**   Compute button class based on button type and other properties  */
    buttonClassComputed() {
      return `${Vo.default} ${Vo[this.buttonType]} ${Vo[this.classTypeForButton]}`;
    },
    /**   Determine additional class type based on button type   */
    classTypeForButton() {
      return jS[this.buttonType] || "";
    },
    /**
     * Returns the alt attribute value for the icon improve the accessibility.
     * This value is based on the buttonType prop.
     */
    altAttributeComputed() {
      return this.buttonType;
    }
  },
  methods: {
    /**
     * Execute click handler method
     */
    executor() {
      var i;
      (i = this.clickHandler) == null || i.call(this);
    }
  }
};
var ES = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    class: i.buttonClassComputed,
    style: i.styleProps,
    attrs: {
      active: i.active,
      disabled: i.disabled
    },
    on: {
      click: i.executor
    }
  }, [t("div", {
    class: i.$style.icon_size
  }, [t("img", {
    attrs: {
      src: "#",
      alt: i.altAttributeComputed
    }
  })])]);
}, RS = [];
const $S = {
  default: "_default_18wqu_7",
  "customizing-data-table": "_customizing-data-table_18wqu_25",
  "cross-icon": "_cross-icon_18wqu_44",
  "sort-desc": "_sort-desc_18wqu_53",
  "sort-asce": "_sort-asce_18wqu_65",
  "restore-icon": "_restore-icon_18wqu_78",
  "kebab-menu": "_kebab-menu_18wqu_88",
  "information-icon": "_information-icon_18wqu_92"
}, Ll = {};
Ll.$style = $S;
var NS = /* @__PURE__ */ X(
  IS,
  ES,
  RS,
  !1,
  FS,
  "ff490b88",
  null,
  null
);
function FS(i) {
  for (let e in Ll)
    this[e] = Ll[e];
}
const hf = /* @__PURE__ */ function() {
  return NS.exports;
}();
function YS(i, e) {
  let t = null, s = 0;
  return (...r) => {
    const n = Date.now(), a = async () => (s = Date.now(), t = null, await i(...r));
    return n - s > e ? a() : new Promise((o) => {
      t && clearTimeout(t), t = setTimeout(async () => {
        o(await a());
      }, e - (n - s));
    });
  };
}
const BS = {
  name: "Dropdown",
  props: {
    initialMode: {
      type: String,
      default: "SELECTED"
    },
    /**
     * props for popover
     */
    visible: Boolean,
    /**
     * option list (title: name to be displayed in option list, image: option image) (ex: {title: 'option1', [image: imageUrl, ...]})
     */
    items: {
      type: Array,
      default: () => []
    },
    /**
     * On close dropdown when you click outside
     */
    onClose: Function,
    /**
     * Set whether dropdown-list wrap-style or not (ex: {top: '10px', left: '10px', width: '10px'})
     */
    styleProps: [String, Object],
    /**
     * Set whether placeholder or not
     */
    placeholder: String,
    infoText: {
      Type: String,
      default: ""
    },
    /**
     * Set whether checkbox-id or not
     */
    id: String,
    position: {
      type: Object,
      default: () => ({ top: "", left: "", right: "", bottom: "" })
    },
    onApplyButtonClicked: {
      type: Function,
      required: !0
    },
    fetchHandler: Function,
    hasSearchBar: {
      type: Boolean,
      default: !0
    },
    pageSize: {
      type: Number,
      default: 10
    },
    selectedIdsInServer: {
      type: Array,
      default: () => []
    },
    unselectedIdsInServer: {
      type: Array,
      default: () => []
    },
    isModeChangable: {
      type: Boolean,
      default: !0
    },
    refName: String
  },
  // alice component
  components: {
    SearchBar: Do,
    CommonPopover: tc,
    CtaButton: Fs,
    DotSpinner: gw
  },
  data() {
    return {
      mode: "SELECTED",
      /** The input value. Shows the input list searched through filtered. */
      searchText: "",
      isLoading: !1,
      itemList: [],
      hasReachedMax: !1,
      page: 1,
      size: this.pageSize,
      selectedIds: [],
      unselectedIds: []
    };
  },
  computed: {
    // Filter your search terms
    filteredItems() {
      const i = this.searchText.trim();
      return this.itemList.length === 0 || this.searchText.length === 0 ? this.itemList : this.itemList.filter(({ name: t }) => t.toUpperCase().includes(i.toUpperCase())).sort((t, s) => {
        const r = t.name, n = s.name;
        return r.toUpperCase() > n.toUpperCase() ? 1 : -1;
      });
    },
    isButtonEnabled() {
      return this.mode === "SELECTED" ? this.selectedIds.length > 0 : this.hasReachedMax ? !this.filteredItems.every(({ id: e }) => this.unselectedIds.includes(e)) : !0;
    },
    throttledFetchFilterItems() {
      return YS(this.fetchFilterItems, 200);
    }
  },
  watch: {
    initialMode: {
      handler() {
        this.mode = this.initialMode;
      },
      immediate: !0
    },
    selectedIdsInServer: {
      handler() {
        this.selectedIds = this.selectedIdsInServer;
      },
      immediate: !0
    },
    unselectedIdsInServer: {
      handler() {
        this.unselectedIds = this.unselectedIdsInServer;
      },
      immediate: !0
    },
    items: {
      handler() {
        this.itemList = this.items;
      },
      immediate: !0
    },
    searchText() {
      this.clearData({
        itemList: !1,
        searchText: !1
      }), this.throttledFetchFilterItems();
    }
  },
  methods: {
    clearData({
      searchText: i = !0,
      itemList: e = !0,
      page: t = !0,
      hasReachedMax: s = !0
    }) {
      i && (this.searchText = ""), e && (this.itemList = []), t && (this.page = 1), s && (this.hasReachedMax = !1);
    },
    isChecked(i) {
      return this.mode === "SELECTED" ? this.selectedIds.includes(i) : !this.unselectedIds.includes(i);
    },
    updateSearchText(i) {
      this.searchText = i;
    },
    truncateText(i, e) {
      return i && i.length > e ? i.substring(0, e) + "..." : i;
    },
    onCheckboxChanged(i, e) {
      const t = i.target.checked;
      if (this.mode === "SELECTED") {
        if (t) {
          this.selectedIds.push(e.id);
          return;
        }
        this.selectedIds = this.selectedIds.filter((s) => s !== e.id);
        return;
      }
      if (t) {
        this.unselectedIds = this.unselectedIds.filter((s) => s !== e.id);
        return;
      }
      this.unselectedIds.push(e.id);
    },
    changeMode(i) {
      this.mode = i, this.selectedIds = [], this.unselectedIds = [];
    },
    // handler for popover
    handleClose() {
      var i;
      this.clearData({}), (i = this.onClose) == null || i.call(this);
    },
    /**
     * get scroll position in percentage
     */
    getScrollPosition(i) {
      const e = i, t = e.offsetHeight, s = e.scrollTop, r = e.scrollHeight;
      return (t + s) / r * 100;
    },
    async scrollHandler() {
      if (this.hasReachedMax || !this.fetchHandler || this.isLoading)
        return;
      const i = this.$refs.scrollContainer;
      this.getScrollPosition(i) > 80 && (this.isLoading = !0, await this.fetchFilterItems(), this.isLoading = !1);
    },
    async fetchFilterItems() {
      if (this.hasReachedMax || !this.fetchHandler)
        return;
      const i = await this.fetchHandler({
        page: this.page,
        size: this.size,
        query: this.searchText
      });
      this.hasReachedMax = i.last, this.page++, this.itemList = [
        ...this.itemList,
        ...i.content.filter((e) => this.itemList.every(
          (t) => t.id !== e.id
        ))
      ].sort((e, t) => {
        const s = e.name, r = t.name;
        return s.toUpperCase() > r.toUpperCase() ? 1 : -1;
      });
    }
  },
  mounted() {
    this.itemList.length === 0 && this.fetchHandler && this.fetchFilterItems();
  }
};
var HS = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("common-popover", {
    attrs: {
      visible: i.visible,
      position: i.position,
      "ref-name": i.refName
    },
    on: {
      close: i.handleClose
    }
  }, [t("div", {
    class: i.$style.dropdown_wrap,
    style: i.styleProps
  }, [i.itemList.length >= 5 && i.hasSearchBar ? t("div", [t("search-bar", {
    attrs: {
      "placeholder-text": i.placeholder || "Search",
      "set-search-complete-keyword": i.updateSearchText
    }
  }), t("div", {
    class: i.$style.focus_border
  })], 1) : i._e(), t("ul", {
    ref: "scrollContainer",
    class: i.$style.dropdown_list,
    on: {
      scroll: i.scrollHandler
    }
  }, [i.isModeChangable && i.filteredItems.length >= 5 ? t("li", {
    class: i.$style.all_select_list
  }, [t("div", {
    attrs: {
      disabled: i.mode === "UNSELECTED" && i.unselectedIds.length === 0
    },
    on: {
      click: function() {
        return i.changeMode("UNSELECTED");
      }
    }
  }, [i._v(" Select All ")]), t("div", {
    attrs: {
      disabled: i.mode === "SELECTED" && i.selectedIds.length === 0
    },
    on: {
      click: function() {
        return i.changeMode("SELECTED");
      }
    }
  }, [i._v(" Unselect All ")])]) : i._e(), t("li", [i.filteredItems.length == 0 ? t("label", [i._v(" No Matching Filter ")]) : i._e()]), t("li", {
    class: i.$style.info_text
  }, [i._v(i._s(i.infoText))]), i._l(i.filteredItems, function(s, r) {
    return t("li", {
      key: r
    }, [t("label", {
      class: [i.$style.list_hover_dropdown],
      attrs: {
        for: `dropdown-input-${r}-${i.id}`
      }
    }, [t("input", {
      attrs: {
        id: `dropdown-input-${r}-${i.id}`,
        type: "checkbox"
      },
      domProps: {
        checked: i.isChecked(s.id)
      },
      on: {
        input: function(n) {
          return i.onCheckboxChanged(n, s);
        }
      }
    }), t("div", {
      class: i.$style.checkbox_custom
    }), i._v(" " + i._s(i.truncateText(s.name, 40)) + " ")])]);
  }), i.isLoading ? t("div", {
    class: i.$style.spinner_wrapper
  }, [t("dot-spinner")], 1) : i._e()], 2), i.filteredItems.length > 0 ? t("div", {
    class: i.$style.dropdown_footer
  }, [t("cta-button", {
    attrs: {
      "color-type": "blue-fill",
      disabled: !i.isButtonEnabled,
      "click-handler": function() {
        return i.onApplyButtonClicked({
          mode: i.mode,
          selectedIds: i.selectedIds,
          unselectedIds: i.unselectedIds
        });
      }
    }
  }, [i._v(" Apply Filter ")])], 1) : i._e()])]);
}, zS = [];
const VS = "_dropdown_wrap_i13lk_7", XS = "_dropdown_list_i13lk_24", WS = "_checkbox_custom_i13lk_45", US = "_all_select_list_i13lk_78", GS = "_info_text_i13lk_97", ZS = "_list_hover_dropdown_i13lk_103", KS = "_spinner_wrapper_i13lk_106", qS = "_dropdown_footer_i13lk_122", QS = {
  dropdown_wrap: VS,
  dropdown_list: XS,
  checkbox_custom: WS,
  all_select_list: US,
  info_text: GS,
  list_hover_dropdown: ZS,
  spinner_wrapper: KS,
  dropdown_footer: qS
}, jl = {};
jl.$style = QS;
var JS = /* @__PURE__ */ X(
  BS,
  HS,
  zS,
  !1,
  e1,
  "90468d6c",
  null,
  null
);
function e1(i) {
  for (let e in jl)
    this[e] = jl[e];
}
const t1 = /* @__PURE__ */ function() {
  return JS.exports;
}(), i1 = {
  props: {
    getSavedFilterList: {
      type: Function,
      required: !0
    },
    getFilterResourceTypes: {
      type: Function,
      required: !0
    },
    getFilterItems: {
      type: Function,
      required: !0
    },
    saveFilterItems: {
      type: Function,
      required: !0
    },
    clearAllFilterItems: {
      type: Function,
      required: !0
    },
    clearFilterItems: {
      type: Function,
      required: !0
    },
    notifyFilterUpdated: {
      type: Function,
      required: !0
    }
  },
  data() {
    return {
      currentMode: "SELECTED",
      searchQuery: "",
      pageNumber: 1,
      currentResourceType: "",
      placeholder: "Search Filter",
      resourceTypeList: [],
      savedFilterList: [],
      isResourceTypesDropdownVisible: !1,
      isResourceTypesContentsDropdownVisible: !1,
      filterListVisbleNumber: null
    };
  },
  computed: {
    computedPlaceholder() {
      return `Search ${this.capitalizeFirstLetter(
        this.currentResourceType.toLowerCase()
      )}`;
    }
  },
  methods: {
    getTooltipStyles() {
      return "width: 100px;";
    },
    getDropdownStyleProps() {
      return "top: 100%; left: 0px; min-width: 205px; margin-top: 2px;";
    },
    // button click handler ===========================================================================================================
    resourceTypeContentsDropdownCloseHandler() {
      console.log("resourceTypeContentsDropdownCloseHandler"), this.isResourceTypesContentsDropdownVisible = !1;
    },
    resourceTypesDropdownCloseHandler() {
      console.log("resourceTypeListCloseHandler"), this.isResourceTypesDropdownVisible = !1;
    },
    selectedDropdownCloseHandler() {
      console.log("selectedDropdownCloseHandler()"), this.filterListVisbleNumber = null;
    },
    /**
     * filter button 을 클릭했을 때 resourceType 을 전달하여 dropdown에 들어갈 데이터를 불러옵니다.
     */
    onResourceTypeButtonClicked(i, e) {
      this.isResourceTypesContentsDropdownVisible = !1, this.isResourceTypesDropdownVisible = !1, this.filterListVisbleNumber === e ? this.filterListVisbleNumber = null : (this.filterListVisbleNumber = e, this.currentResourceType = i);
    },
    /**
     * add filter 를 클릭했을 때 나오는 resourceType List를 클릭했을 때 진행할 동작입니다.
     */
    onResourceTypeDropdownItemClicked(i) {
      !("resourceType" in i) || typeof i.resourceType != "string" || (this.isResourceTypesContentsDropdownVisible = !0, this.filterListVisbleNumber = null, this.isResourceTypesDropdownVisible = !1, this.currentResourceType = i.resourceType);
    },
    async onAddFilterButtonClicked() {
      console.log("addFilterClickHandler"), await this.fetchFilterResourceType(), this.filterListVisbleNumber = null, this.isResourceTypesContentsDropdownVisible = !1, this.isResourceTypesDropdownVisible = !this.isResourceTypesDropdownVisible;
    },
    capitalizeFirstLetter(i) {
      return i.charAt(0).toUpperCase() + i.slice(1);
    },
    // APi ============================================================================================================================
    /**
     * 맨 처음 페이지 진입 시 저장해놓은 필터리스트를 확인하고 가져오기 위해 사용 (mount 시에 사용)
     */
    async fetchSavedFilterItems() {
      try {
        const { content: i } = await this.getSavedFilterList();
        console.log(i), this.savedFilterList = i, this.isResourceTypesContentsDropdownVisible = !1, this.isResourceTypesDropdownVisible = !1, this.filterListVisbleNumber = null;
      } catch {
      }
    },
    // TODO(sun.lee): Remove sleep after BackEnd resolve unmatched data problem.
    sleep(i) {
      return new Promise((e) => setTimeout(e, i));
    },
    /**
     * 저장된 개별 필터 내역을 삭제한다.
     */
    async deleteSavedFilterItems(i) {
      try {
        await this.clearFilterItems(i), await this.sleep(200), await this.fetchSavedFilterItems(), this.notifyFilterUpdated();
      } catch {
      }
    },
    /**
     * 저장된 모든 필터 리스트를 삭제한다.
     */
    async deleteAllSavedFilterItems() {
      try {
        await this.clearAllFilterItems(), await this.sleep(200), await this.fetchSavedFilterItems(), this.notifyFilterUpdated();
      } catch {
      }
    },
    async requestSaveFilterItems(i) {
      try {
        await this.saveFilterItems({
          ...i,
          resourceType: this.currentResourceType
        }), await this.fetchSavedFilterItems(), this.notifyFilterUpdated();
      } catch {
      }
    },
    async fetchFilterResourceType() {
      try {
        const { content: i } = await this.getFilterResourceTypes();
        this.resourceTypeList = i;
      } catch {
      }
    },
    getSelectedIds(i) {
      if ("selectedIds" in i)
        return i.selectedIds;
    },
    getUnselectedIds(i) {
      if ("unselectedIds" in i)
        return i.unselectedIds;
    }
  },
  mounted() {
    this.fetchSavedFilterItems();
  },
  components: {
    CtaButton: Fs,
    Tooltip: ec,
    Dropdown: LS,
    MasterDropdown: t1,
    // TODO(sun.lee): It looks really weird. Icon acts like a IconButton.
    Icon: hf
  }
}, s1 = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTE1IgogIGhlaWdodD0iMTA1IgogIHZpZXdCb3g9IjAgMCAxMTUgMTA1IgogIGZpbGw9Im5vbmUiCiAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8cGF0aCBkPSJNMTExIDRINEw0Ni44MDQ2IDU0Ljk4MTNWOTAuMjIzMUw2OC4yMDMxIDEwMVY1NC45ODEzTDExMSA0WiIKICAgIHN0cm9rZT0iIzM0OTFGRiIKICAgIHN0cm9rZS13aWR0aD0iOCIKICAgIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIKICAgIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz4KPC9zdmc+Cg==";
var r1 = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    staticClass: "filter_container",
    style: {
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      gap: "8px"
    }
  }, [i._l(i.savedFilterList, function(s, r) {
    return t("div", {
      key: r,
      staticClass: "filter_element"
    }, [s.selectedCount > 0 ? t("cta-button", {
      attrs: {
        "style-props": {
          color: "#4b4b4b"
        },
        "click-handler": function() {
          return i.onResourceTypeButtonClicked(s.resourceType, r);
        }
      }
    }, [t("div", {
      staticClass: "filter_wrapper",
      style: {
        display: "flex",
        justifyContent: "center",
        alignItems: "center"
      }
    }, [t("span", [i._v(i._s(`${s.selectedCount} ${i.capitalizeFirstLetter(`${s.resourceType}s`.toLowerCase())}`) + " ")]), t("div", {
      staticStyle: {
        "margin-left": "8px"
      }
    }, [t("tooltip", {
      attrs: {
        color: "white",
        "style-props": "width: 72px"
      },
      scopedSlots: i._u([{
        key: "context",
        fn: function() {
          return [t("icon", {
            attrs: {
              "style-props": {
                padding: 0,
                width: "12px",
                height: "12px"
              },
              "click-handler": function() {
                return i.deleteSavedFilterItems(s.resourceType);
              }
            }
          })];
        },
        proxy: !0
      }, {
        key: "body",
        fn: function() {
          return [t("div", [i._v("Clear Filter")])];
        },
        proxy: !0
      }], null, !0)
    })], 1)])]) : i._e(), i.filterListVisbleNumber === r ? t("master-dropdown", {
      attrs: {
        "fetch-handler": function(n) {
          return i.getFilterItems(Object.assign({}, n, {
            resourceType: i.currentResourceType
          }));
        },
        "initial-mode": s.mode,
        "selected-ids-in-server": i.getSelectedIds(s),
        "unselected-ids-in-server": i.getUnselectedIds(s),
        "on-apply-button-clicked": i.requestSaveFilterItems,
        "on-close": i.selectedDropdownCloseHandler,
        visible: i.filterListVisbleNumber === r,
        "ref-name": `selectedDropdown-${r}`,
        "style-props": i.getDropdownStyleProps(),
        "title-name": "name",
        selected: !0,
        "resource-type": s.resourceType,
        mode: s.mode,
        "is-mode-changable": !1
      }
    }) : i._e()], 1);
  }), t("div", {
    staticClass: "filter_element"
  }, [t("cta-button", {
    attrs: {
      "color-type": "blue",
      "click-handler": i.onAddFilterButtonClicked
    }
  }, [t("span", [i._v("Add Filter")]), t("div", {
    staticStyle: {
      width: "8px"
    }
  }), t("img", {
    attrs: {
      width: "16px",
      src: s1,
      alt: "filter icon"
    }
  })]), t("dropdown", {
    attrs: {
      "ref-name": "resourceTypesDropdown",
      "click-handler": i.onResourceTypeDropdownItemClicked,
      "on-close": i.resourceTypesDropdownCloseHandler,
      visible: i.isResourceTypesDropdownVisible,
      items: i.resourceTypeList.length === 0 ? [{
        name: "All available filters are in use"
      }] : i.resourceTypeList.map(function(s) {
        return Object.assign({}, s, {
          name: i.capitalizeFirstLetter(s.name.toLowerCase())
        });
      }),
      "title-name": "name",
      "style-props": i.getDropdownStyleProps(),
      checkbox: !1,
      placeholder: "Search Filter"
    }
  }), i.isResourceTypesContentsDropdownVisible && i.filterListVisbleNumber === null ? t("master-dropdown", {
    attrs: {
      "ref-name": "resourceTypeContentsDropdown",
      "on-apply-button-clicked": i.requestSaveFilterItems,
      "on-close": i.resourceTypeContentsDropdownCloseHandler,
      visible: i.isResourceTypesContentsDropdownVisible && i.filterListVisbleNumber === null,
      "style-props": i.getDropdownStyleProps(),
      placeholder: i.computedPlaceholder,
      "fetch-handler": function(s) {
        return i.getFilterItems(Object.assign({}, s, {
          resourceType: i.currentResourceType
        }));
      }
    }
  }) : i._e()], 1), t("tooltip", {
    attrs: {
      color: "white",
      "style-props": "width: 92px"
    },
    scopedSlots: i._u([{
      key: "context",
      fn: function() {
        return [i.savedFilterList.length > 0 ? t("icon", {
          attrs: {
            "style-props": {
              width: "12px",
              height: "12px",
              padding: "8px",
              boxSizing: "content-box"
            },
            "click-handler": i.deleteAllSavedFilterItems
          }
        }) : i._e()];
      },
      proxy: !0
    }, {
      key: "body",
      fn: function() {
        return [t("div", [i._v("Clear All Filters")])];
      },
      proxy: !0
    }])
  })], 2);
}, n1 = [];
const Zc = {};
var a1 = /* @__PURE__ */ X(
  i1,
  r1,
  n1,
  !1,
  o1,
  null,
  null,
  null
);
function o1(i) {
  for (let e in Zc)
    this[e] = Zc[e];
}
const MN = /* @__PURE__ */ function() {
  return a1.exports;
}(), l1 = "#ffffff", Kc = "#4b4b4b", u1 = {
  name: "progressBar",
  props: {
    /**
     * value to fill progressbar
     */
    value: {
      type: Number,
      required: !0
    },
    /**
     * The progress percentage<br>
     * = (`value` * 100) / `bufferValue`
     */
    bufferValue: {
      type: Number,
      default: 100
    },
    /**
     * background color for progress-bar
     */
    bgColor: {
      type: String,
      default: "green"
    },
    /**
     * If `borderColor` is not defined,
     * the border color is the same with `bgColor.`
     */
    borderColor: String,
    styleProps: [String, Object]
  },
  computed: {
    /**
     * compute Progress bar width
     * @return  width to fill progress bar
     */
    computedProgressWidth() {
      if (this.bufferValue === 0)
        return 0;
      const i = this.value * 100 / this.bufferValue;
      return i > 100 ? 100 : i;
    },
    /**
     * compute style of progress bar including border color, background color and width
     */
    computedStyle() {
      return `width:${this.computedProgressWidth}%; background:${this.bgColor}; border-color:${this.borderColor ?? this.bgColor};`;
    }
  },
  methods: {
    /**
     * calculate color
     * @param object of R G B value
     * @return color value based on RGB provided in param
     */
    calculateRelativeLuminance({ r: i, g: e, b: t }) {
      const s = i / 255, r = e / 255, n = t / 255, a = s <= 0.03928 ? s / 12.92 : Math.pow((s + 0.055) / 1.055, 2.4), o = r <= 0.03928 ? r / 12.92 : Math.pow((r + 0.055) / 1.055, 2.4), l = n <= 0.03928 ? n / 12.92 : Math.pow((n + 0.055) / 1.055, 2.4);
      return 0.2126 * a + 0.7152 * o + 0.0722 * l;
    },
    /**
     * get R G B values from color
     * @param color
     * @return object of RGB values
     */
    getRGBValues(i) {
      let e = {};
      if (i.startsWith("#"))
        e.r = parseInt(i.substring(1, 3), 16), e.g = parseInt(i.substring(3, 5), 16), e.b = parseInt(i.substring(5, 7), 16);
      else if (i.startsWith("rgb")) {
        const t = /(\d+),\s*(\d+),\s*(\d+)/.exec(
          i
        );
        e.r = parseInt(t[1], 10), e.g = parseInt(t[2], 10), e.b = parseInt(t[3], 10);
      } else
        e.r = 255, e.g = 255, e.b = 255;
      return e;
    },
    /**
     * set font color
     */
    updateFontColor() {
      const i = this.$refs.progressValueBox, e = this.$refs.textRef, t = window.getComputedStyle(i).getPropertyValue("background-color"), s = this.getRGBValues(t), r = this.calculateRelativeLuminance(s);
      e.style.color = r > 0.5 ? Kc : l1;
    }
  },
  watch: {
    /**
     * set text color based on width
     */
    computedProgressWidth() {
      if (this.computedProgressWidth >= 48)
        this.updateFontColor();
      else {
        const i = this.$refs.textRef;
        i.style.color = Kc;
      }
    }
  }
};
var c1 = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    class: i.$style.container,
    style: i.styleProps
  }, [t("div", {
    class: i.$style.progressbar
  }, [t("div", {
    ref: "progressValueBox",
    class: i.$style.progressbar_value,
    style: i.computedStyle
  })]), t("div", {
    ref: "textRef",
    class: i.$style.progress_text
  }, [i._t("value")], 2)]);
}, h1 = [];
const d1 = "_container_339y8_7", f1 = "_progressbar_339y8_14", p1 = "_progressbar_value_339y8_19", g1 = "_progress_text_339y8_23", _1 = {
  container: d1,
  progressbar: f1,
  progressbar_value: p1,
  progress_text: g1
}, Il = {};
Il.$style = _1;
var m1 = /* @__PURE__ */ X(
  u1,
  c1,
  h1,
  !1,
  b1,
  null,
  null,
  null
);
function b1(i) {
  for (let e in Il)
    this[e] = Il[e];
}
const AN = /* @__PURE__ */ function() {
  return m1.exports;
}(), y1 = {
  "change-state": "Change State",
  default: "Change State",
  disable: "Disable",
  note: "Note",
  edit: "Edit",
  enable: "Enable",
  export: "Export",
  view: "View",
  reset: "Reset",
  register: "Register",
  "view-edit-history": "View Edit History",
  "shift-config": "Shift Config",
  "role-user-config": "Role-User Config",
  "remove-from-product": "Remove from Product",
  "role-permission-config": "Set Permission",
  "custom-icon": "Custom icon"
}, v1 = {
  name: "actionBar",
  props: {
    /** function for click handler */
    emit: Function,
    /** active prop to set active state */
    active: Boolean,
    /** disabled prop to set disabled state */
    disabled: Boolean,
    /** iconType to set icon of button (default,disable,note,edit,enable,export..)*/
    iconType: {
      type: String,
      default: ""
    },
    /** size prop to set button size (small or "")*/
    size: {
      type: String,
      default: ""
    },
    /** imgSrc to set url of the icon */
    imgSrc: {
      type: String
    },
    /** label to set text of button */
    label: {
      type: String
    }
  },
  computed: {
    /**
     * compute Icon label
     */
    labelTextChange() {
      return y1[this.iconType] ?? this.label ?? "";
    },
    /**
     * compute button style and size
     */
    buttonClassComputed() {
      return `default default-color ${this.iconType} ${this.size}`;
    }
  },
  methods: {
    /**
     * Handle the emit
     * @return void
     */
    executor() {
      var i;
      (i = this.emit) == null || i.call(this);
    }
  }
};
var x1 = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    class: i.buttonClassComputed,
    attrs: {
      active: i.active,
      disabled: i.disabled
    },
    on: {
      click: i.executor
    }
  }, [i.iconType === "custom-icon" ? t("span", [i._v(i._s(i.label))]) : t("span", [i._v(i._s(i.labelTextChange))]), i.iconType === "custom-icon" ? t("img", {
    staticClass: "right-side-image",
    attrs: {
      src: i.imgSrc,
      alt: "embd-actionbar-custom-icon"
    }
  }) : t("img", {
    class: i.iconType,
    attrs: {
      src: "#",
      alt: "embd-button-actionbar-icon"
    }
  })]);
}, w1 = [];
const qc = {};
var S1 = /* @__PURE__ */ X(
  v1,
  x1,
  w1,
  !1,
  D1,
  "1d98e168",
  null,
  null
);
function D1(i) {
  for (let e in qc)
    this[e] = qc[e];
}
const LN = /* @__PURE__ */ function() {
  return S1.exports;
}(), C1 = {
  name: "timelineStepper",
  props: {
    /** set the status and change shape {e.g unconfirmed, confirmed, start, current} */
    step: {
      type: String,
      default: "current"
    },
    /** it works opposite to the last props. */
    opposite: {
      type: Boolean,
      default: !1
    },
    /** set to true to if its last stepper, to not show the line  */
    last: {
      type: Boolean,
      default: !1
    },
    /** set the style props  */
    styleProps: {
      type: [String, Object]
    }
  }
};
var T1 = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    class: i.$style.horizontal_progress_bar_content_box,
    style: i.styleProps
  }, [t("div", {
    class: i.$style.progress_indicator_box
  }, [t("div", {
    class: [i.$style.progress_indicator_circle, i.$style[i.step]]
  }), t("div", {
    class: [i.$style.progress_indicator_line, i.$style[i.step], i.opposite ? i.$style.opposite : "", i.last ? i.$style.last : ""]
  })]), t("div", [i._t("content")], 2)]);
}, k1 = [];
const P1 = "_horizontal_progress_bar_content_box_17r5w_1", O1 = "_progress_indicator_box_17r5w_6", M1 = "_progress_indicator_circle_17r5w_14", A1 = "_start_17r5w_35", L1 = "_confirmed_17r5w_44", j1 = "_current_17r5w_51", I1 = "_unconfirmed_17r5w_58", E1 = "_progress_indicator_line_17r5w_65", R1 = "_opposite_17r5w_79", $1 = "_last_17r5w_91", N1 = {
  horizontal_progress_bar_content_box: P1,
  progress_indicator_box: O1,
  progress_indicator_circle: M1,
  start: A1,
  confirmed: L1,
  current: j1,
  unconfirmed: I1,
  progress_indicator_line: E1,
  opposite: R1,
  last: $1
}, El = {};
El.$style = N1;
var F1 = /* @__PURE__ */ X(
  C1,
  T1,
  k1,
  !1,
  Y1,
  "907e14c6",
  null,
  null
);
function Y1(i) {
  for (let e in El)
    this[e] = El[e];
}
const jN = /* @__PURE__ */ function() {
  return F1.exports;
}(), B1 = {
  name: "widget",
  components: { Icon: hf },
  props: {
    /**
     * to set the width and height of the widget {e.g {width  : 10rem; height 10rem }}
     * */
    styleProps: [String, Object],
    /**
     * use to set the heading
     * */
    headerText: String
  }
};
var H1 = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    class: i.$style["widget-container"],
    style: i.styleProps
  }, [t("div", {
    class: i.$style["widget-header"]
  }, [t("div", {
    class: i.$style["widget-header-info"]
  }, [t("p", [i._v(i._s(i.headerText))]), i._t("tooltip")], 2), t("div", {
    class: i.$style["widget-header-slot"]
  }, [i._t("header")], 2)]), t("div", {
    class: i.$style["widget-body"]
  }, [i._t("body")], 2), t("div", {
    class: i.$style["widget-footer"]
  }, [i._t("footer")], 2)]);
}, z1 = [];
const V1 = {
  "widget-container": "_widget-container_l10na_13",
  "widget-header": "_widget-header_l10na_21",
  "widget-header-info": "_widget-header-info_l10na_30",
  "widget-header-slot": "_widget-header-slot_l10na_43",
  "widget-body": "_widget-body_l10na_49",
  "widget-footer": "_widget-footer_l10na_54"
}, Rl = {};
Rl.$style = V1;
var X1 = /* @__PURE__ */ X(
  B1,
  H1,
  z1,
  !1,
  W1,
  null,
  null,
  null
);
function W1(i) {
  for (let e in Rl)
    this[e] = Rl[e];
}
const IN = /* @__PURE__ */ function() {
  return X1.exports;
}(), U1 = {
  props: {
    changeHandlerParam: {
      type: Array,
      default: () => []
    },
    /** changeHandler for checklist returns checked items */
    changeHandler: {
      type: Function,
      default: () => !0
    },
    /** field name of ID in item object i.e. (resourceId...)*/
    idName: {
      type: String,
      default: ""
    },
    /** field name of value in item object i.e (permitted..)*/
    valueName: {
      type: String,
      default: ""
    },
    /** field name of checked in item object i.e. (permitted...)*/
    checkedName: {
      type: String,
      default: "checked"
    },
    /** field name of disabled in item object i.e. (enabled/disabled/editable..)*/
    disabledName: {
      type: String,
      default: "disabled"
    },
    enabledName: {
      type: String,
      default: ""
    },
    /** field name of enabled in item object i.e. (name/title...) */
    labelTextName: {
      type: String,
      default: "name"
    },
    /** Style Prop */
    styleProps: {
      type: String,
      default: ""
    },
    /** size prop (small or "") */
    size: {
      type: String,
      default: ""
    },
    /** flex direction prop (row or column) */
    flexDirection: {
      type: String,
      default: "column"
    },
    /** list of items */
    itemList: {
      type: Array,
      default: () => []
    },
    /** category */
    category: {
      type: String,
      default: ""
    }
  },
  computed: {
    checkListClassComputed() {
      return `${this.$style.check_list} ${this.$style[this.size]} ${this.$style[this.flexDirection]}`;
    }
  }
};
var G1 = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("ul", {
    class: i.checkListClassComputed,
    style: i.styleProps
  }, i._l(i.itemList, function(s, r) {
    return t("li", {
      key: r
    }, [t("label", {
      attrs: {
        for: `${i.category ? i.category : "checkbox"}-${s[i.idName]}-${r}`,
        disabled: i.enabledName ? !s[i.enabledName] : !!s[i.disabledName]
      }
    }, [t("input", {
      attrs: {
        id: `${i.category ? i.category : "checkbox"}-${s[i.idName]}-${r}`,
        type: "checkbox"
      },
      domProps: {
        value: s[i.checkedName],
        checked: !!s[i.checkedName]
      },
      on: {
        input: function(n) {
          var a;
          return (a = i).changeHandler.apply(a, [n].concat(i.changeHandlerParam));
        }
      }
    }), t("div", {
      class: [`${i.$style.checkbox_custom} ${s[i.labelTextName] ? i.$style.with_label : ""}`]
    }), i._t("default")], 2)]);
  }), 0);
}, Z1 = [];
const K1 = "_check_list_1ywte_5", q1 = "_row_1ywte_13", Q1 = "_checkbox_custom_1ywte_20", J1 = "_with_label_1ywte_47", eD = "_small_1ywte_66", tD = {
  check_list: K1,
  row: q1,
  checkbox_custom: Q1,
  with_label: J1,
  small: eD
}, $l = {};
$l.$style = tD;
var iD = /* @__PURE__ */ X(
  U1,
  G1,
  Z1,
  !1,
  sD,
  null,
  null,
  null
);
function sD(i) {
  for (let e in $l)
    this[e] = $l[e];
}
const EN = /* @__PURE__ */ function() {
  return iD.exports;
}(), rD = {
  name: "Chips",
  props: {
    /**
     * set chips container style properties {ex {width: 100px; height 100px}}
     */
    styleProps: [String, Object],
    /**
     * set inactive state
     */
    inactive: {
      type: Boolean,
      default: !1
    },
    /**
     * set close icon handler
     */
    clickHandler: Function
  },
  methods: {
    /**
     * click handler to return the value
     */
    executor() {
      var i;
      (i = this.clickHandler) == null || i.call(this);
    }
  }
};
var nD = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    class: i.$style["chips-container"],
    style: i.styleProps,
    attrs: {
      inactive: i.inactive
    }
  }, [t("span", [i._t("default")], 2), i.inactive ? i._e() : t("div", {
    on: {
      click: i.executor
    }
  }, [t("img", {
    attrs: {
      alt: "close-icon"
    }
  })])]);
}, aD = [];
const oD = {
  "chips-container": "_chips-container_1ltme_1"
}, Nl = {};
Nl.$style = oD;
var lD = /* @__PURE__ */ X(
  rD,
  nD,
  aD,
  !1,
  uD,
  "1e0ff11c",
  null,
  null
);
function uD(i) {
  for (let e in Nl)
    this[e] = Nl[e];
}
const RN = /* @__PURE__ */ function() {
  return lD.exports;
}();
var cD = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function hD(i) {
  return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i;
}
function dD(i) {
  if (i.__esModule)
    return i;
  var e = i.default;
  if (typeof e == "function") {
    var t = function s() {
      if (this instanceof s) {
        var r = [null];
        r.push.apply(r, arguments);
        var n = Function.bind.apply(e, r);
        return new n();
      }
      return e.apply(this, arguments);
    };
    t.prototype = e.prototype;
  } else
    t = {};
  return Object.defineProperty(t, "__esModule", { value: !0 }), Object.keys(i).forEach(function(s) {
    var r = Object.getOwnPropertyDescriptor(i, s);
    Object.defineProperty(t, s, r.get ? r : {
      enumerable: !0,
      get: function() {
        return i[s];
      }
    });
  }), t;
}
var df = { exports: {} };
/**!
 * Sortable 1.10.2
 * @author	RubaXa   <trash@rubaxa.org>
 * @author	owenm    <owen23355@gmail.com>
 * @license MIT
 */
function Jn(i) {
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Jn = function(e) {
    return typeof e;
  } : Jn = function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Jn(i);
}
function fD(i, e, t) {
  return e in i ? Object.defineProperty(i, e, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : i[e] = t, i;
}
function Xt() {
  return Xt = Object.assign || function(i) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var s in t)
        Object.prototype.hasOwnProperty.call(t, s) && (i[s] = t[s]);
    }
    return i;
  }, Xt.apply(this, arguments);
}
function Ui(i) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {}, s = Object.keys(t);
    typeof Object.getOwnPropertySymbols == "function" && (s = s.concat(Object.getOwnPropertySymbols(t).filter(function(r) {
      return Object.getOwnPropertyDescriptor(t, r).enumerable;
    }))), s.forEach(function(r) {
      fD(i, r, t[r]);
    });
  }
  return i;
}
function pD(i, e) {
  if (i == null)
    return {};
  var t = {}, s = Object.keys(i), r, n;
  for (n = 0; n < s.length; n++)
    r = s[n], !(e.indexOf(r) >= 0) && (t[r] = i[r]);
  return t;
}
function gD(i, e) {
  if (i == null)
    return {};
  var t = pD(i, e), s, r;
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(i);
    for (r = 0; r < n.length; r++)
      s = n[r], !(e.indexOf(s) >= 0) && Object.prototype.propertyIsEnumerable.call(i, s) && (t[s] = i[s]);
  }
  return t;
}
function _D(i) {
  return mD(i) || bD(i) || yD();
}
function mD(i) {
  if (Array.isArray(i)) {
    for (var e = 0, t = new Array(i.length); e < i.length; e++)
      t[e] = i[e];
    return t;
  }
}
function bD(i) {
  if (Symbol.iterator in Object(i) || Object.prototype.toString.call(i) === "[object Arguments]")
    return Array.from(i);
}
function yD() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}
var vD = "1.10.2";
function Di(i) {
  if (typeof window < "u" && window.navigator)
    return !!/* @__PURE__ */ navigator.userAgent.match(i);
}
var ji = Di(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i), Dn = Di(/Edge/i), Qc = Di(/firefox/i), Fl = Di(/safari/i) && !Di(/chrome/i) && !Di(/android/i), ff = Di(/iP(ad|od|hone)/i), xD = Di(/chrome/i) && Di(/android/i), pf = {
  capture: !1,
  passive: !1
};
function me(i, e, t) {
  i.addEventListener(e, t, !ji && pf);
}
function fe(i, e, t) {
  i.removeEventListener(e, t, !ji && pf);
}
function ba(i, e) {
  if (e) {
    if (e[0] === ">" && (e = e.substring(1)), i)
      try {
        if (i.matches)
          return i.matches(e);
        if (i.msMatchesSelector)
          return i.msMatchesSelector(e);
        if (i.webkitMatchesSelector)
          return i.webkitMatchesSelector(e);
      } catch {
        return !1;
      }
    return !1;
  }
}
function wD(i) {
  return i.host && i !== document && i.host.nodeType ? i.host : i.parentNode;
}
function Qt(i, e, t, s) {
  if (i) {
    t = t || document;
    do {
      if (e != null && (e[0] === ">" ? i.parentNode === t && ba(i, e) : ba(i, e)) || s && i === t)
        return i;
      if (i === t)
        break;
    } while (i = wD(i));
  }
  return null;
}
var Jc = /\s+/g;
function Ee(i, e, t) {
  if (i && e)
    if (i.classList)
      i.classList[t ? "add" : "remove"](e);
    else {
      var s = (" " + i.className + " ").replace(Jc, " ").replace(" " + e + " ", " ");
      i.className = (s + (t ? " " + e : "")).replace(Jc, " ");
    }
}
function q(i, e, t) {
  var s = i && i.style;
  if (s) {
    if (t === void 0)
      return document.defaultView && document.defaultView.getComputedStyle ? t = document.defaultView.getComputedStyle(i, "") : i.currentStyle && (t = i.currentStyle), e === void 0 ? t : t[e];
    !(e in s) && e.indexOf("webkit") === -1 && (e = "-webkit-" + e), s[e] = t + (typeof t == "string" ? "" : "px");
  }
}
function Ts(i, e) {
  var t = "";
  if (typeof i == "string")
    t = i;
  else
    do {
      var s = q(i, "transform");
      s && s !== "none" && (t = s + " " + t);
    } while (!e && (i = i.parentNode));
  var r = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
  return r && new r(t);
}
function gf(i, e, t) {
  if (i) {
    var s = i.getElementsByTagName(e), r = 0, n = s.length;
    if (t)
      for (; r < n; r++)
        t(s[r], r);
    return s;
  }
  return [];
}
function hi() {
  var i = document.scrollingElement;
  return i || document.documentElement;
}
function Be(i, e, t, s, r) {
  if (!(!i.getBoundingClientRect && i !== window)) {
    var n, a, o, l, u, h, c;
    if (i !== window && i !== hi() ? (n = i.getBoundingClientRect(), a = n.top, o = n.left, l = n.bottom, u = n.right, h = n.height, c = n.width) : (a = 0, o = 0, l = window.innerHeight, u = window.innerWidth, h = window.innerHeight, c = window.innerWidth), (e || t) && i !== window && (r = r || i.parentNode, !ji))
      do
        if (r && r.getBoundingClientRect && (q(r, "transform") !== "none" || t && q(r, "position") !== "static")) {
          var f = r.getBoundingClientRect();
          a -= f.top + parseInt(q(r, "border-top-width")), o -= f.left + parseInt(q(r, "border-left-width")), l = a + n.height, u = o + n.width;
          break;
        }
      while (r = r.parentNode);
    if (s && i !== window) {
      var d = Ts(r || i), g = d && d.a, p = d && d.d;
      d && (a /= p, o /= g, c /= g, h /= p, l = a + h, u = o + c);
    }
    return {
      top: a,
      left: o,
      bottom: l,
      right: u,
      width: c,
      height: h
    };
  }
}
function eh(i, e, t) {
  for (var s = Bi(i, !0), r = Be(i)[e]; s; ) {
    var n = Be(s)[t], a = void 0;
    if (t === "top" || t === "left" ? a = r >= n : a = r <= n, !a)
      return s;
    if (s === hi())
      break;
    s = Bi(s, !1);
  }
  return !1;
}
function ya(i, e, t) {
  for (var s = 0, r = 0, n = i.children; r < n.length; ) {
    if (n[r].style.display !== "none" && n[r] !== ie.ghost && n[r] !== ie.dragged && Qt(n[r], t.draggable, i, !1)) {
      if (s === e)
        return n[r];
      s++;
    }
    r++;
  }
  return null;
}
function ic(i, e) {
  for (var t = i.lastElementChild; t && (t === ie.ghost || q(t, "display") === "none" || e && !ba(t, e)); )
    t = t.previousElementSibling;
  return t || null;
}
function Ye(i, e) {
  var t = 0;
  if (!i || !i.parentNode)
    return -1;
  for (; i = i.previousElementSibling; )
    i.nodeName.toUpperCase() !== "TEMPLATE" && i !== ie.clone && (!e || ba(i, e)) && t++;
  return t;
}
function th(i) {
  var e = 0, t = 0, s = hi();
  if (i)
    do {
      var r = Ts(i), n = r.a, a = r.d;
      e += i.scrollLeft * n, t += i.scrollTop * a;
    } while (i !== s && (i = i.parentNode));
  return [e, t];
}
function SD(i, e) {
  for (var t in i)
    if (i.hasOwnProperty(t)) {
      for (var s in e)
        if (e.hasOwnProperty(s) && e[s] === i[t][s])
          return Number(t);
    }
  return -1;
}
function Bi(i, e) {
  if (!i || !i.getBoundingClientRect)
    return hi();
  var t = i, s = !1;
  do
    if (t.clientWidth < t.scrollWidth || t.clientHeight < t.scrollHeight) {
      var r = q(t);
      if (t.clientWidth < t.scrollWidth && (r.overflowX == "auto" || r.overflowX == "scroll") || t.clientHeight < t.scrollHeight && (r.overflowY == "auto" || r.overflowY == "scroll")) {
        if (!t.getBoundingClientRect || t === document.body)
          return hi();
        if (s || e)
          return t;
        s = !0;
      }
    }
  while (t = t.parentNode);
  return hi();
}
function DD(i, e) {
  if (i && e)
    for (var t in e)
      e.hasOwnProperty(t) && (i[t] = e[t]);
  return i;
}
function Xo(i, e) {
  return Math.round(i.top) === Math.round(e.top) && Math.round(i.left) === Math.round(e.left) && Math.round(i.height) === Math.round(e.height) && Math.round(i.width) === Math.round(e.width);
}
var Gr;
function _f(i, e) {
  return function() {
    if (!Gr) {
      var t = arguments, s = this;
      t.length === 1 ? i.call(s, t[0]) : i.apply(s, t), Gr = setTimeout(function() {
        Gr = void 0;
      }, e);
    }
  };
}
function CD() {
  clearTimeout(Gr), Gr = void 0;
}
function mf(i, e, t) {
  i.scrollLeft += e, i.scrollTop += t;
}
function sc(i) {
  var e = window.Polymer, t = window.jQuery || window.Zepto;
  return e && e.dom ? e.dom(i).cloneNode(!0) : t ? t(i).clone(!0)[0] : i.cloneNode(!0);
}
function ih(i, e) {
  q(i, "position", "absolute"), q(i, "top", e.top), q(i, "left", e.left), q(i, "width", e.width), q(i, "height", e.height);
}
function Wo(i) {
  q(i, "position", ""), q(i, "top", ""), q(i, "left", ""), q(i, "width", ""), q(i, "height", "");
}
var ct = "Sortable" + (/* @__PURE__ */ new Date()).getTime();
function TD() {
  var i = [], e;
  return {
    captureAnimationState: function() {
      if (i = [], !!this.options.animation) {
        var s = [].slice.call(this.el.children);
        s.forEach(function(r) {
          if (!(q(r, "display") === "none" || r === ie.ghost)) {
            i.push({
              target: r,
              rect: Be(r)
            });
            var n = Ui({}, i[i.length - 1].rect);
            if (r.thisAnimationDuration) {
              var a = Ts(r, !0);
              a && (n.top -= a.f, n.left -= a.e);
            }
            r.fromRect = n;
          }
        });
      }
    },
    addAnimationState: function(s) {
      i.push(s);
    },
    removeAnimationState: function(s) {
      i.splice(SD(i, {
        target: s
      }), 1);
    },
    animateAll: function(s) {
      var r = this;
      if (!this.options.animation) {
        clearTimeout(e), typeof s == "function" && s();
        return;
      }
      var n = !1, a = 0;
      i.forEach(function(o) {
        var l = 0, u = o.target, h = u.fromRect, c = Be(u), f = u.prevFromRect, d = u.prevToRect, g = o.rect, p = Ts(u, !0);
        p && (c.top -= p.f, c.left -= p.e), u.toRect = c, u.thisAnimationDuration && Xo(f, c) && !Xo(h, c) && // Make sure animatingRect is on line between toRect & fromRect
        (g.top - c.top) / (g.left - c.left) === (h.top - c.top) / (h.left - c.left) && (l = PD(g, f, d, r.options)), Xo(c, h) || (u.prevFromRect = h, u.prevToRect = c, l || (l = r.options.animation), r.animate(u, g, c, l)), l && (n = !0, a = Math.max(a, l), clearTimeout(u.animationResetTimer), u.animationResetTimer = setTimeout(function() {
          u.animationTime = 0, u.prevFromRect = null, u.fromRect = null, u.prevToRect = null, u.thisAnimationDuration = null;
        }, l), u.thisAnimationDuration = l);
      }), clearTimeout(e), n ? e = setTimeout(function() {
        typeof s == "function" && s();
      }, a) : typeof s == "function" && s(), i = [];
    },
    animate: function(s, r, n, a) {
      if (a) {
        q(s, "transition", ""), q(s, "transform", "");
        var o = Ts(this.el), l = o && o.a, u = o && o.d, h = (r.left - n.left) / (l || 1), c = (r.top - n.top) / (u || 1);
        s.animatingX = !!h, s.animatingY = !!c, q(s, "transform", "translate3d(" + h + "px," + c + "px,0)"), kD(s), q(s, "transition", "transform " + a + "ms" + (this.options.easing ? " " + this.options.easing : "")), q(s, "transform", "translate3d(0,0,0)"), typeof s.animated == "number" && clearTimeout(s.animated), s.animated = setTimeout(function() {
          q(s, "transition", ""), q(s, "transform", ""), s.animated = !1, s.animatingX = !1, s.animatingY = !1;
        }, a);
      }
    }
  };
}
function kD(i) {
  return i.offsetWidth;
}
function PD(i, e, t, s) {
  return Math.sqrt(Math.pow(e.top - i.top, 2) + Math.pow(e.left - i.left, 2)) / Math.sqrt(Math.pow(e.top - t.top, 2) + Math.pow(e.left - t.left, 2)) * s.animation;
}
var Lr = [], Uo = {
  initializeByDefault: !0
}, Cn = {
  mount: function(e) {
    for (var t in Uo)
      Uo.hasOwnProperty(t) && !(t in e) && (e[t] = Uo[t]);
    Lr.push(e);
  },
  pluginEvent: function(e, t, s) {
    var r = this;
    this.eventCanceled = !1, s.cancel = function() {
      r.eventCanceled = !0;
    };
    var n = e + "Global";
    Lr.forEach(function(a) {
      t[a.pluginName] && (t[a.pluginName][n] && t[a.pluginName][n](Ui({
        sortable: t
      }, s)), t.options[a.pluginName] && t[a.pluginName][e] && t[a.pluginName][e](Ui({
        sortable: t
      }, s)));
    });
  },
  initializePlugins: function(e, t, s, r) {
    Lr.forEach(function(o) {
      var l = o.pluginName;
      if (!(!e.options[l] && !o.initializeByDefault)) {
        var u = new o(e, t, e.options);
        u.sortable = e, u.options = e.options, e[l] = u, Xt(s, u.defaults);
      }
    });
    for (var n in e.options)
      if (e.options.hasOwnProperty(n)) {
        var a = this.modifyOption(e, n, e.options[n]);
        typeof a < "u" && (e.options[n] = a);
      }
  },
  getEventProperties: function(e, t) {
    var s = {};
    return Lr.forEach(function(r) {
      typeof r.eventProperties == "function" && Xt(s, r.eventProperties.call(t[r.pluginName], e));
    }), s;
  },
  modifyOption: function(e, t, s) {
    var r;
    return Lr.forEach(function(n) {
      e[n.pluginName] && n.optionListeners && typeof n.optionListeners[t] == "function" && (r = n.optionListeners[t].call(e[n.pluginName], s));
    }), r;
  }
};
function $r(i) {
  var e = i.sortable, t = i.rootEl, s = i.name, r = i.targetEl, n = i.cloneEl, a = i.toEl, o = i.fromEl, l = i.oldIndex, u = i.newIndex, h = i.oldDraggableIndex, c = i.newDraggableIndex, f = i.originalEvent, d = i.putSortable, g = i.extraEventProperties;
  if (e = e || t && t[ct], !!e) {
    var p, _ = e.options, m = "on" + s.charAt(0).toUpperCase() + s.substr(1);
    window.CustomEvent && !ji && !Dn ? p = new CustomEvent(s, {
      bubbles: !0,
      cancelable: !0
    }) : (p = document.createEvent("Event"), p.initEvent(s, !0, !0)), p.to = a || t, p.from = o || t, p.item = r || t, p.clone = n, p.oldIndex = l, p.newIndex = u, p.oldDraggableIndex = h, p.newDraggableIndex = c, p.originalEvent = f, p.pullMode = d ? d.lastPutMode : void 0;
    var v = Ui({}, g, Cn.getEventProperties(s, e));
    for (var b in v)
      p[b] = v[b];
    t && t.dispatchEvent(p), _[m] && _[m].call(e, p);
  }
}
var vt = function(e, t) {
  var s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, r = s.evt, n = gD(s, ["evt"]);
  Cn.pluginEvent.bind(ie)(e, t, Ui({
    dragEl: Y,
    parentEl: We,
    ghostEl: oe,
    rootEl: Ie,
    nextEl: ms,
    lastDownEl: ea,
    cloneEl: Ne,
    cloneHidden: $i,
    dragStarted: Nr,
    putSortable: st,
    activeSortable: ie.active,
    originalEvent: r,
    oldIndex: qs,
    oldDraggableIndex: Zr,
    newIndex: jt,
    newDraggableIndex: Ei,
    hideGhostForTarget: xf,
    unhideGhostForTarget: wf,
    cloneNowHidden: function() {
      $i = !0;
    },
    cloneNowShown: function() {
      $i = !1;
    },
    dispatchSortableEvent: function(o) {
      bt({
        sortable: t,
        name: o,
        originalEvent: r
      });
    }
  }, n));
};
function bt(i) {
  $r(Ui({
    putSortable: st,
    cloneEl: Ne,
    targetEl: Y,
    rootEl: Ie,
    oldIndex: qs,
    oldDraggableIndex: Zr,
    newIndex: jt,
    newDraggableIndex: Ei
  }, i));
}
var Y, We, oe, Ie, ms, ea, Ne, $i, qs, jt, Zr, Ei, In, st, Us = !1, va = !1, xa = [], fs, Kt, Go, Zo, sh, rh, Nr, zs, Kr, qr = !1, En = !1, ta, ot, Ko = [], Yl = !1, wa = [], Co = typeof document < "u", Rn = ff, nh = Dn || ji ? "cssFloat" : "float", OD = Co && !xD && !ff && "draggable" in document.createElement("div"), bf = function() {
  if (Co) {
    if (ji)
      return !1;
    var i = document.createElement("x");
    return i.style.cssText = "pointer-events:auto", i.style.pointerEvents === "auto";
  }
}(), yf = function(e, t) {
  var s = q(e), r = parseInt(s.width) - parseInt(s.paddingLeft) - parseInt(s.paddingRight) - parseInt(s.borderLeftWidth) - parseInt(s.borderRightWidth), n = ya(e, 0, t), a = ya(e, 1, t), o = n && q(n), l = a && q(a), u = o && parseInt(o.marginLeft) + parseInt(o.marginRight) + Be(n).width, h = l && parseInt(l.marginLeft) + parseInt(l.marginRight) + Be(a).width;
  if (s.display === "flex")
    return s.flexDirection === "column" || s.flexDirection === "column-reverse" ? "vertical" : "horizontal";
  if (s.display === "grid")
    return s.gridTemplateColumns.split(" ").length <= 1 ? "vertical" : "horizontal";
  if (n && o.float && o.float !== "none") {
    var c = o.float === "left" ? "left" : "right";
    return a && (l.clear === "both" || l.clear === c) ? "vertical" : "horizontal";
  }
  return n && (o.display === "block" || o.display === "flex" || o.display === "table" || o.display === "grid" || u >= r && s[nh] === "none" || a && s[nh] === "none" && u + h > r) ? "vertical" : "horizontal";
}, MD = function(e, t, s) {
  var r = s ? e.left : e.top, n = s ? e.right : e.bottom, a = s ? e.width : e.height, o = s ? t.left : t.top, l = s ? t.right : t.bottom, u = s ? t.width : t.height;
  return r === o || n === l || r + a / 2 === o + u / 2;
}, AD = function(e, t) {
  var s;
  return xa.some(function(r) {
    if (!ic(r)) {
      var n = Be(r), a = r[ct].options.emptyInsertThreshold, o = e >= n.left - a && e <= n.right + a, l = t >= n.top - a && t <= n.bottom + a;
      if (a && o && l)
        return s = r;
    }
  }), s;
}, vf = function(e) {
  function t(n, a) {
    return function(o, l, u, h) {
      var c = o.options.group.name && l.options.group.name && o.options.group.name === l.options.group.name;
      if (n == null && (a || c))
        return !0;
      if (n == null || n === !1)
        return !1;
      if (a && n === "clone")
        return n;
      if (typeof n == "function")
        return t(n(o, l, u, h), a)(o, l, u, h);
      var f = (a ? o : l).options.group.name;
      return n === !0 || typeof n == "string" && n === f || n.join && n.indexOf(f) > -1;
    };
  }
  var s = {}, r = e.group;
  (!r || Jn(r) != "object") && (r = {
    name: r
  }), s.name = r.name, s.checkPull = t(r.pull, !0), s.checkPut = t(r.put), s.revertClone = r.revertClone, e.group = s;
}, xf = function() {
  !bf && oe && q(oe, "display", "none");
}, wf = function() {
  !bf && oe && q(oe, "display", "");
};
Co && document.addEventListener("click", function(i) {
  if (va)
    return i.preventDefault(), i.stopPropagation && i.stopPropagation(), i.stopImmediatePropagation && i.stopImmediatePropagation(), va = !1, !1;
}, !0);
var ps = function(e) {
  if (Y) {
    e = e.touches ? e.touches[0] : e;
    var t = AD(e.clientX, e.clientY);
    if (t) {
      var s = {};
      for (var r in e)
        e.hasOwnProperty(r) && (s[r] = e[r]);
      s.target = s.rootEl = t, s.preventDefault = void 0, s.stopPropagation = void 0, t[ct]._onDragOver(s);
    }
  }
}, LD = function(e) {
  Y && Y.parentNode[ct]._isOutsideThisEl(e.target);
};
function ie(i, e) {
  if (!(i && i.nodeType && i.nodeType === 1))
    throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(i));
  this.el = i, this.options = e = Xt({}, e), i[ct] = this;
  var t = {
    group: null,
    sort: !0,
    disabled: !1,
    store: null,
    handle: null,
    draggable: /^[uo]l$/i.test(i.nodeName) ? ">li" : ">*",
    swapThreshold: 1,
    // percentage; 0 <= x <= 1
    invertSwap: !1,
    // invert always
    invertedSwapThreshold: null,
    // will be set to same as swapThreshold if default
    removeCloneOnHide: !0,
    direction: function() {
      return yf(i, this.options);
    },
    ghostClass: "sortable-ghost",
    chosenClass: "sortable-chosen",
    dragClass: "sortable-drag",
    ignore: "a, img",
    filter: null,
    preventOnFilter: !0,
    animation: 0,
    easing: null,
    setData: function(a, o) {
      a.setData("Text", o.textContent);
    },
    dropBubble: !1,
    dragoverBubble: !1,
    dataIdAttr: "data-id",
    delay: 0,
    delayOnTouchOnly: !1,
    touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
    forceFallback: !1,
    fallbackClass: "sortable-fallback",
    fallbackOnBody: !1,
    fallbackTolerance: 0,
    fallbackOffset: {
      x: 0,
      y: 0
    },
    supportPointer: ie.supportPointer !== !1 && "PointerEvent" in window,
    emptyInsertThreshold: 5
  };
  Cn.initializePlugins(this, i, t);
  for (var s in t)
    !(s in e) && (e[s] = t[s]);
  vf(e);
  for (var r in this)
    r.charAt(0) === "_" && typeof this[r] == "function" && (this[r] = this[r].bind(this));
  this.nativeDraggable = e.forceFallback ? !1 : OD, this.nativeDraggable && (this.options.touchStartThreshold = 1), e.supportPointer ? me(i, "pointerdown", this._onTapStart) : (me(i, "mousedown", this._onTapStart), me(i, "touchstart", this._onTapStart)), this.nativeDraggable && (me(i, "dragover", this), me(i, "dragenter", this)), xa.push(this.el), e.store && e.store.get && this.sort(e.store.get(this) || []), Xt(this, TD());
}
ie.prototype = /** @lends Sortable.prototype */
{
  constructor: ie,
  _isOutsideThisEl: function(e) {
    !this.el.contains(e) && e !== this.el && (zs = null);
  },
  _getDirection: function(e, t) {
    return typeof this.options.direction == "function" ? this.options.direction.call(this, e, t, Y) : this.options.direction;
  },
  _onTapStart: function(e) {
    if (e.cancelable) {
      var t = this, s = this.el, r = this.options, n = r.preventOnFilter, a = e.type, o = e.touches && e.touches[0] || e.pointerType && e.pointerType === "touch" && e, l = (o || e).target, u = e.target.shadowRoot && (e.path && e.path[0] || e.composedPath && e.composedPath()[0]) || l, h = r.filter;
      if (FD(s), !Y && !(/mousedown|pointerdown/.test(a) && e.button !== 0 || r.disabled) && !u.isContentEditable && (l = Qt(l, r.draggable, s, !1), !(l && l.animated) && ea !== l)) {
        if (qs = Ye(l), Zr = Ye(l, r.draggable), typeof h == "function") {
          if (h.call(this, e, l, this)) {
            bt({
              sortable: t,
              rootEl: u,
              name: "filter",
              targetEl: l,
              toEl: s,
              fromEl: s
            }), vt("filter", t, {
              evt: e
            }), n && e.cancelable && e.preventDefault();
            return;
          }
        } else if (h && (h = h.split(",").some(function(c) {
          if (c = Qt(u, c.trim(), s, !1), c)
            return bt({
              sortable: t,
              rootEl: c,
              name: "filter",
              targetEl: l,
              fromEl: s,
              toEl: s
            }), vt("filter", t, {
              evt: e
            }), !0;
        }), h)) {
          n && e.cancelable && e.preventDefault();
          return;
        }
        r.handle && !Qt(u, r.handle, s, !1) || this._prepareDragStart(e, o, l);
      }
    }
  },
  _prepareDragStart: function(e, t, s) {
    var r = this, n = r.el, a = r.options, o = n.ownerDocument, l;
    if (s && !Y && s.parentNode === n) {
      var u = Be(s);
      if (Ie = n, Y = s, We = Y.parentNode, ms = Y.nextSibling, ea = s, In = a.group, ie.dragged = Y, fs = {
        target: Y,
        clientX: (t || e).clientX,
        clientY: (t || e).clientY
      }, sh = fs.clientX - u.left, rh = fs.clientY - u.top, this._lastX = (t || e).clientX, this._lastY = (t || e).clientY, Y.style["will-change"] = "all", l = function() {
        if (vt("delayEnded", r, {
          evt: e
        }), ie.eventCanceled) {
          r._onDrop();
          return;
        }
        r._disableDelayedDragEvents(), !Qc && r.nativeDraggable && (Y.draggable = !0), r._triggerDragStart(e, t), bt({
          sortable: r,
          name: "choose",
          originalEvent: e
        }), Ee(Y, a.chosenClass, !0);
      }, a.ignore.split(",").forEach(function(h) {
        gf(Y, h.trim(), Qo);
      }), me(o, "dragover", ps), me(o, "mousemove", ps), me(o, "touchmove", ps), me(o, "mouseup", r._onDrop), me(o, "touchend", r._onDrop), me(o, "touchcancel", r._onDrop), Qc && this.nativeDraggable && (this.options.touchStartThreshold = 4, Y.draggable = !0), vt("delayStart", this, {
        evt: e
      }), a.delay && (!a.delayOnTouchOnly || t) && (!this.nativeDraggable || !(Dn || ji))) {
        if (ie.eventCanceled) {
          this._onDrop();
          return;
        }
        me(o, "mouseup", r._disableDelayedDrag), me(o, "touchend", r._disableDelayedDrag), me(o, "touchcancel", r._disableDelayedDrag), me(o, "mousemove", r._delayedDragTouchMoveHandler), me(o, "touchmove", r._delayedDragTouchMoveHandler), a.supportPointer && me(o, "pointermove", r._delayedDragTouchMoveHandler), r._dragStartTimer = setTimeout(l, a.delay);
      } else
        l();
    }
  },
  _delayedDragTouchMoveHandler: function(e) {
    var t = e.touches ? e.touches[0] : e;
    Math.max(Math.abs(t.clientX - this._lastX), Math.abs(t.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1)) && this._disableDelayedDrag();
  },
  _disableDelayedDrag: function() {
    Y && Qo(Y), clearTimeout(this._dragStartTimer), this._disableDelayedDragEvents();
  },
  _disableDelayedDragEvents: function() {
    var e = this.el.ownerDocument;
    fe(e, "mouseup", this._disableDelayedDrag), fe(e, "touchend", this._disableDelayedDrag), fe(e, "touchcancel", this._disableDelayedDrag), fe(e, "mousemove", this._delayedDragTouchMoveHandler), fe(e, "touchmove", this._delayedDragTouchMoveHandler), fe(e, "pointermove", this._delayedDragTouchMoveHandler);
  },
  _triggerDragStart: function(e, t) {
    t = t || e.pointerType == "touch" && e, !this.nativeDraggable || t ? this.options.supportPointer ? me(document, "pointermove", this._onTouchMove) : t ? me(document, "touchmove", this._onTouchMove) : me(document, "mousemove", this._onTouchMove) : (me(Y, "dragend", this), me(Ie, "dragstart", this._onDragStart));
    try {
      document.selection ? ia(function() {
        document.selection.empty();
      }) : window.getSelection().removeAllRanges();
    } catch {
    }
  },
  _dragStarted: function(e, t) {
    if (Us = !1, Ie && Y) {
      vt("dragStarted", this, {
        evt: t
      }), this.nativeDraggable && me(document, "dragover", LD);
      var s = this.options;
      !e && Ee(Y, s.dragClass, !1), Ee(Y, s.ghostClass, !0), ie.active = this, e && this._appendGhost(), bt({
        sortable: this,
        name: "start",
        originalEvent: t
      });
    } else
      this._nulling();
  },
  _emulateDragOver: function() {
    if (Kt) {
      this._lastX = Kt.clientX, this._lastY = Kt.clientY, xf();
      for (var e = document.elementFromPoint(Kt.clientX, Kt.clientY), t = e; e && e.shadowRoot && (e = e.shadowRoot.elementFromPoint(Kt.clientX, Kt.clientY), e !== t); )
        t = e;
      if (Y.parentNode[ct]._isOutsideThisEl(e), t)
        do {
          if (t[ct]) {
            var s = void 0;
            if (s = t[ct]._onDragOver({
              clientX: Kt.clientX,
              clientY: Kt.clientY,
              target: e,
              rootEl: t
            }), s && !this.options.dragoverBubble)
              break;
          }
          e = t;
        } while (t = t.parentNode);
      wf();
    }
  },
  _onTouchMove: function(e) {
    if (fs) {
      var t = this.options, s = t.fallbackTolerance, r = t.fallbackOffset, n = e.touches ? e.touches[0] : e, a = oe && Ts(oe, !0), o = oe && a && a.a, l = oe && a && a.d, u = Rn && ot && th(ot), h = (n.clientX - fs.clientX + r.x) / (o || 1) + (u ? u[0] - Ko[0] : 0) / (o || 1), c = (n.clientY - fs.clientY + r.y) / (l || 1) + (u ? u[1] - Ko[1] : 0) / (l || 1);
      if (!ie.active && !Us) {
        if (s && Math.max(Math.abs(n.clientX - this._lastX), Math.abs(n.clientY - this._lastY)) < s)
          return;
        this._onDragStart(e, !0);
      }
      if (oe) {
        a ? (a.e += h - (Go || 0), a.f += c - (Zo || 0)) : a = {
          a: 1,
          b: 0,
          c: 0,
          d: 1,
          e: h,
          f: c
        };
        var f = "matrix(".concat(a.a, ",").concat(a.b, ",").concat(a.c, ",").concat(a.d, ",").concat(a.e, ",").concat(a.f, ")");
        q(oe, "webkitTransform", f), q(oe, "mozTransform", f), q(oe, "msTransform", f), q(oe, "transform", f), Go = h, Zo = c, Kt = n;
      }
      e.cancelable && e.preventDefault();
    }
  },
  _appendGhost: function() {
    if (!oe) {
      var e = this.options.fallbackOnBody ? document.body : Ie, t = Be(Y, !0, Rn, !0, e), s = this.options;
      if (Rn) {
        for (ot = e; q(ot, "position") === "static" && q(ot, "transform") === "none" && ot !== document; )
          ot = ot.parentNode;
        ot !== document.body && ot !== document.documentElement ? (ot === document && (ot = hi()), t.top += ot.scrollTop, t.left += ot.scrollLeft) : ot = hi(), Ko = th(ot);
      }
      oe = Y.cloneNode(!0), Ee(oe, s.ghostClass, !1), Ee(oe, s.fallbackClass, !0), Ee(oe, s.dragClass, !0), q(oe, "transition", ""), q(oe, "transform", ""), q(oe, "box-sizing", "border-box"), q(oe, "margin", 0), q(oe, "top", t.top), q(oe, "left", t.left), q(oe, "width", t.width), q(oe, "height", t.height), q(oe, "opacity", "0.8"), q(oe, "position", Rn ? "absolute" : "fixed"), q(oe, "zIndex", "100000"), q(oe, "pointerEvents", "none"), ie.ghost = oe, e.appendChild(oe), q(oe, "transform-origin", sh / parseInt(oe.style.width) * 100 + "% " + rh / parseInt(oe.style.height) * 100 + "%");
    }
  },
  _onDragStart: function(e, t) {
    var s = this, r = e.dataTransfer, n = s.options;
    if (vt("dragStart", this, {
      evt: e
    }), ie.eventCanceled) {
      this._onDrop();
      return;
    }
    vt("setupClone", this), ie.eventCanceled || (Ne = sc(Y), Ne.draggable = !1, Ne.style["will-change"] = "", this._hideClone(), Ee(Ne, this.options.chosenClass, !1), ie.clone = Ne), s.cloneId = ia(function() {
      vt("clone", s), !ie.eventCanceled && (s.options.removeCloneOnHide || Ie.insertBefore(Ne, Y), s._hideClone(), bt({
        sortable: s,
        name: "clone"
      }));
    }), !t && Ee(Y, n.dragClass, !0), t ? (va = !0, s._loopId = setInterval(s._emulateDragOver, 50)) : (fe(document, "mouseup", s._onDrop), fe(document, "touchend", s._onDrop), fe(document, "touchcancel", s._onDrop), r && (r.effectAllowed = "move", n.setData && n.setData.call(s, r, Y)), me(document, "drop", s), q(Y, "transform", "translateZ(0)")), Us = !0, s._dragStartId = ia(s._dragStarted.bind(s, t, e)), me(document, "selectstart", s), Nr = !0, Fl && q(document.body, "user-select", "none");
  },
  // Returns true - if no further action is needed (either inserted or another condition)
  _onDragOver: function(e) {
    var t = this.el, s = e.target, r, n, a, o = this.options, l = o.group, u = ie.active, h = In === l, c = o.sort, f = st || u, d, g = this, p = !1;
    if (Yl)
      return;
    function _($, Z) {
      vt($, g, Ui({
        evt: e,
        isOwner: h,
        axis: d ? "vertical" : "horizontal",
        revert: a,
        dragRect: r,
        targetRect: n,
        canSort: c,
        fromSortable: f,
        target: s,
        completed: v,
        onMove: function(he, M) {
          return qo(Ie, t, Y, r, he, Be(he), e, M);
        },
        changed: b
      }, Z));
    }
    function m() {
      _("dragOverAnimationCapture"), g.captureAnimationState(), g !== f && f.captureAnimationState();
    }
    function v($) {
      return _("dragOverCompleted", {
        insertion: $
      }), $ && (h ? u._hideClone() : u._showClone(g), g !== f && (Ee(Y, st ? st.options.ghostClass : u.options.ghostClass, !1), Ee(Y, o.ghostClass, !0)), st !== g && g !== ie.active ? st = g : g === ie.active && st && (st = null), f === g && (g._ignoreWhileAnimating = s), g.animateAll(function() {
        _("dragOverAnimationComplete"), g._ignoreWhileAnimating = null;
      }), g !== f && (f.animateAll(), f._ignoreWhileAnimating = null)), (s === Y && !Y.animated || s === t && !s.animated) && (zs = null), !o.dragoverBubble && !e.rootEl && s !== document && (Y.parentNode[ct]._isOutsideThisEl(e.target), !$ && ps(e)), !o.dragoverBubble && e.stopPropagation && e.stopPropagation(), p = !0;
    }
    function b() {
      jt = Ye(Y), Ei = Ye(Y, o.draggable), bt({
        sortable: g,
        name: "change",
        toEl: t,
        newIndex: jt,
        newDraggableIndex: Ei,
        originalEvent: e
      });
    }
    if (e.preventDefault !== void 0 && e.cancelable && e.preventDefault(), s = Qt(s, o.draggable, t, !0), _("dragOver"), ie.eventCanceled)
      return p;
    if (Y.contains(e.target) || s.animated && s.animatingX && s.animatingY || g._ignoreWhileAnimating === s)
      return v(!1);
    if (va = !1, u && !o.disabled && (h ? c || (a = !Ie.contains(Y)) : st === this || (this.lastPutMode = In.checkPull(this, u, Y, e)) && l.checkPut(this, u, Y, e))) {
      if (d = this._getDirection(e, s) === "vertical", r = Be(Y), _("dragOverValid"), ie.eventCanceled)
        return p;
      if (a)
        return We = Ie, m(), this._hideClone(), _("revert"), ie.eventCanceled || (ms ? Ie.insertBefore(Y, ms) : Ie.appendChild(Y)), v(!0);
      var y = ic(t, o.draggable);
      if (!y || ED(e, d, this) && !y.animated) {
        if (y === Y)
          return v(!1);
        if (y && t === e.target && (s = y), s && (n = Be(s)), qo(Ie, t, Y, r, s, n, e, !!s) !== !1)
          return m(), t.appendChild(Y), We = t, b(), v(!0);
      } else if (s.parentNode === t) {
        n = Be(s);
        var x = 0, D, A = Y.parentNode !== t, C = !MD(Y.animated && Y.toRect || r, s.animated && s.toRect || n, d), O = d ? "top" : "left", T = eh(s, "top", "top") || eh(Y, "top", "top"), L = T ? T.scrollTop : void 0;
        zs !== s && (D = n[O], qr = !1, En = !C && o.invertSwap || A), x = RD(e, s, n, d, C ? 1 : o.swapThreshold, o.invertedSwapThreshold == null ? o.swapThreshold : o.invertedSwapThreshold, En, zs === s);
        var j;
        if (x !== 0) {
          var N = Ye(Y);
          do
            N -= x, j = We.children[N];
          while (j && (q(j, "display") === "none" || j === oe));
        }
        if (x === 0 || j === s)
          return v(!1);
        zs = s, Kr = x;
        var ee = s.nextElementSibling, z = !1;
        z = x === 1;
        var H = qo(Ie, t, Y, r, s, n, e, z);
        if (H !== !1)
          return (H === 1 || H === -1) && (z = H === 1), Yl = !0, setTimeout(ID, 30), m(), z && !ee ? t.appendChild(Y) : s.parentNode.insertBefore(Y, z ? ee : s), T && mf(T, 0, L - T.scrollTop), We = Y.parentNode, D !== void 0 && !En && (ta = Math.abs(D - Be(s)[O])), b(), v(!0);
      }
      if (t.contains(Y))
        return v(!1);
    }
    return !1;
  },
  _ignoreWhileAnimating: null,
  _offMoveEvents: function() {
    fe(document, "mousemove", this._onTouchMove), fe(document, "touchmove", this._onTouchMove), fe(document, "pointermove", this._onTouchMove), fe(document, "dragover", ps), fe(document, "mousemove", ps), fe(document, "touchmove", ps);
  },
  _offUpEvents: function() {
    var e = this.el.ownerDocument;
    fe(e, "mouseup", this._onDrop), fe(e, "touchend", this._onDrop), fe(e, "pointerup", this._onDrop), fe(e, "touchcancel", this._onDrop), fe(document, "selectstart", this);
  },
  _onDrop: function(e) {
    var t = this.el, s = this.options;
    if (jt = Ye(Y), Ei = Ye(Y, s.draggable), vt("drop", this, {
      evt: e
    }), We = Y && Y.parentNode, jt = Ye(Y), Ei = Ye(Y, s.draggable), ie.eventCanceled) {
      this._nulling();
      return;
    }
    Us = !1, En = !1, qr = !1, clearInterval(this._loopId), clearTimeout(this._dragStartTimer), Bl(this.cloneId), Bl(this._dragStartId), this.nativeDraggable && (fe(document, "drop", this), fe(t, "dragstart", this._onDragStart)), this._offMoveEvents(), this._offUpEvents(), Fl && q(document.body, "user-select", ""), q(Y, "transform", ""), e && (Nr && (e.cancelable && e.preventDefault(), !s.dropBubble && e.stopPropagation()), oe && oe.parentNode && oe.parentNode.removeChild(oe), (Ie === We || st && st.lastPutMode !== "clone") && Ne && Ne.parentNode && Ne.parentNode.removeChild(Ne), Y && (this.nativeDraggable && fe(Y, "dragend", this), Qo(Y), Y.style["will-change"] = "", Nr && !Us && Ee(Y, st ? st.options.ghostClass : this.options.ghostClass, !1), Ee(Y, this.options.chosenClass, !1), bt({
      sortable: this,
      name: "unchoose",
      toEl: We,
      newIndex: null,
      newDraggableIndex: null,
      originalEvent: e
    }), Ie !== We ? (jt >= 0 && (bt({
      rootEl: We,
      name: "add",
      toEl: We,
      fromEl: Ie,
      originalEvent: e
    }), bt({
      sortable: this,
      name: "remove",
      toEl: We,
      originalEvent: e
    }), bt({
      rootEl: We,
      name: "sort",
      toEl: We,
      fromEl: Ie,
      originalEvent: e
    }), bt({
      sortable: this,
      name: "sort",
      toEl: We,
      originalEvent: e
    })), st && st.save()) : jt !== qs && jt >= 0 && (bt({
      sortable: this,
      name: "update",
      toEl: We,
      originalEvent: e
    }), bt({
      sortable: this,
      name: "sort",
      toEl: We,
      originalEvent: e
    })), ie.active && ((jt == null || jt === -1) && (jt = qs, Ei = Zr), bt({
      sortable: this,
      name: "end",
      toEl: We,
      originalEvent: e
    }), this.save()))), this._nulling();
  },
  _nulling: function() {
    vt("nulling", this), Ie = Y = We = oe = ms = Ne = ea = $i = fs = Kt = Nr = jt = Ei = qs = Zr = zs = Kr = st = In = ie.dragged = ie.ghost = ie.clone = ie.active = null, wa.forEach(function(e) {
      e.checked = !0;
    }), wa.length = Go = Zo = 0;
  },
  handleEvent: function(e) {
    switch (e.type) {
      case "drop":
      case "dragend":
        this._onDrop(e);
        break;
      case "dragenter":
      case "dragover":
        Y && (this._onDragOver(e), jD(e));
        break;
      case "selectstart":
        e.preventDefault();
        break;
    }
  },
  /**
   * Serializes the item into an array of string.
   * @returns {String[]}
   */
  toArray: function() {
    for (var e = [], t, s = this.el.children, r = 0, n = s.length, a = this.options; r < n; r++)
      t = s[r], Qt(t, a.draggable, this.el, !1) && e.push(t.getAttribute(a.dataIdAttr) || ND(t));
    return e;
  },
  /**
   * Sorts the elements according to the array.
   * @param  {String[]}  order  order of the items
   */
  sort: function(e) {
    var t = {}, s = this.el;
    this.toArray().forEach(function(r, n) {
      var a = s.children[n];
      Qt(a, this.options.draggable, s, !1) && (t[r] = a);
    }, this), e.forEach(function(r) {
      t[r] && (s.removeChild(t[r]), s.appendChild(t[r]));
    });
  },
  /**
   * Save the current sorting
   */
  save: function() {
    var e = this.options.store;
    e && e.set && e.set(this);
  },
  /**
   * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
   * @param   {HTMLElement}  el
   * @param   {String}       [selector]  default: `options.draggable`
   * @returns {HTMLElement|null}
   */
  closest: function(e, t) {
    return Qt(e, t || this.options.draggable, this.el, !1);
  },
  /**
   * Set/get option
   * @param   {string} name
   * @param   {*}      [value]
   * @returns {*}
   */
  option: function(e, t) {
    var s = this.options;
    if (t === void 0)
      return s[e];
    var r = Cn.modifyOption(this, e, t);
    typeof r < "u" ? s[e] = r : s[e] = t, e === "group" && vf(s);
  },
  /**
   * Destroy
   */
  destroy: function() {
    vt("destroy", this);
    var e = this.el;
    e[ct] = null, fe(e, "mousedown", this._onTapStart), fe(e, "touchstart", this._onTapStart), fe(e, "pointerdown", this._onTapStart), this.nativeDraggable && (fe(e, "dragover", this), fe(e, "dragenter", this)), Array.prototype.forEach.call(e.querySelectorAll("[draggable]"), function(t) {
      t.removeAttribute("draggable");
    }), this._onDrop(), this._disableDelayedDragEvents(), xa.splice(xa.indexOf(this.el), 1), this.el = e = null;
  },
  _hideClone: function() {
    if (!$i) {
      if (vt("hideClone", this), ie.eventCanceled)
        return;
      q(Ne, "display", "none"), this.options.removeCloneOnHide && Ne.parentNode && Ne.parentNode.removeChild(Ne), $i = !0;
    }
  },
  _showClone: function(e) {
    if (e.lastPutMode !== "clone") {
      this._hideClone();
      return;
    }
    if ($i) {
      if (vt("showClone", this), ie.eventCanceled)
        return;
      Ie.contains(Y) && !this.options.group.revertClone ? Ie.insertBefore(Ne, Y) : ms ? Ie.insertBefore(Ne, ms) : Ie.appendChild(Ne), this.options.group.revertClone && this.animate(Y, Ne), q(Ne, "display", ""), $i = !1;
    }
  }
};
function jD(i) {
  i.dataTransfer && (i.dataTransfer.dropEffect = "move"), i.cancelable && i.preventDefault();
}
function qo(i, e, t, s, r, n, a, o) {
  var l, u = i[ct], h = u.options.onMove, c;
  return window.CustomEvent && !ji && !Dn ? l = new CustomEvent("move", {
    bubbles: !0,
    cancelable: !0
  }) : (l = document.createEvent("Event"), l.initEvent("move", !0, !0)), l.to = e, l.from = i, l.dragged = t, l.draggedRect = s, l.related = r || e, l.relatedRect = n || Be(e), l.willInsertAfter = o, l.originalEvent = a, i.dispatchEvent(l), h && (c = h.call(u, l, a)), c;
}
function Qo(i) {
  i.draggable = !1;
}
function ID() {
  Yl = !1;
}
function ED(i, e, t) {
  var s = Be(ic(t.el, t.options.draggable)), r = 10;
  return e ? i.clientX > s.right + r || i.clientX <= s.right && i.clientY > s.bottom && i.clientX >= s.left : i.clientX > s.right && i.clientY > s.top || i.clientX <= s.right && i.clientY > s.bottom + r;
}
function RD(i, e, t, s, r, n, a, o) {
  var l = s ? i.clientY : i.clientX, u = s ? t.height : t.width, h = s ? t.top : t.left, c = s ? t.bottom : t.right, f = !1;
  if (!a) {
    if (o && ta < u * r) {
      if (!qr && (Kr === 1 ? l > h + u * n / 2 : l < c - u * n / 2) && (qr = !0), qr)
        f = !0;
      else if (Kr === 1 ? l < h + ta : l > c - ta)
        return -Kr;
    } else if (l > h + u * (1 - r) / 2 && l < c - u * (1 - r) / 2)
      return $D(e);
  }
  return f = f || a, f && (l < h + u * n / 2 || l > c - u * n / 2) ? l > h + u / 2 ? 1 : -1 : 0;
}
function $D(i) {
  return Ye(Y) < Ye(i) ? 1 : -1;
}
function ND(i) {
  for (var e = i.tagName + i.className + i.src + i.href + i.textContent, t = e.length, s = 0; t--; )
    s += e.charCodeAt(t);
  return s.toString(36);
}
function FD(i) {
  wa.length = 0;
  for (var e = i.getElementsByTagName("input"), t = e.length; t--; ) {
    var s = e[t];
    s.checked && wa.push(s);
  }
}
function ia(i) {
  return setTimeout(i, 0);
}
function Bl(i) {
  return clearTimeout(i);
}
Co && me(document, "touchmove", function(i) {
  (ie.active || Us) && i.cancelable && i.preventDefault();
});
ie.utils = {
  on: me,
  off: fe,
  css: q,
  find: gf,
  is: function(e, t) {
    return !!Qt(e, t, e, !1);
  },
  extend: DD,
  throttle: _f,
  closest: Qt,
  toggleClass: Ee,
  clone: sc,
  index: Ye,
  nextTick: ia,
  cancelNextTick: Bl,
  detectDirection: yf,
  getChild: ya
};
ie.get = function(i) {
  return i[ct];
};
ie.mount = function() {
  for (var i = arguments.length, e = new Array(i), t = 0; t < i; t++)
    e[t] = arguments[t];
  e[0].constructor === Array && (e = e[0]), e.forEach(function(s) {
    if (!s.prototype || !s.prototype.constructor)
      throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(s));
    s.utils && (ie.utils = Ui({}, ie.utils, s.utils)), Cn.mount(s);
  });
};
ie.create = function(i, e) {
  return new ie(i, e);
};
ie.version = vD;
var Ue = [], Fr, Hl, zl = !1, Jo, el, Sa, Yr;
function YD() {
  function i() {
    this.defaults = {
      scroll: !0,
      scrollSensitivity: 30,
      scrollSpeed: 10,
      bubbleScroll: !0
    };
    for (var e in this)
      e.charAt(0) === "_" && typeof this[e] == "function" && (this[e] = this[e].bind(this));
  }
  return i.prototype = {
    dragStarted: function(t) {
      var s = t.originalEvent;
      this.sortable.nativeDraggable ? me(document, "dragover", this._handleAutoScroll) : this.options.supportPointer ? me(document, "pointermove", this._handleFallbackAutoScroll) : s.touches ? me(document, "touchmove", this._handleFallbackAutoScroll) : me(document, "mousemove", this._handleFallbackAutoScroll);
    },
    dragOverCompleted: function(t) {
      var s = t.originalEvent;
      !this.options.dragOverBubble && !s.rootEl && this._handleAutoScroll(s);
    },
    drop: function() {
      this.sortable.nativeDraggable ? fe(document, "dragover", this._handleAutoScroll) : (fe(document, "pointermove", this._handleFallbackAutoScroll), fe(document, "touchmove", this._handleFallbackAutoScroll), fe(document, "mousemove", this._handleFallbackAutoScroll)), ah(), sa(), CD();
    },
    nulling: function() {
      Sa = Hl = Fr = zl = Yr = Jo = el = null, Ue.length = 0;
    },
    _handleFallbackAutoScroll: function(t) {
      this._handleAutoScroll(t, !0);
    },
    _handleAutoScroll: function(t, s) {
      var r = this, n = (t.touches ? t.touches[0] : t).clientX, a = (t.touches ? t.touches[0] : t).clientY, o = document.elementFromPoint(n, a);
      if (Sa = t, s || Dn || ji || Fl) {
        tl(t, this.options, o, s);
        var l = Bi(o, !0);
        zl && (!Yr || n !== Jo || a !== el) && (Yr && ah(), Yr = setInterval(function() {
          var u = Bi(document.elementFromPoint(n, a), !0);
          u !== l && (l = u, sa()), tl(t, r.options, u, s);
        }, 10), Jo = n, el = a);
      } else {
        if (!this.options.bubbleScroll || Bi(o, !0) === hi()) {
          sa();
          return;
        }
        tl(t, this.options, Bi(o, !1), !1);
      }
    }
  }, Xt(i, {
    pluginName: "scroll",
    initializeByDefault: !0
  });
}
function sa() {
  Ue.forEach(function(i) {
    clearInterval(i.pid);
  }), Ue = [];
}
function ah() {
  clearInterval(Yr);
}
var tl = _f(function(i, e, t, s) {
  if (e.scroll) {
    var r = (i.touches ? i.touches[0] : i).clientX, n = (i.touches ? i.touches[0] : i).clientY, a = e.scrollSensitivity, o = e.scrollSpeed, l = hi(), u = !1, h;
    Hl !== t && (Hl = t, sa(), Fr = e.scroll, h = e.scrollFn, Fr === !0 && (Fr = Bi(t, !0)));
    var c = 0, f = Fr;
    do {
      var d = f, g = Be(d), p = g.top, _ = g.bottom, m = g.left, v = g.right, b = g.width, y = g.height, x = void 0, D = void 0, A = d.scrollWidth, C = d.scrollHeight, O = q(d), T = d.scrollLeft, L = d.scrollTop;
      d === l ? (x = b < A && (O.overflowX === "auto" || O.overflowX === "scroll" || O.overflowX === "visible"), D = y < C && (O.overflowY === "auto" || O.overflowY === "scroll" || O.overflowY === "visible")) : (x = b < A && (O.overflowX === "auto" || O.overflowX === "scroll"), D = y < C && (O.overflowY === "auto" || O.overflowY === "scroll"));
      var j = x && (Math.abs(v - r) <= a && T + b < A) - (Math.abs(m - r) <= a && !!T), N = D && (Math.abs(_ - n) <= a && L + y < C) - (Math.abs(p - n) <= a && !!L);
      if (!Ue[c])
        for (var ee = 0; ee <= c; ee++)
          Ue[ee] || (Ue[ee] = {});
      (Ue[c].vx != j || Ue[c].vy != N || Ue[c].el !== d) && (Ue[c].el = d, Ue[c].vx = j, Ue[c].vy = N, clearInterval(Ue[c].pid), (j != 0 || N != 0) && (u = !0, Ue[c].pid = setInterval((function() {
        s && this.layer === 0 && ie.active._onTouchMove(Sa);
        var z = Ue[this.layer].vy ? Ue[this.layer].vy * o : 0, H = Ue[this.layer].vx ? Ue[this.layer].vx * o : 0;
        typeof h == "function" && h.call(ie.dragged.parentNode[ct], H, z, i, Sa, Ue[this.layer].el) !== "continue" || mf(Ue[this.layer].el, H, z);
      }).bind({
        layer: c
      }), 24))), c++;
    } while (e.bubbleScroll && f !== l && (f = Bi(f, !1)));
    zl = u;
  }
}, 30), Sf = function(e) {
  var t = e.originalEvent, s = e.putSortable, r = e.dragEl, n = e.activeSortable, a = e.dispatchSortableEvent, o = e.hideGhostForTarget, l = e.unhideGhostForTarget;
  if (t) {
    var u = s || n;
    o();
    var h = t.changedTouches && t.changedTouches.length ? t.changedTouches[0] : t, c = document.elementFromPoint(h.clientX, h.clientY);
    l(), u && !u.el.contains(c) && (a("spill"), this.onSpill({
      dragEl: r,
      putSortable: s
    }));
  }
};
function rc() {
}
rc.prototype = {
  startIndex: null,
  dragStart: function(e) {
    var t = e.oldDraggableIndex;
    this.startIndex = t;
  },
  onSpill: function(e) {
    var t = e.dragEl, s = e.putSortable;
    this.sortable.captureAnimationState(), s && s.captureAnimationState();
    var r = ya(this.sortable.el, this.startIndex, this.options);
    r ? this.sortable.el.insertBefore(t, r) : this.sortable.el.appendChild(t), this.sortable.animateAll(), s && s.animateAll();
  },
  drop: Sf
};
Xt(rc, {
  pluginName: "revertOnSpill"
});
function nc() {
}
nc.prototype = {
  onSpill: function(e) {
    var t = e.dragEl, s = e.putSortable, r = s || this.sortable;
    r.captureAnimationState(), t.parentNode && t.parentNode.removeChild(t), r.animateAll();
  },
  drop: Sf
};
Xt(nc, {
  pluginName: "removeOnSpill"
});
var Ft;
function BD() {
  function i() {
    this.defaults = {
      swapClass: "sortable-swap-highlight"
    };
  }
  return i.prototype = {
    dragStart: function(t) {
      var s = t.dragEl;
      Ft = s;
    },
    dragOverValid: function(t) {
      var s = t.completed, r = t.target, n = t.onMove, a = t.activeSortable, o = t.changed, l = t.cancel;
      if (a.options.swap) {
        var u = this.sortable.el, h = this.options;
        if (r && r !== u) {
          var c = Ft;
          n(r) !== !1 ? (Ee(r, h.swapClass, !0), Ft = r) : Ft = null, c && c !== Ft && Ee(c, h.swapClass, !1);
        }
        o(), s(!0), l();
      }
    },
    drop: function(t) {
      var s = t.activeSortable, r = t.putSortable, n = t.dragEl, a = r || this.sortable, o = this.options;
      Ft && Ee(Ft, o.swapClass, !1), Ft && (o.swap || r && r.options.swap) && n !== Ft && (a.captureAnimationState(), a !== s && s.captureAnimationState(), HD(n, Ft), a.animateAll(), a !== s && s.animateAll());
    },
    nulling: function() {
      Ft = null;
    }
  }, Xt(i, {
    pluginName: "swap",
    eventProperties: function() {
      return {
        swapItem: Ft
      };
    }
  });
}
function HD(i, e) {
  var t = i.parentNode, s = e.parentNode, r, n;
  !t || !s || t.isEqualNode(e) || s.isEqualNode(i) || (r = Ye(i), n = Ye(e), t.isEqualNode(s) && r < n && n++, t.insertBefore(e, t.children[r]), s.insertBefore(i, s.children[n]));
}
var ne = [], Lt = [], jr, qt, Ir = !1, Mt = !1, Vs = !1, ke, Er, $n;
function zD() {
  function i(e) {
    for (var t in this)
      t.charAt(0) === "_" && typeof this[t] == "function" && (this[t] = this[t].bind(this));
    e.options.supportPointer ? me(document, "pointerup", this._deselectMultiDrag) : (me(document, "mouseup", this._deselectMultiDrag), me(document, "touchend", this._deselectMultiDrag)), me(document, "keydown", this._checkKeyDown), me(document, "keyup", this._checkKeyUp), this.defaults = {
      selectedClass: "sortable-selected",
      multiDragKey: null,
      setData: function(r, n) {
        var a = "";
        ne.length && qt === e ? ne.forEach(function(o, l) {
          a += (l ? ", " : "") + o.textContent;
        }) : a = n.textContent, r.setData("Text", a);
      }
    };
  }
  return i.prototype = {
    multiDragKeyDown: !1,
    isMultiDrag: !1,
    delayStartGlobal: function(t) {
      var s = t.dragEl;
      ke = s;
    },
    delayEnded: function() {
      this.isMultiDrag = ~ne.indexOf(ke);
    },
    setupClone: function(t) {
      var s = t.sortable, r = t.cancel;
      if (this.isMultiDrag) {
        for (var n = 0; n < ne.length; n++)
          Lt.push(sc(ne[n])), Lt[n].sortableIndex = ne[n].sortableIndex, Lt[n].draggable = !1, Lt[n].style["will-change"] = "", Ee(Lt[n], this.options.selectedClass, !1), ne[n] === ke && Ee(Lt[n], this.options.chosenClass, !1);
        s._hideClone(), r();
      }
    },
    clone: function(t) {
      var s = t.sortable, r = t.rootEl, n = t.dispatchSortableEvent, a = t.cancel;
      this.isMultiDrag && (this.options.removeCloneOnHide || ne.length && qt === s && (oh(!0, r), n("clone"), a()));
    },
    showClone: function(t) {
      var s = t.cloneNowShown, r = t.rootEl, n = t.cancel;
      this.isMultiDrag && (oh(!1, r), Lt.forEach(function(a) {
        q(a, "display", "");
      }), s(), $n = !1, n());
    },
    hideClone: function(t) {
      var s = this;
      t.sortable;
      var r = t.cloneNowHidden, n = t.cancel;
      this.isMultiDrag && (Lt.forEach(function(a) {
        q(a, "display", "none"), s.options.removeCloneOnHide && a.parentNode && a.parentNode.removeChild(a);
      }), r(), $n = !0, n());
    },
    dragStartGlobal: function(t) {
      t.sortable, !this.isMultiDrag && qt && qt.multiDrag._deselectMultiDrag(), ne.forEach(function(s) {
        s.sortableIndex = Ye(s);
      }), ne = ne.sort(function(s, r) {
        return s.sortableIndex - r.sortableIndex;
      }), Vs = !0;
    },
    dragStarted: function(t) {
      var s = this, r = t.sortable;
      if (this.isMultiDrag) {
        if (this.options.sort && (r.captureAnimationState(), this.options.animation)) {
          ne.forEach(function(a) {
            a !== ke && q(a, "position", "absolute");
          });
          var n = Be(ke, !1, !0, !0);
          ne.forEach(function(a) {
            a !== ke && ih(a, n);
          }), Mt = !0, Ir = !0;
        }
        r.animateAll(function() {
          Mt = !1, Ir = !1, s.options.animation && ne.forEach(function(a) {
            Wo(a);
          }), s.options.sort && Nn();
        });
      }
    },
    dragOver: function(t) {
      var s = t.target, r = t.completed, n = t.cancel;
      Mt && ~ne.indexOf(s) && (r(!1), n());
    },
    revert: function(t) {
      var s = t.fromSortable, r = t.rootEl, n = t.sortable, a = t.dragRect;
      ne.length > 1 && (ne.forEach(function(o) {
        n.addAnimationState({
          target: o,
          rect: Mt ? Be(o) : a
        }), Wo(o), o.fromRect = a, s.removeAnimationState(o);
      }), Mt = !1, VD(!this.options.removeCloneOnHide, r));
    },
    dragOverCompleted: function(t) {
      var s = t.sortable, r = t.isOwner, n = t.insertion, a = t.activeSortable, o = t.parentEl, l = t.putSortable, u = this.options;
      if (n) {
        if (r && a._hideClone(), Ir = !1, u.animation && ne.length > 1 && (Mt || !r && !a.options.sort && !l)) {
          var h = Be(ke, !1, !0, !0);
          ne.forEach(function(f) {
            f !== ke && (ih(f, h), o.appendChild(f));
          }), Mt = !0;
        }
        if (!r)
          if (Mt || Nn(), ne.length > 1) {
            var c = $n;
            a._showClone(s), a.options.animation && !$n && c && Lt.forEach(function(f) {
              a.addAnimationState({
                target: f,
                rect: Er
              }), f.fromRect = Er, f.thisAnimationDuration = null;
            });
          } else
            a._showClone(s);
      }
    },
    dragOverAnimationCapture: function(t) {
      var s = t.dragRect, r = t.isOwner, n = t.activeSortable;
      if (ne.forEach(function(o) {
        o.thisAnimationDuration = null;
      }), n.options.animation && !r && n.multiDrag.isMultiDrag) {
        Er = Xt({}, s);
        var a = Ts(ke, !0);
        Er.top -= a.f, Er.left -= a.e;
      }
    },
    dragOverAnimationComplete: function() {
      Mt && (Mt = !1, Nn());
    },
    drop: function(t) {
      var s = t.originalEvent, r = t.rootEl, n = t.parentEl, a = t.sortable, o = t.dispatchSortableEvent, l = t.oldIndex, u = t.putSortable, h = u || this.sortable;
      if (s) {
        var c = this.options, f = n.children;
        if (!Vs)
          if (c.multiDragKey && !this.multiDragKeyDown && this._deselectMultiDrag(), Ee(ke, c.selectedClass, !~ne.indexOf(ke)), ~ne.indexOf(ke))
            ne.splice(ne.indexOf(ke), 1), jr = null, $r({
              sortable: a,
              rootEl: r,
              name: "deselect",
              targetEl: ke,
              originalEvt: s
            });
          else {
            if (ne.push(ke), $r({
              sortable: a,
              rootEl: r,
              name: "select",
              targetEl: ke,
              originalEvt: s
            }), s.shiftKey && jr && a.el.contains(jr)) {
              var d = Ye(jr), g = Ye(ke);
              if (~d && ~g && d !== g) {
                var p, _;
                for (g > d ? (_ = d, p = g) : (_ = g, p = d + 1); _ < p; _++)
                  ~ne.indexOf(f[_]) || (Ee(f[_], c.selectedClass, !0), ne.push(f[_]), $r({
                    sortable: a,
                    rootEl: r,
                    name: "select",
                    targetEl: f[_],
                    originalEvt: s
                  }));
              }
            } else
              jr = ke;
            qt = h;
          }
        if (Vs && this.isMultiDrag) {
          if ((n[ct].options.sort || n !== r) && ne.length > 1) {
            var m = Be(ke), v = Ye(ke, ":not(." + this.options.selectedClass + ")");
            if (!Ir && c.animation && (ke.thisAnimationDuration = null), h.captureAnimationState(), !Ir && (c.animation && (ke.fromRect = m, ne.forEach(function(y) {
              if (y.thisAnimationDuration = null, y !== ke) {
                var x = Mt ? Be(y) : m;
                y.fromRect = x, h.addAnimationState({
                  target: y,
                  rect: x
                });
              }
            })), Nn(), ne.forEach(function(y) {
              f[v] ? n.insertBefore(y, f[v]) : n.appendChild(y), v++;
            }), l === Ye(ke))) {
              var b = !1;
              ne.forEach(function(y) {
                if (y.sortableIndex !== Ye(y)) {
                  b = !0;
                  return;
                }
              }), b && o("update");
            }
            ne.forEach(function(y) {
              Wo(y);
            }), h.animateAll();
          }
          qt = h;
        }
        (r === n || u && u.lastPutMode !== "clone") && Lt.forEach(function(y) {
          y.parentNode && y.parentNode.removeChild(y);
        });
      }
    },
    nullingGlobal: function() {
      this.isMultiDrag = Vs = !1, Lt.length = 0;
    },
    destroyGlobal: function() {
      this._deselectMultiDrag(), fe(document, "pointerup", this._deselectMultiDrag), fe(document, "mouseup", this._deselectMultiDrag), fe(document, "touchend", this._deselectMultiDrag), fe(document, "keydown", this._checkKeyDown), fe(document, "keyup", this._checkKeyUp);
    },
    _deselectMultiDrag: function(t) {
      if (!(typeof Vs < "u" && Vs) && qt === this.sortable && !(t && Qt(t.target, this.options.draggable, this.sortable.el, !1)) && !(t && t.button !== 0))
        for (; ne.length; ) {
          var s = ne[0];
          Ee(s, this.options.selectedClass, !1), ne.shift(), $r({
            sortable: this.sortable,
            rootEl: this.sortable.el,
            name: "deselect",
            targetEl: s,
            originalEvt: t
          });
        }
    },
    _checkKeyDown: function(t) {
      t.key === this.options.multiDragKey && (this.multiDragKeyDown = !0);
    },
    _checkKeyUp: function(t) {
      t.key === this.options.multiDragKey && (this.multiDragKeyDown = !1);
    }
  }, Xt(i, {
    // Static methods & properties
    pluginName: "multiDrag",
    utils: {
      /**
       * Selects the provided multi-drag item
       * @param  {HTMLElement} el    The element to be selected
       */
      select: function(t) {
        var s = t.parentNode[ct];
        !s || !s.options.multiDrag || ~ne.indexOf(t) || (qt && qt !== s && (qt.multiDrag._deselectMultiDrag(), qt = s), Ee(t, s.options.selectedClass, !0), ne.push(t));
      },
      /**
       * Deselects the provided multi-drag item
       * @param  {HTMLElement} el    The element to be deselected
       */
      deselect: function(t) {
        var s = t.parentNode[ct], r = ne.indexOf(t);
        !s || !s.options.multiDrag || !~r || (Ee(t, s.options.selectedClass, !1), ne.splice(r, 1));
      }
    },
    eventProperties: function() {
      var t = this, s = [], r = [];
      return ne.forEach(function(n) {
        s.push({
          multiDragElement: n,
          index: n.sortableIndex
        });
        var a;
        Mt && n !== ke ? a = -1 : Mt ? a = Ye(n, ":not(." + t.options.selectedClass + ")") : a = Ye(n), r.push({
          multiDragElement: n,
          index: a
        });
      }), {
        items: _D(ne),
        clones: [].concat(Lt),
        oldIndicies: s,
        newIndicies: r
      };
    },
    optionListeners: {
      multiDragKey: function(t) {
        return t = t.toLowerCase(), t === "ctrl" ? t = "Control" : t.length > 1 && (t = t.charAt(0).toUpperCase() + t.substr(1)), t;
      }
    }
  });
}
function VD(i, e) {
  ne.forEach(function(t, s) {
    var r = e.children[t.sortableIndex + (i ? Number(s) : 0)];
    r ? e.insertBefore(t, r) : e.appendChild(t);
  });
}
function oh(i, e) {
  Lt.forEach(function(t, s) {
    var r = e.children[t.sortableIndex + (i ? Number(s) : 0)];
    r ? e.insertBefore(t, r) : e.appendChild(t);
  });
}
function Nn() {
  ne.forEach(function(i) {
    i !== ke && i.parentNode && i.parentNode.removeChild(i);
  });
}
ie.mount(new YD());
ie.mount(nc, rc);
const XD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  MultiDrag: zD,
  Sortable: ie,
  Swap: BD,
  default: ie
}, Symbol.toStringTag, { value: "Module" })), WD = /* @__PURE__ */ dD(XD);
(function(i, e) {
  (function(s, r) {
    i.exports = r(WD);
  })(typeof self < "u" ? self : cD, function(t) {
    return (
      /******/
      function(s) {
        var r = {};
        function n(a) {
          if (r[a])
            return r[a].exports;
          var o = r[a] = {
            /******/
            i: a,
            /******/
            l: !1,
            /******/
            exports: {}
            /******/
          };
          return s[a].call(o.exports, o, o.exports, n), o.l = !0, o.exports;
        }
        return n.m = s, n.c = r, n.d = function(a, o, l) {
          n.o(a, o) || Object.defineProperty(a, o, { enumerable: !0, get: l });
        }, n.r = function(a) {
          typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(a, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(a, "__esModule", { value: !0 });
        }, n.t = function(a, o) {
          if (o & 1 && (a = n(a)), o & 8 || o & 4 && typeof a == "object" && a && a.__esModule)
            return a;
          var l = /* @__PURE__ */ Object.create(null);
          if (n.r(l), Object.defineProperty(l, "default", { enumerable: !0, value: a }), o & 2 && typeof a != "string")
            for (var u in a)
              n.d(l, u, (function(h) {
                return a[h];
              }).bind(null, u));
          return l;
        }, n.n = function(a) {
          var o = a && a.__esModule ? (
            /******/
            function() {
              return a.default;
            }
          ) : (
            /******/
            function() {
              return a;
            }
          );
          return n.d(o, "a", o), o;
        }, n.o = function(a, o) {
          return Object.prototype.hasOwnProperty.call(a, o);
        }, n.p = "", n(n.s = "fb15");
      }({
        /***/
        "01f9": (
          /***/
          function(s, r, n) {
            var a = n("2d00"), o = n("5ca1"), l = n("2aba"), u = n("32e9"), h = n("84f2"), c = n("41a0"), f = n("7f20"), d = n("38fd"), g = n("2b4c")("iterator"), p = !([].keys && "next" in [].keys()), _ = "@@iterator", m = "keys", v = "values", b = function() {
              return this;
            };
            s.exports = function(y, x, D, A, C, O, T) {
              c(D, x, A);
              var L = function(P) {
                if (!p && P in z)
                  return z[P];
                switch (P) {
                  case m:
                    return function() {
                      return new D(this, P);
                    };
                  case v:
                    return function() {
                      return new D(this, P);
                    };
                }
                return function() {
                  return new D(this, P);
                };
              }, j = x + " Iterator", N = C == v, ee = !1, z = y.prototype, H = z[g] || z[_] || C && z[C], $ = H || L(C), Z = C ? N ? L("entries") : $ : void 0, B = x == "Array" && z.entries || H, he, M, k;
              if (B && (k = d(B.call(new y())), k !== Object.prototype && k.next && (f(k, j, !0), !a && typeof k[g] != "function" && u(k, g, b))), N && H && H.name !== v && (ee = !0, $ = function() {
                return H.call(this);
              }), (!a || T) && (p || ee || !z[g]) && u(z, g, $), h[x] = $, h[j] = b, C)
                if (he = {
                  values: N ? $ : L(v),
                  keys: O ? $ : L(m),
                  entries: Z
                }, T)
                  for (M in he)
                    M in z || l(z, M, he[M]);
                else
                  o(o.P + o.F * (p || ee), x, he);
              return he;
            };
          }
        ),
        /***/
        "02f4": (
          /***/
          function(s, r, n) {
            var a = n("4588"), o = n("be13");
            s.exports = function(l) {
              return function(u, h) {
                var c = String(o(u)), f = a(h), d = c.length, g, p;
                return f < 0 || f >= d ? l ? "" : void 0 : (g = c.charCodeAt(f), g < 55296 || g > 56319 || f + 1 === d || (p = c.charCodeAt(f + 1)) < 56320 || p > 57343 ? l ? c.charAt(f) : g : l ? c.slice(f, f + 2) : (g - 55296 << 10) + (p - 56320) + 65536);
              };
            };
          }
        ),
        /***/
        "0390": (
          /***/
          function(s, r, n) {
            var a = n("02f4")(!0);
            s.exports = function(o, l, u) {
              return l + (u ? a(o, l).length : 1);
            };
          }
        ),
        /***/
        "0bfb": (
          /***/
          function(s, r, n) {
            var a = n("cb7c");
            s.exports = function() {
              var o = a(this), l = "";
              return o.global && (l += "g"), o.ignoreCase && (l += "i"), o.multiline && (l += "m"), o.unicode && (l += "u"), o.sticky && (l += "y"), l;
            };
          }
        ),
        /***/
        "0d58": (
          /***/
          function(s, r, n) {
            var a = n("ce10"), o = n("e11e");
            s.exports = Object.keys || function(u) {
              return a(u, o);
            };
          }
        ),
        /***/
        1495: (
          /***/
          function(s, r, n) {
            var a = n("86cc"), o = n("cb7c"), l = n("0d58");
            s.exports = n("9e1e") ? Object.defineProperties : function(h, c) {
              o(h);
              for (var f = l(c), d = f.length, g = 0, p; d > g; )
                a.f(h, p = f[g++], c[p]);
              return h;
            };
          }
        ),
        /***/
        "214f": (
          /***/
          function(s, r, n) {
            n("b0c5");
            var a = n("2aba"), o = n("32e9"), l = n("79e5"), u = n("be13"), h = n("2b4c"), c = n("520a"), f = h("species"), d = !l(function() {
              var p = /./;
              return p.exec = function() {
                var _ = [];
                return _.groups = { a: "7" }, _;
              }, "".replace(p, "$<a>") !== "7";
            }), g = function() {
              var p = /(?:)/, _ = p.exec;
              p.exec = function() {
                return _.apply(this, arguments);
              };
              var m = "ab".split(p);
              return m.length === 2 && m[0] === "a" && m[1] === "b";
            }();
            s.exports = function(p, _, m) {
              var v = h(p), b = !l(function() {
                var O = {};
                return O[v] = function() {
                  return 7;
                }, ""[p](O) != 7;
              }), y = b ? !l(function() {
                var O = !1, T = /a/;
                return T.exec = function() {
                  return O = !0, null;
                }, p === "split" && (T.constructor = {}, T.constructor[f] = function() {
                  return T;
                }), T[v](""), !O;
              }) : void 0;
              if (!b || !y || p === "replace" && !d || p === "split" && !g) {
                var x = /./[v], D = m(
                  u,
                  v,
                  ""[p],
                  function(T, L, j, N, ee) {
                    return L.exec === c ? b && !ee ? { done: !0, value: x.call(L, j, N) } : { done: !0, value: T.call(j, L, N) } : { done: !1 };
                  }
                ), A = D[0], C = D[1];
                a(String.prototype, p, A), o(
                  RegExp.prototype,
                  v,
                  _ == 2 ? function(O, T) {
                    return C.call(O, this, T);
                  } : function(O) {
                    return C.call(O, this);
                  }
                );
              }
            };
          }
        ),
        /***/
        "230e": (
          /***/
          function(s, r, n) {
            var a = n("d3f4"), o = n("7726").document, l = a(o) && a(o.createElement);
            s.exports = function(u) {
              return l ? o.createElement(u) : {};
            };
          }
        ),
        /***/
        "23c6": (
          /***/
          function(s, r, n) {
            var a = n("2d95"), o = n("2b4c")("toStringTag"), l = a(function() {
              return arguments;
            }()) == "Arguments", u = function(h, c) {
              try {
                return h[c];
              } catch {
              }
            };
            s.exports = function(h) {
              var c, f, d;
              return h === void 0 ? "Undefined" : h === null ? "Null" : typeof (f = u(c = Object(h), o)) == "string" ? f : l ? a(c) : (d = a(c)) == "Object" && typeof c.callee == "function" ? "Arguments" : d;
            };
          }
        ),
        /***/
        2621: (
          /***/
          function(s, r) {
            r.f = Object.getOwnPropertySymbols;
          }
        ),
        /***/
        "2aba": (
          /***/
          function(s, r, n) {
            var a = n("7726"), o = n("32e9"), l = n("69a8"), u = n("ca5a")("src"), h = n("fa5b"), c = "toString", f = ("" + h).split(c);
            n("8378").inspectSource = function(d) {
              return h.call(d);
            }, (s.exports = function(d, g, p, _) {
              var m = typeof p == "function";
              m && (l(p, "name") || o(p, "name", g)), d[g] !== p && (m && (l(p, u) || o(p, u, d[g] ? "" + d[g] : f.join(String(g)))), d === a ? d[g] = p : _ ? d[g] ? d[g] = p : o(d, g, p) : (delete d[g], o(d, g, p)));
            })(Function.prototype, c, function() {
              return typeof this == "function" && this[u] || h.call(this);
            });
          }
        ),
        /***/
        "2aeb": (
          /***/
          function(s, r, n) {
            var a = n("cb7c"), o = n("1495"), l = n("e11e"), u = n("613b")("IE_PROTO"), h = function() {
            }, c = "prototype", f = function() {
              var d = n("230e")("iframe"), g = l.length, p = "<", _ = ">", m;
              for (d.style.display = "none", n("fab2").appendChild(d), d.src = "javascript:", m = d.contentWindow.document, m.open(), m.write(p + "script" + _ + "document.F=Object" + p + "/script" + _), m.close(), f = m.F; g--; )
                delete f[c][l[g]];
              return f();
            };
            s.exports = Object.create || function(g, p) {
              var _;
              return g !== null ? (h[c] = a(g), _ = new h(), h[c] = null, _[u] = g) : _ = f(), p === void 0 ? _ : o(_, p);
            };
          }
        ),
        /***/
        "2b4c": (
          /***/
          function(s, r, n) {
            var a = n("5537")("wks"), o = n("ca5a"), l = n("7726").Symbol, u = typeof l == "function", h = s.exports = function(c) {
              return a[c] || (a[c] = u && l[c] || (u ? l : o)("Symbol." + c));
            };
            h.store = a;
          }
        ),
        /***/
        "2d00": (
          /***/
          function(s, r) {
            s.exports = !1;
          }
        ),
        /***/
        "2d95": (
          /***/
          function(s, r) {
            var n = {}.toString;
            s.exports = function(a) {
              return n.call(a).slice(8, -1);
            };
          }
        ),
        /***/
        "2fdb": (
          /***/
          function(s, r, n) {
            var a = n("5ca1"), o = n("d2c8"), l = "includes";
            a(a.P + a.F * n("5147")(l), "String", {
              includes: function(h) {
                return !!~o(this, h, l).indexOf(h, arguments.length > 1 ? arguments[1] : void 0);
              }
            });
          }
        ),
        /***/
        "32e9": (
          /***/
          function(s, r, n) {
            var a = n("86cc"), o = n("4630");
            s.exports = n("9e1e") ? function(l, u, h) {
              return a.f(l, u, o(1, h));
            } : function(l, u, h) {
              return l[u] = h, l;
            };
          }
        ),
        /***/
        "38fd": (
          /***/
          function(s, r, n) {
            var a = n("69a8"), o = n("4bf8"), l = n("613b")("IE_PROTO"), u = Object.prototype;
            s.exports = Object.getPrototypeOf || function(h) {
              return h = o(h), a(h, l) ? h[l] : typeof h.constructor == "function" && h instanceof h.constructor ? h.constructor.prototype : h instanceof Object ? u : null;
            };
          }
        ),
        /***/
        "41a0": (
          /***/
          function(s, r, n) {
            var a = n("2aeb"), o = n("4630"), l = n("7f20"), u = {};
            n("32e9")(u, n("2b4c")("iterator"), function() {
              return this;
            }), s.exports = function(h, c, f) {
              h.prototype = a(u, { next: o(1, f) }), l(h, c + " Iterator");
            };
          }
        ),
        /***/
        "456d": (
          /***/
          function(s, r, n) {
            var a = n("4bf8"), o = n("0d58");
            n("5eda")("keys", function() {
              return function(u) {
                return o(a(u));
              };
            });
          }
        ),
        /***/
        4588: (
          /***/
          function(s, r) {
            var n = Math.ceil, a = Math.floor;
            s.exports = function(o) {
              return isNaN(o = +o) ? 0 : (o > 0 ? a : n)(o);
            };
          }
        ),
        /***/
        4630: (
          /***/
          function(s, r) {
            s.exports = function(n, a) {
              return {
                enumerable: !(n & 1),
                configurable: !(n & 2),
                writable: !(n & 4),
                value: a
              };
            };
          }
        ),
        /***/
        "4bf8": (
          /***/
          function(s, r, n) {
            var a = n("be13");
            s.exports = function(o) {
              return Object(a(o));
            };
          }
        ),
        /***/
        5147: (
          /***/
          function(s, r, n) {
            var a = n("2b4c")("match");
            s.exports = function(o) {
              var l = /./;
              try {
                "/./"[o](l);
              } catch {
                try {
                  return l[a] = !1, !"/./"[o](l);
                } catch {
                }
              }
              return !0;
            };
          }
        ),
        /***/
        "520a": (
          /***/
          function(s, r, n) {
            var a = n("0bfb"), o = RegExp.prototype.exec, l = String.prototype.replace, u = o, h = "lastIndex", c = function() {
              var g = /a/, p = /b*/g;
              return o.call(g, "a"), o.call(p, "a"), g[h] !== 0 || p[h] !== 0;
            }(), f = /()??/.exec("")[1] !== void 0, d = c || f;
            d && (u = function(p) {
              var _ = this, m, v, b, y;
              return f && (v = new RegExp("^" + _.source + "$(?!\\s)", a.call(_))), c && (m = _[h]), b = o.call(_, p), c && b && (_[h] = _.global ? b.index + b[0].length : m), f && b && b.length > 1 && l.call(b[0], v, function() {
                for (y = 1; y < arguments.length - 2; y++)
                  arguments[y] === void 0 && (b[y] = void 0);
              }), b;
            }), s.exports = u;
          }
        ),
        /***/
        "52a7": (
          /***/
          function(s, r) {
            r.f = {}.propertyIsEnumerable;
          }
        ),
        /***/
        5537: (
          /***/
          function(s, r, n) {
            var a = n("8378"), o = n("7726"), l = "__core-js_shared__", u = o[l] || (o[l] = {});
            (s.exports = function(h, c) {
              return u[h] || (u[h] = c !== void 0 ? c : {});
            })("versions", []).push({
              version: a.version,
              mode: n("2d00") ? "pure" : "global",
              copyright: "© 2019 Denis Pushkarev (zloirock.ru)"
            });
          }
        ),
        /***/
        "5ca1": (
          /***/
          function(s, r, n) {
            var a = n("7726"), o = n("8378"), l = n("32e9"), u = n("2aba"), h = n("9b43"), c = "prototype", f = function(d, g, p) {
              var _ = d & f.F, m = d & f.G, v = d & f.S, b = d & f.P, y = d & f.B, x = m ? a : v ? a[g] || (a[g] = {}) : (a[g] || {})[c], D = m ? o : o[g] || (o[g] = {}), A = D[c] || (D[c] = {}), C, O, T, L;
              m && (p = g);
              for (C in p)
                O = !_ && x && x[C] !== void 0, T = (O ? x : p)[C], L = y && O ? h(T, a) : b && typeof T == "function" ? h(Function.call, T) : T, x && u(x, C, T, d & f.U), D[C] != T && l(D, C, L), b && A[C] != T && (A[C] = T);
            };
            a.core = o, f.F = 1, f.G = 2, f.S = 4, f.P = 8, f.B = 16, f.W = 32, f.U = 64, f.R = 128, s.exports = f;
          }
        ),
        /***/
        "5eda": (
          /***/
          function(s, r, n) {
            var a = n("5ca1"), o = n("8378"), l = n("79e5");
            s.exports = function(u, h) {
              var c = (o.Object || {})[u] || Object[u], f = {};
              f[u] = h(c), a(a.S + a.F * l(function() {
                c(1);
              }), "Object", f);
            };
          }
        ),
        /***/
        "5f1b": (
          /***/
          function(s, r, n) {
            var a = n("23c6"), o = RegExp.prototype.exec;
            s.exports = function(l, u) {
              var h = l.exec;
              if (typeof h == "function") {
                var c = h.call(l, u);
                if (typeof c != "object")
                  throw new TypeError("RegExp exec method returned something other than an Object or null");
                return c;
              }
              if (a(l) !== "RegExp")
                throw new TypeError("RegExp#exec called on incompatible receiver");
              return o.call(l, u);
            };
          }
        ),
        /***/
        "613b": (
          /***/
          function(s, r, n) {
            var a = n("5537")("keys"), o = n("ca5a");
            s.exports = function(l) {
              return a[l] || (a[l] = o(l));
            };
          }
        ),
        /***/
        "626a": (
          /***/
          function(s, r, n) {
            var a = n("2d95");
            s.exports = Object("z").propertyIsEnumerable(0) ? Object : function(o) {
              return a(o) == "String" ? o.split("") : Object(o);
            };
          }
        ),
        /***/
        6762: (
          /***/
          function(s, r, n) {
            var a = n("5ca1"), o = n("c366")(!0);
            a(a.P, "Array", {
              includes: function(u) {
                return o(this, u, arguments.length > 1 ? arguments[1] : void 0);
              }
            }), n("9c6c")("includes");
          }
        ),
        /***/
        6821: (
          /***/
          function(s, r, n) {
            var a = n("626a"), o = n("be13");
            s.exports = function(l) {
              return a(o(l));
            };
          }
        ),
        /***/
        "69a8": (
          /***/
          function(s, r) {
            var n = {}.hasOwnProperty;
            s.exports = function(a, o) {
              return n.call(a, o);
            };
          }
        ),
        /***/
        "6a99": (
          /***/
          function(s, r, n) {
            var a = n("d3f4");
            s.exports = function(o, l) {
              if (!a(o))
                return o;
              var u, h;
              if (l && typeof (u = o.toString) == "function" && !a(h = u.call(o)) || typeof (u = o.valueOf) == "function" && !a(h = u.call(o)) || !l && typeof (u = o.toString) == "function" && !a(h = u.call(o)))
                return h;
              throw TypeError("Can't convert object to primitive value");
            };
          }
        ),
        /***/
        7333: (
          /***/
          function(s, r, n) {
            var a = n("0d58"), o = n("2621"), l = n("52a7"), u = n("4bf8"), h = n("626a"), c = Object.assign;
            s.exports = !c || n("79e5")(function() {
              var f = {}, d = {}, g = Symbol(), p = "abcdefghijklmnopqrst";
              return f[g] = 7, p.split("").forEach(function(_) {
                d[_] = _;
              }), c({}, f)[g] != 7 || Object.keys(c({}, d)).join("") != p;
            }) ? function(d, g) {
              for (var p = u(d), _ = arguments.length, m = 1, v = o.f, b = l.f; _ > m; )
                for (var y = h(arguments[m++]), x = v ? a(y).concat(v(y)) : a(y), D = x.length, A = 0, C; D > A; )
                  b.call(y, C = x[A++]) && (p[C] = y[C]);
              return p;
            } : c;
          }
        ),
        /***/
        7726: (
          /***/
          function(s, r) {
            var n = s.exports = typeof window < "u" && window.Math == Math ? window : typeof self < "u" && self.Math == Math ? self : Function("return this")();
            typeof __g == "number" && (__g = n);
          }
        ),
        /***/
        "77f1": (
          /***/
          function(s, r, n) {
            var a = n("4588"), o = Math.max, l = Math.min;
            s.exports = function(u, h) {
              return u = a(u), u < 0 ? o(u + h, 0) : l(u, h);
            };
          }
        ),
        /***/
        "79e5": (
          /***/
          function(s, r) {
            s.exports = function(n) {
              try {
                return !!n();
              } catch {
                return !0;
              }
            };
          }
        ),
        /***/
        "7f20": (
          /***/
          function(s, r, n) {
            var a = n("86cc").f, o = n("69a8"), l = n("2b4c")("toStringTag");
            s.exports = function(u, h, c) {
              u && !o(u = c ? u : u.prototype, l) && a(u, l, { configurable: !0, value: h });
            };
          }
        ),
        /***/
        8378: (
          /***/
          function(s, r) {
            var n = s.exports = { version: "2.6.5" };
            typeof __e == "number" && (__e = n);
          }
        ),
        /***/
        "84f2": (
          /***/
          function(s, r) {
            s.exports = {};
          }
        ),
        /***/
        "86cc": (
          /***/
          function(s, r, n) {
            var a = n("cb7c"), o = n("c69a"), l = n("6a99"), u = Object.defineProperty;
            r.f = n("9e1e") ? Object.defineProperty : function(c, f, d) {
              if (a(c), f = l(f, !0), a(d), o)
                try {
                  return u(c, f, d);
                } catch {
                }
              if ("get" in d || "set" in d)
                throw TypeError("Accessors not supported!");
              return "value" in d && (c[f] = d.value), c;
            };
          }
        ),
        /***/
        "9b43": (
          /***/
          function(s, r, n) {
            var a = n("d8e8");
            s.exports = function(o, l, u) {
              if (a(o), l === void 0)
                return o;
              switch (u) {
                case 1:
                  return function(h) {
                    return o.call(l, h);
                  };
                case 2:
                  return function(h, c) {
                    return o.call(l, h, c);
                  };
                case 3:
                  return function(h, c, f) {
                    return o.call(l, h, c, f);
                  };
              }
              return function() {
                return o.apply(l, arguments);
              };
            };
          }
        ),
        /***/
        "9c6c": (
          /***/
          function(s, r, n) {
            var a = n("2b4c")("unscopables"), o = Array.prototype;
            o[a] == null && n("32e9")(o, a, {}), s.exports = function(l) {
              o[a][l] = !0;
            };
          }
        ),
        /***/
        "9def": (
          /***/
          function(s, r, n) {
            var a = n("4588"), o = Math.min;
            s.exports = function(l) {
              return l > 0 ? o(a(l), 9007199254740991) : 0;
            };
          }
        ),
        /***/
        "9e1e": (
          /***/
          function(s, r, n) {
            s.exports = !n("79e5")(function() {
              return Object.defineProperty({}, "a", { get: function() {
                return 7;
              } }).a != 7;
            });
          }
        ),
        /***/
        a352: (
          /***/
          function(s, r) {
            s.exports = t;
          }
        ),
        /***/
        a481: (
          /***/
          function(s, r, n) {
            var a = n("cb7c"), o = n("4bf8"), l = n("9def"), u = n("4588"), h = n("0390"), c = n("5f1b"), f = Math.max, d = Math.min, g = Math.floor, p = /\$([$&`']|\d\d?|<[^>]*>)/g, _ = /\$([$&`']|\d\d?)/g, m = function(v) {
              return v === void 0 ? v : String(v);
            };
            n("214f")("replace", 2, function(v, b, y, x) {
              return [
                // `String.prototype.replace` method
                // https://tc39.github.io/ecma262/#sec-string.prototype.replace
                function(C, O) {
                  var T = v(this), L = C == null ? void 0 : C[b];
                  return L !== void 0 ? L.call(C, T, O) : y.call(String(T), C, O);
                },
                // `RegExp.prototype[@@replace]` method
                // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
                function(A, C) {
                  var O = x(y, A, this, C);
                  if (O.done)
                    return O.value;
                  var T = a(A), L = String(this), j = typeof C == "function";
                  j || (C = String(C));
                  var N = T.global;
                  if (N) {
                    var ee = T.unicode;
                    T.lastIndex = 0;
                  }
                  for (var z = []; ; ) {
                    var H = c(T, L);
                    if (H === null || (z.push(H), !N))
                      break;
                    var $ = String(H[0]);
                    $ === "" && (T.lastIndex = h(L, l(T.lastIndex), ee));
                  }
                  for (var Z = "", B = 0, he = 0; he < z.length; he++) {
                    H = z[he];
                    for (var M = String(H[0]), k = f(d(u(H.index), L.length), 0), P = [], F = 1; F < H.length; F++)
                      P.push(m(H[F]));
                    var te = H.groups;
                    if (j) {
                      var U = [M].concat(P, k, L);
                      te !== void 0 && U.push(te);
                      var _e = String(C.apply(void 0, U));
                    } else
                      _e = D(M, L, k, P, te, C);
                    k >= B && (Z += L.slice(B, k) + _e, B = k + M.length);
                  }
                  return Z + L.slice(B);
                }
              ];
              function D(A, C, O, T, L, j) {
                var N = O + A.length, ee = T.length, z = _;
                return L !== void 0 && (L = o(L), z = p), y.call(j, z, function(H, $) {
                  var Z;
                  switch ($.charAt(0)) {
                    case "$":
                      return "$";
                    case "&":
                      return A;
                    case "`":
                      return C.slice(0, O);
                    case "'":
                      return C.slice(N);
                    case "<":
                      Z = L[$.slice(1, -1)];
                      break;
                    default:
                      var B = +$;
                      if (B === 0)
                        return H;
                      if (B > ee) {
                        var he = g(B / 10);
                        return he === 0 ? H : he <= ee ? T[he - 1] === void 0 ? $.charAt(1) : T[he - 1] + $.charAt(1) : H;
                      }
                      Z = T[B - 1];
                  }
                  return Z === void 0 ? "" : Z;
                });
              }
            });
          }
        ),
        /***/
        aae3: (
          /***/
          function(s, r, n) {
            var a = n("d3f4"), o = n("2d95"), l = n("2b4c")("match");
            s.exports = function(u) {
              var h;
              return a(u) && ((h = u[l]) !== void 0 ? !!h : o(u) == "RegExp");
            };
          }
        ),
        /***/
        ac6a: (
          /***/
          function(s, r, n) {
            for (var a = n("cadf"), o = n("0d58"), l = n("2aba"), u = n("7726"), h = n("32e9"), c = n("84f2"), f = n("2b4c"), d = f("iterator"), g = f("toStringTag"), p = c.Array, _ = {
              CSSRuleList: !0,
              // TODO: Not spec compliant, should be false.
              CSSStyleDeclaration: !1,
              CSSValueList: !1,
              ClientRectList: !1,
              DOMRectList: !1,
              DOMStringList: !1,
              DOMTokenList: !0,
              DataTransferItemList: !1,
              FileList: !1,
              HTMLAllCollection: !1,
              HTMLCollection: !1,
              HTMLFormElement: !1,
              HTMLSelectElement: !1,
              MediaList: !0,
              // TODO: Not spec compliant, should be false.
              MimeTypeArray: !1,
              NamedNodeMap: !1,
              NodeList: !0,
              PaintRequestList: !1,
              Plugin: !1,
              PluginArray: !1,
              SVGLengthList: !1,
              SVGNumberList: !1,
              SVGPathSegList: !1,
              SVGPointList: !1,
              SVGStringList: !1,
              SVGTransformList: !1,
              SourceBufferList: !1,
              StyleSheetList: !0,
              // TODO: Not spec compliant, should be false.
              TextTrackCueList: !1,
              TextTrackList: !1,
              TouchList: !1
            }, m = o(_), v = 0; v < m.length; v++) {
              var b = m[v], y = _[b], x = u[b], D = x && x.prototype, A;
              if (D && (D[d] || h(D, d, p), D[g] || h(D, g, b), c[b] = p, y))
                for (A in a)
                  D[A] || l(D, A, a[A], !0);
            }
          }
        ),
        /***/
        b0c5: (
          /***/
          function(s, r, n) {
            var a = n("520a");
            n("5ca1")({
              target: "RegExp",
              proto: !0,
              forced: a !== /./.exec
            }, {
              exec: a
            });
          }
        ),
        /***/
        be13: (
          /***/
          function(s, r) {
            s.exports = function(n) {
              if (n == null)
                throw TypeError("Can't call method on  " + n);
              return n;
            };
          }
        ),
        /***/
        c366: (
          /***/
          function(s, r, n) {
            var a = n("6821"), o = n("9def"), l = n("77f1");
            s.exports = function(u) {
              return function(h, c, f) {
                var d = a(h), g = o(d.length), p = l(f, g), _;
                if (u && c != c) {
                  for (; g > p; )
                    if (_ = d[p++], _ != _)
                      return !0;
                } else
                  for (; g > p; p++)
                    if ((u || p in d) && d[p] === c)
                      return u || p || 0;
                return !u && -1;
              };
            };
          }
        ),
        /***/
        c649: (
          /***/
          function(s, r, n) {
            (function(a) {
              n.d(r, "c", function() {
                return d;
              }), n.d(r, "a", function() {
                return c;
              }), n.d(r, "b", function() {
                return l;
              }), n.d(r, "d", function() {
                return f;
              }), n("a481");
              function o() {
                return typeof window < "u" ? window.console : a.console;
              }
              var l = o();
              function u(g) {
                var p = /* @__PURE__ */ Object.create(null);
                return function(m) {
                  var v = p[m];
                  return v || (p[m] = g(m));
                };
              }
              var h = /-(\w)/g, c = u(function(g) {
                return g.replace(h, function(p, _) {
                  return _ ? _.toUpperCase() : "";
                });
              });
              function f(g) {
                g.parentElement !== null && g.parentElement.removeChild(g);
              }
              function d(g, p, _) {
                var m = _ === 0 ? g.children[0] : g.children[_ - 1].nextSibling;
                g.insertBefore(p, m);
              }
            }).call(this, n("c8ba"));
          }
        ),
        /***/
        c69a: (
          /***/
          function(s, r, n) {
            s.exports = !n("9e1e") && !n("79e5")(function() {
              return Object.defineProperty(n("230e")("div"), "a", { get: function() {
                return 7;
              } }).a != 7;
            });
          }
        ),
        /***/
        c8ba: (
          /***/
          function(s, r) {
            var n;
            n = function() {
              return this;
            }();
            try {
              n = n || new Function("return this")();
            } catch {
              typeof window == "object" && (n = window);
            }
            s.exports = n;
          }
        ),
        /***/
        ca5a: (
          /***/
          function(s, r) {
            var n = 0, a = Math.random();
            s.exports = function(o) {
              return "Symbol(".concat(o === void 0 ? "" : o, ")_", (++n + a).toString(36));
            };
          }
        ),
        /***/
        cadf: (
          /***/
          function(s, r, n) {
            var a = n("9c6c"), o = n("d53b"), l = n("84f2"), u = n("6821");
            s.exports = n("01f9")(Array, "Array", function(h, c) {
              this._t = u(h), this._i = 0, this._k = c;
            }, function() {
              var h = this._t, c = this._k, f = this._i++;
              return !h || f >= h.length ? (this._t = void 0, o(1)) : c == "keys" ? o(0, f) : c == "values" ? o(0, h[f]) : o(0, [f, h[f]]);
            }, "values"), l.Arguments = l.Array, a("keys"), a("values"), a("entries");
          }
        ),
        /***/
        cb7c: (
          /***/
          function(s, r, n) {
            var a = n("d3f4");
            s.exports = function(o) {
              if (!a(o))
                throw TypeError(o + " is not an object!");
              return o;
            };
          }
        ),
        /***/
        ce10: (
          /***/
          function(s, r, n) {
            var a = n("69a8"), o = n("6821"), l = n("c366")(!1), u = n("613b")("IE_PROTO");
            s.exports = function(h, c) {
              var f = o(h), d = 0, g = [], p;
              for (p in f)
                p != u && a(f, p) && g.push(p);
              for (; c.length > d; )
                a(f, p = c[d++]) && (~l(g, p) || g.push(p));
              return g;
            };
          }
        ),
        /***/
        d2c8: (
          /***/
          function(s, r, n) {
            var a = n("aae3"), o = n("be13");
            s.exports = function(l, u, h) {
              if (a(u))
                throw TypeError("String#" + h + " doesn't accept regex!");
              return String(o(l));
            };
          }
        ),
        /***/
        d3f4: (
          /***/
          function(s, r) {
            s.exports = function(n) {
              return typeof n == "object" ? n !== null : typeof n == "function";
            };
          }
        ),
        /***/
        d53b: (
          /***/
          function(s, r) {
            s.exports = function(n, a) {
              return { value: a, done: !!n };
            };
          }
        ),
        /***/
        d8e8: (
          /***/
          function(s, r) {
            s.exports = function(n) {
              if (typeof n != "function")
                throw TypeError(n + " is not a function!");
              return n;
            };
          }
        ),
        /***/
        e11e: (
          /***/
          function(s, r) {
            s.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",");
          }
        ),
        /***/
        f559: (
          /***/
          function(s, r, n) {
            var a = n("5ca1"), o = n("9def"), l = n("d2c8"), u = "startsWith", h = ""[u];
            a(a.P + a.F * n("5147")(u), "String", {
              startsWith: function(f) {
                var d = l(this, f, u), g = o(Math.min(arguments.length > 1 ? arguments[1] : void 0, d.length)), p = String(f);
                return h ? h.call(d, p, g) : d.slice(g, g + p.length) === p;
              }
            });
          }
        ),
        /***/
        f6fd: (
          /***/
          function(s, r) {
            (function(n) {
              var a = "currentScript", o = n.getElementsByTagName("script");
              a in n || Object.defineProperty(n, a, {
                get: function() {
                  try {
                    throw new Error();
                  } catch (h) {
                    var l, u = (/.*at [^\(]*\((.*):.+:.+\)$/ig.exec(h.stack) || [!1])[1];
                    for (l in o)
                      if (o[l].src == u || o[l].readyState == "interactive")
                        return o[l];
                    return null;
                  }
                }
              });
            })(document);
          }
        ),
        /***/
        f751: (
          /***/
          function(s, r, n) {
            var a = n("5ca1");
            a(a.S + a.F, "Object", { assign: n("7333") });
          }
        ),
        /***/
        fa5b: (
          /***/
          function(s, r, n) {
            s.exports = n("5537")("native-function-to-string", Function.toString);
          }
        ),
        /***/
        fab2: (
          /***/
          function(s, r, n) {
            var a = n("7726").document;
            s.exports = a && a.documentElement;
          }
        ),
        /***/
        fb15: (
          /***/
          function(s, r, n) {
            if (n.r(r), typeof window < "u") {
              n("f6fd");
              var a;
              (a = window.document.currentScript) && (a = a.src.match(/(.+\/)[^/]+\.js(\?.*)?$/)) && (n.p = a[1]);
            }
            n("f751"), n("f559"), n("ac6a"), n("cadf"), n("456d");
            function o(M) {
              if (Array.isArray(M))
                return M;
            }
            function l(M, k) {
              if (!(typeof Symbol > "u" || !(Symbol.iterator in Object(M)))) {
                var P = [], F = !0, te = !1, U = void 0;
                try {
                  for (var _e = M[Symbol.iterator](), Se; !(F = (Se = _e.next()).done) && (P.push(Se.value), !(k && P.length === k)); F = !0)
                    ;
                } catch (Ot) {
                  te = !0, U = Ot;
                } finally {
                  try {
                    !F && _e.return != null && _e.return();
                  } finally {
                    if (te)
                      throw U;
                  }
                }
                return P;
              }
            }
            function u(M, k) {
              (k == null || k > M.length) && (k = M.length);
              for (var P = 0, F = new Array(k); P < k; P++)
                F[P] = M[P];
              return F;
            }
            function h(M, k) {
              if (M) {
                if (typeof M == "string")
                  return u(M, k);
                var P = Object.prototype.toString.call(M).slice(8, -1);
                if (P === "Object" && M.constructor && (P = M.constructor.name), P === "Map" || P === "Set")
                  return Array.from(M);
                if (P === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(P))
                  return u(M, k);
              }
            }
            function c() {
              throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            function f(M, k) {
              return o(M) || l(M, k) || h(M, k) || c();
            }
            n("6762"), n("2fdb");
            function d(M) {
              if (Array.isArray(M))
                return u(M);
            }
            function g(M) {
              if (typeof Symbol < "u" && Symbol.iterator in Object(M))
                return Array.from(M);
            }
            function p() {
              throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            function _(M) {
              return d(M) || g(M) || h(M) || p();
            }
            var m = n("a352"), v = /* @__PURE__ */ n.n(m), b = n("c649");
            function y(M, k, P) {
              return P === void 0 || (M = M || {}, M[k] = P), M;
            }
            function x(M, k) {
              return M.map(function(P) {
                return P.elm;
              }).indexOf(k);
            }
            function D(M, k, P, F) {
              if (!M)
                return [];
              var te = M.map(function(Se) {
                return Se.elm;
              }), U = k.length - F, _e = _(k).map(function(Se, Ot) {
                return Ot >= U ? te.length : te.indexOf(Se);
              });
              return P ? _e.filter(function(Se) {
                return Se !== -1;
              }) : _e;
            }
            function A(M, k) {
              var P = this;
              this.$nextTick(function() {
                return P.$emit(M.toLowerCase(), k);
              });
            }
            function C(M) {
              var k = this;
              return function(P) {
                k.realList !== null && k["onDrag" + M](P), A.call(k, M, P);
              };
            }
            function O(M) {
              return ["transition-group", "TransitionGroup"].includes(M);
            }
            function T(M) {
              if (!M || M.length !== 1)
                return !1;
              var k = f(M, 1), P = k[0].componentOptions;
              return P ? O(P.tag) : !1;
            }
            function L(M, k, P) {
              return M[P] || (k[P] ? k[P]() : void 0);
            }
            function j(M, k, P) {
              var F = 0, te = 0, U = L(k, P, "header");
              U && (F = U.length, M = M ? [].concat(_(U), _(M)) : _(U));
              var _e = L(k, P, "footer");
              return _e && (te = _e.length, M = M ? [].concat(_(M), _(_e)) : _(_e)), {
                children: M,
                headerOffset: F,
                footerOffset: te
              };
            }
            function N(M, k) {
              var P = null, F = function(cs, Bp) {
                P = y(P, cs, Bp);
              }, te = Object.keys(M).filter(function(Ot) {
                return Ot === "id" || Ot.startsWith("data-");
              }).reduce(function(Ot, cs) {
                return Ot[cs] = M[cs], Ot;
              }, {});
              if (F("attrs", te), !k)
                return P;
              var U = k.on, _e = k.props, Se = k.attrs;
              return F("on", U), F("props", _e), Object.assign(P.attrs, Se), P;
            }
            var ee = ["Start", "Add", "Remove", "Update", "End"], z = ["Choose", "Unchoose", "Sort", "Filter", "Clone"], H = ["Move"].concat(ee, z).map(function(M) {
              return "on" + M;
            }), $ = null, Z = {
              options: Object,
              list: {
                type: Array,
                required: !1,
                default: null
              },
              value: {
                type: Array,
                required: !1,
                default: null
              },
              noTransitionOnDrag: {
                type: Boolean,
                default: !1
              },
              clone: {
                type: Function,
                default: function(k) {
                  return k;
                }
              },
              element: {
                type: String,
                default: "div"
              },
              tag: {
                type: String,
                default: null
              },
              move: {
                type: Function,
                default: null
              },
              componentData: {
                type: Object,
                required: !1,
                default: null
              }
            }, B = {
              name: "draggable",
              inheritAttrs: !1,
              props: Z,
              data: function() {
                return {
                  transitionMode: !1,
                  noneFunctionalComponentMode: !1
                };
              },
              render: function(k) {
                var P = this.$slots.default;
                this.transitionMode = T(P);
                var F = j(P, this.$slots, this.$scopedSlots), te = F.children, U = F.headerOffset, _e = F.footerOffset;
                this.headerOffset = U, this.footerOffset = _e;
                var Se = N(this.$attrs, this.componentData);
                return k(this.getTag(), Se, te);
              },
              created: function() {
                this.list !== null && this.value !== null && b.b.error("Value and list props are mutually exclusive! Please set one or another."), this.element !== "div" && b.b.warn("Element props is deprecated please use tag props instead. See https://github.com/SortableJS/Vue.Draggable/blob/master/documentation/migrate.md#element-props"), this.options !== void 0 && b.b.warn("Options props is deprecated, add sortable options directly as vue.draggable item, or use v-bind. See https://github.com/SortableJS/Vue.Draggable/blob/master/documentation/migrate.md#options-props");
              },
              mounted: function() {
                var k = this;
                if (this.noneFunctionalComponentMode = this.getTag().toLowerCase() !== this.$el.nodeName.toLowerCase() && !this.getIsFunctional(), this.noneFunctionalComponentMode && this.transitionMode)
                  throw new Error("Transition-group inside component is not supported. Please alter tag value or remove transition-group. Current tag value: ".concat(this.getTag()));
                var P = {};
                ee.forEach(function(U) {
                  P["on" + U] = C.call(k, U);
                }), z.forEach(function(U) {
                  P["on" + U] = A.bind(k, U);
                });
                var F = Object.keys(this.$attrs).reduce(function(U, _e) {
                  return U[Object(b.a)(_e)] = k.$attrs[_e], U;
                }, {}), te = Object.assign({}, this.options, F, P, {
                  onMove: function(_e, Se) {
                    return k.onDragMove(_e, Se);
                  }
                });
                !("draggable" in te) && (te.draggable = ">*"), this._sortable = new v.a(this.rootContainer, te), this.computeIndexes();
              },
              beforeDestroy: function() {
                this._sortable !== void 0 && this._sortable.destroy();
              },
              computed: {
                rootContainer: function() {
                  return this.transitionMode ? this.$el.children[0] : this.$el;
                },
                realList: function() {
                  return this.list ? this.list : this.value;
                }
              },
              watch: {
                options: {
                  handler: function(k) {
                    this.updateOptions(k);
                  },
                  deep: !0
                },
                $attrs: {
                  handler: function(k) {
                    this.updateOptions(k);
                  },
                  deep: !0
                },
                realList: function() {
                  this.computeIndexes();
                }
              },
              methods: {
                getIsFunctional: function() {
                  var k = this._vnode.fnOptions;
                  return k && k.functional;
                },
                getTag: function() {
                  return this.tag || this.element;
                },
                updateOptions: function(k) {
                  for (var P in k) {
                    var F = Object(b.a)(P);
                    H.indexOf(F) === -1 && this._sortable.option(F, k[P]);
                  }
                },
                getChildrenNodes: function() {
                  if (this.noneFunctionalComponentMode)
                    return this.$children[0].$slots.default;
                  var k = this.$slots.default;
                  return this.transitionMode ? k[0].child.$slots.default : k;
                },
                computeIndexes: function() {
                  var k = this;
                  this.$nextTick(function() {
                    k.visibleIndexes = D(k.getChildrenNodes(), k.rootContainer.children, k.transitionMode, k.footerOffset);
                  });
                },
                getUnderlyingVm: function(k) {
                  var P = x(this.getChildrenNodes() || [], k);
                  if (P === -1)
                    return null;
                  var F = this.realList[P];
                  return {
                    index: P,
                    element: F
                  };
                },
                getUnderlyingPotencialDraggableComponent: function(k) {
                  var P = k.__vue__;
                  return !P || !P.$options || !O(P.$options._componentTag) ? !("realList" in P) && P.$children.length === 1 && "realList" in P.$children[0] ? P.$children[0] : P : P.$parent;
                },
                emitChanges: function(k) {
                  var P = this;
                  this.$nextTick(function() {
                    P.$emit("change", k);
                  });
                },
                alterList: function(k) {
                  if (this.list) {
                    k(this.list);
                    return;
                  }
                  var P = _(this.value);
                  k(P), this.$emit("input", P);
                },
                spliceList: function() {
                  var k = arguments, P = function(te) {
                    return te.splice.apply(te, _(k));
                  };
                  this.alterList(P);
                },
                updatePosition: function(k, P) {
                  var F = function(U) {
                    return U.splice(P, 0, U.splice(k, 1)[0]);
                  };
                  this.alterList(F);
                },
                getRelatedContextFromMoveEvent: function(k) {
                  var P = k.to, F = k.related, te = this.getUnderlyingPotencialDraggableComponent(P);
                  if (!te)
                    return {
                      component: te
                    };
                  var U = te.realList, _e = {
                    list: U,
                    component: te
                  };
                  if (P !== F && U && te.getUnderlyingVm) {
                    var Se = te.getUnderlyingVm(F);
                    if (Se)
                      return Object.assign(Se, _e);
                  }
                  return _e;
                },
                getVmIndex: function(k) {
                  var P = this.visibleIndexes, F = P.length;
                  return k > F - 1 ? F : P[k];
                },
                getComponent: function() {
                  return this.$slots.default[0].componentInstance;
                },
                resetTransitionData: function(k) {
                  if (!(!this.noTransitionOnDrag || !this.transitionMode)) {
                    var P = this.getChildrenNodes();
                    P[k].data = null;
                    var F = this.getComponent();
                    F.children = [], F.kept = void 0;
                  }
                },
                onDragStart: function(k) {
                  this.context = this.getUnderlyingVm(k.item), k.item._underlying_vm_ = this.clone(this.context.element), $ = k.item;
                },
                onDragAdd: function(k) {
                  var P = k.item._underlying_vm_;
                  if (P !== void 0) {
                    Object(b.d)(k.item);
                    var F = this.getVmIndex(k.newIndex);
                    this.spliceList(F, 0, P), this.computeIndexes();
                    var te = {
                      element: P,
                      newIndex: F
                    };
                    this.emitChanges({
                      added: te
                    });
                  }
                },
                onDragRemove: function(k) {
                  if (Object(b.c)(this.rootContainer, k.item, k.oldIndex), k.pullMode === "clone") {
                    Object(b.d)(k.clone);
                    return;
                  }
                  var P = this.context.index;
                  this.spliceList(P, 1);
                  var F = {
                    element: this.context.element,
                    oldIndex: P
                  };
                  this.resetTransitionData(P), this.emitChanges({
                    removed: F
                  });
                },
                onDragUpdate: function(k) {
                  Object(b.d)(k.item), Object(b.c)(k.from, k.item, k.oldIndex);
                  var P = this.context.index, F = this.getVmIndex(k.newIndex);
                  this.updatePosition(P, F);
                  var te = {
                    element: this.context.element,
                    oldIndex: P,
                    newIndex: F
                  };
                  this.emitChanges({
                    moved: te
                  });
                },
                updateProperty: function(k, P) {
                  k.hasOwnProperty(P) && (k[P] += this.headerOffset);
                },
                computeFutureIndex: function(k, P) {
                  if (!k.element)
                    return 0;
                  var F = _(P.to.children).filter(function(Se) {
                    return Se.style.display !== "none";
                  }), te = F.indexOf(P.related), U = k.component.getVmIndex(te), _e = F.indexOf($) !== -1;
                  return _e || !P.willInsertAfter ? U : U + 1;
                },
                onDragMove: function(k, P) {
                  var F = this.move;
                  if (!F || !this.realList)
                    return !0;
                  var te = this.getRelatedContextFromMoveEvent(k), U = this.context, _e = this.computeFutureIndex(te, k);
                  Object.assign(U, {
                    futureIndex: _e
                  });
                  var Se = Object.assign({}, k, {
                    relatedContext: te,
                    draggedContext: U
                  });
                  return F(Se, P);
                },
                onDragEnd: function() {
                  this.computeIndexes(), $ = null;
                }
              }
            };
            typeof window < "u" && "Vue" in window && window.Vue.component("draggable", B);
            var he = B;
            r.default = he;
          }
        )
        /******/
      }).default
    );
  });
})(df);
var UD = df.exports;
const GD = /* @__PURE__ */ hD(UD), lh = 10, ZD = {
  name: "CustomList",
  components: { CtaButton: Fs, SearchBar: Do, draggable: GD },
  props: {
    /**
     * Set the styles for the element.
     */
    styleProps: {
      type: [String, Object]
    },
    /**
     * Set the list of items.
     */
    itemList: {
      type: Array,
      default: []
    },
    /**
     * Result handler for the element list.
     */
    setResult: Function
  },
  data() {
    return {
      /**
       * The list of available items.
       */
      availableList: [],
      /**
       * The list of selected items.
       */
      selectedList: []
    };
  },
  computed: {
    /**
     * The number of remaining items that can be selected.
     */
    selectedListComputed() {
      return lh - Number(this.selectedList.length);
    }
  },
  methods: {
    /**
     * Set initial data for the list.
     */
    setInitialData() {
      this.availableList = this.itemList.map((i) => ({
        ...i,
        display: !0
      })), this.selectedList = this.itemList.filter((i) => i.default).slice(0, 10);
    },
    /**
     * Set the search complete keyword for filtering available items.
     */
    setSearchCompleteKeyword(i) {
      const e = i ? i.replace(/\s/g, "").toLowerCase() : "";
      this.availableList.forEach((t) => {
        const s = t.title.replace(/\s/g, "").toLowerCase();
        t.display = !e || s.includes(e);
      });
    },
    /**
     * Select an item and add it to the selected list.
     */
    selectItem(i) {
      if (this.selectedList.length === lh)
        return;
      this.selectedList.push({ ...i, selected: !0 });
      const e = this.availableList.find(
        (t) => t.id === i.id
      );
      e && (e.selected = !0);
    },
    /**
     * Unselect an item and remove it from the selected list.
     */
    unselectItem(i) {
      this.selectedList = this.selectedList.filter(
        (t) => t.id !== i.id
      );
      const e = this.availableList.find(
        (t) => t.id === i.id
      );
      e && (e.selected = !1);
    },
    /**
     * Check if an item is draggable.
     */
    isDraggable(i) {
      const { index: e, futureIndex: t } = i, s = this.selectedList[e], r = this.selectedList[t];
      return !(s != null && s.fixed || r != null && r.fixed);
    },
    /**
     * Check if an item can be moved during dragging.
     */
    checkMove(i) {
      return this.isDraggable(i.draggedContext);
    }
  },
  /**
   * Set initial data for the list.
   */
  mounted() {
    this.setInitialData();
  },
  watch: {
    /**
     * Watch for changes in the selected list and invoke the result handler.
     */
    selectedList() {
      this.setResult && this.setResult(this.selectedList);
    }
  }
};
var KD = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    class: i.$style.custom_list_container,
    style: i.styleProps
  }, [t("div", {
    class: i.$style.available_side
  }, [t("div", {
    class: i.$style.available_side_header
  }, [t("p", [i._v("Available Columns")])]), t("search-bar", {
    attrs: {
      setSearchCompleteKeyword: i.setSearchCompleteKeyword,
      "placeholder-text": "Search Available Columns"
    }
  }), t("div", {
    class: i.$style.available_side_contents
  }, i._l(i.availableList, function(s) {
    return s.display ? t("div", {
      key: s.id,
      class: i.$style.available_content
    }, [t("div", {
      attrs: {
        selected: s.selected
      }
    }, [i._v(i._s(s.title))]), t("span", {
      class: i.$style.list_plus_icon,
      style: {
        visibility: s.selected ? "hidden" : "visible"
      },
      on: {
        click: function() {
          return i.selectItem(s);
        }
      }
    })]) : i._e();
  }), 0)], 1), t("div", {
    class: i.$style.selected_side
  }, [t("div", {
    class: i.$style.selected_side_header
  }, [t("p", [i._v("Selected Columns")]), t("cta-button", {
    attrs: {
      "click-handler": i.setInitialData,
      "button-type": "text",
      "style-props": "font-size: 14px; padding: 0;"
    }
  }, [i._v("Reset To Default ")])], 1), t("draggable", {
    attrs: {
      move: i.checkMove
    },
    model: {
      value: i.selectedList,
      callback: function(s) {
        i.selectedList = s;
      },
      expression: "selectedList"
    }
  }, [t("transition-group", i._l(i.selectedList, function(s, r) {
    return t("div", {
      key: s.id,
      class: i.$style.selected_content
    }, [t("span", [i._v(i._s(r + 1))]), t("div", {
      attrs: {
        selected: s.selected,
        fixed: s.fixed
      }
    }, [i._v(" " + i._s(s.title) + " ")]), t("span", {
      class: i.$style.list_minus_icon,
      style: {
        visibility: !s.selected || s.fixed ? "hidden" : "visible"
      },
      on: {
        click: function() {
          return i.unselectItem(s);
        }
      }
    })]);
  }), 0)], 1), i._l(i.selectedListComputed, function(s) {
    return t("div", {
      key: s,
      class: i.$style.selected_content,
      staticStyle: {
        cursor: "default"
      }
    }, [t("span", [i._v(i._s(s + i.selectedList.length))]), t("div", {
      class: i.$style.empty_content
    }), t("span", {
      class: i.$style.empty_content_icon_area
    })]);
  })], 2)]);
}, qD = [];
const QD = "_custom_list_container_1a4ed_1", JD = "_available_side_1a4ed_32", eC = "_available_side_header_1a4ed_39", tC = "_available_side_contents_1a4ed_46", iC = "_available_content_1a4ed_57", sC = "_list_plus_icon_1a4ed_78", rC = "_selected_side_1a4ed_120", nC = "_selected_side_header_1a4ed_127", aC = "_selected_content_1a4ed_142", oC = "_empty_content_1a4ed_195", lC = "_list_minus_icon_1a4ed_203", uC = "_empty_content_icon_area_1a4ed_240", cC = "_sortable_ghost_1a4ed_246", hC = {
  custom_list_container: QD,
  available_side: JD,
  available_side_header: eC,
  available_side_contents: tC,
  available_content: iC,
  list_plus_icon: sC,
  selected_side: rC,
  selected_side_header: nC,
  selected_content: aC,
  empty_content: oC,
  list_minus_icon: lC,
  empty_content_icon_area: uC,
  sortable_ghost: cC
}, Vl = {};
Vl.$style = hC;
var dC = /* @__PURE__ */ X(
  ZD,
  KD,
  qD,
  !1,
  fC,
  null,
  null,
  null
);
function fC(i) {
  for (let e in Vl)
    this[e] = Vl[e];
}
const $N = /* @__PURE__ */ function() {
  return dC.exports;
}(), pC = {
  props: {
    /** set styles of component */
    styleProps: {
      type: String,
      default: ""
    },
    /** set background color */
    bgColor: {
      type: String,
      default: "#F5F8FF"
    },
    /** set height of component */
    bodyHeight: {
      type: String,
      default: "156px"
    },
    /** set column  width array */
    columnWidthArray: Array
  },
  data() {
    return {
      hasScroll: !1
    };
  },
  computed: {
    /** compute background color of data table */
    bgColorComputed() {
      return {
        "--data-table-bg-color": this.bgColor
      };
    }
  },
  methods: {
    /** set scroll if component element overflowing */
    isOverflowing() {
      let i = this.$refs.bodyRef;
      this.$refs.bodyRef && i.clientHeight < i.scrollHeight && (this.hasScroll = !0);
    }
  },
  mounted() {
    this.isOverflowing();
  }
};
var gC = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    staticClass: "data-table-container",
    style: i.styleProps
  }, [t("div", {
    staticClass: "data-table-header",
    class: {
      scrollbar: i.hasScroll
    },
    style: i.bgColorComputed
  }, [t("table", [t("colgroup", i._l(i.columnWidthArray, function(s, r) {
    return t("col", {
      key: r,
      style: {
        width: s
      }
    });
  }), 0), t("thead", [i._t("header")], 2)])]), t("div", {
    ref: "bodyRef",
    staticClass: "data-table-body",
    style: [i.bgColorComputed, {
      maxHeight: i.bodyHeight
    }]
  }, [t("table", [t("colgroup", i._l(i.columnWidthArray, function(s, r) {
    return t("col", {
      key: r,
      style: {
        width: s
      }
    });
  }), 0), t("tbody", [i._t("body")], 2)])]), i.$slots.footer ? t("div", [i._t("footer")], 2) : i._e()]);
}, _C = [];
const uh = {};
var mC = /* @__PURE__ */ X(
  pC,
  gC,
  _C,
  !1,
  bC,
  "4053c242",
  null,
  null
);
function bC(i) {
  for (let e in uh)
    this[e] = uh[e];
}
const NN = /* @__PURE__ */ function() {
  return mC.exports;
}(), yC = {
  /** Adding checkbox button component */
  components: {
    CheckboxButton: bd
  },
  props: {
    /** set column width */
    columnWidthArray: Array,
    /** set array of rows */
    rows: Array,
    /** set array for selected rows */
    selectedRows: Array,
    /** set checkbox */
    checkboxes: {
      type: Boolean,
      default: !0
    }
  },
  data() {
    return {
      /** set sorting attributes */
      ascending: !1,
      sortColumn: ""
    };
  },
  created() {
    this.AddCheckboxes(this.checkboxes);
  },
  watch: {
    /** when checkboxes value changes trigger AddCheckBoxes */
    checkboxes(i) {
      this.AddCheckboxes(i);
    }
  },
  methods: {
    /** if value is true, set all checkbox property of row false */
    AddCheckboxes(i) {
      i && (this.rows = this.rows.map((e) => ({ checkbox: !1, ...e })));
    },
    /** convert a camelCase or PascalCase formatted string
     *  into separate readable format
     */
    handleHeading(i) {
      const e = i.replace(/([A-Z])/g, " $1");
      return e.charAt(0).toUpperCase() + e.slice(1);
    },
    /** if value is true, it will set checkbox property
     *  of all rows in the table to true
     * and updates the this.selectedRows
     * if value is false then set checkbox false
     */
    handleAllCheckboxes(i) {
      this.rows.map((e) => e.checkbox = i), i ? this.selectedRows = this.rows : this.selectedRows = [];
    },
    /** set checkbox of row according to checked and unchecked */
    handleEachSelection(i, e) {
      e.checkbox = !e.checkbox;
      var t = this.rows.filter((s) => s.checkbox == !0);
      this.selectedRows = t;
    },
    /** perform sorting of table */
    sortTable: function(e) {
      this.sortColumn === e ? this.ascending = !this.ascending : (this.ascending = !0, this.sortColumn = e);
      var t = this.ascending;
      this.rows.sort(function(s, r) {
        return s[e] > r[e] ? t ? 1 : -1 : s[e] < r[e] ? t ? -1 : 1 : 0;
      });
    }
  },
  computed: {
    columns: function() {
      return this.rows.length == 0 ? [] : Object.keys(this.rows[0]);
    }
  }
};
var vC = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", [t("table", {
    attrs: {
      id: "fifthTable"
    }
  }, [t("colgroup", [i.checkboxes ? t("col", {
    staticStyle: {
      width: "10px"
    }
  }) : i._e(), i._l(i.columnWidthArray, function(s, r) {
    return t("col", {
      key: r,
      style: {
        width: s
      }
    });
  })], 2), t("thead", [t("tr", i._l(i.columns, function(s, r) {
    return t("th", {
      key: r,
      on: {
        click: function(n) {
          return i.sortTable(s);
        }
      }
    }, [s == "checkbox" && i.checkboxes ? t("div", [t("CheckboxButton", {
      attrs: {
        "button-type": "checkbox",
        "click-handler": function(n) {
          return i.handleAllCheckboxes(n);
        }
      }
    })], 1) : s !== "checkbox" ? t("div", {
      staticClass: "heading"
    }, [t("span", [i._v(i._s(i.handleHeading(s)))]), s == i.sortColumn ? t("div", {
      staticClass: "arrow",
      class: i.ascending ? "arrow_up" : "arrow_down"
    }) : i._e()]) : i._e()]);
  }), 0)]), t("tbody", i._l(i.rows, function(s, r) {
    return t("tr", {
      key: r
    }, i._l(i.columns, function(n, a) {
      return t("td", {
        key: a
      }, [n == "checkbox" && i.checkboxes ? t("div", [t("CheckboxButton", {
        attrs: {
          "button-type": "checkbox",
          active: s.checkbox,
          "click-handler": function(o) {
            return i.handleEachSelection(o, s);
          }
        }
      })], 1) : n !== "checkbox" ? t("div", [Array.isArray(s[n]) ? t("div", {
        staticClass: "arrayDiv"
      }, [t("span", [i._v(i._s(s[n][0]))]), t("span", [i._v(i._s(s[n][1]))])]) : t("div", [t("span", {
        staticClass: "singleDiv"
      }, [i._v(i._s(s[n]))])])]) : i._e()]);
    }), 0);
  }), 0)])]);
}, xC = [];
const ch = {};
var wC = /* @__PURE__ */ X(
  yC,
  vC,
  xC,
  !1,
  SC,
  "496b87dc",
  null,
  null
);
function SC(i) {
  for (let e in ch)
    this[e] = ch[e];
}
const FN = /* @__PURE__ */ function() {
  return wC.exports;
}(), DC = {
  props: {
    styleProps: [String, Object],
    /**
     * If **true**, the table body will be scrollable.<br>
     * The parent element must have a fixed height.
     * */
    scrollable: {
      type: Boolean,
      default: !1
    }
  },
  data() {
    return {
      hasScroll: !1
    };
  },
  computed: {
    tableBorderStyles() {
      return this.scrollable && this.hasScroll ? "width: calc(100% - 16px);" : "width: 100%;";
    },
    tableContainerStyles() {
      return this.scrollable && this.hasScroll ? "padding-right: 6px; overflow-y: scroll;" : "";
    }
  },
  methods: {
    checkScrollable() {
      const i = this.$refs.tableWrapperRef, e = this.$refs.tableContainerRef, t = this.$refs.tableInnerRef, s = i == null ? void 0 : i.getClientRects()[0].height, r = e == null ? void 0 : e.getClientRects()[0].height, n = t == null ? void 0 : t.getClientRects()[0].height;
      s < r || s < n ? (this.hasScroll = !0, e.style.height = "100%") : (this.hasScroll = !1, e.style.height = "auto");
    }
  },
  mounted() {
    this.checkScrollable(), this.$watch(
      () => {
        var i;
        return (i = this.$slots.tbody) == null ? void 0 : i.length;
      },
      () => {
        this.checkScrollable();
      },
      { deep: !0 }
    );
  }
};
var CC = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    ref: "tableWrapperRef",
    class: i.$style.table_wrapper
  }, [t("span", {
    class: i.$style.table_border,
    style: i.tableBorderStyles
  }), t("div", {
    ref: "tableContainerRef",
    class: i.$style.table_container,
    style: i.tableContainerStyles
  }, [t("table", {
    ref: "tableInnerRef"
  }, [t("colgroup", [i._t("colgroup")], 2), t("thead", [i._t("thead")], 2), t("tbody", [i._t("tbody")], 2)])]), t("span", {
    class: i.$style.table_border,
    style: i.tableBorderStyles
  })]);
}, TC = [];
const kC = "_table_border_d41l9_8", PC = "_table_wrapper_d41l9_13", OC = "_table_container_d41l9_17", MC = {
  table_border: kC,
  table_wrapper: PC,
  table_container: OC
}, Xl = {};
Xl.$style = MC;
var AC = /* @__PURE__ */ X(
  DC,
  CC,
  TC,
  !1,
  LC,
  "67e320ad",
  null,
  null
);
function LC(i) {
  for (let e in Xl)
    this[e] = Xl[e];
}
const YN = /* @__PURE__ */ function() {
  return AC.exports;
}(), jC = {
  name: "doubleDropdown",
  props: {
    /** visible prop handle popover display and hide */
    visible: {
      default: !1,
      Type: Boolean
    },
    /** items {id,title,code, childrens[]} */
    items: {
      type: Array,
      default: []
    },
    /** Set whether dropdown-list wrap-style or not (ex: {top: '10px', left: '10px', width: '10px'}) */
    styleProps: {
      type: [String, Object]
    },
    placeholder: String,
    id: String,
    /** Apply Handler that will return selected items [{id,title,code, childrens[]},...] */
    applyHandler: Function,
    /** reset handler that will return selected items [{id,title,code, childrens[]},...] */
    resetHandler: Function,
    /** onClose popover handler */
    onClose: Function,
    position: {
      type: Object,
      default: () => ({ top: "", left: "", right: "", bottom: "" })
    }
  },
  components: {
    CtaButton: Fs,
    "common-popover": tc
  },
  data() {
    return {
      colorType: "blue-fill",
      /** The input value. Shows the input list searched through filtered. */
      inputContent: "",
      checkedArray: []
    };
  },
  mounted() {
    setTimeout(() => {
      this.filtered.forEach((i) => {
        i.title && this.selectAll(i, i, i.title);
      });
    }, 1e3);
  },
  computed: {
    /**  Filter your search terms */
    filtered() {
      if (this.items) {
        const i = this.inputContent.trim();
        return !i || i === "" ? this.items : this.items != null ? this.items.filter((t) => t.title != null && t.title.toUpperCase().includes(i.toUpperCase())) : this.items;
      } else
        return this.items;
    }
  },
  methods: {
    /** toggle check button state */
    toggleCheckValue(i, e, t) {
      e.checked = !e.checked, e.title === "All" && e.checked ? this.selectAllCheckBox(i, t, !0) : e.title === "All" && this.selectAllCheckBox(i, t, !1), this.SyncCheckedArray();
      let s = this.checkedArray.find(
        (r) => r.title === i.title
      );
      typeof s < "u" && (s == null ? void 0 : s.childrens.length) === this.filtered[t].childrens.length - 1 && this.selectOrDeselectAllBox(i), this.SyncCheckedArray();
    },
    /** select all items and unselect all handler */
    selectOrDeselectAllBox(i) {
      let e = i.title, t = structuredClone(this.filtered);
      this.filtered.splice(0), this.$nextTick(() => {
        t.map((s) => {
          let r = {
            id: s.id,
            title: s.title,
            childrens: []
          };
          s.childrens && s.childrens.map((n) => {
            r.childrens && r.childrens.push({
              title: n.title,
              code: n.code
            });
          }), this.filtered.push(r);
        }), this.filtered.map((s, r) => {
          this.selectAllBox(s, t[r], e);
        });
      });
    },
    /** select all box */
    selectAllBox(i, e, t) {
      i.childrens.forEach((s, r) => {
        i.title === t && s.title === "All" ? s.checked = !e.childrens[r].checked : s.checked = e.childrens[r].checked;
      }), this.$forceUpdate();
    },
    /**
     * Click on option. If there is a click handler,
     * the click handler is executed, and if there is no click handler, the checklist is saved.
     */
    applyHandlerMethod() {
      this.$nextTick(() => {
        this.applyHandler && (this.SyncCheckedArray(), this.applyHandler(this.checkedArray));
      }), this.$forceUpdate();
    },
    /** eslint-disable  no-unused-vars */
    selectAllCheckBox(i, e, t) {
      let s = i.title, r = structuredClone(this.filtered);
      this.filtered.splice(0), this.$nextTick(() => {
        r.map((n) => {
          let a = {
            id: n.id,
            title: n.title,
            childrens: []
          }, o = [];
          n == null || n.childrens.map((l) => {
            o.push({
              title: l.title,
              code: l.code
            });
          }), a.childrens = o, this.filtered.push(a);
        }), this.filtered.map((n, a) => {
          t ? this.selectAll(n, r[a], s) : this.unselectAll(n, r[a], s);
        });
      }), this.$forceUpdate();
    },
    /** select all */
    selectAll(i, e, t) {
      t === i.title ? i == null || i.childrens.forEach((s) => {
        s.checked = !0;
      }) : i == null || i.childrens.forEach((s, r) => {
        s.checked = e.childrens[r].checked;
      }), this.$forceUpdate();
    },
    /** Deselect all. */
    unselectAll(i, e, t) {
      t === i.title ? i == null || i.childrens.forEach((s) => {
        s.checked = !1;
      }) : i == null || i.childrens.forEach((s, r) => {
        s.checked = e.childrens[r].checked;
      }), this.$forceUpdate();
    },
    /** Reset All checkboxes  */
    resetAllCheckBox() {
      let i = structuredClone(this.filtered);
      this.filtered.splice(0), this.$nextTick(() => {
        i.map((e) => {
          let t = {
            id: e.id,
            title: e.title,
            childrens: []
          }, s = [];
          e == null || e.childrens.map((r) => {
            s.push({
              title: r.title,
              code: r.code
            });
          }), t.childrens = s, this.filtered.push(t);
        }), this.filtered.map((e, t) => {
          this.selectAll(e, i[t], e.title);
        });
      }), this.$forceUpdate();
    },
    /** reset Handler that will reset checkboxes and return all selected items */
    resetDataHandler() {
      this.resetAllCheckBox(), this.$nextTick(() => {
        this.resetHandler && this.resetHandler(this.checkedArray);
      }), this.$forceUpdate();
    },
    /** Save checked array */
    SyncCheckedArray() {
      const i = structuredClone(this.filtered), e = [];
      i.forEach((t) => {
        t.childrens = t.childrens.filter(
          (s) => s.checked === !0
        ), e.push(t);
      }), this.checkedArray = e;
    },
    /** Close handler for popover */
    handleClose() {
      this.$nextTick(() => {
        var i;
        (i = this.onClose) == null || i.call(this);
      });
    }
  }
};
var IC = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("common-popover", {
    attrs: {
      visible: i.visible,
      position: i.position
    },
    on: {
      close: i.handleClose
    }
  }, [t("div", {
    class: i.$style.dropdown_wrap,
    style: i.styleProps
  }, [t("ul", {
    class: [i.$style.parent_item, i.$style.row]
  }, i._l(i.filtered, function(s, r) {
    return t("li", {
      key: r,
      class: [i.$style.col_md, i.$style.custom_padding]
    }, [t("label", {
      class: i.$style.label_height
    }, [t("h5", {
      class: i.$style.font_setting
    }, [i._v(i._s(s.title))])]), t("ul", {
      class: i.$style.child_item
    }, i._l(s.childrens, function(n, a) {
      return t("li", {
        key: `${a}-${r}`
      }, [t("label", {
        attrs: {
          for: `dropdown-input-${r}-${a}-${i.id}`
        },
        on: {
          mouseup: function(o) {
            return i.toggleCheckValue(s, n, r);
          }
        }
      }, [[t("input", {
        directives: [{
          name: "model",
          rawName: "v-model",
          value: n.checked,
          expression: "subItem.checked"
        }],
        attrs: {
          id: `dropdown-input-${r}-${a}-${i.id}`,
          type: "checkbox"
        },
        domProps: {
          value: JSON.stringify(n),
          checked: n.checked,
          checked: Array.isArray(n.checked) ? i._i(n.checked, JSON.stringify(n)) > -1 : n.checked
        },
        on: {
          change: function(o) {
            var l = n.checked, u = o.target, h = !!u.checked;
            if (Array.isArray(l)) {
              var c = JSON.stringify(n), f = i._i(l, c);
              u.checked ? f < 0 && i.$set(n, "checked", l.concat([c])) : f > -1 && i.$set(n, "checked", l.slice(0, f).concat(l.slice(f + 1)));
            } else
              i.$set(n, "checked", h);
          }
        }
      }), t("div", {
        class: i.$style.checkbox_custom
      })], n.image ? t("div", [t("img", {
        attrs: {
          src: n.image,
          alt: ""
        }
      })]) : i._e(), i._v(" " + i._s(n.title) + " ")], 2)]);
    }), 0), t("span", {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: r != i.items.length - 1,
        expression: "index != items.length - 1"
      }],
      class: i.$style.vertical_line
    })]);
  }), 0), t("div", {
    class: [i.$style.buttons_custom, i.$style.w_100, i.$style.align_items_center, i.$style.d_flex, i.$style.justify_content_between]
  }, [t("div", {
    class: [i.$style.all_select_list, i.$style.reset_styles]
  }, [t("div", {
    class: i.$style.reset_btn_styles,
    on: {
      click: function(s) {
        return i.resetDataHandler();
      }
    }
  }, [i._v(" Reset to Default ")])]), t("div", [t("CtaButton", {
    attrs: {
      "click-handler": i.applyHandlerMethod,
      "color-type": "blue-fill"
    }
  }, [t("span", [i._v("Apply")])])], 1)])])]);
}, EC = [];
const RC = "_dropdown_wrap_1wke5_7", $C = "_parent_item_1wke5_25", NC = "_row_1wke5_34", FC = "_col_md_1wke5_38", YC = "_custom_padding_1wke5_47", BC = "_font_setting_1wke5_55", HC = "_child_item_1wke5_68", zC = "_checkbox_custom_1wke5_89", VC = "_vertical_line_1wke5_111", XC = "_buttons_custom_1wke5_118", WC = "_w_100_1wke5_122", UC = "_align_items_center_1wke5_125", GC = "_d_flex_1wke5_128", ZC = "_justify_content_between_1wke5_131", KC = "_reset_styles_1wke5_134", qC = "_all_select_list_1wke5_142", QC = "_btn_custom_1wke5_155", JC = {
  dropdown_wrap: RC,
  parent_item: $C,
  row: NC,
  col_md: FC,
  custom_padding: YC,
  font_setting: BC,
  child_item: HC,
  checkbox_custom: zC,
  vertical_line: VC,
  buttons_custom: XC,
  w_100: WC,
  align_items_center: UC,
  d_flex: GC,
  justify_content_between: ZC,
  reset_styles: KC,
  all_select_list: qC,
  btn_custom: QC
}, Wl = {};
Wl.$style = JC;
var eT = /* @__PURE__ */ X(
  jC,
  IC,
  EC,
  !1,
  tT,
  "16d10d6c",
  null,
  null
);
function tT(i) {
  for (let e in Wl)
    this[e] = Wl[e];
}
const BN = /* @__PURE__ */ function() {
  return eT.exports;
}();
function Wt(i) {
  return Number(i) !== i;
}
function Df(i) {
  return {}.toString.call(i);
}
function iT(i, e = "Assertion failed") {
  if (!i)
    throw new Error(e);
}
function yt(i) {
  if (i != null && !S(i)) {
    let e = Number(i);
    return Wt(e) && Gi(i) && i != "" ? yt(i.replace(/[^0-9.\-]+/g, "")) : e;
  }
  return i;
}
function Cf(i) {
  if (Da(i))
    return new Date(i);
  if (S(i))
    return new Date(i);
  {
    let e = Number(i);
    return S(e) ? new Date(e) : new Date(i);
  }
}
function Tf(i) {
  if (Wt(i))
    return "NaN";
  if (i === 1 / 0)
    return "Infinity";
  if (i === -1 / 0)
    return "-Infinity";
  if (i === 0 && 1 / i === -1 / 0)
    return "-0";
  let e = i < 0;
  i = Math.abs(i);
  let t = /^([0-9]+)(?:\.([0-9]+))?(?:e[\+\-]([0-9]+))?$/.exec("" + i), s = t[1], r = t[2] || "", n;
  if (t[3] === void 0)
    n = r === "" ? s : s + "." + r;
  else {
    let a = +t[3];
    if (i < 1) {
      let o = a - 1;
      n = "0." + Ul("0", o) + s + r;
    } else {
      let o = a - r.length;
      o === 0 ? n = s + r : o < 0 ? n = s + r.slice(0, o) + "." + r.slice(o) : n = s + r + Ul("0", o);
    }
  }
  return e ? "-" + n : n;
}
function Ul(i, e) {
  return new Array(e + 1).join(i);
}
function Da(i) {
  return Df(i) === "[object Date]";
}
function Gi(i) {
  return typeof i == "string";
}
function S(i) {
  return typeof i == "number" && Number(i) == i;
}
function Ys(i) {
  return typeof i == "object" && i !== null;
}
function Ca(i) {
  return Array.isArray(i);
}
const Oi = "__§§§__", Ss = "__§§§§__", sT = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  PLACEHOLDER: Oi,
  PLACEHOLDER2: Ss,
  assert: iT,
  getType: Df,
  isArray: Ca,
  isDate: Da,
  isNaN: Wt,
  isNumber: S,
  isObject: Ys,
  isString: Gi,
  numberToString: Tf,
  repeat: Ul,
  toDate: Cf,
  toNumber: yt
}, Symbol.toStringTag, { value: "Module" }));
function Zi(i, e) {
  const t = i.length;
  for (let s = 0; s < t; ++s)
    if (i[s] === e)
      return s;
  return -1;
}
function kf(i, e) {
  const t = i.length;
  for (let s = 0; s < t; ++s)
    if (e(i[s]))
      return !0;
  return !1;
}
function Ta(i, e) {
  const t = i.length, s = new Array(t);
  for (let r = 0; r < t; ++r)
    s[r] = e(i[r], r);
  return s;
}
function w(i, e) {
  const t = i.length;
  for (let s = 0; s < t; ++s)
    e(i[s], s);
}
function rr(i, e) {
  let t = i.length;
  for (; t > 0; )
    --t, e(i[t], t);
}
function ac(i, e) {
  const t = i.length;
  for (let s = 0; s < t && e(i[s], s); ++s)
    ;
}
function rT(i, e) {
  const t = i.length;
  for (let s = e; s < t; ++s)
    i[s - e] = i[s];
  i.length = t - e;
}
function nT(i) {
  const e = i.length;
  return e ? i[e - 1] : void 0;
}
function aT(i) {
  return i[0];
}
function Pf(i, e, t) {
  t = Math.max(0, Math.min(t, i.length)), i.splice(t, 0, e);
}
function oT(i, e, t) {
  St(i, e), Pf(i, e, t);
}
function lT(i, e) {
  const t = e.length;
  for (let s = 0; s < t; ++s)
    i.push(e[s]);
}
function St(i, e) {
  let t = !1, s = 0;
  for (; ; ) {
    if (s = i.indexOf(e, s), s === -1)
      return t;
    t = !0, i.splice(s, 1);
  }
}
function ht(i, e) {
  let t = i.indexOf(e);
  return t !== -1 ? (i.splice(t, 1), !0) : !1;
}
function ka(i, e, t) {
  let s = Zi(i, e);
  s !== -1 && Pa(i, s), t == null ? i.push(e) : nr(i, t, e);
}
function uT(i, e, t) {
  S(t) ? t === 0 ? i.unshift(e) : i.splice(t, 0, e) : i.push(e);
}
function lr(i, e) {
  i.indexOf(e) === -1 && i.push(e);
}
function cT(i, e, t) {
  let s = i.indexOf(e);
  s !== -1 && i.splice(s, 1), S(t) ? i.splice(t, 0, e) : i.push(e);
}
function hT(i) {
  return Array.isArray(i) ? i : [i];
}
function dT(i, e) {
  return Zi(i, e) !== -1;
}
function Hi(i) {
  const e = i.length, t = new Array(e);
  for (let s = 0; s < e; ++s)
    t[s] = i[s];
  return t;
}
function fT(i, e, t = i.length) {
  const s = new Array(t - e);
  for (let r = e; r < t; ++r)
    s[r - e] = i[r];
  return s;
}
function nr(i, e, t) {
  i.splice(e, 0, t);
}
function Pa(i, e) {
  i.splice(e, 1);
}
function oc(i, e) {
  const t = i.length;
  for (let s = 0; s < t; ++s)
    if (e(i[s], s))
      return s;
  return -1;
}
function Of(i, e) {
  let t = i.length;
  for (; t > 0; )
    if (--t, e(i[t], t))
      return t;
  return -1;
}
function lc(i, e) {
  const t = oc(i, e);
  if (t !== -1)
    return i[t];
}
function Mf(i, e) {
  const t = Of(i, e);
  if (t !== -1)
    return i[t];
}
function pT(i, e) {
  const t = i.length;
  for (let s = 0; s < t; ++s) {
    const r = e(i[s], s);
    if (r !== void 0)
      return r;
  }
}
function gT(i) {
  let e = i.length, t, s;
  for (; e !== 0; )
    s = Math.floor(Math.random() * e), e -= 1, t = i[e], i[e] = i[s], i[s] = t;
}
function Wi(i, e) {
  let t = 0, s = i.length, r = !1;
  for (; t < s; ) {
    const n = t + s >> 1, a = e(i[n]);
    a < 0 ? t = n + 1 : a === 0 ? (r = !0, t = n + 1) : s = n;
  }
  return {
    found: r,
    index: r ? t - 1 : t
  };
}
function Af(i, e) {
  let t = 0, s = i.length, r = !1;
  for (; t < s; ) {
    const n = t + s >> 1, a = e(i[n]);
    a < 0 ? t = n + 1 : (a === 0 && (r = !0), s = n);
  }
  return {
    found: r,
    index: t
  };
}
function Tn(i, e) {
  let t = i.length;
  for (; t > 0; )
    --t, e(i[t]) || i.splice(t, 1);
}
const _T = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  add: uT,
  any: kf,
  copy: Hi,
  each: w,
  eachContinue: ac,
  eachReverse: rr,
  find: lc,
  findIndex: oc,
  findIndexReverse: Of,
  findMap: pT,
  findReverse: Mf,
  first: aT,
  getFirstSortedIndex: Af,
  getSortedIndex: Wi,
  has: dT,
  indexOf: Zi,
  insert: Pf,
  insertIndex: nr,
  keepIf: Tn,
  last: nT,
  map: Ta,
  move: ka,
  pushAll: lT,
  pushOne: lr,
  remove: St,
  removeFirst: ht,
  removeIndex: Pa,
  replace: cT,
  setIndex: oT,
  shiftLeft: rT,
  shuffle: gT,
  slice: fT,
  toArray: hT
}, Symbol.toStringTag, { value: "Module" }));
class Tr {
  /**
   * Constructor.
   */
  constructor() {
    Object.defineProperty(this, "_disposed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._disposed = !1;
  }
  /**
   * Checks if object is disposed.
   *
   * @return Disposed?
   */
  isDisposed() {
    return this._disposed;
  }
  /**
   * Disposes the object.
   */
  dispose() {
    this._disposed || (this._disposed = !0, this._dispose());
  }
}
class Ge {
  /**
   * Constructor.
   *
   * @param dispose  Function that disposes object
   */
  constructor(e) {
    Object.defineProperty(this, "_disposed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_dispose", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._disposed = !1, this._dispose = e;
  }
  /**
   * Checks if object is disposed.
   *
   * @return Disposed?
   */
  isDisposed() {
    return this._disposed;
  }
  /**
   * Disposes the object.
   */
  dispose() {
    this._disposed || (this._disposed = !0, this._dispose());
  }
}
class Lf extends Tr {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_disposers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    });
  }
  _dispose() {
    w(this._disposers, (e) => {
      e.dispose();
    });
  }
}
class ut extends Tr {
  constructor(e) {
    super(), Object.defineProperty(this, "_disposers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._disposers = e;
  }
  _dispose() {
    w(this._disposers, (e) => {
      e.dispose();
    });
  }
  get disposers() {
    return this._disposers;
  }
}
class mT extends Tr {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_disposer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_value", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  _dispose() {
    this._disposer != null && (this._disposer.dispose(), this._disposer = void 0);
  }
  /**
   * Returns current value.
   *
   * @return Value
   */
  get() {
    return this._value;
  }
  /**
   * Sets value and disposes previous disposer if it was set.
   *
   * @param value     New value
   * @param disposer  Disposer
   */
  set(e, t) {
    this._disposer != null && this._disposer.dispose(), this._disposer = t, this._value = e;
  }
  /**
   * Resets the disposer value.
   */
  reset() {
    this.set(void 0, void 0);
  }
}
class To extends Ge {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_counter", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    });
  }
  /**
   * [increment description]
   *
   * @todo Description
   */
  increment() {
    return ++this._counter, new Ge(() => {
      --this._counter, this._counter === 0 && this.dispose();
    });
  }
}
class kr {
  /**
   * Constructor
   */
  constructor() {
    Object.defineProperty(this, "_listeners", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_killed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_disabled", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_iterating", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_enabled", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_disposed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._listeners = [], this._killed = [], this._disabled = {}, this._iterating = 0, this._enabled = !0, this._disposed = !1;
  }
  /**
   * Returns if this object has been already disposed.
   *
   * @return Disposed?
   */
  isDisposed() {
    return this._disposed;
  }
  /**
   * Dispose (destroy) this object.
   */
  dispose() {
    if (!this._disposed) {
      this._disposed = !0;
      const e = this._listeners;
      this._iterating = 1, this._listeners = null, this._disabled = null;
      try {
        w(e, (t) => {
          t.disposer.dispose();
        });
      } finally {
        this._killed = null, this._iterating = null;
      }
    }
  }
  /**
   * Checks if this particular event dispatcher has any listeners set.
   *
   * @return Has listeners?
   */
  hasListeners() {
    return this._listeners.length !== 0;
  }
  /**
   * Checks if this particular event dispatcher has any particular listeners set.
   *
   * @return Has particular event listeners?
   */
  hasListenersByType(e) {
    return kf(this._listeners, (t) => (t.type === null || t.type === e) && !t.killed);
  }
  /**
   * Enable dispatching of events if they were previously disabled by
   * `disable()`.
   */
  enable() {
    this._enabled = !0;
  }
  /**
   * Disable dispatching of events until re-enabled by `enable()`.
   */
  disable() {
    this._enabled = !1;
  }
  /**
   * Enable dispatching particular event, if it was disabled before by
   * `disableType()`.
   *
   * @param type Event type
   */
  enableType(e) {
    delete this._disabled[e];
  }
  /**
   * Disable dispatching of events for a certain event type.
   *
   * Optionally, can set how many dispatches to skip before automatically
   * re-enabling the dispatching.
   *
   * @param type    Event type
   * @param amount  Number of event dispatches to skip
   */
  disableType(e, t = 1 / 0) {
    this._disabled[e] = t;
  }
  /**
   * Removes listener from dispatcher.
   *
   * Will throw an exception if such listener does not exists.
   *
   * @param listener Listener to remove
   */
  _removeListener(e) {
    if (this._iterating === 0) {
      const t = this._listeners.indexOf(e);
      if (t === -1)
        throw new Error("Invalid state: could not remove listener");
      this._listeners.splice(t, 1);
    } else
      this._killed.push(e);
  }
  /**
   * Removes existing listener by certain parameters.
   *
   * @param once         Listener's once setting
   * @param type         Listener's type
   * @param callback     Callback function
   * @param context      Callback context
   */
  _removeExistingListener(e, t, s, r) {
    if (this._disposed)
      throw new Error("EventDispatcher is disposed");
    this._eachListener((n) => {
      n.once === e && // TODO is this correct ?
      n.type === t && (s === void 0 || n.callback === s) && n.context === r && n.disposer.dispose();
    });
  }
  /**
   * Checks if dispatching for particular event type is enabled.
   *
   * @param type  Event type
   * @return Enabled?
   */
  isEnabled(e) {
    if (this._disposed)
      throw new Error("EventDispatcher is disposed");
    return this._enabled && this._listeners.length > 0 && this.hasListenersByType(e) && this._disabled[e] === void 0;
  }
  /**
   * Removes all listeners of a particular event type
   *
   * @param type  Listener's type
   */
  removeType(e) {
    if (this._disposed)
      throw new Error("EventDispatcher is disposed");
    this._eachListener((t) => {
      t.type === e && t.disposer.dispose();
    });
  }
  /**
   * Checks if there's already a listener with specific parameters.
   *
   * @param type      Listener's type
   * @param callback  Callback function
   * @param context   Callback context
   * @return Has listener?
   */
  has(e, t, s) {
    return oc(this._listeners, (n) => n.once !== !0 && // Ignoring "once" listeners
    n.type === e && (t === void 0 || n.callback === t) && n.context === s) !== -1;
  }
  /**
   * Checks whether event of the particular type should be dispatched.
   *
   * @param type  Event type
   * @return Dispatch?
   */
  _shouldDispatch(e) {
    if (this._disposed)
      throw new Error("EventDispatcher is disposed");
    const t = this._disabled[e];
    return S(t) ? (t <= 1 ? delete this._disabled[e] : --this._disabled[e], !1) : this._enabled;
  }
  /**
   * [_eachListener description]
   *
   * All of this extra code is needed when a listener is removed while iterating
   *
   * @todo Description
   * @param fn [description]
   */
  _eachListener(e) {
    ++this._iterating;
    try {
      w(this._listeners, e);
    } finally {
      --this._iterating, this._iterating === 0 && this._killed.length !== 0 && (w(this._killed, (t) => {
        this._removeListener(t);
      }), this._killed.length = 0);
    }
  }
  /**
   * Dispatches an event immediately without waiting for next cycle.
   *
   * @param type   Event type
   * @param event  Event object
   * @todo automatically add in type and target properties if they are missing
   */
  dispatch(e, t) {
    this._shouldDispatch(e) && this._eachListener((s) => {
      !s.killed && (s.type === null || s.type === e) && s.dispatch(e, t);
    });
  }
  /**
   * Shelves the event to be dispatched within next update cycle.
   *
   * @param type   Event type
   * @param event  Event object
   * @todo automatically add in type and target properties if they are missing
   */
  /*public dispatchLater<Key extends keyof T>(type: Key, event: T[Key]): void {
      if (this._shouldDispatch(type)) {
          this._eachListener((listener) => {
              // TODO check if it's faster to use an object of listeners rather than a single big array
              if (!listener.killed && (listener.type === null || listener.type === type)) {
                  // TODO if the function throws, maybe it should keep going ?
                  // TODO dispatch during the update cycle, rather than using whenIdle
                  $async.whenIdle(() => {
                      if (!listener.killed) {
                          listener.dispatch(type, event);
                      }
                  });
              }
          });
      }
  }*/
  /**
   * Creates, catalogs and returns an [[EventListener]].
   *
   * Event listener can be disposed.
   *
   * @param once         Listener's once setting
   * @param type         Listener's type
   * @param callback     Callback function
   * @param context      Callback context
   * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied
   * @param dispatch
   * @returns An event listener
   */
  _on(e, t, s, r, n, a) {
    if (this._disposed)
      throw new Error("EventDispatcher is disposed");
    this._removeExistingListener(e, t, s, r);
    const o = {
      type: t,
      callback: s,
      context: r,
      shouldClone: n,
      dispatch: a,
      killed: !1,
      once: e,
      disposer: new Ge(() => {
        o.killed = !0, this._removeListener(o);
      })
    };
    return this._listeners.push(o), o;
  }
  /**
   * Creates an event listener to be invoked on **any** event.
   *
   * @param callback     Callback function
   * @param context      Callback context
   * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied
   * @returns A disposable event listener
   */
  onAll(e, t, s = !0) {
    return this._on(!1, null, e, t, s, (r, n) => e.call(t, n)).disposer;
  }
  /**
   * Creates an event listener to be invoked on a specific event type.
   *
   * ```TypeScript
   * button.events.once("click", (ev) => {
   *   console.log("Button clicked");
   * }, this);
   * ```
   * ```JavaScript
   * button.events.once("click", (ev) => {
   *   console.log("Button clicked");
   * }, this);
   * ```
   *
   * The above will invoke our custom event handler whenever series we put
   * event on is hidden.
   *
   * @param type         Listener's type
   * @param callback     Callback function
   * @param context      Callback context
   * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied
   * @returns A disposable event listener
   */
  on(e, t, s, r = !0) {
    return this._on(!1, e, t, s, r, (n, a) => t.call(s, a)).disposer;
  }
  /**
   * Creates an event listener to be invoked on a specific event type once.
   *
   * Once the event listener is invoked, it is automatically disposed.
   *
   * ```TypeScript
   * button.events.once("click", (ev) => {
   *   console.log("Button clicked");
   * }, this);
   * ```
   * ```JavaScript
   * button.events.once("click", (ev) => {
   *   console.log("Button clicked");
   * }, this);
   * ```
   *
   * The above will invoke our custom event handler the first time series we
   * put event on is hidden.
   *
   * @param type         Listener's type
   * @param callback     Callback function
   * @param context      Callback context
   * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied
   * @returns A disposable event listener
   */
  once(e, t, s, r = !0) {
    const n = this._on(!0, e, t, s, r, (a, o) => {
      n.disposer.dispose(), t.call(s, o);
    });
    return n.disposer;
  }
  /**
   * Removes the event listener with specific parameters.
   *
   * @param type         Listener's type
   * @param callback     Callback function
   * @param context      Callback context
   */
  off(e, t, s) {
    this._removeExistingListener(!1, e, t, s);
  }
  /**
   * Copies all dispatcher parameters, including listeners, from another event
   * dispatcher.
   *
   * @param source Source event dispatcher
   * @ignore
   */
  copyFrom(e) {
    if (this._disposed)
      throw new Error("EventDispatcher is disposed");
    if (e === this)
      throw new Error("Cannot copyFrom the same TargetedEventDispatcher");
    const t = [];
    return w(e._listeners, (s) => {
      !s.killed && s.shouldClone && (s.type === null ? t.push(this.onAll(s.callback, s.context)) : s.once ? t.push(this.once(s.type, s.callback, s.context)) : t.push(this.on(s.type, s.callback, s.context)));
    }), new ut(t);
  }
}
function Rr(i, e) {
  if (!(i >= 0 && i < e))
    throw new Error("Index out of bounds: " + i);
}
class Pr {
  /**
   * Constructor
   *
   * @param initial  Inital list of values to add to list
   */
  constructor(e = []) {
    Object.defineProperty(this, "_values", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "events", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new kr()
    }), this._values = e;
  }
  /**
   * An array of values in the list.
   *
   * Do not use this property to add values. Rather use dedicated methods, like
   * `push()`, `removeIndex()`, etc.
   *
   * @readonly
   * @return List values
   */
  get values() {
    return this._values;
  }
  /**
   * Checks if list contains specific item reference.
   *
   * @param item  Item to search for
   * @return `true` if found, `false` if not found
   */
  contains(e) {
    return this._values.indexOf(e) !== -1;
  }
  /**
   * Removes specific item from the list.
   *
   * @param item An item to remove
   */
  removeValue(e) {
    let t = 0, s = this._values.length;
    for (; t < s; )
      this._values[t] === e ? (this.removeIndex(t), --s) : ++t;
  }
  /**
   * Searches the list for specific item and returns its index.
   *
   * @param item  An item to search for
   * @return Index or -1 if not found
   */
  indexOf(e) {
    return Zi(this._values, e);
  }
  /**
   * Number of items in list.
   *
   * @readonly
   * @return Number of items
   */
  get length() {
    return this._values.length;
  }
  /**
   * Checks if there's a value at specific index.
   *
   * @param index  Index
   * @return Value exists?
   */
  hasIndex(e) {
    return e >= 0 && e < this._values.length;
  }
  /**
   * Returns an item at specified index.
   *
   * @param index  Index
   * @return List item
   */
  getIndex(e) {
    return this._values[e];
  }
  _onPush(e) {
    this.events.isEnabled("push") && this.events.dispatch("push", {
      type: "push",
      target: this,
      newValue: e
    });
  }
  _onInsertIndex(e, t) {
    this.events.isEnabled("insertIndex") && this.events.dispatch("insertIndex", {
      type: "insertIndex",
      target: this,
      index: e,
      newValue: t
    });
  }
  _onSetIndex(e, t, s) {
    this.events.isEnabled("setIndex") && this.events.dispatch("setIndex", {
      type: "setIndex",
      target: this,
      index: e,
      oldValue: t,
      newValue: s
    });
  }
  _onRemoveIndex(e, t) {
    this.events.isEnabled("removeIndex") && this.events.dispatch("removeIndex", {
      type: "removeIndex",
      target: this,
      index: e,
      oldValue: t
    });
  }
  _onMoveIndex(e, t, s) {
    this.events.isEnabled("moveIndex") && this.events.dispatch("moveIndex", {
      type: "moveIndex",
      target: this,
      oldIndex: e,
      newIndex: t,
      value: s
    });
  }
  _onClear(e) {
    this.events.isEnabled("clear") && this.events.dispatch("clear", {
      type: "clear",
      target: this,
      oldValues: e
    });
  }
  /**
   * Sets value at specific index.
   *
   * If there's already a value at the index, it is overwritten.
   *
   * @param index  Index
   * @param value  New value
   * @return New value
   */
  setIndex(e, t) {
    Rr(e, this._values.length);
    const s = this._values[e];
    return s !== t && (this._values[e] = t, this._onSetIndex(e, s, t)), s;
  }
  /**
   * Adds an item to the list at a specific index, which pushes all the other
   * items further down the list.
   *
   * @param index Index
   * @param item  An item to add
   */
  insertIndex(e, t) {
    return Rr(e, this._values.length + 1), nr(this._values, e, t), this._onInsertIndex(e, t), t;
  }
  /**
   * Swaps indexes of two items in the list.
   *
   * @param a  Item 1
   * @param b  Item 2
   */
  swap(e, t) {
    const s = this._values.length;
    if (Rr(e, s), Rr(t, s), e !== t) {
      const r = this._values[e], n = this._values[t];
      this._values[e] = n, this._onSetIndex(e, r, n), this._values[t] = r, this._onSetIndex(t, n, r);
    }
  }
  /**
   * Removes a value at specific index.
   *
   * @param index  Index of value to remove
   * @return Removed value
   */
  removeIndex(e) {
    Rr(e, this._values.length);
    const t = this._values[e];
    return Pa(this._values, e), this._onRemoveIndex(e, t), t;
  }
  /**
   * Moves an item to a specific index within the list.
   *
   * If the index is not specified it will move the item to the end of the
   * list.
   *
   * @param value  Item to move
   * @param index  Index to place item at
   */
  moveValue(e, t) {
    let s = this.indexOf(e);
    if (s !== -1)
      if (Pa(this._values, s), t == null) {
        const r = this._values.length;
        this._values.push(e), this._onMoveIndex(s, r, e);
      } else
        nr(this._values, t, e), this._onMoveIndex(s, t, e);
    else
      t == null ? (this._values.push(e), this._onPush(e)) : (nr(this._values, t, e), this._onInsertIndex(t, e));
    return e;
  }
  /**
   * Adds an item to the end of the list.
   *
   * @param item  An item to add
   */
  push(e) {
    return this._values.push(e), this._onPush(e), e;
  }
  /**
   * Adds an item as a first item in the list.
   *
   * @param item  An item to add
   */
  unshift(e) {
    return this.insertIndex(0, e), e;
  }
  /**
   * Adds multiple items to the list.
   *
   * @param items  An Array of items to add
   */
  pushAll(e) {
    w(e, (t) => {
      this.push(t);
    });
  }
  /**
   * Copies and adds items from abother list.
   *
   * @param source  A list top copy items from
   */
  copyFrom(e) {
    this.pushAll(e._values);
  }
  /**
   * Returns the last item from the list, and removes it.
   *
   * @return Item
   */
  pop() {
    return this._values.length - 1 < 0 ? void 0 : this.removeIndex(this._values.length - 1);
  }
  /**
   * Returns the first item from the list, and removes it.
   *
   * @return Item
   */
  shift() {
    return this._values.length ? this.removeIndex(0) : void 0;
  }
  /**
   * Sets multiple items to the list.
   *
   * All current items are removed.
   *
   * @param newArray  New items
   */
  setAll(e) {
    const t = this._values;
    this._values = [], this._onClear(t), w(e, (s) => {
      this._values.push(s), this._onPush(s);
    });
  }
  /**
   * Removes all items from the list.
   */
  clear() {
    this.setAll([]);
  }
  /**
   * Returns an ES6 iterator for the list.
   */
  *[Symbol.iterator]() {
    const e = this._values.length;
    for (let t = 0; t < e; ++t)
      yield this._values[t];
  }
  /**
   * Calls `f` for each element in the list.
   *
   * `f` should have at least one parameter defined which will get a current
   * item, with optional second argument - index.
   */
  each(e) {
    w(this._values, e);
  }
  /**
   * Calls `f` for each element in the list, from right to left.
   *
   * `f` should have at least one parameter defined which will get a current
   * item, with optional second argument - index.
   */
  eachReverse(e) {
    rr(this._values, e);
  }
}
class Oa extends Pr {
  constructor() {
    super(...arguments), Object.defineProperty(this, "autoDispose", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "_disposed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    });
  }
  _onSetIndex(e, t, s) {
    this.autoDispose && t.dispose(), super._onSetIndex(e, t, s);
  }
  _onRemoveIndex(e, t) {
    this.autoDispose && t.dispose(), super._onRemoveIndex(e, t);
  }
  _onClear(e) {
    this.autoDispose && w(e, (t) => {
      t.dispose();
    }), super._onClear(e);
  }
  isDisposed() {
    return this._disposed;
  }
  dispose() {
    this._disposed || (this._disposed = !0, this.autoDispose && w(this._values, (e) => {
      e.dispose();
    }));
  }
}
class $e extends Oa {
  constructor(e, t) {
    super(), Object.defineProperty(this, "template", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "make", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.template = e, this.make = t;
  }
}
class bT extends Pr {
  constructor(e) {
    super(), Object.defineProperty(this, "_disposed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_container", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_events", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._container = e, this._events = this.events.onAll((t) => {
      if (t.type === "clear")
        w(t.oldValues, (s) => {
          this._onRemoved(s);
        });
      else if (t.type === "push")
        this._onInserted(t.newValue);
      else if (t.type === "setIndex")
        this._onRemoved(t.oldValue), this._onInserted(t.newValue, t.index);
      else if (t.type === "insertIndex")
        this._onInserted(t.newValue, t.index);
      else if (t.type === "removeIndex")
        this._onRemoved(t.oldValue);
      else if (t.type === "moveIndex")
        this._onRemoved(t.value), this._onInserted(t.value, t.newIndex);
      else
        throw new Error("Unknown IListEvent type");
    });
  }
  _onInserted(e, t) {
    e._setParent(this._container, !0);
    const s = this._container._childrenDisplay;
    t === void 0 ? s.addChild(e._display) : s.addChildAt(e._display, t);
  }
  _onRemoved(e) {
    this._container._childrenDisplay.removeChild(e._display), this._container.markDirtyBounds(), this._container.markDirty();
  }
  /**
   * Returns `true` if obejct is disposed.
   */
  isDisposed() {
    return this._disposed;
  }
  /**
   * Permanently dispose this object.
   */
  dispose() {
    this._disposed || (this._disposed = !0, this._events.dispose(), w(this.values, (e) => {
      e.dispose();
    }));
  }
}
class ae {
  /**
   * Constructor.
   *
   * @param percent  Percent value
   */
  constructor(e) {
    Object.defineProperty(this, "_value", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._value = e;
  }
  /**
   * Relative value.
   *
   * E.g. 100% is 1, 50% is 0.5, etc.
   *
   * This is useful to apply transformations to other values. E.g.:
   *
   * ```TypeScript
   * let value = 256;
   * let percent = new am5.p50;
   * console.log(value * percent.value); // outputs 128
   * ```
   * ```JavaScript
   * var value = 256;
   * var percent = new am5.p50;
   * console.log(value * percent.value); // outputs 128
   * ```
   *
   * Alternatively, you can use `am5.percent()` helper function:
   *
   * ```TypeScript
   * let value = 256;
   * let percent = am5.p50;
   * console.log(value * percent.value); // outputs 128
   * ```
   * ```JavaScript
   * var value = 256;
   * var percent = am5.p50;
   * console.log(value * percent.value); // outputs 128
   * ```
   *
   * @readonly
   * @return Relative value
   */
  get value() {
    return this._value / 100;
  }
  /**
   * Value in percent.
   *
   * @return Percent
   */
  get percent() {
    return this._value;
  }
  toString() {
    return "" + this._value + "%";
  }
  interpolate(e, t) {
    return e + this.value * (t - e);
  }
  static normalize(e, t, s) {
    return e instanceof ae ? e : t === s ? new ae(0) : new ae(Math.min(Math.max((e - t) * (1 / (s - t)), 0), 1) * 100);
  }
}
function de(i) {
  return new ae(i);
}
const yT = de(0), R = de(100), le = de(50);
function Ze(i, e, t, s) {
  function r(n) {
    return n instanceof t ? n : new t(function(a) {
      a(n);
    });
  }
  return new (t || (t = Promise))(function(n, a) {
    function o(h) {
      try {
        u(s.next(h));
      } catch (c) {
        a(c);
      }
    }
    function l(h) {
      try {
        u(s.throw(h));
      } catch (c) {
        a(c);
      }
    }
    function u(h) {
      h.done ? n(h.value) : r(h.value).then(o, l);
    }
    u((s = s.apply(i, e || [])).next());
  });
}
function Ve(i) {
  return Object.keys(i);
}
function uc(i, e) {
  return Ve(i).sort(e);
}
function zi(i) {
  return Object.assign({}, i);
}
function ye(i, e) {
  Ve(i).forEach((t) => {
    e(t, i[t]);
  });
}
function jf(i, e) {
  for (let t in i)
    if (If(i, t) && !e(t, i[t]))
      break;
}
function vT(i, e, t) {
  w(uc(i, t), (s) => {
    e(s, i[s]);
  });
}
function If(i, e) {
  return {}.hasOwnProperty.call(i, e);
}
function xT(i, e) {
  return ye(i, (t, s) => {
    s != null && e[t] == null && (e[t] = s);
  }), e;
}
const wT = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  copy: zi,
  each: ye,
  eachContinue: jf,
  eachOrdered: vT,
  hasKey: If,
  keys: Ve,
  keysOrdered: uc,
  softCopyProperties: xT
}, Symbol.toStringTag, { value: "Module" }));
function Ef(i) {
  if (document.readyState !== "loading")
    i();
  else {
    const e = () => {
      document.readyState !== "loading" && (document.removeEventListener("readystatechange", e), i());
    };
    document.addEventListener("readystatechange", e);
  }
}
function Rf(i) {
  i.parentNode && i.parentNode.removeChild(i);
}
function Me(i, e, t, s) {
  return i.addEventListener(e, t, s || !1), new Ge(() => {
    i.removeEventListener(e, t, s || !1);
  });
}
function cc(i) {
  return Me(window, "resize", (e) => {
    i();
  });
}
function ei(i) {
  switch (i) {
    case "touchevents":
      return window.hasOwnProperty("TouchEvent");
    case "pointerevents":
      return window.hasOwnProperty("PointerEvent");
    case "mouseevents":
      return window.hasOwnProperty("MouseEvent");
    case "wheelevents":
      return window.hasOwnProperty("WheelEvent");
    case "keyboardevents":
      return window.hasOwnProperty("KeyboardEvent");
  }
  return !1;
}
function ra(i) {
  return i.pointerId || 0;
}
function $f() {
  if (document.activeElement && document.activeElement != document.body)
    if (document.activeElement.blur)
      document.activeElement.blur();
    else {
      let i = document.createElement("button");
      i.style.position = "fixed", i.style.top = "0px", i.style.left = "-10000px", document.body.appendChild(i), i.focus(), i.blur(), document.body.removeChild(i);
    }
}
function Nf(i) {
  i && i.focus();
}
function Ma(i) {
  if (ei("pointerevents"))
    return i;
  if (ei("touchevents"))
    switch (i) {
      case "pointerover":
        return "touchstart";
      case "pointerout":
        return "touchend";
      case "pointerleave":
        return "touchend";
      case "pointerdown":
        return "touchstart";
      case "pointermove":
        return "touchmove";
      case "pointerup":
        return "touchend";
      case "click":
        return "click";
      case "dblclick":
        return "dblclick";
    }
  else if (ei("mouseevents"))
    switch (i) {
      case "pointerover":
        return "mouseover";
      case "pointerout":
        return "mouseout";
      case "pointerleave":
        return "mouseleave";
      case "pointerdown":
        return "mousedown";
      case "pointermove":
        return "mousemove";
      case "pointerup":
        return "mouseup";
      case "click":
        return "click";
      case "dblclick":
        return "dblclick";
    }
  return i;
}
function Aa(i) {
  if (typeof Touch < "u" && i instanceof Touch)
    return !0;
  if (typeof PointerEvent < "u" && i instanceof PointerEvent && i.pointerType != null)
    switch (i.pointerType) {
      case "touch":
      case "pen":
      case 2:
        return !0;
      case "mouse":
      case 4:
        return !1;
      default:
        return !(i instanceof MouseEvent);
    }
  else if (i.type != null && i.type.match(/^mouse/))
    return !1;
  return !0;
}
function na(i, e, t) {
  i.style[e] = t;
}
function Ff(i, e) {
  return i.style[e];
}
function hc(i) {
  if (i.composedPath) {
    const e = i.composedPath();
    return e.length === 0 ? null : e[0];
  } else
    return i.target;
}
function Yf(i, e) {
  let t = e;
  for (; ; ) {
    if (i === t)
      return !0;
    if (t.parentNode === null) {
      if (t.host == null)
        return !1;
      t = t.host;
    } else
      t = t.parentNode;
  }
}
function ko(i, e) {
  return i.target && Yf(e.root.dom, i.target);
}
function vs(i, e) {
  e ? i.style.pointerEvents = "auto" : i.style.pointerEvents = "none";
}
function Bf(i) {
  let e = i;
  for (; ; ) {
    if (e.parentNode === null)
      return e.host != null ? e : null;
    e = e.parentNode;
  }
}
let il;
function ST(i, e, t = "") {
  const s = document.createElement("style");
  return s.type = "text/css", t != "" && s.setAttribute("nonce", t), s.textContent = e, i === null ? document.head.appendChild(s) : i.appendChild(s), s;
}
function DT(i, e = "") {
  if (i === null) {
    if (il == null) {
      const t = document.createElement("style");
      t.type = "text/css", e != "" && t.setAttribute("nonce", e), document.head.appendChild(t), il = t.sheet;
    }
    return il;
  } else {
    const t = document.createElement("style");
    return t.type = "text/css", e != "" && t.setAttribute("nonce", e), i.appendChild(t), t.sheet;
  }
}
function CT(i, e) {
  const t = i.cssRules.length;
  return i.insertRule(e + "{}", t), i.cssRules[t];
}
class tt extends Tr {
  /**
   * Constructor.
   *
   * @param selector  CSS selector
   * @param styles    An object of style attribute - value pairs
   */
  constructor(e, t, s, r = "") {
    super(), Object.defineProperty(this, "_root", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_rule", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._root = DT(e, r);
    try {
      this._rule = CT(this._root, t), ye(s, (n, a) => {
        this.setStyle(n, a);
      });
    } catch {
      this._rule = new CSSStyleRule();
    }
  }
  /**
   * A CSS selector text.
   *
   * E.g.: `.myClass p`
   *
   * @param selector  CSS selector
   */
  set selector(e) {
    this._rule.selectorText = e;
  }
  /**
   * @return CSS selector
   */
  get selector() {
    return this._rule.selectorText;
  }
  // TODO test this
  _dispose() {
    const e = Zi(this._root.cssRules, this._rule);
    if (e === -1)
      throw new Error("Could not dispose StyleRule");
    this._root.deleteRule(e);
  }
  /**
   * Sets the same style properties with browser-specific prefixes.
   *
   * @param name   Attribute name
   * @param value  Attribute value
   */
  _setVendorPrefixName(e, t) {
    const s = this._rule.style;
    s.setProperty("-webkit-" + e, t, ""), s.setProperty("-moz-" + e, t, ""), s.setProperty("-ms-" + e, t, ""), s.setProperty("-o-" + e, t, ""), s.setProperty(e, t, "");
  }
  /**
   * Sets a value for specific style attribute.
   *
   * @param name   Attribute
   * @param value  Value
   */
  setStyle(e, t) {
    e === "transition" ? this._setVendorPrefixName(e, t) : this._rule.style.setProperty(e, t, "");
  }
}
class TT extends Tr {
  /**
   * Constructor.
   *
   * @param text  CSS stylesheet
   */
  constructor(e, t, s = "") {
    super(), Object.defineProperty(this, "_element", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._element = ST(e, t, s);
  }
  _dispose() {
    this._element.parentNode && this._element.parentNode.removeChild(this._element);
  }
}
function kT(i, e) {
  if (i)
    if (i.classList) {
      const t = e.split(" ");
      w(t, (s) => {
        i.classList.add(s);
      });
    } else {
      let t = i.getAttribute("class");
      t ? i.setAttribute("class", t.split(" ").filter((s) => s !== e).join(" ") + " " + e) : i.setAttribute("class", e);
    }
}
function PT(i, e) {
  if (i)
    if (i.classList)
      i.classList.remove(e);
    else {
      let t = i.getAttribute("class");
      t && i.setAttribute("class", t.split(" ").filter((s) => s !== e).join(" "));
    }
}
function Hf() {
  return /apple/i.test(navigator.vendor) && "ontouchend" in document;
}
function zf() {
  return Hf() ? 1 : void 0;
}
function Te(i, e) {
  return S(i) ? i : i != null && S(i.value) && S(e) ? e * i.value : 0;
}
function Vf(i) {
  let e = ("" + i).match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);
  return e ? Math.max(0, (e[1] ? e[1].length : 0) - (e[2] ? +e[2] : 0)) : 0;
}
function Fe(i, e = 0, t = "0") {
  return typeof i != "string" && (i = i.toString()), e > i.length ? Array(e - i.length + 1).join(t) + i : i;
}
function Xf(i) {
  return i.replace(/^[\s]*/, "");
}
function Wf(i) {
  return i.replace(/[\s]*$/, "");
}
function Qr(i) {
  return Xf(Wf(i));
}
function Uf(i) {
  if (typeof i > "u")
    return "string";
  i = i.toLowerCase().replace(/^\[[^\]]*\]/, ""), i = i.replace(/\[[^\]]+\]/, ""), i = i.trim();
  let e = i.match(/\/(date|number|duration)$/);
  return e ? e[1] : i === "number" ? "number" : i === "date" ? "date" : i === "duration" ? "duration" : i.match(/[#0]/) ? "number" : i.match(/[ymwdhnsqaxkzgtei]/) ? "date" : "string";
}
function Po(i) {
  return i.replace(/\/(date|number|duration)$/i, "");
}
function La(i) {
  return i && i.replace(/<[^>]*>/g, "");
}
function OT(i) {
  return i && La(("" + i).replace(/[\n\r]+/g, ". "));
}
function Gl(i) {
  return i.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
}
function MT(i) {
  let e = "";
  for (let t = 0; t < i.length; t++) {
    const s = i.charAt(t);
    s.toUpperCase() == s && t != 0 && (e += " "), e += s;
  }
  return e;
}
function Zl(i, e = !1) {
  const t = new Date(i.getFullYear(), 0, 0), s = i.getTime() - t.getTime() + (t.getTimezoneOffset() - i.getTimezoneOffset()) * 60 * 1e3, r = 1e3 * 60 * 60 * 24;
  return Math.floor(s / r);
}
function ur(i, e = !1) {
  const t = new Date(Date.UTC(i.getFullYear(), i.getMonth(), i.getDate())), s = t.getUTCDay() || 7;
  t.setUTCDate(t.getUTCDate() + 4 - s);
  const r = new Date(Date.UTC(t.getUTCFullYear(), 0, 1));
  return Math.ceil(((t.getTime() - r.getTime()) / 864e5 + 1) / 7);
}
function Gf(i, e = !1) {
  const t = new Date(Date.UTC(i.getFullYear(), i.getMonth(), i.getDate())), s = t.getUTCDay() || 7;
  return t.setUTCDate(t.getUTCDate() + 4 - s), new Date(Date.UTC(t.getUTCFullYear(), 0, 1)).getFullYear();
}
function Zf(i, e = !1) {
  const t = ur(new Date(i.getFullYear(), i.getMonth(), 1), e);
  let s = ur(i, e);
  return s == 1 && (s = 53), s - t + 1;
}
function Kf(i, e, t = 1, s = !1) {
  let r = new Date(e, 0, 4, 0, 0, 0, 0);
  return s && r.setUTCFullYear(e), i * 7 + t - ((r.getDay() || 7) + 3);
}
function Br(i, e) {
  return i > 12 ? i -= 12 : i === 0 && (i = 12), e != null ? i + (e - 1) : i;
}
function Hr(i, e = !1, t = !1, s = !1) {
  if (s)
    return e ? "Coordinated Universal Time" : "UTC";
  let r = i.toLocaleString("UTC"), n = i.toLocaleString("UTC", { timeZoneName: e ? "long" : "short" }).substr(r.length);
  return t === !1 && (n = n.replace(/ (standard|daylight|summer|winter) /i, " ")), n;
}
function qf(i) {
  const e = new Date(Date.UTC(2012, 0, 1, 0, 0, 0, 0)), t = new Date(e.toLocaleString("en-US", { timeZone: "UTC" }));
  return (new Date(e.toLocaleString("en-US", { timeZone: i })).getTime() - t.getTime()) / 6e4 * -1;
}
function Kl(i) {
  return i.charAt(0).toUpperCase() + i.slice(1);
}
function dc(i) {
  let e, t, s, r = i.h, n = i.s, a = i.l;
  if (n == 0)
    e = t = s = a;
  else {
    let o = function(c, f, d) {
      return d < 0 && (d += 1), d > 1 && (d -= 1), d < 0.16666666666666666 ? c + (f - c) * 6 * d : d < 0.5 ? f : d < 0.6666666666666666 ? c + (f - c) * (0.6666666666666666 - d) * 6 : c;
    }, l = a < 0.5 ? a * (1 + n) : a + n - a * n, u = 2 * a - l;
    e = o(u, l, r + 1 / 3), t = o(u, l, r), s = o(u, l, r - 1 / 3);
  }
  return {
    r: Math.round(e * 255),
    g: Math.round(t * 255),
    b: Math.round(s * 255)
  };
}
function fc(i) {
  let e = i.r / 255, t = i.g / 255, s = i.b / 255, r = Math.max(e, t, s), n = Math.min(e, t, s), a = 0, o = 0, l = (r + n) / 2;
  if (r === n)
    a = o = 0;
  else {
    let u = r - n;
    switch (o = l > 0.5 ? u / (2 - r - n) : u / (r + n), r) {
      case e:
        a = (t - s) / u + (t < s ? 6 : 0);
        break;
      case t:
        a = (s - e) / u + 2;
        break;
      case s:
        a = (e - t) / u + 4;
        break;
    }
    a /= 6;
  }
  return {
    h: a,
    s: o,
    l
  };
}
function Qf(i, e) {
  return i && {
    r: Math.max(0, Math.min(255, i.r + Jr(i.r, e))),
    g: Math.max(0, Math.min(255, i.g + Jr(i.g, e))),
    b: Math.max(0, Math.min(255, i.b + Jr(i.b, e))),
    a: i.a
  };
}
function Jr(i, e) {
  let t = e > 0 ? 255 - i : i;
  return Math.round(t * e);
}
function Jf(i, e) {
  if (i) {
    let t = Math.min(Math.max(i.r, i.g, i.b), 230), s = Jr(t, e);
    return {
      r: Math.max(0, Math.min(255, Math.round(i.r + s))),
      g: Math.max(0, Math.min(255, Math.round(i.g + s))),
      b: Math.max(0, Math.min(255, Math.round(i.b + s))),
      a: i.a
    };
  } else
    return i;
}
function AT(i, e) {
  return Math.round(255 * e);
}
function ql(i) {
  return (i.r * 299 + i.g * 587 + i.b * 114) / 1e3 >= 128;
}
function ep(i, e) {
  if (i === void 0 || e == 1)
    return i;
  let t = fc(i);
  return t.s = e, dc(t);
}
function tp(i, e = { r: 255, g: 255, b: 255 }, t = { r: 255, g: 255, b: 255 }) {
  let s = e, r = t;
  return ql(t) && (s = t, r = e), ql(i) ? r : s;
}
function se(i, e) {
  return i || (i = []), [...i, ...e].filter((t, s, r) => r.indexOf(t) === s);
}
function pc(i, e) {
  return !(!e || i.left != e.left || i.right != e.right || i.top != e.top || i.bottom != e.bottom);
}
const LT = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  StyleRule: tt,
  StyleSheet: TT,
  addClass: kT,
  addEventListener: Me,
  addSpacing: MT,
  alternativeColor: tp,
  blur: $f,
  brighten: Jf,
  capitalizeFirst: Kl,
  cleanFormat: Po,
  contains: Yf,
  decimalPlaces: Vf,
  escapeForRgex: Gl,
  focus: Nf,
  get12Hours: Br,
  getBrightnessStep: AT,
  getDayFromWeek: Kf,
  getEventTarget: hc,
  getFormat: Uf,
  getLightnessStep: Jr,
  getMonthWeek: Zf,
  getPointerId: ra,
  getRendererEvent: Ma,
  getSafeResolution: zf,
  getShadowRoot: Bf,
  getStyle: Ff,
  getTimeZone: Hr,
  getTimezoneOffset: qf,
  getWeek: ur,
  getWeekYear: Gf,
  getYearDay: Zl,
  hslToRgb: dc,
  iOS: Hf,
  isLight: ql,
  isLocalEvent: ko,
  isTouchEvent: Aa,
  lighten: Qf,
  mergeTags: se,
  onZoom: cc,
  padString: Fe,
  plainText: OT,
  ready: Ef,
  relativeToValue: Te,
  removeClass: PT,
  removeElement: Rf,
  rgbToHsl: fc,
  sameBounds: pc,
  saturate: ep,
  setInteractive: vs,
  setStyle: na,
  stripTags: La,
  supports: ei,
  trim: Qr,
  trimLeft: Xf,
  trimRight: Wf
}, Symbol.toStringTag, { value: "Module" }));
function ip(i) {
  return i[0] === "#" && (i = i.substr(1)), i.length == 3 && (i = i[0].repeat(2) + i[1].repeat(2) + i[2].repeat(2)), parseInt(i, 16);
}
function jT(i) {
  i = i.replace(/[ ]/g, "");
  let e = i.match(/^rgb\(([0-9]*),([0-9]*),([0-9]*)\)/i);
  if (e)
    e.push("1");
  else if (e = i.match(/^rgba\(([0-9]*),([0-9]*),([0-9]*),([.0-9]*)\)/i), !e)
    return 0;
  let t = "";
  for (let s = 1; s <= 3; s++) {
    let r = parseInt(e[s]).toString(16);
    r.length == 1 && (r = "0" + r), t += r;
  }
  return ip(t);
}
function K(i) {
  return V.fromAny(i);
}
class V {
  constructor(e) {
    Object.defineProperty(this, "_hex", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._hex = e | 0;
  }
  /**
   * Color numeric value.
   */
  get hex() {
    return this._hex;
  }
  /**
   * Value of color's R channel.
   * @return R value
   */
  get r() {
    return this._hex >>> 16;
  }
  /**
   * Value of color's G channel.
   * @return G value
   */
  get g() {
    return this._hex >> 8 & 255;
  }
  /**
   * Value of color's B channel.
   * @return B value
   */
  get b() {
    return this._hex & 255;
  }
  /**
   * Returns color CSS representation in form of `rgba(r, g, b, a)` string.
   *
   * @param   alpha  Opacity
   * @return         CSS string
   */
  toCSS(e = 1) {
    return "rgba(" + this.r + ", " + this.g + ", " + this.b + ", " + e + ")";
  }
  /**
   * Returns color CSS representation in form of `#rgb` string.
   *
   * @return         CSS string
   */
  toCSSHex() {
    return "#" + Fe(this.r.toString(16), 2) + Fe(this.g.toString(16), 2) + Fe(this.b.toString(16), 2);
  }
  /**
   * Returns color's HSL info.
   * @param   alpha Opacity
   * @return        HSL info
   */
  toHSL(e = 1) {
    return fc({
      r: this.r,
      g: this.g,
      b: this.b,
      a: e
    });
  }
  /**
   * Converts HSL values into a new [[Color]] object.
   *
   * @param   h H value
   * @param   s S value
   * @param   l L value
   * @return    Color object
   */
  static fromHSL(e, t, s) {
    const r = dc({
      h: e,
      s: t,
      l: s
    });
    return this.fromRGB(r.r, r.g, r.b);
  }
  toString() {
    return this.toCSSHex();
  }
  /**
   * Converts hex number into a new [[Color]] object.
   *
   * ```TypeScript
   * Color.fromHex(0xff0000) // red
   * ```
   * ```JavaScript
   * Color.fromHex(0xff0000) // red
   * ```
   *
   * @param   hex  Hex color
   * @return       Color
   */
  static fromHex(e) {
    return new V(e);
  }
  /**
   * Converts RGB values to a new [[Color]] object.
   *
   * @param   r  R value
   * @param   g  G value
   * @param   b  B value
   * @return     Color
   */
  static fromRGB(e, t, s) {
    return new V((s | 0) + (t << 8) + (e << 16));
  }
  /**
   * Converts RGB string to a new [[Color]] object.
   *
   * ```TypeScript
   * Color.fromString("#ff0000") // red
   * ```
   * ```JavaScript
   * Color.fromString("#ff0000") // red
   * ```
   *
   * @param   s  RGB string
   * @return     Color
   */
  static fromString(e) {
    return new V(ip(e));
  }
  /**
   * Converts CSS rgba() syntax to a new [[Color]] object.
   *
   * ```TypeScript
   * Color.fromCSS("rgba(255, 0, 0, 1)") // red
   * ```
   * ```JavaScript
   * Color.fromCSS("rgba(255, 0, 0, 1)") // red
   * ```
   *
   * @param  {string} s [description]
   * @return {Color}    [description]
   */
  static fromCSS(e) {
    return new V(jT(e));
  }
  /**
   * Convert to color from virtually anything.
   *
   * Will throw an exception if unable to resolve the color.
   *
   * @param   s  Source
   * @return     Color
   */
  static fromAny(e) {
    if (Gi(e)) {
      if (e[0] == "#")
        return V.fromString(e);
      if (e.substr(0, 3) == "rgb")
        return V.fromCSS(e);
    } else {
      if (S(e))
        return V.fromHex(e);
      if (e instanceof V)
        return V.fromHex(e.hex);
    }
    throw new Error("Unknown color syntax: " + e);
  }
  /**
   * Returns a new [[Color]] object based on either `lightAlternative` or
   * `darkAlternative` depending on which one is more contrasting with
   * the `color`.
   *
   * @param   color             Reference color
   * @param   lightAlternative  Light color
   * @param   darkAlternative   Dark color
   * @return                    Alternative color
   */
  static alternative(e, t, s) {
    const r = tp({ r: e.r, g: e.g, b: e.b }, t ? { r: t.r, g: t.g, b: t.b } : void 0, s ? { r: s.r, g: s.g, b: s.b } : void 0);
    return this.fromRGB(r.r, r.g, r.b);
  }
  /**
   * Returns an intermediate Color between two reference colors depending on
   * the progress (`diff`) between the two.
   *
   * @param   diff  Progress
   * @param   from  Source color
   * @param   to    Target color
   * @param   mode  Interpolation mode
   * @return        Color
   */
  static interpolate(e, t, s, r = "rgb") {
    if (r == "hsl") {
      const n = t.toHSL(), a = s.toHSL();
      return V.fromHSL(Ri(e, n.h, a.h), Ri(e, n.s, a.s), Ri(e, n.l, a.l));
    } else
      return V.fromRGB(Ri(e, t.r, s.r), Ri(e, t.g, s.g), Ri(e, t.b, s.b));
  }
  /**
   * Returns a new [[Color]] lightened by `percent` value.
   *
   * Use negative value to darken the color.
   *
   * @param   color    Source color
   * @param   percent  Percent
   * @return           New color
   */
  static lighten(e, t) {
    const s = Qf({ r: e.r, g: e.g, b: e.b }, t);
    return V.fromRGB(s.r, s.g, s.b);
  }
  /**
   * Returns a new [[Color]] brightened by `percent` value.
   *
   * Use negative value to dim the color.
   *
   * @param   color    Source color
   * @param   percent  Percent
   * @return           New color
   */
  static brighten(e, t) {
    const s = Jf({ r: e.r, g: e.g, b: e.b }, t);
    return V.fromRGB(s.r, s.g, s.b);
  }
  /**
   * Returns a new [[Color]] saturated by `percent` value.
   *
   * Value range is between `0` (fully desaturated), to `1` (full color).
   *
   * @param   color    Source color
   * @param   percent  Percent
   * @return           New color
   */
  static saturate(e, t) {
    const s = ep({ r: e.r, g: e.g, b: e.b }, t);
    return V.fromRGB(s.r, s.g, s.b);
  }
}
function hh(i) {
  return Ze(this, void 0, void 0, function* () {
    if (i !== void 0) {
      const e = [];
      ye(i, (t, s) => {
        e.push(s.waitForStop());
      }), yield Promise.all(e);
    }
  });
}
function Ri(i, e, t) {
  return e + i * (t - e);
}
function IT(i, e, t) {
  return i >= 1 ? t : e;
}
function sp(i, e, t) {
  return new ae(Ri(i, e.percent, t.percent));
}
function ET(i, e, t) {
  return V.interpolate(i, e, t);
}
function RT(i, e) {
  return typeof i == "number" && typeof e == "number" ? Ri : i instanceof ae && e instanceof ae ? sp : i instanceof V && e instanceof V ? ET : IT;
}
const Oo = Math.PI, rp = Oo / 2, Os = Oo / 180, ks = 180 / Oo;
function rt(i, e, t) {
  if (!S(e) || e <= 0) {
    let s = Math.round(i);
    return t && s - i == 0.5 && s--, s;
  } else {
    let s = Math.pow(10, e);
    return Math.round(i * s) / s;
  }
}
function np(i, e) {
  if (!S(e) || e <= 0)
    return Math.ceil(i);
  {
    let t = Math.pow(10, e);
    return Math.ceil(i * t) / t;
  }
}
function $T(i, e, t, s, r) {
  return { x: (-i.x + e.x / s + t.x) * s, y: (-i.y + e.y / r + t.y) * r };
}
function NT(i, e, t, s, r) {
  return { x: (i.x + e.x / s - t.x) * s, y: (i.y + e.y / r - t.y) * r };
}
function Re(i, e, t) {
  return Math.min(Math.max(i, e), t);
}
function it(i) {
  return Math.sin(Os * i);
}
function FT(i) {
  return Math.tan(Os * i);
}
function pt(i) {
  return Math.cos(Os * i);
}
function Ms(i) {
  return i = i % 360, i < 0 && (i += 360), i;
}
function ja(i, e, t, s, r) {
  let n = Number.MAX_VALUE, a = Number.MAX_VALUE, o = -Number.MAX_VALUE, l = -Number.MAX_VALUE, u = [];
  u.push(aa(r, t)), u.push(aa(r, s));
  let h = Math.min(Math.floor(t / 90) * 90, Math.floor(s / 90) * 90), c = Math.max(Math.ceil(t / 90) * 90, Math.ceil(s / 90) * 90);
  for (let f = h; f <= c; f += 90)
    f >= t && f <= s && u.push(aa(r, f));
  for (let f = 0; f < u.length; f++) {
    let d = u[f];
    d.x < n && (n = d.x), d.y < a && (a = d.y), d.x > o && (o = d.x), d.y > l && (l = d.y);
  }
  return { left: i + n, top: e + a, right: i + o, bottom: e + l };
}
function aa(i, e) {
  return { x: i * pt(e), y: i * it(e) };
}
function ap(i) {
  const e = i.length;
  if (e > 0) {
    let t = i[0], s = t.left, r = t.top, n = t.right, a = t.bottom;
    if (e > 1)
      for (let o = 1; o < e; o++)
        t = i[o], s = Math.min(t.left, s), n = Math.max(t.right, n), r = Math.min(t.top, r), a = Math.max(t.bottom, a);
    return { left: s, right: n, top: r, bottom: a };
  }
  return { left: 0, right: 0, top: 0, bottom: 0 };
}
function YT(i, e, t) {
  if (e > t) {
    let a = e;
    e = t, t = a;
  }
  i = Ms(i);
  let s = (e - Ms(e)) / 360;
  i < e && (i += 360 * (s + 1));
  let r = e + (t - e) / 2 + 180, n = e + (t - e) / 2 - 180;
  return i > t && (i - 360 > e ? i -= 360 : i < r ? i = t : i = e), i < e && (i > n ? i = e : i = t), i;
}
function BT(i, e) {
  return i.x >= e.left && i.y >= e.top && i.x <= e.right && i.y <= e.bottom;
}
function op(i, e) {
  e || (e = { x: i.x * 2, y: i.y * 2 });
  let t = e.x - i.x, s = e.y - i.y, r = Math.atan2(s, t) * ks;
  return r < 0 && (r += 360), Ms(r);
}
function HT(i, e, t, s) {
  let r = (1 - s) * (1 - s) * i.x + 2 * (1 - s) * s * t.x + s * s * e.x, n = (1 - s) * (1 - s) * i.y + 2 * (1 - s) * s * t.y + s * s * e.y;
  return { x: r, y: n };
}
function zT(i, e, t) {
  return { x: i.x + (e.x - i.x) * t, y: i.y + (e.y - i.y) * t };
}
function lp(i, e) {
  return i.reduce(function(t, s) {
    return Math.abs(s - e) < Math.abs(t - e) ? s : t;
  });
}
function VT(i, e) {
  return !(i.bottom < e.top || e.bottom < i.top || i.right < e.left || e.right < i.left);
}
const XT = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  DEGREES: ks,
  HALFPI: rp,
  PI: Oo,
  RADIANS: Os,
  boundsOverlap: VT,
  ceil: np,
  closest: lp,
  cos: pt,
  fitAngleToRange: YT,
  fitToRange: Re,
  getAngle: op,
  getArcBounds: ja,
  getArcPoint: aa,
  getCubicControlPointA: $T,
  getCubicControlPointB: NT,
  getPointOnLine: zT,
  getPointOnQuadraticCurve: HT,
  inBounds: BT,
  mergeBounds: ap,
  normalizeAngle: Ms,
  round: rt,
  sin: it,
  tan: FT
}, Symbol.toStringTag, { value: "Module" }));
function Ql(i) {
  return i;
}
function WT(i) {
  return i * i;
}
function xs(i) {
  return i * i * i;
}
function UT(i, e) {
  return Math.pow(i, e);
}
function GT(i) {
  return Math.pow(2, 10 * i - 10);
}
function ZT(i) {
  return 1 - Math.cos(i * rp);
}
function KT(i) {
  return 1 - Math.sqrt(1 - i * i);
}
function qT(i) {
  return function(e) {
    return e < 0.5 ? i(e * 2) : i((1 - e) * 2);
  };
}
function Gs(i) {
  return function(e) {
    return 1 - i(1 - e);
  };
}
function QT(i) {
  return function(e) {
    return e <= 0.5 ? i(e * 2) / 2 : 1 - i((1 - e) * 2) / 2;
  };
}
let Jl = 4 / 11, JT = 6 / 11, ek = 8 / 11, tk = 3 / 4, ik = 9 / 11, sk = 10 / 11, rk = 15 / 16, nk = 21 / 22, ak = 63 / 64, Fn = 1 / Jl / Jl;
function ok(i) {
  return 1 - lk(1 - i);
}
function lk(i) {
  return i = i, i < Jl ? Fn * i * i : i < ek ? Fn * (i -= JT) * i + tk : i < sk ? Fn * (i -= ik) * i + rk : Fn * (i -= nk) * i + ak;
}
let uk = 2 * Math.PI, up = 1, cp = 0.3 / uk, ck = Math.asin(1 / up) * cp;
function hk(i) {
  let e = i;
  return up * Math.pow(2, 10 * --e) * Math.sin((ck - e) / cp);
}
const dk = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bounce: ok,
  circle: KT,
  cubic: xs,
  elastic: hk,
  exp: GT,
  inOut: QT,
  linear: Ql,
  out: Gs,
  pow: UT,
  quad: WT,
  sine: ZT,
  yoyo: qT
}, Symbol.toStringTag, { value: "Module" }));
class fk {
  constructor(e, t) {
    Object.defineProperty(this, "_entity", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_settings", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_userSettings", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), this._entity = e, this._settings = t, ye(t, (s) => {
      this._userSettings[s] = !0;
    });
  }
  get(e, t) {
    const s = this._settings[e];
    return s !== void 0 ? s : t;
  }
  /**
   * @ignore
   */
  setRaw(e, t) {
    this._settings[e] = t;
  }
  /**
   * Sets a setting `value` for the specified `key` to be set when the state
   * is applied.
   *
   * @param   key       Setting key
   * @param   value     Setting value
   * @return            Setting value
   */
  set(e, t) {
    this._userSettings[e] = !0, this.setRaw(e, t);
  }
  /**
   * Removes a setting value for the specified `key`.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
   * @param   key       Setting key
   */
  remove(e) {
    delete this._userSettings[e], delete this._settings[e];
  }
  /**
   * Sets multiple settings at once.
   *
   * `settings` must be an object with key: value pairs.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
   * @param settings Settings
   */
  setAll(e) {
    Ve(e).forEach((t) => {
      this.set(t, e[t]);
    });
  }
  _eachSetting(e) {
    ye(this._settings, e);
  }
  /**
   * Applies the state to the target element.
   *
   * All setting values are set immediately.
   */
  apply() {
    const e = {};
    e.stateAnimationEasing = !0, e.stateAnimationDuration = !0;
    const t = this._entity.states.lookup("default");
    this._eachSetting((s, r) => {
      e[s] || (e[s] = !0, this !== t && (s in t._settings || (t._settings[s] = this._entity.get(s))), this._entity.set(s, r));
    });
  }
  /**
   * Applies the state to the target element.
   *
   * Returns an object representing all [[Animation]] objects created for
   * each setting key transition.
   *
   * @return           Animations
   */
  applyAnimate(e) {
    e == null && (e = this._settings.stateAnimationDuration), e == null && (e = this.get("stateAnimationDuration", this._entity.get("stateAnimationDuration", 0)));
    let t = this._settings.stateAnimationEasing;
    t == null && (t = this.get("stateAnimationEasing", this._entity.get("stateAnimationEasing", xs)));
    const s = this._entity.states.lookup("default"), r = {};
    r.stateAnimationEasing = !0, r.stateAnimationDuration = !0;
    const n = {};
    return this._eachSetting((a, o) => {
      if (!r[a]) {
        r[a] = !0, this != s && (a in s._settings || (s._settings[a] = this._entity.get(a)));
        const l = this._entity.animate({
          key: a,
          to: o,
          duration: e,
          easing: t
        });
        l && (n[a] = l);
      }
    }), n;
  }
}
class pk {
  constructor(e) {
    Object.defineProperty(this, "_states", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_entity", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._entity = e;
  }
  /**
   * Checks if a state by `name` exists. Returns it there is one.
   *
   * @param  name  State name
   * @return       State
   */
  lookup(e) {
    return this._states[e];
  }
  /**
   * Sets supplied `settings` on a state by the `name`.
   *
   * If such state does not yet exists, it is created.
   *
   * @param   name      State name
   * @param   settings  Settings
   * @return            New State
   */
  create(e, t) {
    const s = this._states[e];
    if (s)
      return s.setAll(t), s;
    {
      const r = new fk(this._entity, t);
      return this._states[e] = r, r;
    }
  }
  /**
   * Removes the state called `name`.
   *
   * @param   name      State name
   */
  remove(e) {
    delete this._states[e];
  }
  /**
   * Applies a named state to the target element.
   *
   * @param  newState  State name
   */
  apply(e) {
    const t = this._states[e];
    t && t.apply(), this._entity._applyState(e);
  }
  /**
   * Applies a named state to the element.
   *
   * Returns an object representing all [[Animation]] objects created for
   * each setting key transition.
   *
   * @param   newState  State name
   * @return            Animations
   */
  applyAnimate(e, t) {
    let s;
    const r = this._states[e];
    return r && (s = r.applyAnimate(t)), this._entity._applyStateAnimated(e, t), s;
  }
}
class gk {
  constructor() {
    Object.defineProperty(this, "version", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "5.4.0"
    }), Object.defineProperty(this, "licenses", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "entitiesById", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "rootElements", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    });
  }
}
const Rt = new gk();
function Mo(i) {
  Rt.licenses.push(i);
}
function _k() {
  let i;
  for (; i = Rt.rootElements.pop(); )
    i.dispose();
}
function $t(i, e) {
  return i === e ? 0 : i < e ? -1 : 1;
}
function hp(i, e, t) {
  const s = i.length, r = e.length, n = Math.min(s, r);
  for (let a = 0; a < n; ++a) {
    const o = t(i[a], e[a]);
    if (o !== 0)
      return o;
  }
  return $t(s, r);
}
function dh(i, e) {
  return i === e ? 0 : i < e ? -1 : 1;
}
class mk {
  constructor(e) {
    Object.defineProperty(this, "_entity", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_callbacks", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_disabled", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), this._entity = e;
  }
  /**
   * Add a function (`callback`) that will modify value for setting `key`.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/adapters/} for more info
   */
  add(e, t) {
    let s = this._callbacks[e];
    return s === void 0 && (s = this._callbacks[e] = []), s.push(t), this._entity._markDirtyKey(e), new Ge(() => {
      ht(s, t) && this._entity._markDirtyKey(e);
    });
  }
  /**
   * Removes all adapters for the specific key.
   *
   * @since 5.1.0
   */
  remove(e) {
    const t = this._callbacks[e];
    t !== void 0 && (delete this._callbacks[e], t.length !== 0 && this._entity._markDirtyKey(e));
  }
  /**
   * Enables (previously disabled) adapters for specific key.
   *
   * @since 5.1.0
   */
  enable(e) {
    this._disabled[e] && (delete this._disabled[e], this._entity._markDirtyKey(e));
  }
  /**
   * Disables all adapters for specific key.
   *
   * @since 5.1.0
   */
  disable(e) {
    this._disabled[e] || (this._disabled[e] = !0, this._entity._markDirtyKey(e));
  }
  /**
   * @ignore
   */
  fold(e, t) {
    if (!this._disabled[e]) {
      const s = this._callbacks[e];
      if (s !== void 0)
        for (let r = 0, n = s.length; r < n; ++r)
          t = s[r](t, this._entity, e);
    }
    return t;
  }
}
class Yn {
  constructor(e, t, s, r, n, a, o) {
    Object.defineProperty(this, "_animation", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_from", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_to", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_duration", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_easing", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_loops", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_interpolate", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_oldTime", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_time", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_stopped", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_playing", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "events", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new kr()
    }), this._animation = e, this._from = t, this._to = s, this._duration = r, this._easing = n, this._loops = a, this._interpolate = RT(t, s), this._oldTime = o;
  }
  get to() {
    return this._to;
  }
  get from() {
    return this._from;
  }
  get playing() {
    return this._playing;
  }
  get stopped() {
    return this._stopped;
  }
  stop() {
    this._stopped || (this._stopped = !0, this._playing = !1, this.events.isEnabled("stopped") && this.events.dispatch("stopped", {
      type: "stopped",
      target: this
    }));
  }
  pause() {
    this._playing = !1, this._oldTime = null;
  }
  play() {
    !this._stopped && !this._playing && (this._playing = !0, this._animation._startAnimation());
  }
  get percentage() {
    return this._time / this._duration;
  }
  waitForStop() {
    return new Promise((e, t) => {
      if (this._stopped)
        e();
      else {
        const s = () => {
          r.dispose(), e();
        }, r = this.events.on("stopped", s);
      }
    });
  }
  _checkEnded() {
    return this._loops > 1 ? (--this._loops, !1) : !0;
  }
  _run(e) {
    this._oldTime !== null && (this._time += e - this._oldTime, this._time > this._duration && (this._time = this._duration)), this._oldTime = e;
  }
  _reset(e) {
    this._oldTime = e, this._time = 0;
  }
  _value(e) {
    return this._interpolate(this._easing(e), this._from, this._to);
  }
}
let bk = 0;
class dp {
  constructor(e) {
    Object.defineProperty(this, "uid", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ++bk
    }), Object.defineProperty(this, "_settings", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_privateSettings", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_settingEvents", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_privateSettingEvents", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_prevSettings", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_prevPrivateSettings", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_animatingSettings", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_animatingPrivateSettings", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_disposed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_userProperties", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), this._settings = e;
  }
  _checkDirty() {
    Ve(this._settings).forEach((e) => {
      this._userProperties[e] = !0, this._markDirtyKey(e);
    });
  }
  /**
   * @ignore
   */
  resetUserSettings() {
    this._userProperties = {};
  }
  _runAnimation(e) {
    if (this.isDisposed())
      return !1;
    {
      let t = !1;
      return ye(this._animatingSettings, (s, r) => {
        if (r._stopped)
          this._stopAnimation(s);
        else if (r._playing) {
          r._run(e);
          const n = r.percentage;
          n >= 1 ? r._checkEnded() ? this.set(s, r._value(1)) : (t = !0, r._reset(e), this._set(s, r._value(1))) : (t = !0, this._set(s, r._value(n)));
        }
      }), ye(this._animatingPrivateSettings, (s, r) => {
        if (r._stopped)
          this._stopAnimationPrivate(s);
        else if (r._playing) {
          r._run(e);
          const n = r.percentage;
          n >= 1 ? r._checkEnded() ? this.setPrivate(s, r._value(1)) : (t = !0, r._reset(e), this._setPrivate(s, r._value(1))) : (t = !0, this._setPrivate(s, r._value(n)));
        }
      }), t;
    }
  }
  _markDirtyKey(e) {
    this.markDirty();
  }
  _markDirtyPrivateKey(e) {
    this.markDirty();
  }
  /**
   * Sets a callback function to invoke when specific key of settings changes
   * or is set.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/events/#Settings_value_change} for more info
   * @param   key       Settings key
   * @param   callback  Callback
   * @return            Disposer for event
   */
  on(e, t) {
    let s = this._settingEvents[e];
    return s === void 0 && (s = this._settingEvents[e] = []), s.push(t), new Ge(() => {
      ht(s, t), s.length === 0 && delete this._settingEvents[e];
    });
  }
  /**
   * Sets a callback function to invoke when specific key of private settings
   * changes or is set.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/events/#Settings_value_change} for more info
   * @ignore
   * @param   key       Private settings key
   * @param   callback  Callback
   * @return            Disposer for event
   */
  onPrivate(e, t) {
    let s = this._privateSettingEvents[e];
    return s === void 0 && (s = this._privateSettingEvents[e] = []), s.push(t), new Ge(() => {
      ht(s, t), s.length === 0 && delete this._privateSettingEvents[e];
    });
  }
  /**
   * @ignore
   */
  getRaw(e, t) {
    const s = this._settings[e];
    return s !== void 0 ? s : t;
  }
  get(e, t) {
    return this.getRaw(e, t);
  }
  _sendKeyEvent(e, t) {
    const s = this._settingEvents[e];
    s !== void 0 && w(s, (r) => {
      r(t, this, e);
    });
  }
  _sendPrivateKeyEvent(e, t) {
    const s = this._privateSettingEvents[e];
    s !== void 0 && w(s, (r) => {
      r(t, this, e);
    });
  }
  /**
   * @ignore
   */
  _setRaw(e, t, s) {
    this._prevSettings[e] = t, this._sendKeyEvent(e, s);
  }
  /**
   * @ignore
   */
  setRaw(e, t) {
    const s = this._settings[e];
    this._settings[e] = t, s !== t && this._setRaw(e, s, t);
  }
  /**
   * @ignore
   */
  _set(e, t) {
    const s = this._settings[e];
    this._settings[e] = t, s !== t && (this._setRaw(e, s, t), this._markDirtyKey(e));
  }
  _stopAnimation(e) {
    const t = this._animatingSettings[e];
    t && (delete this._animatingSettings[e], t.stop());
  }
  /**
   * Sets a setting `value` for the specified `key`, and returns the same `value`.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
   * @param   key       Setting key
   * @param   value     Setting value
   * @return            Setting value
   */
  set(e, t) {
    return this._set(e, t), this._stopAnimation(e), t;
  }
  /**
   * Removes a setting value for the specified `key`;
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
   * @param   key       Setting key
   */
  remove(e) {
    e in this._settings && (this._prevSettings[e] = this._settings[e], delete this._settings[e], this._sendKeyEvent(e, void 0), this._markDirtyKey(e)), this._stopAnimation(e);
  }
  /**
   * Removes all keys;
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
   */
  removeAll() {
    w(Ve(this._settings), (e) => {
      this.remove(e);
    });
  }
  /**
   * Returns a value of a private setting.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/#Private_settings} for more info
   */
  getPrivate(e, t) {
    const s = this._privateSettings[e];
    return s !== void 0 ? s : t;
  }
  /**
   * @ignore
   */
  _setPrivateRaw(e, t, s) {
    this._prevPrivateSettings[e] = t, this._sendPrivateKeyEvent(e, s);
  }
  /**
   * @ignore
   */
  setPrivateRaw(e, t) {
    const s = this._privateSettings[e];
    this._privateSettings[e] = t, s !== t && this._setPrivateRaw(e, s, t);
  }
  /**
   * @ignore
   */
  _setPrivate(e, t) {
    const s = this._privateSettings[e];
    this._privateSettings[e] = t, s !== t && (this._setPrivateRaw(e, s, t), this._markDirtyPrivateKey(e));
  }
  _stopAnimationPrivate(e) {
    const t = this._animatingPrivateSettings[e];
    t && (t.stop(), delete this._animatingPrivateSettings[e]);
  }
  /**
   * @ignore
   */
  setPrivate(e, t) {
    return this._setPrivate(e, t), this._stopAnimationPrivate(e), t;
  }
  /**
   * @ignore
   */
  removePrivate(e) {
    e in this._privateSettings && (this._prevPrivateSettings[e] = this._privateSettings[e], delete this._privateSettings[e], this._markDirtyPrivateKey(e)), this._stopAnimationPrivate(e);
  }
  /**
   * Sets multiple settings at once.
   *
   * `settings` must be an object with key: value pairs.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
   * @param settings Settings
   */
  setAll(e) {
    ye(e, (t, s) => {
      this.set(t, s);
    });
  }
  /**
   * Animates setting values from current/start values to new ones.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/animations/#Animating_settings} for more info
   * @param   options  Animation options
   * @return           Animation object
   */
  animate(e) {
    const t = e.key, s = e.to, r = e.duration || 0, n = e.loops || 1, a = e.from === void 0 ? this.get(t) : e.from, o = e.easing === void 0 ? Ql : e.easing;
    if (r === 0)
      this.set(t, s);
    else if (a === void 0 || a === s)
      this.set(t, s);
    else {
      this.set(t, a);
      const u = this._animatingSettings[t] = new Yn(this, a, s, r, o, n, this._animationTime());
      return this._startAnimation(), u;
    }
    const l = new Yn(this, a, s, r, o, n, null);
    return l.stop(), l;
  }
  /**
   * @ignore
   */
  animatePrivate(e) {
    const t = e.key, s = e.to, r = e.duration || 0, n = e.loops || 1, a = e.from === void 0 ? this.getPrivate(t) : e.from, o = e.easing === void 0 ? Ql : e.easing;
    if (r === 0)
      this.setPrivate(t, s);
    else if (a === void 0 || a === s)
      this.setPrivate(t, s);
    else {
      this.setPrivate(t, a);
      const u = this._animatingPrivateSettings[t] = new Yn(this, a, s, r, o, n, this._animationTime());
      return this._startAnimation(), u;
    }
    const l = new Yn(this, a, s, r, o, n, null);
    return l.stop(), l;
  }
  _dispose() {
  }
  /**
   * Returns `true` if this element is disposed.
   *
   * @return Disposed
   */
  isDisposed() {
    return this._disposed;
  }
  /**
   * Disposes this object.
   */
  dispose() {
    this._disposed || (this._disposed = !0, this._dispose());
  }
}
class Oe extends dp {
  /**
   * IMPORTANT! Do not instantiate this class via `new Class()` syntax.
   *
   * Use static method `Class.new()` instead.
   *
   * @see {@link https://www.amcharts.com/docs/v5/getting-started/#New_element_syntax} for more info
   * @ignore
   */
  constructor(e, t, s, r = []) {
    if (super(t), Object.defineProperty(this, "_root", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_user_id", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "states", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new pk(this)
    }), Object.defineProperty(this, "adapters", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new mk(this)
    }), Object.defineProperty(this, "events", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._createEvents()
    }), Object.defineProperty(this, "_userPrivateProperties", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_dirty", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_dirtyPrivate", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_template", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_templates", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_internalTemplates", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_defaultThemes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_templateDisposers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_disposers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_runSetup", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "_disposerProperties", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), !s)
      throw new Error("You cannot use `new Class()`, instead use `Class.new()`");
    this._root = e, this._internalTemplates = r, t.id && this._registerId(t.id);
  }
  /**
   * Use this method to create an instance of this class.
   *
   * @see {@link https://www.amcharts.com/docs/v5/getting-started/#New_element_syntax} for more info
   * @param   root      Root element
   * @param   settings  Settings
   * @param   template  Template
   * @return            Instantiated object
   */
  static new(e, t, s) {
    const r = new this(e, t, !0);
    return r._template = s, r._afterNew(), r;
  }
  static _new(e, t, s = []) {
    const r = new this(e, t, !0, s);
    return r._afterNew(), r;
  }
  _afterNew() {
    this._checkDirty();
    let e = !1;
    const t = this._template;
    t && (e = !0, t._setObjectTemplate(this)), w(this._internalTemplates, (s) => {
      e = !0, s._setObjectTemplate(this);
    }), e && this._applyTemplates(!1), this.states.create("default", {}), this._setDefaults();
  }
  // This is the same as _afterNew, except it also applies the themes.
  // This should only be used for classes which don't have a parent (because they extend from Entity and not Sprite).
  _afterNewApplyThemes() {
    this._checkDirty();
    const e = this._template;
    e && e._setObjectTemplate(this), w(this._internalTemplates, (t) => {
      t._setObjectTemplate(this);
    }), this.states.create("default", {}), this._setDefaults(), this._applyThemes();
  }
  _createEvents() {
    return new kr();
  }
  /**
   * @ignore
   */
  get classNames() {
    return this.constructor.classNames;
  }
  /**
   * @ignore
   */
  get className() {
    return this.constructor.className;
  }
  _setDefaults() {
  }
  _setDefault(e, t) {
    e in this._settings || super.set(e, t);
  }
  _setRawDefault(e, t) {
    e in this._settings || super.setRaw(e, t);
  }
  _clearDirty() {
    Ve(this._dirty).forEach((e) => {
      this._dirty[e] = !1;
    }), Ve(this._dirtyPrivate).forEach((e) => {
      this._dirtyPrivate[e] = !1;
    });
  }
  /**
   * @ignore
   */
  isDirty(e) {
    return !!this._dirty[e];
  }
  /**
   * @ignore
   */
  isPrivateDirty(e) {
    return !!this._dirtyPrivate[e];
  }
  _markDirtyKey(e) {
    this._dirty[e] = !0, super._markDirtyKey(e);
  }
  _markDirtyPrivateKey(e) {
    this._dirtyPrivate[e] = !0, super._markDirtyKey(e);
  }
  /**
   * Checks if element is of certain class (or inherits one).
   *
   * @param   type  Class name to check
   * @return {boolean} Is of class?
   */
  isType(e) {
    return this.classNames.indexOf(e) !== -1;
  }
  _pushPropertyDisposer(e, t) {
    let s = this._disposerProperties[e];
    return s === void 0 && (s = this._disposerProperties[e] = []), s.push(t), t;
  }
  _disposeProperty(e) {
    const t = this._disposerProperties[e];
    t !== void 0 && (w(t, (s) => {
      s.dispose();
    }), delete this._disposerProperties[e]);
  }
  /**
   * @todo needs description
   * @param  value  Template
   */
  set template(e) {
    const t = this._template;
    t !== e && (this._template = e, t && t._removeObjectTemplate(this), e && e._setObjectTemplate(this), this._applyTemplates());
  }
  get template() {
    return this._template;
  }
  /**
   * @ignore
   */
  markDirty() {
    this._root._addDirtyEntity(this);
  }
  _startAnimation() {
    this._root._addAnimation(this);
  }
  _animationTime() {
    return this._root.animationTime;
  }
  _applyState(e) {
  }
  _applyStateAnimated(e, t) {
  }
  get(e, t) {
    const s = this.adapters.fold(e, this._settings[e]);
    return s !== void 0 ? s : t;
  }
  /**
   * @ignore
   */
  isUserSetting(e) {
    return this._userProperties[e] || !1;
  }
  /**
   * Sets a setting `value` for the specified `key`, and returns the same `value`.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
   * @param   key       Setting key
   * @param   value     Setting value
   * @return            Setting value
   */
  set(e, t) {
    return this._userProperties[e] = !0, super.set(e, t);
  }
  /**
   * @ignore
   */
  setRaw(e, t) {
    this._userProperties[e] = !0, super.setRaw(e, t);
  }
  /**
   * Sets a setting `value` for the specified `key` only if the value for this key was not set previously using set method, and returns the same `value`.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
   * @param   key       Setting key
   * @param   value     Setting value
   * @return            Setting value
   */
  _setSoft(e, t) {
    return this._userProperties[e] ? t : super.set(e, t);
  }
  /**
   * Removes a setting value for the specified `key`.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
   * @param   key       Setting key
   */
  remove(e) {
    delete this._userProperties[e], this._removeTemplateProperty(e);
  }
  /**
   * @ignore
   */
  setPrivate(e, t) {
    return this._userPrivateProperties[e] = !0, super.setPrivate(e, t);
  }
  /**
   * @ignore
   */
  setPrivateRaw(e, t) {
    this._userPrivateProperties[e] = !0, super.setPrivateRaw(e, t);
  }
  /**
   * @ignore
   */
  removePrivate(e) {
    delete this._userPrivateProperties[e], this._removeTemplatePrivateProperty(e);
  }
  _setTemplateProperty(e, t, s) {
    if (!this._userProperties[t]) {
      const r = this._findTemplateByKey(t);
      e === r && super.set(t, s);
    }
  }
  _setTemplatePrivateProperty(e, t, s) {
    if (!this._userPrivateProperties[t]) {
      const r = this._findTemplateByPrivateKey(t);
      e === r && super.setPrivate(t, s);
    }
  }
  _removeTemplateProperty(e) {
    if (!this._userProperties[e]) {
      const t = this._findTemplateByKey(e);
      t ? super.set(e, t._settings[e]) : super.remove(e);
    }
  }
  _removeTemplatePrivateProperty(e) {
    if (!this._userPrivateProperties[e]) {
      const t = this._findTemplateByPrivateKey(e);
      t ? super.setPrivate(e, t._privateSettings[e]) : super.removePrivate(e);
    }
  }
  _walkParents(e) {
    e(this._root._rootContainer), e(this);
  }
  // TODO faster version of this method which is specialized to just 1 key
  _applyStateByKey(e) {
    const t = this.states.create(e, {}), s = {};
    this._eachTemplate((r) => {
      const n = r.states.lookup(e);
      n && n._apply(t, s);
    }), ye(t._settings, (r) => {
      !s[r] && !t._userSettings[r] && t.remove(r);
    });
  }
  _applyTemplate(e, t) {
    this._templateDisposers.push(e._apply(this, t)), ye(e._settings, (s, r) => {
      !t.settings[s] && !this._userProperties[s] && (t.settings[s] = !0, super.set(s, r));
    }), ye(e._privateSettings, (s, r) => {
      !t.privateSettings[s] && !this._userPrivateProperties[s] && (t.privateSettings[s] = !0, super.setPrivate(s, r));
    }), this._runSetup && e.setup && (this._runSetup = !1, e.setup(this));
  }
  /**
   * Calls the closure with each template and returns the first template which is true
   */
  _findStaticTemplate(e) {
    if (this._template && e(this._template))
      return this._template;
  }
  _eachTemplate(e) {
    this._findStaticTemplate((t) => (e(t), !1)), rr(this._internalTemplates, e), w(this._templates, e);
  }
  _applyTemplates(e = !0) {
    e && this._disposeTemplates();
    const t = {
      settings: {},
      privateSettings: {},
      states: {}
    };
    this._eachTemplate((s) => {
      this._applyTemplate(s, t);
    }), e && (ye(this._settings, (s) => {
      !this._userProperties[s] && !t.settings[s] && super.remove(s);
    }), ye(this._privateSettings, (s) => {
      !this._userPrivateProperties[s] && !t.privateSettings[s] && super.removePrivate(s);
    }));
  }
  _findTemplate(e) {
    const t = this._findStaticTemplate(e);
    if (t === void 0) {
      const s = Mf(this._internalTemplates, e);
      return s === void 0 ? lc(this._templates, e) : s;
    } else
      return t;
  }
  _findTemplateByKey(e) {
    return this._findTemplate((t) => e in t._settings);
  }
  _findTemplateByPrivateKey(e) {
    return this._findTemplate((t) => e in t._privateSettings);
  }
  _disposeTemplates() {
    w(this._templateDisposers, (e) => {
      e.dispose();
    }), this._templateDisposers.length = 0;
  }
  _removeTemplates() {
    w(this._templates, (e) => {
      e._removeObjectTemplate(this);
    }), this._templates.length = 0;
  }
  _applyThemes() {
    let e = !1;
    const t = [];
    let s = [];
    const r = /* @__PURE__ */ new Set(), n = this.get("themeTagsSelf");
    return n && w(n, (a) => {
      r.add(a);
    }), this._walkParents((a) => {
      a === this._root._rootContainer && (e = !0), a._defaultThemes.length > 0 && t.push(a._defaultThemes);
      const o = a.get("themes");
      o && s.push(o);
      const l = a.get("themeTags");
      l && w(l, (u) => {
        r.add(u);
      });
    }), s = t.concat(s), this._removeTemplates(), e && rr(this.classNames, (a) => {
      const o = [];
      w(s, (l) => {
        w(l, (u) => {
          const h = u._lookupRules(a);
          h && rr(h, (c) => {
            if (c.tags.every((d) => r.has(d))) {
              const d = Af(o, (g) => {
                const p = $t(c.tags.length, g.tags.length);
                return p === 0 ? hp(c.tags, g.tags, $t) : p;
              });
              o.splice(d.index, 0, c);
            }
          });
        });
      }), w(o, (l) => {
        this._templates.push(l.template), l.template._setObjectTemplate(this);
      });
    }), this._applyTemplates(), e && (this._runSetup = !1), e;
  }
  _changed() {
  }
  _beforeChanged() {
    if (this.isDirty("id")) {
      const e = this.get("id");
      e && this._registerId(e);
      const t = this._prevSettings.id;
      t && delete Rt.entitiesById[t];
    }
  }
  _registerId(e) {
    if (Rt.entitiesById[e] && Rt.entitiesById[e] !== this)
      throw new Error('An entity with id "' + e + '" already exists.');
    Rt.entitiesById[e] = this;
  }
  _afterChanged() {
  }
  /**
   * @ignore
   */
  addDisposer(e) {
    return this._disposers.push(e), e;
  }
  _dispose() {
    super._dispose();
    const e = this._template;
    e && e._removeObjectTemplate(this), w(this._internalTemplates, (s) => {
      s._removeObjectTemplate(this);
    }), this._removeTemplates(), this._disposeTemplates(), this.events.dispose(), this._disposers.forEach((s) => {
      s.dispose();
    }), ye(this._disposerProperties, (s, r) => {
      w(r, (n) => {
        n.dispose();
      });
    });
    const t = this.get("id");
    t && delete Rt.entitiesById[t];
  }
  /**
   * Creates and returns a "disposable" timeout.
   *
   * @param   fn     Callback
   * @param   delay  Delay in milliseconds
   * @return         Timeout disposer
   */
  setTimeout(e, t) {
    const s = setTimeout(() => {
      this.removeDispose(r), e();
    }, t), r = new Ge(() => {
      clearTimeout(s);
    });
    return this._disposers.push(r), r;
  }
  /**
   * @ignore
   */
  removeDispose(e) {
    if (!this.isDisposed()) {
      let t = Zi(this._disposers, e);
      t > -1 && this._disposers.splice(t, 1);
    }
    e.dispose();
  }
  /**
   * @ignore
   */
  hasTag(e) {
    return Zi(this.get("themeTags", []), e) !== -1;
  }
  /**
   * @ignore
   */
  addTag(e) {
    if (!this.hasTag(e)) {
      const t = this.get("themeTags", []);
      t.push(e), this.set("themeTags", t);
    }
  }
  /**
   * @ignore
   */
  removeTag(e) {
    if (this.hasTag(e)) {
      const t = this.get("themeTags", []);
      St(t, e), this.set("themeTags", t);
    }
  }
  _t(e, t, ...s) {
    return this._root.language.translate(e, t, ...s);
  }
  /**
   * An instance of [[Root]] object.
   *
   * @readonly
   * @since 5.0.6
   * @return Root object
   */
  get root() {
    return this._root;
  }
}
Object.defineProperty(Oe, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Entity"
});
Object.defineProperty(Oe, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: ["Entity"]
});
class yk {
  constructor(e, t, s) {
    Object.defineProperty(this, "_settings", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_template", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._name = e, this._template = t, this._settings = s;
  }
  get(e, t) {
    const s = this._settings[e];
    return s !== void 0 ? s : t;
  }
  set(e, t) {
    this._settings[e] = t, this._template._stateChanged(this._name);
  }
  remove(e) {
    delete this._settings[e], this._template._stateChanged(this._name);
  }
  setAll(e) {
    Ve(e).forEach((t) => {
      this._settings[t] = e[t];
    }), this._template._stateChanged(this._name);
  }
  _apply(e, t) {
    ye(this._settings, (s, r) => {
      !t[s] && !e._userSettings[s] && (t[s] = !0, e.setRaw(s, r));
    });
  }
}
class vk {
  constructor(e) {
    Object.defineProperty(this, "_template", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_states", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), this._template = e;
  }
  lookup(e) {
    return this._states[e];
  }
  create(e, t) {
    const s = this._states[e];
    if (s)
      return s.setAll(t), s;
    {
      const r = new yk(e, this._template, t);
      return this._states[e] = r, this._template._stateChanged(e), r;
    }
  }
  remove(e) {
    delete this._states[e], this._template._stateChanged(e);
  }
  _apply(e, t) {
    ye(this._states, (s, r) => {
      let n = t.states[s];
      n == null && (n = t.states[s] = {});
      const a = e.states.create(s, {});
      r._apply(a, n);
    });
  }
}
class xk {
  constructor() {
    Object.defineProperty(this, "_callbacks", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    });
  }
  add(e, t) {
    let s = this._callbacks[e];
    return s === void 0 && (s = this._callbacks[e] = []), s.push(t), new Ge(() => {
      ht(s, t), s.length === 0 && delete this._callbacks[e];
    });
  }
  remove(e) {
    this._callbacks[e] !== void 0 && delete this._callbacks[e];
  }
  _apply(e) {
    const t = [];
    return ye(this._callbacks, (s, r) => {
      w(r, (n) => {
        t.push(e.adapters.add(s, n));
      });
    }), new ut(t);
  }
}
class be {
  constructor(e, t) {
    if (Object.defineProperty(this, "_settings", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_privateSettings", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_settingEvents", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_privateSettingEvents", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_entities", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "states", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new vk(this)
    }), Object.defineProperty(this, "adapters", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new xk()
    }), Object.defineProperty(this, "events", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new kr()
    }), Object.defineProperty(this, "setup", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), !t)
      throw new Error("You cannot use `new Class()`, instead use `Class.new()`");
    this._settings = e;
  }
  /**
   * Use this method to create an instance of this class.
   *
   * @see {@link https://www.amcharts.com/docs/v5/getting-started/#New_element_syntax} for more info
   * @param   root      Root element
   * @param   settings  Settings
   * @param   template  Template
   * @return            Instantiated object
   */
  static new(e) {
    return new be(e, !0);
  }
  /**
   * Array of all entities using this template.
   */
  get entities() {
    return this._entities;
  }
  get(e, t) {
    const s = this._settings[e];
    return s !== void 0 ? s : t;
  }
  setRaw(e, t) {
    this._settings[e] = t;
  }
  set(e, t) {
    this._settings[e] !== t && (this.setRaw(e, t), this._entities.forEach((s) => {
      s._setTemplateProperty(this, e, t);
    }));
  }
  remove(e) {
    e in this._settings && (delete this._settings[e], this._entities.forEach((t) => {
      t._removeTemplateProperty(e);
    }));
  }
  removeAll() {
    ye(this._settings, (e, t) => {
      this.remove(e);
    });
  }
  getPrivate(e, t) {
    const s = this._privateSettings[e];
    return s !== void 0 ? s : t;
  }
  setPrivateRaw(e, t) {
    return this._privateSettings[e] = t, t;
  }
  setPrivate(e, t) {
    return this._privateSettings[e] !== t && (this.setPrivateRaw(e, t), this._entities.forEach((s) => {
      s._setTemplatePrivateProperty(this, e, t);
    })), t;
  }
  removePrivate(e) {
    e in this._privateSettings && (delete this._privateSettings[e], this._entities.forEach((t) => {
      t._removeTemplatePrivateProperty(e);
    }));
  }
  setAll(e) {
    ye(e, (t, s) => {
      this.set(t, s);
    });
  }
  // TODO code duplication with Properties
  on(e, t) {
    let s = this._settingEvents[e];
    return s === void 0 && (s = this._settingEvents[e] = []), s.push(t), new Ge(() => {
      ht(s, t), s.length === 0 && delete this._settingEvents[e];
    });
  }
  // TODO code duplication with Properties
  onPrivate(e, t) {
    let s = this._privateSettingEvents[e];
    return s === void 0 && (s = this._privateSettingEvents[e] = []), s.push(t), new Ge(() => {
      ht(s, t), s.length === 0 && delete this._privateSettingEvents[e];
    });
  }
  _apply(e, t) {
    const s = [];
    return ye(this._settingEvents, (r, n) => {
      w(n, (a) => {
        s.push(e.on(r, a));
      });
    }), ye(this._privateSettingEvents, (r, n) => {
      w(n, (a) => {
        s.push(e.onPrivate(r, a));
      });
    }), this.states._apply(e, t), s.push(this.adapters._apply(e)), s.push(e.events.copyFrom(this.events)), new ut(s);
  }
  _setObjectTemplate(e) {
    this._entities.push(e);
  }
  _removeObjectTemplate(e) {
    St(this._entities, e);
  }
  _stateChanged(e) {
    this._entities.forEach((t) => {
      t._applyStateByKey(e);
    });
  }
}
class Ao extends kr {
  constructor(e) {
    super(), Object.defineProperty(this, "_sprite", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_rendererDisposers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_dispatchParents", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), this._sprite = e;
  }
  _makePointerEvent(e, t) {
    return {
      type: e,
      originalEvent: t.event,
      point: t.point,
      simulated: t.simulated,
      native: t.native,
      target: this._sprite
    };
  }
  _onRenderer(e, t) {
    this._sprite.set("interactive", !0), this._sprite._display.interactive = !0;
    let s = this._rendererDisposers[e];
    if (s === void 0) {
      const r = this._sprite._display.on(e, (n) => {
        t.call(this, n);
      });
      s = this._rendererDisposers[e] = new To(() => {
        delete this._rendererDisposers[e], r.dispose();
      });
    }
    return s.increment();
  }
  _on(e, t, s, r, n, a) {
    const o = super._on(e, t, s, r, n, a), l = Ao.RENDERER_EVENTS[t];
    return l !== void 0 && (o.disposer = new ut([
      o.disposer,
      this._onRenderer(t, l)
    ])), o;
  }
  /**
   * Will stop any bubbling up of the event to element's parents.
   *
   * Should be called in an event handler, e.g.:
   *
   * ```TypeScript
   * element.events.on("pointerdown", function(ev) {
   *   // Do something here and prevent from "pointerdown" bubbling up
   *   // ...
   *   ev.target.events.stopParentDispatch();
   * });
   * ```
   * ```JavaScript
   * element.events.on("pointerdown", function(ev) {
   *   // Do something here and prevent from "pointerdown" bubbling up
   *   // ...
   *   ev.target.events.stopParentDispatch();
   * });
   * ```
   */
  stopParentDispatch() {
    this._dispatchParents = !1;
  }
  /**
   * @ignore
   */
  dispatchParents(e, t) {
    const s = this._dispatchParents;
    this._dispatchParents = !0;
    try {
      this.dispatch(e, t), this._dispatchParents && this._sprite.parent && this._sprite.parent.events.dispatchParents(e, t);
    } finally {
      this._dispatchParents = s;
    }
  }
}
Object.defineProperty(Ao, "RENDERER_EVENTS", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: {
    click: function(i) {
      this.isEnabled("click") && !this._sprite.isDragging() && this._sprite._hasDown() && !this._sprite._hasMoved(this._makePointerEvent("click", i)) && this.dispatch("click", this._makePointerEvent("click", i));
    },
    rightclick: function(i) {
      this.isEnabled("rightclick") && this.dispatch("rightclick", this._makePointerEvent("rightclick", i));
    },
    middleclick: function(i) {
      this.isEnabled("middleclick") && this.dispatch("middleclick", this._makePointerEvent("middleclick", i));
    },
    dblclick: function(i) {
      this.dispatchParents("dblclick", this._makePointerEvent("dblclick", i));
    },
    pointerover: function(i) {
      this.isEnabled("pointerover") && this.dispatch("pointerover", this._makePointerEvent("pointerover", i));
    },
    pointerout: function(i) {
      this.isEnabled("pointerout") && this.dispatch("pointerout", this._makePointerEvent("pointerout", i));
    },
    pointerdown: function(i) {
      this.dispatchParents("pointerdown", this._makePointerEvent("pointerdown", i));
    },
    pointerup: function(i) {
      this.isEnabled("pointerup") && this.dispatch("pointerup", this._makePointerEvent("pointerup", i));
    },
    globalpointerup: function(i) {
      this.isEnabled("globalpointerup") && this.dispatch("globalpointerup", this._makePointerEvent("globalpointerup", i));
    },
    globalpointermove: function(i) {
      this.isEnabled("globalpointermove") && this.dispatch("globalpointermove", this._makePointerEvent("globalpointermove", i));
    },
    wheel: function(i) {
      this.dispatchParents("wheel", {
        type: "wheel",
        target: this._sprite,
        originalEvent: i.event,
        point: i.point
      });
    }
  }
});
class kt extends Oe {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_adjustedLocalBounds", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: { left: 0, right: 0, top: 0, bottom: 0 }
    }), Object.defineProperty(this, "_localBounds", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: { left: 0, right: 0, top: 0, bottom: 0 }
    }), Object.defineProperty(this, "_parent", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_dataItem", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_templateField", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_sizeDirty", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_isDragging", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_dragEvent", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_dragPoint", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_isHidden", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_isShowing", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_isHiding", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_isDown", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_downPoint", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_downPoints", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_toggleDp", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_dragDp", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_tooltipDp", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_hoverDp", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_focusDp", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_tooltipMoveDp", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_tooltipPointerDp", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_statesHandled", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    });
  }
  _afterNew() {
    this.setPrivateRaw("visible", !0), super._afterNew();
  }
  _markDirtyKey(e) {
    super._markDirtyKey(e), (e == "x" || e == "y" || e == "dx" || e == "dy") && (this.markDirtyBounds(), this._addPercentagePositionChildren(), this.markDirtyPosition());
  }
  _markDirtyPrivateKey(e) {
    super._markDirtyPrivateKey(e), (e == "x" || e == "y") && this.markDirtyPosition();
  }
  _removeTemplateField() {
    this._templateField && this._templateField._removeObjectTemplate(this);
  }
  _createEvents() {
    return new Ao(this);
  }
  _processTemplateField() {
    let e;
    const t = this.get("templateField");
    if (t) {
      const s = this.dataItem;
      if (s) {
        const r = s.dataContext;
        r && (e = r[t], !(e instanceof be) && e && (e = be.new(e)));
      }
    }
    this._templateField !== e && (this._removeTemplateField(), this._templateField = e, e && e._setObjectTemplate(this), this._applyTemplates());
  }
  // TODO change this to run before the element is added to the parent, so that way
  //      it doesn't need to apply the themes twice
  _setDataItem(e) {
    const t = this._dataItem;
    this._dataItem = e, this._processTemplateField();
    const s = "dataitemchanged";
    e != t && this.events.isEnabled(s) && this.events.dispatch(s, {
      type: s,
      target: this,
      oldDataItem: t,
      newDataItem: e
    });
  }
  /**
   * A [[DataItem]] used for this element.
   *
   * NOTE: data item is being assigned automatically in most cases where it
   * matters. Use this accessor to set data item only if you know what you're
   * doing.
   *
   * @param  value  Data item
   */
  set dataItem(e) {
    this._setDataItem(e);
  }
  /**
   * @return DataItem
   */
  get dataItem() {
    if (this._dataItem)
      return this._dataItem;
    {
      let e = this._parent;
      for (; e; ) {
        if (e._dataItem)
          return e._dataItem;
        e = e._parent;
      }
    }
  }
  _addPercentageSizeChildren() {
    let e = this.parent;
    e && (this.get("width") instanceof ae || this.get("height") instanceof ae ? lr(e._percentageSizeChildren, this) : ht(e._percentageSizeChildren, this));
  }
  _addPercentagePositionChildren() {
    let e = this.parent;
    e && (this.get("x") instanceof ae || this.get("y") instanceof ae ? lr(e._percentagePositionChildren, this) : ht(e._percentagePositionChildren, this));
  }
  /**
   * @ignore
   */
  markDirtyPosition() {
    this._root._addDirtyPosition(this);
  }
  updatePivotPoint() {
    const e = this._localBounds;
    if (e) {
      const t = this.get("centerX");
      t != null && (this._display.pivot.x = e.left + Te(t, e.right - e.left));
      const s = this.get("centerY");
      s != null && (this._display.pivot.y = e.top + Te(s, e.bottom - e.top));
    }
  }
  _beforeChanged() {
    if (super._beforeChanged(), this._handleStates(), this.isDirty("tooltip")) {
      const e = this._prevSettings.tooltip;
      e && e.dispose();
    }
    if ((this.isDirty("layer") || this.isDirty("layerMargin")) && (this._display.setLayer(this.get("layer"), this.get("layerMargin")), this.markDirtyLayer()), this.isDirty("tooltipPosition")) {
      const e = this._tooltipMoveDp;
      e && (e.dispose(), this._tooltipMoveDp = void 0);
      const t = this._tooltipPointerDp;
      t && (t.dispose(), this._tooltipPointerDp = void 0), this.get("tooltipPosition") == "pointer" && (this.isHover() && (this._tooltipMoveDp = this.events.on("globalpointermove", (s) => {
        this.showTooltip(s.point);
      })), this._tooltipPointerDp = new ut([
        this.events.on("pointerover", () => {
          this._tooltipMoveDp = this.events.on("globalpointermove", (s) => {
            this.showTooltip(s.point);
          });
        }),
        this.events.on("pointerout", () => {
          const s = this._tooltipMoveDp;
          s && (s.dispose(), this._tooltipMoveDp = void 0);
        })
      ]));
    }
  }
  _handleStates() {
    this._statesHandled || (this.isDirty("active") && (this.get("active") ? (this.states.applyAnimate("active"), this.set("ariaChecked", !0)) : (this.isHidden() || this.states.applyAnimate("default"), this.set("ariaChecked", !1)), this.markDirtyAccessibility()), this.isDirty("disabled") && (this.get("disabled") ? (this.states.applyAnimate("disabled"), this.set("ariaChecked", !1)) : (this.isHidden() || this.states.applyAnimate("default"), this.set("ariaChecked", !0)), this.markDirtyAccessibility()), this._statesHandled = !0);
  }
  _changed() {
    super._changed();
    const e = this._display, t = this.events;
    if (this.isDirty("draggable")) {
      const s = this.get("draggable");
      s ? (this.set("interactive", !0), this._dragDp = new ut([
        t.on("pointerdown", (r) => {
          this.dragStart(r);
        }),
        t.on("globalpointermove", (r) => {
          this.dragMove(r);
        }),
        t.on("globalpointerup", (r) => {
          this.dragStop(r);
        })
      ])) : this._dragDp && (this._dragDp.dispose(), this._dragDp = void 0), e.cancelTouch = !!s;
    }
    if (this.isDirty("tooltipText") || this.isDirty("tooltipHTML") || this.isDirty("showTooltipOn")) {
      const s = this.get("tooltipText"), r = this.get("tooltipHTML"), n = this.get("showTooltipOn", "hover");
      this._tooltipDp && (this._tooltipDp.dispose(), this._tooltipDp = void 0), (s || r) && (n == "click" ? (this._tooltipDp = new ut([
        t.on("click", () => {
          this.setTimeout(() => this.showTooltip(), 10);
        }),
        Me(document, "click", (a) => {
          this.hideTooltip();
        })
      ]), this._disposers.push(this._tooltipDp)) : n == "always" || (this._tooltipDp = new ut([
        t.on("pointerover", () => {
          this.showTooltip();
        }),
        t.on("pointerout", () => {
          this.hideTooltip();
        })
      ]), this._disposers.push(this._tooltipDp)));
    }
    if (this.isDirty("toggleKey")) {
      let s = this.get("toggleKey");
      s && s != "none" ? this._toggleDp = t.on("click", () => {
        this._isDragging || this.set(s, !this.get(s));
      }) : this._toggleDp && (this._toggleDp.dispose(), this._toggleDp = void 0);
    }
    if (this.isDirty("opacity") && (e.alpha = Math.max(0, this.get("opacity", 1))), this.isDirty("rotation") && (this.markDirtyBounds(), e.angle = this.get("rotation", 0)), this.isDirty("scale") && (this.markDirtyBounds(), e.scale = this.get("scale", 0)), (this.isDirty("centerX") || this.isDirty("centerY")) && (this.markDirtyBounds(), this.updatePivotPoint()), (this.isDirty("visible") || this.isPrivateDirty("visible") || this.isDirty("forceHidden")) && (!this.get("visible") || !this.getPrivate("visible") || this.get("forceHidden") ? (e.visible = !1, this.hideTooltip()) : e.visible = !0, this.markDirtyBounds(), this.get("focusable") && this.markDirtyAccessibility()), this.isDirty("width") || this.isDirty("height")) {
      this.markDirtyBounds(), this._addPercentageSizeChildren();
      const s = this.parent;
      s && (this.isDirty("width") && this.get("width") instanceof ae || this.isDirty("height") && this.get("height") instanceof ae) && (s.markDirty(), s._prevWidth = 0), this._sizeDirty = !0;
    }
    if ((this.isDirty("maxWidth") || this.isDirty("maxHeight") || this.isPrivateDirty("width") || this.isPrivateDirty("height") || this.isDirty("minWidth") || this.isDirty("minHeight") || this.isPrivateDirty("maxWidth") || this.isPrivateDirty("maxHeight") || this.isPrivateDirty("minWidth") || this.isPrivateDirty("minHeight")) && (this.markDirtyBounds(), this._sizeDirty = !0), this._sizeDirty && this._updateSize(), this.isDirty("wheelable")) {
      const s = this.get("wheelable");
      s && this.set("interactive", !0), e.wheelable = !!s;
    }
    if ((this.isDirty("tabindexOrder") || this.isDirty("focusableGroup")) && (this.get("focusable") ? this._root._registerTabindexOrder(this) : this._root._unregisterTabindexOrder(this)), this.isDirty("filter") && (e.filter = this.get("filter")), this.isDirty("cursorOverStyle") && (e.cursorOverStyle = this.get("cursorOverStyle")), this.isDirty("hoverOnFocus") && (this.get("hoverOnFocus") ? this._focusDp = new ut([
      t.on("focus", () => {
        this.showTooltip();
      }),
      t.on("blur", () => {
        this.hideTooltip();
      })
    ]) : this._focusDp && (this._focusDp.dispose(), this._focusDp = void 0)), this.isDirty("focusable") && (this.get("focusable") ? this._root._registerTabindexOrder(this) : this._root._unregisterTabindexOrder(this), this.markDirtyAccessibility()), this.isPrivateDirty("focusable") && this.markDirtyAccessibility(), (this.isDirty("role") || this.isDirty("ariaLive") || this.isDirty("ariaChecked") || this.isDirty("ariaHidden") || this.isDirty("ariaOrientation") || this.isDirty("ariaValueNow") || this.isDirty("ariaValueMin") || this.isDirty("ariaValueMax") || this.isDirty("ariaValueText") || this.isDirty("ariaLabel") || this.isDirty("ariaControls")) && this.markDirtyAccessibility(), this.isDirty("exportable") && (e.exportable = this.get("exportable")), this.isDirty("interactive")) {
      const s = this.events;
      this.get("interactive") ? this._hoverDp = new ut([
        s.on("click", (r) => {
          Aa(r.originalEvent) && (this.getPrivate("touchHovering") || this.setTimeout(() => {
            this._handleOver(), (this.get("tooltipText") || this.get("tooltipHTML")) && this.showTooltip(), this.setPrivateRaw("touchHovering", !0), this.events.dispatch("pointerover", {
              type: "pointerover",
              target: r.target,
              originalEvent: r.originalEvent,
              point: r.point,
              simulated: r.simulated
            });
          }, 10));
        }),
        s.on("globalpointerup", (r) => {
          Aa(r.originalEvent) && this.getPrivate("touchHovering") && (this._handleOut(), (this.get("tooltipText") || this.get("tooltipHTML")) && this.hideTooltip(), this.setPrivateRaw("touchHovering", !1), this.events.dispatch("pointerout", {
            type: "pointerout",
            target: r.target,
            originalEvent: r.originalEvent,
            point: r.point,
            simulated: r.simulated
          })), this._isDown && this._handleUp(r);
        }),
        s.on("pointerover", () => {
          this._handleOver();
        }),
        s.on("pointerout", () => {
          this._handleOut();
        }),
        s.on("pointerdown", (r) => {
          this._handleDown(r);
        })
      ]) : (this._display.interactive = !1, this._hoverDp && (this._hoverDp.dispose(), this._hoverDp = void 0));
    }
    this.isDirty("forceInactive") && (this._display.inactive = this.get("forceInactive", !1)), this.get("showTooltipOn") == "always" && this._display.visible && this.showTooltip();
  }
  /**
   * @ignore
   * @todo should this be user-accessible?
   */
  dragStart(e) {
    this._dragEvent = e, this.events.stopParentDispatch();
  }
  /**
   * @ignore
   * @todo should this be user-accessible?
   */
  dragStop(e) {
    if (this._dragEvent = void 0, this._dragPoint = void 0, this.events.stopParentDispatch(), this._isDragging) {
      this._isDragging = !1;
      const t = "dragstop";
      this.events.isEnabled(t) && this.events.dispatch(t, {
        type: t,
        target: this,
        originalEvent: e.originalEvent,
        point: e.point,
        simulated: e.simulated
      });
    }
  }
  _handleOver() {
    this.isHidden() || (this.get("active") && this.states.lookup("hoverActive") ? this.states.applyAnimate("hoverActive") : this.get("disabled") && this.states.lookup("hoverDisabled") ? this.states.applyAnimate("hoverDisabled") : this.states.applyAnimate("hover"), this.get("draggable") && this._isDown && this.states.lookup("down") && this.states.applyAnimate("down"));
  }
  _handleOut() {
    this.isHidden() || (this.get("active") && this.states.lookup("active") ? this.states.applyAnimate("active") : this.get("disabled") && this.states.lookup("disabled") ? this.states.applyAnimate("disabled") : (this.states.lookup("hover") || this.states.lookup("hoverActive")) && this.states.applyAnimate("default"), this.get("draggable") && this._isDown && this.states.lookup("down") && this.states.applyAnimate("down"));
  }
  _handleUp(e) {
    if (!this.isHidden()) {
      this.get("active") && this.states.lookup("active") ? this.states.applyAnimate("active") : this.get("disabled") && this.states.lookup("disabled") ? this.states.applyAnimate("disabled") : this.states.lookup("down") && (this.isHover() ? this.states.applyAnimate("hover") : this.states.applyAnimate("default")), this._downPoint = void 0;
      const t = ra(e.originalEvent);
      delete this._downPoints[t], Ve(this._downPoints).length == 0 && (this._isDown = !1);
    }
  }
  _hasMoved(e) {
    const t = ra(e.originalEvent), s = this._downPoints[t];
    if (s) {
      const r = Math.abs(s.x - e.point.x), n = Math.abs(s.y - e.point.y);
      return r > 5 || n > 5;
    }
    return !1;
  }
  _hasDown() {
    return Ve(this._downPoints).length > 0;
  }
  _handleDown(e) {
    const t = this.parent;
    if (t && !this.get("draggable") && t._handleDown(e), this.get("interactive") && !this.isHidden()) {
      this.states.lookup("down") && this.states.applyAnimate("down"), this._downPoint = {
        x: e.point.x,
        y: e.point.y
      }, this._isDown = !0;
      const s = ra(e.originalEvent);
      this._downPoints[s] = {
        x: e.point.x,
        y: e.point.y
      };
    }
  }
  /**
   * @ignore
   * @todo should this be user-accessible?
   */
  dragMove(e) {
    let t = this._dragEvent;
    if (t) {
      if (t.simulated && !e.simulated)
        return !0;
      let s = 0, r = this.parent;
      for (; r != null; )
        s += r.get("rotation", 0), r = r.parent;
      let n = e.point.x - t.point.x, a = e.point.y - t.point.y;
      const o = this.events;
      if (t.simulated && !this._isDragging) {
        this._isDragging = !0, this._dragEvent = e, this._dragPoint = {
          x: this.x(),
          y: this.y()
        };
        const l = "dragstart";
        o.isEnabled(l) && o.dispatch(l, {
          type: l,
          target: this,
          originalEvent: e.originalEvent,
          point: e.point,
          simulated: e.simulated
        });
      }
      if (this._isDragging) {
        let l = this._dragPoint;
        this.set("x", l.x + n * pt(s) + a * it(s)), this.set("y", l.y + a * pt(s) - n * it(s));
        const u = "dragged";
        o.isEnabled(u) && o.dispatch(u, {
          type: u,
          target: this,
          originalEvent: e.originalEvent,
          point: e.point,
          simulated: e.simulated
        });
      } else if (Math.hypot(n, a) > 5) {
        this._isDragging = !0, this._dragEvent = e, this._dragPoint = {
          x: this.x(),
          y: this.y()
        };
        const l = "dragstart";
        o.isEnabled(l) && o.dispatch(l, {
          type: l,
          target: this,
          originalEvent: e.originalEvent,
          point: e.point,
          simulated: e.simulated
        });
      }
    }
  }
  _updateSize() {
  }
  _getBounds() {
    this._localBounds = this._display.getLocalBounds();
  }
  /**
   * Returns depth (how deep in the hierachy of the content tree) of this
   * element.
   *
   * @return Depth
   */
  depth() {
    let e = this.parent, t = 0;
    for (; ; )
      if (e)
        ++t, e = e.parent;
      else
        return t;
  }
  /**
   * @ignore
   */
  markDirtySize() {
    this._sizeDirty = !0, this.markDirty();
  }
  /**
   * @ignore
   */
  markDirtyBounds() {
    const e = this._display;
    if (this.get("isMeasured")) {
      this._root._addDirtyBounds(this), e.isMeasured = !0, e.invalidateBounds();
      const t = this.parent;
      t && this.get("position") != "absolute" && (t.get("width") == null || t.get("height") == null || t.get("layout")) && t.markDirtyBounds(), this.get("focusable") && this.isFocus() && this.markDirtyAccessibility();
    }
  }
  /**
   * @ignore
   */
  markDirtyAccessibility() {
    this._root._invalidateAccessibility(this);
  }
  /**
   * @ignore
   */
  markDirtyLayer() {
    this._display.markDirtyLayer(!0);
  }
  /**
   * @ignore
   */
  markDirty() {
    super.markDirty(), this.markDirtyLayer();
  }
  _updateBounds() {
    const e = this._adjustedLocalBounds;
    let t;
    if (!this.get("visible") || !this.getPrivate("visible") || this.get("forceHidden") ? (t = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, this._localBounds = t, this._adjustedLocalBounds = t) : (this._getBounds(), this._fixMinBounds(this._localBounds), this.updatePivotPoint(), this._adjustedLocalBounds = this._display.getAdjustedBounds(this._localBounds), t = this._adjustedLocalBounds), !e || e.left !== t.left || e.top !== t.top || e.right !== t.right || e.bottom !== t.bottom) {
      const s = "boundschanged";
      this.events.isEnabled(s) && this.events.dispatch(s, { type: s, target: this }), this.parent && (this.parent.markDirty(), this.parent.markDirtyBounds());
    }
  }
  _fixMinBounds(e) {
    let t = this.get("minWidth", this.getPrivate("minWidth")), s = this.get("minHeight", this.getPrivate("minHeight"));
    S(t) && e.right - e.left < t && (e.right = e.left + t), S(s) && e.bottom - e.top < s && (e.bottom = e.top + s);
    let r = this.getPrivate("width"), n = this.getPrivate("height");
    S(r) && (r > 0 ? e.right = e.left + r : e.left = e.right + r), S(n) && (n > 0 ? e.bottom = e.top + n : e.top = e.bottom + n);
  }
  _removeParent(e) {
    e && (e.children.removeValue(this), ht(e._percentageSizeChildren, this), ht(e._percentagePositionChildren, this));
  }
  _clearDirty() {
    super._clearDirty(), this._sizeDirty = !1, this._statesHandled = !1;
  }
  /**
   * Simulate hover over element.
   */
  hover() {
    this.showTooltip(), this._handleOver();
  }
  /**
   * Simulate unhover over element.
   */
  unhover() {
    this.hideTooltip(), this._handleOut();
  }
  /**
   * Shows element's [[Tooltip]].
   */
  showTooltip(e) {
    const t = this.getTooltip(), s = this.get("tooltipText"), r = this.get("tooltipHTML");
    if ((s || r) && t) {
      const n = this.get("tooltipPosition"), a = this.getPrivate("tooltipTarget", this);
      (n == "fixed" || !e) && (this._display._setMatrix(), e = this.toGlobal(a._getTooltipPoint())), t.set("pointTo", e), t.set("tooltipTarget", a), t.get("x") || t.set("x", e.x), t.get("y") || t.set("y", e.y), s && t.label.set("text", s), r && t.label.set("html", r);
      const o = this.dataItem;
      if (o && t.label._setDataItem(o), this.get("showTooltipOn") == "always" && (e.x < 0 || e.x > this._root.width() || e.y < 0 || e.y > this._root.height())) {
        this.hideTooltip();
        return;
      }
      t.label.text.markDirtyText();
      const l = t.show();
      return this.setPrivateRaw("showingTooltip", !0), l;
    }
  }
  /**
   * Hides element's [[Tooltip]].
   */
  hideTooltip() {
    const e = this.getTooltip();
    if (e && (e.get("tooltipTarget") == this.getPrivate("tooltipTarget", this) || this.get("tooltip") == e)) {
      let t = e.get("keepTargetHover") && e.get("stateAnimationDuration", 0) == 0 ? 400 : void 0;
      const s = e.hide(t);
      return this.setPrivateRaw("showingTooltip", !1), s;
    }
  }
  _getTooltipPoint() {
    const e = this._localBounds;
    if (e) {
      let t = 0, s = 0;
      return this.get("isMeasured") ? (t = e.left + Te(this.get("tooltipX", 0), e.right - e.left), s = e.top + Te(this.get("tooltipY", 0), e.bottom - e.top)) : (t = Te(this.get("tooltipX", 0), this.width()), s = Te(this.get("tooltipY", 0), this.height())), { x: t, y: s };
    }
    return { x: 0, y: 0 };
  }
  /**
   * Returns [[Tooltip]] used for this element.
   *
   * @return Tooltip
   */
  getTooltip() {
    let e = this.get("tooltip");
    if (e)
      return e;
    {
      let t = this.parent;
      if (t)
        return t.getTooltip();
    }
  }
  _updatePosition() {
    const e = this.parent;
    let t = this.get("dx", 0), s = this.get("dy", 0), r = this.get("x"), n = this.getPrivate("x"), a = 0, o = 0;
    const l = this.get("position");
    r instanceof ae && (e ? r = e.innerWidth() * r.value + e.get("paddingLeft", 0) : r = 0), S(r) ? a = r + t : n != null ? a = n : e && l == "relative" && (a = e.get("paddingLeft", 0) + t);
    let u = this.get("y"), h = this.getPrivate("y");
    u instanceof ae && (e ? u = e.innerHeight() * u.value + e.get("paddingTop", 0) : u = 0), S(u) ? o = u + s : h != null ? o = h : e && l == "relative" && (o = e.get("paddingTop", 0) + s);
    const c = this._display;
    if (c.x != a || c.y != o) {
      c.invalidateBounds(), c.x = a, c.y = o;
      const f = "positionchanged";
      this.events.isEnabled(f) && this.events.dispatch(f, { type: f, target: this });
    }
    this.getPrivate("showingTooltip") && this.showTooltip();
  }
  /**
   * Returns element's actual X position in pixels.
   *
   * @return X (px)
   */
  x() {
    let e = this.get("x"), t = this.getPrivate("x");
    const s = this.parent;
    return s ? e instanceof ae ? Te(e, s.innerWidth()) + s.get("paddingLeft", 0) : S(e) ? e : t ?? s.get("paddingLeft", this._display.x) : this._display.x;
  }
  /**
   * Returns element's actual Y position in pixels.
   *
   * @return Y (px)
   */
  y() {
    let e = this.getPrivate("y");
    if (e != null)
      return e;
    let t = this.get("y");
    const s = this.parent;
    return s ? t instanceof ae ? Te(t, s.innerHeight()) + s.get("paddingTop", 0) : S(t) ? t : e ?? s.get("paddingTop", this._display.y) : this._display.y;
  }
  _dispose() {
    super._dispose(), this._display.dispose(), this._removeTemplateField(), this._removeParent(this.parent), this._root._removeFocusElement(this);
    const e = this.get("tooltip");
    e && e.dispose(), this.markDirty();
  }
  /**
   * @ignore
   */
  adjustedLocalBounds() {
    return this._fixMinBounds(this._adjustedLocalBounds), this._adjustedLocalBounds;
  }
  /**
   * Returns local coordinates of the element's bounds.
   *
   * @ignore
   * @return Global bounds
   */
  localBounds() {
    return this._localBounds;
  }
  /**
   * Returns adjusted local coordinates of the element's bounds.
   *
   * @ignore
   * @return Global bounds
   */
  bounds() {
    const e = this._adjustedLocalBounds, t = this.x(), s = this.y();
    return { left: e.left + t, right: e.right + t, top: e.top + s, bottom: e.bottom + s };
  }
  /**
   * Returns global coordinates of the element's bounds.
   *
   * @ignore
   * @return Global bounds
   */
  globalBounds() {
    const e = this.localBounds(), t = this.toGlobal({ x: e.left, y: e.top }), s = this.toGlobal({ x: e.right, y: e.top }), r = this.toGlobal({ x: e.right, y: e.bottom }), n = this.toGlobal({ x: e.left, y: e.bottom });
    return {
      left: Math.min(t.x, s.x, r.x, n.x),
      top: Math.min(t.y, s.y, r.y, n.y),
      right: Math.max(t.x, s.x, r.x, n.x),
      bottom: Math.max(t.y, s.y, r.y, n.y)
    };
  }
  _onShow(e) {
  }
  _onHide(e) {
  }
  /**
   * Plays initial reveal animation regardless if element is currently hidden
   * or visible.
   *
   * @param   duration  Duration of the animation in milliseconds
   * @param   delay     Delay showing of the element by X milliseconds
   * @return            Promise
   */
  appear(e, t) {
    return Ze(this, void 0, void 0, function* () {
      return yield this.hide(0), t ? new Promise((s, r) => {
        this.setTimeout(() => {
          s(this.show(e));
        }, t);
      }) : this.show(e);
    });
  }
  /**
   * Shows currently hidden element and returns a `Promise` which completes
   * when all showing animations are finished.
   *
   * ```TypeScript
   * series.show().then(function(ev) {
   *   console.log("Series is now fully visible");
   * })
   * ```
   * ```JavaScript
   * series.show().then(function(ev) {
   *   console.log("Series is now fully visible");
   * })
   * ```
   *
   * @return Promise
   */
  show(e) {
    return Ze(this, void 0, void 0, function* () {
      if (!this._isShowing) {
        this._isHidden = !1, this._isShowing = !0, this._isHiding = !1, this.states.lookup("default").get("visible") && this.set("visible", !0), this._onShow(e);
        const t = this.states.applyAnimate("default", e);
        yield hh(t), this._isShowing = !1;
      }
    });
  }
  /**
   * Hides the element and returns a `Promise` which completes when all hiding
   * animations are finished.
   *
   * ```TypeScript
   * series.hide().then(function(ev) {
   *   console.log("Series finished hiding");
   * })
   * ```
   * ```JavaScript
   * series.hide().then(function(ev) {
   *   console.log("Series finished hiding");
   * })
   * ```
   *
   * @return Promise
   */
  hide(e) {
    return Ze(this, void 0, void 0, function* () {
      if (!this._isHiding && !this._isHidden) {
        this._isHiding = !0, this._isShowing = !1;
        let t = this.states.lookup("hidden");
        t || (t = this.states.create("hidden", {
          opacity: 0,
          visible: !1
        })), this._isHidden = !0, this._onHide(e);
        const s = this.states.applyAnimate("hidden", e);
        yield hh(s), this._isHiding = !1;
      }
    });
  }
  /**
   * Returns `true` if this element is currently hidden.
   *
   * @return Is hidden?
   */
  isHidden() {
    return this._isHidden;
  }
  /**
   * Returns `true` if this element is currently animating to a default state.
   *
   * @return Is showing?
   */
  isShowing() {
    return this._isShowing;
  }
  /**
   * Returns `true` if this element is currently animating to a hidden state.
   *
   * @return Is hiding?
   */
  isHiding() {
    return this._isHiding;
  }
  /**
   * Returns `true` if this element is currently hovered by a pointer.
   *
   * @return Is hovered?
   */
  isHover() {
    return this._display.hovering();
  }
  /**
   * Returns `true` if this element does currently have focus.
   *
   * @return Is focused?
   */
  isFocus() {
    return this._root.focused(this);
  }
  /**
   * Returns `true` if this element is currently being dragged.
   *
   * @return Is dragged?
   */
  isDragging() {
    return this._isDragging;
  }
  /**
   * Returns `false` if if either public or private setting `visible` is set
   * to `false`, or `forceHidden` is set to `true`.
   *
   * @return Visible?
   */
  isVisible() {
    return !!(this.get("visible") && this.getPrivate("visible") && !this.get("forceHidden"));
  }
  /**
   * Same as `isVisible()`, except it checks all ascendants, too.
   *
   * @since 5.2.7
   * @return Visible?
   */
  isVisibleDeep() {
    return this._parent ? this._parent.isVisibleDeep() && this.isVisible() : this.isVisible();
  }
  /**
   * Returns an actual opacity of the element, taking into account all parents.
   *
   * @return Opacity
   * @since 5.2.11
   */
  compositeOpacity() {
    const e = this.get("opacity", 1);
    return this._parent ? this._parent.compositeOpacity() * e : e;
  }
  /**
   * Returns width of this element in pixels.
   *
   * @return Width (px)
   */
  width() {
    let e = this.get("width"), t = this.get("maxWidth", this.getPrivate("maxWidth")), s = this.get("minWidth", this.getPrivate("minWidth")), r = this.getPrivate("width"), n = 0;
    if (S(r))
      n = r;
    else if (e == null)
      this._adjustedLocalBounds && (n = this._adjustedLocalBounds.right - this._adjustedLocalBounds.left);
    else if (e instanceof ae) {
      const a = this.parent;
      a ? n = a.innerWidth() * e.value : n = this._root.width() * e.value;
    } else
      S(e) && (n = e);
    return S(s) && (n = Math.max(s, n)), S(t) && (n = Math.min(t, n)), n;
  }
  /**
   * Returns maximum allowed width of this element in pixels.
   *
   * @return Maximum width (px)
   */
  maxWidth() {
    let e = this.get("maxWidth", this.getPrivate("maxWidth"));
    if (S(e))
      return e;
    {
      let s = this.get("width");
      if (S(s))
        return s;
    }
    const t = this.parent;
    return t ? t.innerWidth() : this._root.width();
  }
  /**
   * Returns maximum allowed height of this element in pixels.
   *
   * @return Maximum height (px)
   */
  maxHeight() {
    let e = this.get("maxHeight", this.getPrivate("maxHeight"));
    if (S(e))
      return e;
    {
      let s = this.get("height");
      if (S(s))
        return s;
    }
    const t = this.parent;
    return t ? t.innerHeight() : this._root.height();
  }
  /**
   * Returns height of this element in pixels.
   *
   * @return Height (px)
   */
  height() {
    let e = this.get("height"), t = this.get("maxHeight", this.getPrivate("maxHeight")), s = this.get("minHeight", this.getPrivate("minHeight")), r = this.getPrivate("height"), n = 0;
    if (S(r))
      n = r;
    else if (e == null)
      this._adjustedLocalBounds && (n = this._adjustedLocalBounds.bottom - this._adjustedLocalBounds.top);
    else if (e instanceof ae) {
      const a = this.parent;
      a ? n = a.innerHeight() * e.value : n = this._root.height() * e.value;
    } else
      S(e) && (n = e);
    return S(s) && (n = Math.max(s, n)), S(t) && (n = Math.min(t, n)), n;
  }
  _findStaticTemplate(e) {
    return this._templateField && e(this._templateField) ? this._templateField : super._findStaticTemplate(e);
  }
  _walkParents(e) {
    this._parent && this._walkParent(e);
  }
  _walkParent(e) {
    this._parent && this._parent._walkParent(e), e(this);
  }
  /**
   * Parent [[Container]] of this element.
   *
   * @return Parent container
   */
  get parent() {
    return this._parent;
  }
  _setParent(e, t = !1) {
    const s = this._parent;
    e !== s && (this.markDirtyBounds(), e.markDirty(), this._parent = e, t && (this._removeParent(s), e && (this._addPercentageSizeChildren(), this._addPercentagePositionChildren())), this.markDirtyPosition(), this._applyThemes());
  }
  /**
   * Returns an instance of [[NumberFormatter]] used in this element.
   *
   * If this element does not have it set, global one form [[Root]] is used.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/using-formatters/} for more info
   * @return NumberFormatter instace
   */
  getNumberFormatter() {
    return this.get("numberFormatter", this._root.numberFormatter);
  }
  /**
   * Returns an instance of [[DateFormatter]] used in this element.
   *
   * If this element does not have it set, global one form [[Root]] is used.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/using-formatters/} for more info
   * @return DateFormatter instace
   */
  getDateFormatter() {
    return this.get("dateFormatter", this._root.dateFormatter);
  }
  /**
   * Returns an instance of [[DurationFormatter]] used in this element.
   *
   * If this element does not have it set, global one form [[Root]] is used.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/using-formatters/} for more info
   * @return DurationFormatter instace
   */
  getDurationFormatter() {
    return this.get("durationFormatter", this._root.durationFormatter);
  }
  /**
   * Converts X/Y coordinate within this element to a global coordinate.
   *
   * @param  point  Local coordinate
   * @return        Global coordinate
   */
  toGlobal(e) {
    return this._display.toGlobal(e);
  }
  /**
   * Converts global X/Y coordinate to a coordinate within this element.
   *
   * @param  point  Global coordinate
   * @return        Local coordinate
   */
  toLocal(e) {
    return this._display.toLocal(e);
  }
  _getDownPoint() {
    const e = this._getDownPointId();
    if (e)
      return this._downPoints[e];
  }
  _getDownPointId() {
    if (this._downPoints)
      return uc(this._downPoints, (e, t) => e > t ? 1 : e < t ? -1 : 0)[0];
  }
  /**
   * Moves sprite to the end of the parent's children array.
   *
   * Depending on `layout` setting of the parten container, it may effect the
   * positioning or overlapping order of the elements.
   */
  toFront() {
    const e = this.parent;
    e && e.children.moveValue(this, e.children.length - 1);
  }
  /**
   * Moves sprite to the beginning of the parent's children array.
   *
   * Depending on `layout` setting of the parten container, it may effect the
   * positioning or overlapping order of the elements.
   */
  toBack() {
    const e = this.parent;
    e && e.children.moveValue(this, 0);
  }
}
Object.defineProperty(kt, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Sprite"
});
Object.defineProperty(kt, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Oe.classNames.concat([kt.className])
});
class Pt extends Oe {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_display", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._root._renderer.makeGraphics()
    }), Object.defineProperty(this, "_backgroundDisplay", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._root._renderer.makeGraphics()
    }), Object.defineProperty(this, "_clear", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_pattern", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  _afterNew() {
    super._afterNewApplyThemes();
  }
  get pattern() {
    return this._pattern;
  }
  _draw() {
  }
  _beforeChanged() {
    super._beforeChanged(), (this.isDirty("repetition") || this.isDirty("width") || this.isDirty("height") || this.isDirty("rotation") || this.isDirty("color") || this.isDirty("strokeWidth") || this.isDirty("strokeDasharray") || this.isDirty("strokeDashoffset") || this.isDirty("colorOpacity") || this.isDirty("fill") || this.isDirty("fillOpacity")) && (this._clear = !0);
  }
  _changed() {
    if (super._changed(), this._clear) {
      const e = this.get("repetition", ""), t = this.get("width", 100), s = this.get("height", 100), r = this.get("fill"), n = this.get("fillOpacity", 1);
      this._display.clear(), this._backgroundDisplay.clear(), r && n > 0 && (this._backgroundDisplay.beginFill(r, n), this._backgroundDisplay.drawRect(0, 0, t, s), this._backgroundDisplay.endFill()), this._display.angle = this.get("rotation", 0), this._draw(), this._pattern = this._root._renderer.createPattern(this._display, this._backgroundDisplay, e, t, s);
    }
  }
}
Object.defineProperty(Pt, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Pattern"
});
Object.defineProperty(Pt, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Oe.classNames.concat([Pt.className])
});
class cr extends Pt {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_image", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  _beforeChanged() {
    super._beforeChanged(), this._clear = !0, this.isDirty("src") && this._load();
  }
  _draw() {
    super._draw();
    const e = this._image;
    if (e) {
      const t = this.get("width", 100), s = this.get("height", 100), r = this.get("fit", "image");
      let n = 0, a = 0;
      r == "pattern" ? (n = t, a = s) : (n = e.width, a = e.height, r == "image" && (this.set("width", n), this.set("height", a)));
      const o = this.get("centered", !0);
      let l = 0, u = 0;
      o && (l = t / 2 - n / 2, u = s / 2 - a / 2), this._display.image(e, n, a, l, u);
    }
  }
  _load() {
    const e = this.get("src");
    if (e) {
      const t = new Image();
      t.src = e, t.decode().then(() => {
        this._image = t, this._draw(), this.events.isEnabled("loaded") && this.events.dispatch("loaded", { type: "loaded", target: this });
      }).catch((s) => {
      });
    }
  }
}
Object.defineProperty(cr, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "PicturePattern"
});
Object.defineProperty(cr, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Pt.classNames.concat([cr.className])
});
var Ia;
(function(i) {
  i.ADD = "lighter", i.COLOR = "color", i.COLOR_BURN = "color-burn", i.COLOR_DODGE = "color-dodge", i.DARKEN = "darken", i.DIFFERENCE = "difference", i.DST_OVER = "destination-over", i.EXCLUSION = "exclusion", i.HARD_LIGHT = "hard-light", i.HUE = "hue", i.LIGHTEN = "lighten", i.LUMINOSITY = "luminosity", i.MULTIPLY = "multiply", i.NORMAL = "source-over", i.OVERLAY = "overlay", i.SATURATION = "saturation", i.SCREEN = "screen", i.SOFT_LIGHT = "soft-light", i.SRC_ATOP = "source-atop", i.XOR = "xor";
})(Ia || (Ia = {}));
const fp = ["fill", "fillOpacity", "stroke", "strokeWidth", "strokeOpacity", "fillPattern", "strokePattern", "fillGradient", "strokeGradient", "strokeDasharray", "strokeDashoffset"];
class ce extends kt {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_display", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._root._renderer.makeGraphics()
    }), Object.defineProperty(this, "_clear", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    });
  }
  _beforeChanged() {
    if (super._beforeChanged(), (this.isDirty("draw") || this.isDirty("svgPath")) && this.markDirtyBounds(), (this.isDirty("fill") || this.isDirty("stroke") || this.isDirty("visible") || this.isDirty("forceHidden") || this.isDirty("scale") || this.isDirty("fillGradient") || this.isDirty("strokeGradient") || this.isDirty("fillPattern") || this.isDirty("strokePattern") || this.isDirty("fillOpacity") || this.isDirty("strokeOpacity") || this.isDirty("strokeWidth") || this.isDirty("draw") || this.isDirty("blendMode") || this.isDirty("strokeDasharray") || this.isDirty("strokeDashoffset") || this.isDirty("svgPath") || this.isDirty("lineJoin") || this.isDirty("shadowColor") || this.isDirty("shadowBlur") || this.isDirty("shadowOffsetX") || this.isDirty("shadowOffsetY")) && (this._clear = !0), this._display.crisp = this.get("crisp", !1), this.isDirty("fillGradient")) {
      const e = this.get("fillGradient");
      if (e) {
        this._display.isMeasured = !0;
        const t = e.get("target");
        t && (this._disposers.push(t.events.on("boundschanged", () => {
          this._markDirtyKey("fill");
        })), this._disposers.push(t.events.on("positionchanged", () => {
          this._markDirtyKey("fill");
        })));
      }
    }
    if (this.isDirty("strokeGradient")) {
      const e = this.get("strokeGradient");
      if (e) {
        this._display.isMeasured = !0;
        const t = e.get("target");
        t && (this._disposers.push(t.events.on("boundschanged", () => {
          this._markDirtyKey("stroke");
        })), this._disposers.push(t.events.on("positionchanged", () => {
          this._markDirtyKey("stroke");
        })));
      }
    }
  }
  _changed() {
    if (super._changed(), this._clear) {
      this.markDirtyBounds(), this.markDirtyLayer(), this._display.clear();
      let e = this.get("strokeDasharray");
      S(e) && (e < 0.5 ? e = [0] : e = [e]), this._display.setLineDash(e);
      const t = this.get("strokeDashoffset");
      t && this._display.setLineDashOffset(t);
      const s = this.get("blendMode", Ia.NORMAL);
      this._display.blendMode = s;
      const r = this.get("draw");
      r && r(this._display, this);
      const n = this.get("svgPath");
      n != null && this._display.svgPath(n);
    }
  }
  _afterChanged() {
    if (super._afterChanged(), this._clear) {
      const e = this.get("fill"), t = this.get("fillGradient"), s = this.get("fillPattern"), r = this.get("fillOpacity"), n = this.get("stroke"), a = this.get("strokeGradient"), o = this.get("strokePattern"), l = this.get("shadowColor"), u = this.get("shadowBlur"), h = this.get("shadowOffsetX"), c = this.get("shadowOffsetY"), f = this.get("shadowOpacity");
      if (l && (u || h || c) && this._display.shadow(l, u, h, c, f), s) {
        let d = !1;
        e && (!s.get("fill") || s.get("fillInherited")) && (s.set("fill", e), s.set("fillInherited", !0), d = !0), n && (!s.get("color") || s.get("colorInherited")) && (s.set("color", n), s.set("colorInherited", !0), d = !0), d && s._changed();
        const g = s.pattern;
        g && (this._display.beginFill(g, r), this._display.endFill(), s instanceof cr && s.events.once("loaded", () => {
          this._clear = !0, this.markDirty();
        }));
      } else if (t) {
        if (e) {
          const g = t.get("stops", []);
          g.length && w(g, (p) => {
            (!p.color || p.colorInherited) && e && (p.color = e, p.colorInherited = !0), (p.opacity == null || p.opacityInherited) && (p.opacity = r, p.opacityInherited = !0);
          });
        }
        const d = t.getFill(this);
        d && (this._display.beginFill(d, r), this._display.endFill());
      } else
        e && (this._display.beginFill(e, r), this._display.endFill());
      if (n || a || o) {
        const d = this.get("strokeOpacity");
        let g = this.get("strokeWidth", 1);
        this.get("nonScalingStroke") && (g = g / this.get("scale", 1)), this.get("crisp") && (g /= this._root._renderer.resolution);
        const p = this.get("lineJoin");
        if (o) {
          let _ = !1;
          n && (!o.get("color") || o.get("colorInherited")) && (o.set("color", n), o.set("colorInherited", !0), _ = !0), _ && o._changed();
          const m = o.pattern;
          m && (this._display.lineStyle(g, m, d, p), this._display.endStroke(), o instanceof cr && o.events.once("loaded", () => {
            this._clear = !0, this.markDirty();
          }));
        } else if (a) {
          const _ = a.get("stops", []);
          _.length && w(_, (v) => {
            (!v.color || v.colorInherited) && n && (v.color = n, v.colorInherited = !0), (v.opacity == null || v.opacityInherited) && (v.opacity = d, v.opacityInherited = !0);
          });
          const m = a.getFill(this);
          m && (this._display.lineStyle(g, m, d, p), this._display.endStroke());
        } else
          n && (this._display.lineStyle(g, n, d, p), this._display.endStroke());
      }
      this.getPrivate("showingTooltip") && this.showTooltip();
    }
    this._clear = !1;
  }
}
Object.defineProperty(ce, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Graphics"
});
Object.defineProperty(ce, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: kt.classNames.concat([ce.className])
});
class gt extends ce {
  _beforeChanged() {
    super._beforeChanged(), (this.isDirty("width") || this.isDirty("height") || this.isPrivateDirty("width") || this.isPrivateDirty("height")) && (this._clear = !0);
  }
  _changed() {
    super._changed(), this._clear && !this.get("draw") && this._draw();
  }
  _draw() {
    this._display.drawRect(0, 0, this.width(), this.height());
  }
  _updateSize() {
    this.markDirty(), this._clear = !0;
  }
}
Object.defineProperty(gt, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Rectangle"
});
Object.defineProperty(gt, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: ce.classNames.concat([gt.className])
});
function Ci(i, e) {
  i.get("reverseChildren", !1) ? i.children.eachReverse(e) : i.children.each(e);
}
class fi extends Oe {
}
Object.defineProperty(fi, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Layout"
});
Object.defineProperty(fi, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Oe.classNames.concat([fi.className])
});
class As extends fi {
  /**
   * @ignore
   */
  updateContainer(e) {
    let t = e.get("paddingLeft", 0), s = e.innerWidth(), r = 0;
    Ci(e, (a) => {
      if (a.isVisible() && a.get("position") == "relative") {
        let o = a.get("width");
        if (o instanceof ae) {
          r += o.value;
          let l = s * o.value, u = a.get("minWidth", a.getPrivate("minWidth", -1 / 0));
          u > l && (s -= u, r -= o.value);
          let h = a.get("maxWidth", a.getPrivate("maxWidth", 1 / 0));
          l > h && (s -= h, r -= o.value);
        } else
          S(o) || (o = a.width()), s -= o + a.get("marginLeft", 0) + a.get("marginRight", 0);
      }
    }), (s <= 0 || s == 1 / 0) && (s = 0.1), Ci(e, (a) => {
      if (a.isVisible() && a.get("position") == "relative") {
        let o = a.get("width");
        if (o instanceof ae) {
          let l = s * o.value / r - a.get("marginLeft", 0) - a.get("marginRight", 0), u = a.get("minWidth", a.getPrivate("minWidth", -1 / 0)), h = a.get("maxWidth", a.getPrivate("maxWidth", 1 / 0));
          l = Math.min(Math.max(u, l), h), a.setPrivate("width", l);
        }
      }
    });
    let n = t;
    Ci(e, (a) => {
      if (a.get("position") == "relative")
        if (a.isVisible()) {
          let o = a.adjustedLocalBounds(), l = a.get("marginLeft", 0), u = a.get("marginRight", 0), h = a.get("maxWidth"), c = o.left, f = o.right;
          h && f - c > h && (f = c + h);
          let d = n + l - c;
          a.setPrivate("x", d), n = d + f + u;
        } else
          a.setPrivate("x", void 0);
    });
  }
}
Object.defineProperty(As, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "HorizontalLayout"
});
Object.defineProperty(As, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: fi.classNames.concat([As.className])
});
class Ls extends fi {
  /**
   * @ignore
   */
  updateContainer(e) {
    let t = e.get("paddingTop", 0), s = e.innerHeight(), r = 0;
    Ci(e, (a) => {
      if (a.isVisible() && a.get("position") == "relative") {
        let o = a.get("height");
        if (o instanceof ae) {
          r += o.value;
          let l = s * o.value, u = a.get("minHeight", a.getPrivate("minHeight", -1 / 0));
          u > l && (s -= u, r -= o.value);
          let h = a.get("maxHeight", a.getPrivate("maxHeight", 1 / 0));
          l > h && (s -= h, r -= o.value);
        } else
          S(o) || (o = a.height()), s -= o + a.get("marginTop", 0) + a.get("marginBottom", 0);
      }
    }), (s <= 0 || s == 1 / 0) && (s = 0.1), Ci(e, (a) => {
      if (a.isVisible() && a.get("position") == "relative") {
        let o = a.get("height");
        if (o instanceof ae) {
          let l = s * o.value / r - a.get("marginTop", 0) - a.get("marginBottom", 0), u = a.get("minHeight", a.getPrivate("minHeight", -1 / 0)), h = a.get("maxHeight", a.getPrivate("maxHeight", 1 / 0));
          l = Math.min(Math.max(u, l), h), a.setPrivate("height", l);
        }
      }
    });
    let n = t;
    Ci(e, (a) => {
      if (a.get("position") == "relative")
        if (a.isVisible()) {
          let o = a.adjustedLocalBounds(), l = a.get("marginTop", 0), u = o.top, h = o.bottom, c = a.get("maxHeight");
          c && h - u > c && (h = u + c);
          let f = a.get("marginBottom", 0), d = n + l - u;
          a.setPrivate("y", d), n = d + h + f;
        } else
          a.setPrivate("y", void 0);
    });
  }
}
Object.defineProperty(Ls, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "VerticalLayout"
});
Object.defineProperty(Ls, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: fi.classNames.concat([Ls.className])
});
class Ki extends fi {
  _afterNew() {
    this._setRawDefault("maxColumns", Number.MAX_VALUE), super._afterNew();
  }
  /**
   * @ignore
   */
  updateContainer(e) {
    let t = e.get("paddingLeft", 0), s = e.get("paddingRight", 0), r = e.get("paddingTop", 0), n = e.maxWidth() - t - s, a = n, o = 1;
    Ci(e, (g) => {
      if (g.get("visible") && g.getPrivate("visible") && !g.get("forceHidden") && g.get("position") != "absolute") {
        let p = g.width();
        p < a && (a = p), p > o && (o = p);
      }
    }), a = Re(a, 1, n), o = Re(o, 1, n);
    let l = 1;
    this.get("fixedWidthGrid") ? l = n / o : l = n / a, l = Math.max(1, Math.floor(l)), l = Math.min(this.get("maxColumns", Number.MAX_VALUE), l);
    let u = this.getColumnWidths(e, l, o, n), h = r, c = 0, f = 0;
    l = u.length;
    let d = t;
    Ci(e, (g) => {
      if (g.get("position") == "relative" && g.isVisible()) {
        const p = g.get("marginTop", 0), _ = g.get("marginBottom", 0);
        let m = g.adjustedLocalBounds(), v = g.get("marginLeft", 0), b = g.get("marginRight", 0), y = d + v - m.left, x = h + p - m.top;
        g.setPrivate("x", y), g.setPrivate("y", x), d += u[c] + b, f = Math.max(f, g.height() + p + _), c++, c >= l && (c = 0, d = t, h += f);
      }
    });
  }
  /**
   * @ignore
   */
  getColumnWidths(e, t, s, r) {
    let n = 0, a = [], o = 0;
    return Ci(e, (l) => {
      let u = l.adjustedLocalBounds();
      l.get("position") != "absolute" && l.isVisible() && (this.get("fixedWidthGrid") ? a[o] = s : a[o] = Math.max(a[o] | 0, u.right - u.left + l.get("marginLeft", 0) + l.get("marginRight", 0)), o < e.children.length - 1 && (o++, o == t && (o = 0)));
    }), w(a, (l) => {
      n += l;
    }), n > r ? t > 2 ? (t -= 1, this.getColumnWidths(e, t, s, r)) : [r] : a;
  }
}
Object.defineProperty(Ki, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "GridLayout"
});
Object.defineProperty(Ki, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: fi.classNames.concat([Ki.className])
});
class Ht {
  /**
   * Replaces brackets with temporary placeholders.
   *
   * @ignore Exclude from docs
   * @param text  Input text
   * @return Escaped text
   */
  static escape(e) {
    return e.replace(/\[\[/g, this.prefix + "1").replace(/([^\/\]]{1})\]\]/g, "$1" + this.prefix + "2").replace(/\]\]/g, this.prefix + "2").replace(/\{\{/g, this.prefix + "3").replace(/\}\}/g, this.prefix + "4").replace(/\'\'/g, this.prefix + "5");
  }
  /**
   * Replaces placeholders back to brackets.
   *
   * @ignore Exclude from docs
   * @param text  Escaped text
   * @return Unescaped text
   */
  static unescape(e) {
    return e.replace(new RegExp(this.prefix + "1", "g"), "[[").replace(new RegExp(this.prefix + "2", "g"), "]]").replace(new RegExp(this.prefix + "3", "g"), "{{").replace(new RegExp(this.prefix + "4", "g"), "}}").replace(new RegExp(this.prefix + "5", "g"), "''");
  }
  /**
   * Cleans up the text text for leftover double square brackets.
   *
   * @ignore Exclude from docs
   * @param text  Input text
   * @return Cleaned up text
   */
  static cleanUp(e) {
    return e.replace(/\[\[/g, "[").replace(/\]\]/g, "]").replace(/\{\{/g, "{").replace(/\}\}/g, "}").replace(/\'\'/g, "'");
  }
  /**
   * Splits string into chunks. (style blocks, quoted blocks, regular blocks)
   *
   * If the second parameter `quotedBlocks` is set to `true` this method will
   * also single out text blocks enclosed within single quotes that no
   * formatting should be applied to, and they should be displayed as is.
   *
   * Default for the above is `false`, so that you can use single quote in text
   * without escaping it.
   *
   * If enabled, single quotes can be escaped by doubling it - adding two
   * single quotes, which will be replaced by a one single quote in the final
   * output.
   *
   * @ignore Exclude from docs
   * @param text          Text to chunk
   * @param quotedBlocks  Use quoted blocks
   * @param noFormatting  Formatting blocks will be treated as regular text
   * @return Array of string chunks
   */
  static chunk(e, t = !1, s = !1) {
    let r = [];
    e = this.escape(e);
    let n = t ? e.split("'") : [e];
    for (let a = 0; a < n.length; a++) {
      let o = n[a];
      if (o !== "")
        if (a % 2 === 0) {
          o = o.replace(/\]\[/g, "]" + Oi + "["), o = o.replace(/\[\]/g, "[ ]");
          let l = o.split(/[\[\]]+/);
          for (let u = 0; u < l.length; u++) {
            let h = this.cleanUp(this.unescape(l[u]));
            h !== Oi && h !== "" && (u % 2 === 0 ? r.push({
              type: "value",
              text: h
            }) : r.push({
              type: s ? "value" : "format",
              text: "[" + h + "]"
            }));
          }
        } else {
          let l = o.split(/[\[\]]+/);
          for (let u = 0; u < l.length; u++) {
            let h = this.cleanUp(this.unescape(l[u]));
            h !== "" && (u % 2 === 0 ? r.push({
              type: "text",
              text: h
            }) : this.isImage(h) ? r.push({
              type: "image",
              text: "[" + h + "]"
            }) : r.push({
              type: "format",
              text: "[" + h + "]"
            }));
          }
        }
    }
    return r;
  }
  /**
   * Checks if supplied format contains image information and should be
   * formatted as such.
   * I.e.: `[img: myImage.png]`
   *
   * @ignore
   * @param  text  Format
   * @return true if it is an image
   */
  static isImage(e) {
    return !!e.match(/img[ ]?:/);
  }
  static getTextStyle(e) {
    let t = {};
    if (e == "" || e == "[ ]")
      return {};
    const s = e.match(/('[^']*')|("[^"]*")/gi);
    if (s)
      for (let n = 0; n < s.length; n++)
        e = e.replace(s[n], s[n].replace(/['"]*/g, "").replace(/[ ]+/g, "+"));
    let r = e.match(/([\w\-]*:[\s]?[^;\s\]]*)|(\#[\w]{1,6})|([\w\-]+)|(\/)/gi);
    if (!r)
      return {};
    for (let n = 0; n < r.length; n++)
      if (r[n].match(/^(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900)$/i))
        t.fontWeight = r[n];
      else if (r[n].match(/^(underline|line-through)$/i))
        t.textDecoration = r[n];
      else if (r[n] != "/")
        if (!r[n].match(/:/))
          t.fill = V.fromString(r[n]);
        else {
          const a = r[n].replace("+", " ").split(/:[ ]*/);
          t[a[0]] = a[1];
        }
    return t;
  }
}
Object.defineProperty(Ht, "prefix", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "__amcharts__"
});
function nn(i, e) {
  if (e != null) {
    e = "" + e, e = Ht.escape(e);
    let t = e.match(/\{([^}]+)\}/g), s;
    if (t)
      for (s = 0; s < t.length; s++) {
        let r = t[s].replace(/\{([^}]+)\}/, "$1"), n = eu(i, r);
        n == null && (n = ""), e = e.split(t[s]).join(n);
      }
    e = Ht.unescape(e);
  } else
    e = "";
  return e;
}
function eu(i, e, t) {
  let s;
  const r = i.dataItem;
  let n = [], a = /(format[a-zA-Z]*)\((.*)\)|([^.]+)/g, o;
  for (; o = a.exec(e), o !== null; )
    if (o[3]) {
      n.push({
        prop: o[3]
      });
      const l = i.getDateFormatter().get("dateFields", []), u = i.getNumberFormatter().get("numericFields", []), h = i.getDurationFormatter().get("durationFields", []);
      l.indexOf(o[3]) !== -1 ? n.push({
        method: "formatDate",
        params: []
      }) : u.indexOf(o[3]) !== -1 ? n.push({
        method: "formatNumber",
        params: []
      }) : h.indexOf(o[3]) !== -1 && n.push({
        method: "formatDuration",
        params: []
      });
    } else {
      let l = [];
      if (Qr(o[2]) != "") {
        let u = /'([^']*)'|"([^"]*)"|([0-9\-]+)/g, h;
        for (; h = u.exec(o[2]), h !== null; )
          l.push(h[1] || h[2] || h[3]);
      }
      n.push({
        method: o[1],
        params: l
      });
    }
  if (r) {
    s = bs(i, n, r._settings), (s == null || Ys(s)) && (s = bs(i, n, r));
    let l = r.dataContext;
    s == null && l && (s = bs(i, n, l), s == null && (s = bs(i, [{
      prop: e
    }], l)), s == null && l.dataContext && (s = bs(i, n, l.dataContext))), s == null && r.component && r.component.dataItem !== r && (s = eu(r.component, e));
  }
  return s == null && (s = bs(i, n, i)), s == null && i.parent && (s = eu(i.parent, e)), s;
}
function wk(i, e) {
  const t = i.getPrivate("customData");
  if (Ys(t))
    return t[e];
}
function bs(i, e, t, s) {
  let r = t, n = !1;
  for (let a = 0, o = e.length; a < o; a++) {
    let l = e[a];
    if (l.prop) {
      if (r instanceof kt) {
        let u = r.get(l.prop);
        u == null && (u = r.getPrivate(l.prop)), u == null && (u = wk(r, l.prop)), u == null && (u = r[l.prop]), r = u;
      } else if (r.get) {
        let u = r.get(l.prop);
        u == null && (u = r[l.prop]), r = u;
      } else
        r = r[l.prop];
      if (r == null)
        return;
    } else
      switch (l.method) {
        case "formatNumber":
          let u = yt(r);
          u != null && (r = i.getNumberFormatter().format(u, s || l.params[0] || void 0), n = !0);
          break;
        case "formatDate":
          let h = Cf(r);
          if (!Da(h) || Wt(h.getTime()))
            return;
          h != null && (r = i.getDateFormatter().format(h, s || l.params[0] || void 0), n = !0);
          break;
        case "formatDuration":
          let c = yt(r);
          c != null && (r = i.getDurationFormatter().format(c, s || l.params[0] || void 0, l.params[1] || void 0), n = !0);
          break;
        case "urlEncode":
        case "encodeURIComponent":
          r = encodeURIComponent(r);
          break;
        default:
          r[l.method] && r[l.method].apply(t, l.params);
          break;
      }
  }
  if (!n) {
    let a = [{
      method: "",
      params: s
    }];
    if (s == null)
      S(r) ? (a[0].method = "formatNumber", a[0].params = "") : Da(r) && (a[0].method = "formatDate", a[0].params = "");
    else {
      let o = Uf(s);
      o === "number" ? a[0].method = "formatNumber" : o === "date" ? a[0].method = "formatDate" : o === "duration" && (a[0].method = "formatDuration");
    }
    a[0].method && (r = bs(i, a, r));
  }
  return r;
}
class G extends kt {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_display", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._root._renderer.makeContainer()
    }), Object.defineProperty(this, "_childrenDisplay", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._root._renderer.makeContainer()
    }), Object.defineProperty(this, "children", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new bT(this)
    }), Object.defineProperty(this, "_percentageSizeChildren", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_percentagePositionChildren", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_prevWidth", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_prevHeight", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_contentWidth", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_contentHeight", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_contentMask", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_vsbd0", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_vsbd1", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  _afterNew() {
    super._afterNew(), this._display.addChild(this._childrenDisplay);
  }
  _dispose() {
    rr(this.allChildren(), (e) => {
      e.dispose();
    }), this.getPrivate("htmlElement") && this._root._removeHTMLContent(this), super._dispose();
  }
  _changed() {
    if (super._changed(), this.isDirty("interactiveChildren") && (this._display.interactiveChildren = this.get("interactiveChildren", !1)), this.isDirty("layout") && (this._prevWidth = 0, this._prevHeight = 0, this.markDirtyBounds(), this._prevSettings.layout && this.children.each((e) => {
      e.removePrivate("x"), e.removePrivate("y");
    })), (this.isDirty("paddingTop") || this.isDirty("paddingBottom") || this.isDirty("paddingLeft") || this.isDirty("paddingRight")) && this.children.each((e) => {
      e.markDirtyPosition();
    }), this.isDirty("maskContent")) {
      const e = this._childrenDisplay;
      let t = this._contentMask;
      this.get("maskContent") ? t || (t = gt.new(this._root, {
        x: -0.5,
        y: -0.5,
        width: this.width() + 1,
        height: this.height() + 1
      }), this._contentMask = t, e.addChildAt(t._display, 0), e.mask = t._display) : t && (e.removeChild(t._display), e.mask = null, t.dispose(), this._contentMask = void 0);
    }
  }
  _updateSize() {
    super._updateSize(), w(this._percentageSizeChildren, (e) => {
      e._updateSize();
    }), w(this._percentagePositionChildren, (e) => {
      e.markDirtyPosition(), e._updateSize();
    }), this.updateBackground();
  }
  updateBackground() {
    const e = this.get("background");
    let t = this._localBounds;
    if (t && !this.isHidden()) {
      let s = t.left, r = t.top, n = t.right - s, a = t.bottom - r, o = this.get("maxWidth"), l = this.get("maxHeight");
      l && a > l && (a = l), o && n > o && (n = o);
      let u = this.width(), h = this.height();
      e && (e.setAll({ width: n, height: a, x: s, y: r }), this._display.interactive && (e._display.interactive = !0));
      const c = this._contentMask;
      c && c.setAll({ width: u + 1, height: h + 1 });
      const f = this.get("verticalScrollbar");
      if (f) {
        f.set("height", h), f.set("x", u - f.width() - f.get("marginRight", 0)), f.set("end", f.get("start", 0) + h / this._contentHeight);
        const d = f.get("background");
        d && d.setAll({ width: f.width(), height: h });
        let g = !0;
        this._contentHeight <= h && (g = !1), f.setPrivate("visible", g);
      }
    }
  }
  _applyThemes() {
    return super._applyThemes() ? (this.eachChildren((e) => {
      e._applyThemes();
    }), !0) : !1;
  }
  _applyState(e) {
    super._applyState(e), this.get("setStateOnChildren") && this.eachChildren((t) => {
      t.states.apply(e);
    });
  }
  _applyStateAnimated(e, t) {
    super._applyStateAnimated(e, t), this.get("setStateOnChildren") && this.eachChildren((s) => {
      s.states.applyAnimate(e, t);
    });
  }
  /**
   * Returns container's inner width (width without padding) in pixels.
   *
   * @return Inner width (px)
   */
  innerWidth() {
    return this.width() - this.get("paddingRight", 0) - this.get("paddingLeft", 0);
  }
  /**
   * Returns container's inner height (height without padding) in pixels.
   *
   * @return Inner height (px)
   */
  innerHeight() {
    return this.height() - this.get("paddingTop", 0) - this.get("paddingBottom", 0);
  }
  _getBounds() {
    let e = this.get("width"), t = this.get("height"), s = this.getPrivate("width"), r = this.getPrivate("height"), n = {
      left: 0,
      top: 0,
      right: this.width(),
      bottom: this.height()
    }, a = this.get("layout"), o = !1, l = !1;
    if ((a instanceof As || a instanceof Ki) && (o = !0), a instanceof Ls && (l = !0), !((e != null || s != null) && (t != null || r != null) && !this.get("verticalScrollbar"))) {
      let u = Number.MAX_VALUE, h = u, c = -u, f = u, d = -u;
      const g = this.get("paddingLeft", 0), p = this.get("paddingTop", 0), _ = this.get("paddingRight", 0), m = this.get("paddingBottom", 0);
      this.children.each((v) => {
        if (v.get("position") != "absolute" && v.get("isMeasured")) {
          let b = v.adjustedLocalBounds(), y = v.x(), x = v.y(), D = y + b.left, A = y + b.right, C = x + b.top, O = x + b.bottom;
          o && (D -= v.get("marginLeft", 0), A += v.get("marginRight", 0)), l && (C -= v.get("marginTop", 0), O += v.get("marginBottom", 0)), D < h && (h = D), A > c && (c = A), C < f && (f = C), O > d && (d = O);
        }
      }), h == u && (h = 0), c == -u && (c = 0), f == u && (f = 0), d == -u && (d = 0), n.left = h - g, n.top = f - p, n.right = c + _, n.bottom = d + m;
    }
    this._contentWidth = n.right - n.left, this._contentHeight = n.bottom - n.top, S(e) && (n.left = 0, n.right = e), S(s) && (n.left = 0, n.right = s), S(t) && (n.top = 0, n.bottom = t), S(r) && (n.top = 0, n.bottom = r), this._localBounds = n;
  }
  _updateBounds() {
    const e = this.get("layout");
    e && e.updateContainer(this), super._updateBounds(), this.updateBackground();
  }
  /**
   * @ignore
   */
  markDirty() {
    super.markDirty(), this._root._addDirtyParent(this);
  }
  _prepareChildren() {
    const e = this.innerWidth(), t = this.innerHeight();
    if (e != this._prevWidth || t != this._prevHeight) {
      let s = this.get("layout"), r = !1, n = !1;
      s && ((s instanceof As || s instanceof Ki) && (r = !0), s instanceof Ls && (n = !0)), w(this._percentageSizeChildren, (a) => {
        if (!r) {
          let o = a.get("width");
          o instanceof ae && a.setPrivate("width", o.value * e);
        }
        if (!n) {
          let o = a.get("height");
          o instanceof ae && a.setPrivate("height", o.value * t);
        }
      }), w(this._percentagePositionChildren, (a) => {
        a.markDirtyPosition(), a.markDirtyBounds();
      }), this._prevWidth = e, this._prevHeight = t, this._sizeDirty = !0, this.updateBackground();
    }
    this._handleStates();
  }
  _updateChildren() {
    if (this.isDirty("html")) {
      const e = this.get("html");
      e && e !== "" ? this._root._setHTMLContent(this, nn(this, this.get("html", ""))) : this._root._removeHTMLContent(this), this._root._positionHTMLElement(this);
    }
    if (this.isDirty("verticalScrollbar")) {
      const e = this.get("verticalScrollbar");
      if (e) {
        e._setParent(this), e.startGrip.setPrivate("visible", !1), e.endGrip.setPrivate("visible", !1), this.set("maskContent", !0), this.set("paddingRight", e.width() + e.get("marginRight", 0) + e.get("marginLeft", 0));
        let t = this.get("background");
        t || (t = this.set("background", gt.new(this._root, {
          themeTags: ["background"],
          fillOpacity: 0,
          fill: this._root.interfaceColors.get("alternativeBackground")
        }))), this._vsbd0 = this.events.on("wheel", (s) => {
          const r = s.originalEvent;
          if (ko(r, this))
            r.preventDefault();
          else
            return;
          let n = r.deltaY / 5e3;
          const a = e.get("start", 0), o = e.get("end", 1);
          a + n <= 0 && (n = -a), o + n >= 1 && (n = 1 - o), a + n >= 0 && o + n <= 1 && (e.set("start", a + n), e.set("end", o + n));
        }), this._disposers.push(this._vsbd0), this._vsbd1 = e.events.on("rangechanged", () => {
          let s = this._contentHeight;
          const r = this._childrenDisplay, n = this._contentMask;
          r.y = -e.get("start") * s, r.markDirtyLayer(), n && (n._display.y = -r.y, r.mask = n._display);
        }), this._disposers.push(this._vsbd1), this._display.addChild(e._display);
      } else {
        const t = this._prevSettings.verticalScrollbar;
        if (t) {
          this._display.removeChild(t._display), this._vsbd0 && this._vsbd0.dispose(), this._vsbd1 && this._vsbd1.dispose();
          const s = this._childrenDisplay;
          s.y = 0, this.setPrivate("height", void 0), this.set("maskContent", !1), this.set("paddingRight", void 0);
        }
      }
    }
    if (this.isDirty("background")) {
      const e = this._prevSettings.background;
      e && this._display.removeChild(e._display);
      const t = this.get("background");
      t instanceof kt && (t.set("isMeasured", !1), t._setParent(this), this._display.addChildAt(t._display, 0));
    }
    if (this.isDirty("mask")) {
      const e = this.get("mask"), t = this._prevSettings.mask;
      if (t && (this._display.removeChild(t._display), t != e && t.dispose()), e) {
        const s = e.parent;
        s && s.children.removeValue(e), e._setParent(this), this._display.addChildAt(e._display, 0), this._childrenDisplay.mask = e._display;
      }
    }
  }
  _processTemplateField() {
    super._processTemplateField(), this.children.each((e) => {
      e._processTemplateField();
    });
  }
  /**
   * @ignore
   */
  walkChildren(e) {
    this.children.each((t) => {
      t instanceof G && t.walkChildren(e), e(t);
    });
  }
  eachChildren(e) {
    const t = this.get("background");
    t && e(t);
    const s = this.get("verticalScrollbar");
    s && e(s);
    const r = this.get("mask");
    r && e(r), this.children.values.forEach((n) => {
      e(n);
    });
  }
  allChildren() {
    const e = [];
    return this.eachChildren((t) => {
      e.push(t);
    }), e;
  }
  _setDataItem(e) {
    const t = e !== this._dataItem;
    super._setDataItem(e);
    const s = this.get("html", "");
    s && s !== "" && t && this._root._setHTMLContent(this, nn(this, s));
  }
}
Object.defineProperty(G, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Container"
});
Object.defineProperty(G, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: kt.classNames.concat([G.className])
});
class qi extends kt {
  constructor() {
    super(...arguments), Object.defineProperty(this, "textStyle", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._root._renderer.makeTextStyle()
    }), Object.defineProperty(this, "_display", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._root._renderer.makeText("", this.textStyle)
    }), Object.defineProperty(this, "_textStyles", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: [
        "textAlign",
        "fontFamily",
        "fontSize",
        "fontStyle",
        "fontWeight",
        "fontStyle",
        "fontVariant",
        "textDecoration",
        "shadowColor",
        "shadowBlur",
        "shadowOffsetX",
        "shadowOffsetY",
        "shadowOpacity",
        // "leading",
        // "letterSpacing",
        "lineHeight",
        "baselineRatio",
        //"padding",
        // "stroke",
        // "strokeThickness",
        // "trim",
        // "wordWrap",
        "direction",
        "textBaseline",
        "oversizedBehavior",
        "breakWords",
        "ellipsis",
        "minScale"
      ]
    }), Object.defineProperty(this, "_originalScale", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  _updateBounds() {
    if (this.get("text"))
      super._updateBounds();
    else {
      let e = {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
      };
      this._adjustedLocalBounds = e;
    }
  }
  _changed() {
    super._changed(), this._display.clear();
    let e = this.textStyle;
    if (this.isDirty("opacity")) {
      let t = this.get("opacity", 1);
      this._display.alpha = t;
    }
    if ((this.isDirty("text") || this.isDirty("populateText")) && (this._display.text = this._getText(), this.markDirtyBounds(), this.get("role") == "tooltip" && this._root.updateTooltip(this)), this.isPrivateDirty("tooltipElement") && this.getPrivate("tooltipElement") && this._disposers.push(new Ge(() => {
      this._root._removeTooltipElement(this);
    })), this.isDirty("width") && (e.wordWrapWidth = this.width(), this.markDirtyBounds()), this.isDirty("oversizedBehavior") && (e.oversizedBehavior = this.get("oversizedBehavior", "none"), this.markDirtyBounds()), this.isDirty("breakWords") && (e.breakWords = this.get("breakWords", !1), this.markDirtyBounds()), this.isDirty("ellipsis") && (e.ellipsis = this.get("ellipsis"), this.markDirtyBounds()), this.isDirty("ignoreFormatting") && (e.ignoreFormatting = this.get("ignoreFormatting", !1), this.markDirtyBounds()), this.isDirty("minScale") && (e.minScale = this.get("minScale", 0), this.markDirtyBounds()), this.isDirty("fill")) {
      let t = this.get("fill");
      t && (e.fill = t);
    }
    if (this.isDirty("fillOpacity")) {
      let t = this.get("fillOpacity", 1);
      t && (e.fillOpacity = t);
    }
    (this.isDirty("maxWidth") || this.isPrivateDirty("maxWidth")) && (e.maxWidth = this.get("maxWidth", this.getPrivate("maxWidth")), this.markDirtyBounds()), (this.isDirty("maxHeight") || this.isPrivateDirty("maxHeight")) && (e.maxHeight = this.get("maxHeight", this.getPrivate("maxHeight")), this.markDirtyBounds()), w(this._textStyles, (t) => {
      this._dirty[t] && (e[t] = this.get(t), this.markDirtyBounds());
    }), e.fontSize = this.get("fontSize"), e.fontFamily = this.get("fontFamily"), this._display.style = e, this.isDirty("role") && this.get("role") == "tooltip" && this._root.updateTooltip(this);
  }
  _getText() {
    const e = this.get("text", "");
    return this.get("populateText") ? nn(this, e) : e;
  }
  markDirtyText() {
    this._display.text = this._getText(), this.get("role") == "tooltip" && this._root.updateTooltip(this), this.markDirtyBounds(), this.markDirty();
  }
  _setDataItem(e) {
    super._setDataItem(e), this.get("populateText") && this.markDirtyText();
  }
  getNumberFormatter() {
    return this.parent ? this.parent.getNumberFormatter() : super.getNumberFormatter();
  }
  getDateFormatter() {
    return this.parent ? this.parent.getDateFormatter() : super.getDateFormatter();
  }
  getDurationFormatter() {
    return this.parent ? this.parent.getDurationFormatter() : super.getDurationFormatter();
  }
}
Object.defineProperty(qi, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Text"
});
Object.defineProperty(qi, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: kt.classNames.concat([qi.className])
});
class Sk {
  constructor() {
    Object.defineProperty(this, "_observer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_targets", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), this._observer = new ResizeObserver((e) => {
      w(e, (t) => {
        w(this._targets, (s) => {
          s.target === t.target && s.callback();
        });
      });
    });
  }
  addTarget(e, t) {
    this._observer.observe(e, { box: "border-box" }), this._targets.push({ target: e, callback: t });
  }
  removeTarget(e) {
    this._observer.unobserve(e), Tn(this._targets, (t) => t.target !== e);
  }
}
class Lo {
  constructor() {
    Object.defineProperty(this, "_timer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "_targets", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    });
  }
  addTarget(e, t) {
    if (this._timer === null) {
      let r = null;
      const n = () => {
        const a = Date.now();
        (r === null || a > r + Lo.delay) && (r = a, w(this._targets, (o) => {
          let l = o.target.getBoundingClientRect();
          (l.width !== o.size.width || l.height !== o.size.height) && (o.size = l, o.callback());
        })), this._targets.length === 0 ? this._timer = null : this._timer = requestAnimationFrame(n);
      };
      this._timer = requestAnimationFrame(n);
    }
    let s = { width: 0, height: 0, left: 0, right: 0, top: 0, bottom: 0, x: 0, y: 0 };
    this._targets.push({ target: e, callback: t, size: s });
  }
  removeTarget(e) {
    Tn(this._targets, (t) => t.target !== e), this._targets.length === 0 && this._timer !== null && (cancelAnimationFrame(this._timer), this._timer = null);
  }
}
Object.defineProperty(Lo, "delay", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 200
});
let Bn = null;
function Dk() {
  return Bn === null && (typeof ResizeObserver < "u" ? Bn = new Sk() : Bn = new Lo()), Bn;
}
class Ck {
  constructor(e, t) {
    Object.defineProperty(this, "_sensor", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_element", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_listener", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_disposed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), this._sensor = Dk(), this._element = e, this._listener = cc(t), this._sensor.addTarget(e, t);
  }
  isDisposed() {
    return this._disposed;
  }
  dispose() {
    this._disposed || (this._disposed = !0, this._sensor.removeTarget(this._element), this._listener.dispose());
  }
  get sensor() {
    return this._sensor;
  }
}
class an extends Oe {
}
Object.defineProperty(an, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "InterfaceColors"
});
Object.defineProperty(an, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Oe.classNames.concat([an.className])
});
class Je extends G {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_text", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_textKeys", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: [
        "text",
        "fill",
        "fillOpacity",
        "textAlign",
        "fontFamily",
        "fontSize",
        "fontStyle",
        "fontWeight",
        "fontStyle",
        "fontVariant",
        "textDecoration",
        "shadowColor",
        "shadowBlur",
        "shadowOffsetX",
        "shadowOffsetY",
        "shadowOpacity",
        // "leading",
        // "letterSpacing",
        "lineHeight",
        "baselineRatio",
        //"padding",
        // "stroke",
        // "strokeThickness",
        // "trim",
        // "wordWrap",
        "direction",
        "textBaseline",
        "oversizedBehavior",
        "breakWords",
        "ellipsis",
        "minScale",
        "populateText",
        "role",
        "ignoreFormatting"
      ]
    });
  }
  /**
   * @ignore Text is not to be used directly
   */
  get text() {
    return this._text;
  }
  _afterNew() {
    super._afterNew(), this._makeText(), w(this._textKeys, (e) => {
      const t = this.get(e);
      t != null && this._text.set(e, t);
    }), this.get("html", "") !== "" && this._text.set("text", ""), this.onPrivate("maxWidth", () => {
      this._setMaxDimentions();
    }), this.onPrivate("maxHeight", () => {
      this._setMaxDimentions();
    });
  }
  _makeText() {
    this._text = this.children.push(qi.new(this._root, {}));
  }
  _updateChildren() {
    if (super._updateChildren(), w(this._textKeys, (e) => {
      this._text.set(e, this.get(e));
    }), this.isDirty("maxWidth") && this._setMaxDimentions(), this.isDirty("maxHeight") && this._setMaxDimentions(), this.isDirty("rotation") && this._setMaxDimentions(), this.get("html", "") !== "" ? this._text.set("text", "") : this._text.set("text", this.get("text")), this.isDirty("textAlign") || this.isDirty("width")) {
      const e = this.get("textAlign");
      let t;
      this.get("width") != null ? e == "right" ? t = R : e == "center" ? t = le : t = 0 : e == "left" || e == "start" ? t = this.get("paddingLeft") : (e == "right" || e == "end") && (t = -this.get("paddingRight")), this.text.set("x", t);
    }
  }
  _setMaxDimentions() {
    const e = this.get("rotation"), t = e == 90 || e == 270 || e == -90, s = this.get("maxWidth", this.getPrivate("maxWidth", 1 / 0));
    S(s) ? this.text.set(t ? "maxHeight" : "maxWidth", s - this.get("paddingLeft", 0) - this.get("paddingRight", 0)) : this.text.set(t ? "maxHeight" : "maxWidth", void 0);
    const r = this.get("maxHeight", this.getPrivate("maxHeight", 1 / 0));
    S(r) ? this.text.set(t ? "maxWidth" : "maxHeight", r - this.get("paddingTop", 0) - this.get("paddingBottom", 0)) : this.text.set(t ? "maxWidth" : "maxHeight", void 0);
  }
  _setDataItem(e) {
    super._setDataItem(e), this._markDirtyKey("text"), this.text.get("populateText") && this.text.markDirtyText();
  }
  /**
   * Returns text with populated placeholders and formatting if `populateText` is
   * set to `true`.
   *
   * @return Populated text
   */
  getText() {
    return this._text._getText();
  }
}
Object.defineProperty(Je, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Label"
});
Object.defineProperty(Je, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: G.classNames.concat([Je.className])
});
class Ps extends ce {
  _beforeChanged() {
    super._beforeChanged(), (this.isDirty("pointerBaseWidth") || this.isDirty("cornerRadius") || this.isDirty("pointerLength") || this.isDirty("pointerX") || this.isDirty("pointerY") || this.isDirty("width") || this.isDirty("height")) && (this._clear = !0);
  }
  _changed() {
    if (super._changed(), this._clear) {
      this.markDirtyBounds();
      let e = this.width(), t = this.height();
      if (e > 0 && t > 0) {
        let s = this.get("cornerRadius", 8);
        s = Re(s, 0, Math.min(e / 2, t / 2));
        let r = this.get("pointerX", 0), n = this.get("pointerY", 0), a = this.get("pointerBaseWidth", 15) / 2, o = 0, l = 0, u = e, h = 0, c = e, f = t, d = 0, g = t, p = (r - o) * (f - l) - (n - l) * (c - o), _ = (r - d) * (h - g) - (n - g) * (u - d);
        const m = this._display;
        if (m.moveTo(s, 0), p > 0 && _ > 0) {
          let v = Math.round(Re(r, s + a, e - a - s));
          n = Re(n, -1 / 0, 0), m.lineTo(v - a, 0), m.lineTo(r, n), m.lineTo(v + a, 0);
        }
        if (m.lineTo(e - s, 0), m.arcTo(e, 0, e, s, s), p > 0 && _ < 0) {
          let v = Math.round(Re(n, s + a, t - a - s));
          r = Re(r, e, 1 / 0), m.lineTo(e, s), m.lineTo(e, Math.max(v - a, s)), m.lineTo(r, n), m.lineTo(e, v + a);
        }
        if (m.lineTo(e, t - s), m.arcTo(e, t, e - s, t, s), p < 0 && _ < 0) {
          let v = Math.round(Re(r, s + a, e - a - s));
          n = Re(n, t, 1 / 0), m.lineTo(e - s, t), m.lineTo(v + a, t), m.lineTo(r, n), m.lineTo(v - a, t);
        }
        if (m.lineTo(s, t), m.arcTo(0, t, 0, t - s, s), p < 0 && _ > 0) {
          let v = Math.round(Re(n, s + a, t - s - a));
          r = Re(r, -1 / 0, 0), m.lineTo(0, t - s), m.lineTo(0, v + a), m.lineTo(r, n), m.lineTo(0, Math.max(v - a, s));
        }
        m.lineTo(0, s), m.arcTo(0, 0, s, 0, s), m.closePath();
      }
    }
  }
}
Object.defineProperty(Ps, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "PointedRectangle"
});
Object.defineProperty(Ps, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: ce.classNames.concat([Ps.className])
});
class pi extends G {
  constructor(e, t, s, r = []) {
    super(e, t, s, r), Object.defineProperty(this, "_fx", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_fy", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_label", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_fillDp", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_strokeDp", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_labelDp", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_w", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_h", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_keepHoverDp", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_htmlContentHovered", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    });
  }
  _afterNew() {
    this._settings.themeTags = se(this._settings.themeTags, ["tooltip"]), super._afterNew(), this.set("background", Ps.new(this._root, {
      themeTags: ["tooltip", "background"]
    })), this._label = this.children.push(Je.new(this._root, {})), this._disposers.push(this._label.events.on("boundschanged", () => {
      this._updateBackground();
    })), this._disposers.push(this.on("bounds", () => {
      this._updateBackground();
    })), this._updateTextColor(), this._root.tooltipContainer.children.push(this), this.hide(0), this._disposers.push(this.label.onPrivate("htmlElement", (e) => {
      e && (Me(e, "pointerover", (t) => {
        this._htmlContentHovered = !0;
      }), Me(e, "pointerout", (t) => {
        this._htmlContentHovered = !1;
      }));
    })), this._root._tooltips.push(this);
  }
  /**
   * A [[Label]] element for the tooltip.
   *
   * @readonly
   * @return Label
   */
  get label() {
    return this._label;
  }
  /**
   * Permanently disposes the tooltip.
   */
  dispose() {
    super.dispose(), St(this._root._tooltips, this);
  }
  _updateChildren() {
    super._updateChildren(), (this.isDirty("pointerOrientation") || this.isPrivateDirty("minWidth") || this.isPrivateDirty("minHeight")) && this.get("background")._markDirtyKey("width"), this.get("labelText") != null && this.label.set("text", this.get("labelText")), this.get("labelHTML") != null && this.label.set("html", this.get("labelHTML"));
  }
  _changed() {
    if (super._changed(), (this.isDirty("pointTo") || this.isDirty("pointerOrientation")) && this._updateBackground(), this.isDirty("tooltipTarget") && this.updateBackgroundColor(), this.isDirty("keepTargetHover"))
      if (this.get("keepTargetHover")) {
        const t = this.get("background");
        this._keepHoverDp = new ut([
          t.events.on("pointerover", (s) => {
            let r = this.get("tooltipTarget");
            r && (r.parent && r.parent.getPrivate("tooltipTarget") == r && (r = r.parent), r.hover());
          }),
          t.events.on("pointerout", (s) => {
            let r = this.get("tooltipTarget");
            r && (r.parent && r.parent.getPrivate("tooltipTarget") == r && (r = r.parent), this._htmlContentHovered || r.unhover());
          })
        ]), this.label.onPrivate("htmlElement", (s) => {
          this._keepHoverDp && s && this._keepHoverDp.disposers.push(Me(s, "pointerleave", (r) => {
            const n = this.root._renderer.getEvent(r);
            t.events.dispatch("pointerout", {
              type: "pointerout",
              originalEvent: n.event,
              point: n.point,
              simulated: !1,
              target: t
            });
          }));
        });
      } else
        this._keepHoverDp && (this._keepHoverDp.dispose(), this._keepHoverDp = void 0);
  }
  _onShow() {
    super._onShow(), this.updateBackgroundColor();
  }
  updateBackgroundColor() {
    let e = this.get("tooltipTarget");
    const t = this.get("background");
    let s, r;
    e && t && (s = e.get("fill"), r = e.get("stroke"), s == null && (s = r), this.get("getFillFromSprite") && (this._fillDp && this._fillDp.dispose(), s != null && t.set("fill", s), this._fillDp = e.on("fill", (n) => {
      n != null && (t.set("fill", n), this._updateTextColor(n));
    }), this._disposers.push(this._fillDp)), this.get("getStrokeFromSprite") && (this._strokeDp && this._strokeDp.dispose(), s != null && t.set("stroke", s), this._strokeDp = e.on("fill", (n) => {
      n != null && t.set("stroke", n);
    }), this._disposers.push(this._strokeDp)), this.get("getLabelFillFromSprite") && (this._labelDp && this._labelDp.dispose(), s != null && this.label.set("fill", s), this._labelDp = e.on("fill", (n) => {
      n != null && this.label.set("fill", n);
    }), this._disposers.push(this._labelDp))), this._updateTextColor(s);
  }
  _updateTextColor(e) {
    this.get("autoTextColor") && (e == null && (e = this.get("background").get("fill")), e == null && (e = this._root.interfaceColors.get("background")), e instanceof V && this.label.set("fill", V.alternative(e, this._root.interfaceColors.get("alternativeText"), this._root.interfaceColors.get("text"))));
  }
  _setDataItem(e) {
    super._setDataItem(e), this.label._setDataItem(e);
  }
  _updateBackground() {
    super.updateBackground();
    const e = this._root.container;
    if (e) {
      let t = 0.5, s = 0.5, r = this.get("centerX");
      r instanceof ae && (t = r.value);
      let n = this.get("centerY");
      n instanceof ae && (s = n.value);
      let a = e.width(), o = e.height(), l = this.parent, u = 0, h = 0;
      if (l) {
        u = l.x(), h = l.y();
        const L = l.get("layerMargin");
        L && (u += L.left || 0, h += L.top || 0, a += (L.left || 0) + (L.right || 0), o += (L.top || 0) + (L.bottom || 0));
      }
      const c = this.get("bounds", { left: -u, top: -h, right: a - u, bottom: o - h });
      this._updateBounds();
      let f = this.width(), d = this.height();
      f === 0 && (f = this._w), d === 0 && (d = this._h);
      let g = this.get("pointTo", { x: a / 2, y: o / 2 }), p = g.x, _ = g.y, m = this.get("pointerOrientation"), v = this.get("background"), b = 0, y = 0, x = 0;
      v instanceof Ps && (b = v.get("pointerLength", 0), y = v.get("strokeWidth", 0) / 2, x = y, v.set("width", f), v.set("height", d));
      let D = 0, A = 0, C = c.right - c.left, O = c.bottom - c.top;
      m == "horizontal" || m == "left" || m == "right" ? (y = 0, m == "horizontal" ? p > c.left + C / 2 ? (p -= f * (1 - t) + b, x *= -1) : p += f * t + b : m == "left" ? p += f * (1 - t) + b : (p -= f * t + b, x *= -1)) : (x = 0, m == "vertical" ? _ > c.top + d / 2 + b ? _ -= d * (1 - s) + b : (_ += d * s + b, y *= -1) : m == "down" ? _ -= d * (1 - s) + b : (_ += d * s + b, y *= -1)), p = Re(p, c.left + f * t, c.left + C - f * (1 - t)) + x, _ = Re(_, c.top + d * s, c.top + O - d * (1 - s)) - y, D = g.x - p + f * t + x, A = g.y - _ + d * s - y, this._fx = p, this._fy = _;
      const T = this.get("animationDuration", 0);
      if (T > 0 && this.get("visible") && this.get("opacity") > 0.1) {
        const L = this.get("animationEasing");
        this.animate({ key: "x", to: p, duration: T, easing: L }), this.animate({ key: "y", to: _, duration: T, easing: L });
      } else
        this.set("x", p), this.set("y", _);
      v instanceof Ps && (v.set("pointerX", D), v.set("pointerY", A)), f > 0 && (this._w = f), d > 0 && (this._h = d);
    }
  }
}
Object.defineProperty(pi, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Tooltip"
});
Object.defineProperty(pi, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: G.classNames.concat([pi.className])
});
class pp extends Oe {
  _setDefaults() {
    this._setDefault("negativeBase", 0), this._setDefault("numberFormat", "#,###.#####"), this._setDefault("smallNumberThreshold", 1);
    const e = "_big_number_suffix_", t = "_small_number_suffix_", s = "_byte_suffix_";
    this._setDefault("bigNumberPrefixes", [
      { number: 1e3, suffix: this._t(e + "3") },
      { number: 1e6, suffix: this._t(e + "6") },
      { number: 1e9, suffix: this._t(e + "9") },
      { number: 1e12, suffix: this._t(e + "12") },
      { number: 1e15, suffix: this._t(e + "15") },
      { number: 1e18, suffix: this._t(e + "18") },
      { number: 1e21, suffix: this._t(e + "21") },
      { number: 1e24, suffix: this._t(e + "24") }
    ]), this._setDefault("smallNumberPrefixes", [
      { number: 1e-24, suffix: this._t(t + "24") },
      { number: 1e-21, suffix: this._t(t + "21") },
      { number: 1e-18, suffix: this._t(t + "18") },
      { number: 1e-15, suffix: this._t(t + "15") },
      { number: 1e-12, suffix: this._t(t + "12") },
      { number: 1e-9, suffix: this._t(t + "9") },
      { number: 1e-6, suffix: this._t(t + "6") },
      { number: 1e-3, suffix: this._t(t + "3") }
    ]), this._setDefault("bytePrefixes", [
      { number: 1, suffix: this._t(s + "B") },
      { number: 1024, suffix: this._t(s + "KB") },
      { number: 1048576, suffix: this._t(s + "MB") },
      { number: 1073741824, suffix: this._t(s + "GB") },
      { number: 1099511627776, suffix: this._t(s + "TB") },
      { number: 1125899906842624, suffix: this._t(s + "PB") }
    ]), super._setDefaults();
  }
  _beforeChanged() {
    super._beforeChanged();
  }
  /**
   * Formats the number according to specific format.
   *
   * @param value   Value to format
   * @param format  Format to apply
   * @return Formatted number
   */
  format(e, t, s) {
    (t == null || Gi(t) && t.toLowerCase() === "number") && (t = this.get("numberFormat", ""));
    let r, n = Number(e);
    if (Ys(t))
      try {
        return this.get("intlLocales") ? new Intl.NumberFormat(this.get("intlLocales"), t).format(n) : new Intl.NumberFormat(void 0, t).format(n);
      } catch {
        return "Invalid";
      }
    else {
      t = Po(t);
      let a = this.parseFormat(t, this._root.language), o;
      n > this.get("negativeBase") ? o = a.positive : n < this.get("negativeBase") ? o = a.negative : o = a.zero, s != null && !o.mod && (o = zi(o), o.decimals.active = n == 0 ? 0 : s), r = o.template.split(Oi).join(this.applyFormat(n, o));
    }
    return this.get("forceLTR") === !0 && (r = "‎" + r), r;
  }
  /**
   * Parses supplied format into structured object which can be used to format
   * the number.
   *
   * @param format Format string, i.e. "#,###.00"
   * @param language Language
   * @ignore
   */
  parseFormat(e, t) {
    const s = t.translateEmpty("_thousandSeparator"), r = t.translateEmpty("_decimalSeparator");
    let n = {
      positive: {
        thousands: {
          active: -1,
          passive: -1,
          interval: -1,
          separator: s
        },
        decimals: {
          active: -1,
          passive: -1,
          separator: r
        },
        template: "",
        source: "",
        parsed: !1
      },
      negative: {
        thousands: {
          active: -1,
          passive: -1,
          interval: -1,
          separator: s
        },
        decimals: {
          active: -1,
          passive: -1,
          separator: r
        },
        template: "",
        source: "",
        parsed: !1
      },
      zero: {
        thousands: {
          active: -1,
          passive: -1,
          interval: -1,
          separator: s
        },
        decimals: {
          active: -1,
          passive: -1,
          separator: r
        },
        template: "",
        source: "",
        parsed: !1
      }
    };
    e = e.replace("||", Ss);
    let a = e.split("|");
    return n.positive.source = a[0], typeof a[2] > "u" ? n.zero = n.positive : n.zero.source = a[2], typeof a[1] > "u" ? n.negative = n.positive : n.negative.source = a[1], ye(n, (o, l) => {
      if (l.parsed)
        return;
      let u = l.source;
      u.toLowerCase() === "number" && (u = this.get("numberFormat", "#,###.#####"));
      let h = Ht.chunk(u, !0);
      for (let c = 0; c < h.length; c++) {
        let f = h[c];
        if (f.text = f.text.replace(Ss, "|"), f.type === "value") {
          let d = f.text.match(/[#0.,]+[ ]?[abespABESP%!]?[abespABESP‰!]?/);
          if (d)
            if (d === null || d[0] === "")
              l.template += f.text;
            else {
              let g = d[0].match(/[abespABESP%‰!]{2}|[abespABESP%‰]{1}$/);
              g && (l.mod = g[0].toLowerCase(), l.modSpacing = !!d[0].match(/[ ]{1}[abespABESP%‰!]{1}$/));
              let p = d[0].split(".");
              if (p[0] !== "") {
                l.thousands.active = (p[0].match(/0/g) || []).length, l.thousands.passive = (p[0].match(/\#/g) || []).length + l.thousands.active;
                let _ = p[0].split(",");
                _.length === 1 || (l.thousands.interval = (_.pop() || "").length, l.thousands.interval === 0 && (l.thousands.interval = -1));
              }
              typeof p[1] > "u" || (l.decimals.active = (p[1].match(/0/g) || []).length, l.decimals.passive = (p[1].match(/\#/g) || []).length + l.decimals.active), l.template += f.text.split(d[0]).join(Oi);
            }
        } else
          l.template += f.text;
      }
      l.parsed = !0;
    }), n;
  }
  /**
   * Applies parsed format to a numeric value.
   *
   * @param value    Value
   * @param details  Parsed format as returned by parseFormat()
   * @return Formatted number
   * @ignore
   */
  applyFormat(e, t) {
    let s = e < 0;
    e = Math.abs(e);
    let r = "", n = "", a = t.mod ? t.mod.split("") : [];
    if (a.indexOf("b") !== -1) {
      let c = this.applyPrefix(e, this.get("bytePrefixes"), a.indexOf("!") !== -1);
      e = c[0], r = c[1], n = c[2], t.modSpacing && (n = " " + n);
    } else if (a.indexOf("a") !== -1) {
      let c = this.applyPrefix(e, e < this.get("smallNumberThreshold") ? this.get("smallNumberPrefixes") : this.get("bigNumberPrefixes"), a.indexOf("!") !== -1);
      e = c[0], r = c[1], n = c[2], t.modSpacing && (n = " " + n);
    } else if (a.indexOf("p") !== -1) {
      let c = Math.min(e.toString().length + 2, 21);
      e = parseFloat(e.toPrecision(c)), r = this._root.language.translate("_percentPrefix"), n = this._root.language.translate("_percentSuffix"), r == "" && n == "" && (n = "%");
    } else if (a.indexOf("%") !== -1) {
      let c = Math.min(e.toString().length + 2, 21);
      e *= 100, e = parseFloat(e.toPrecision(c)), n = "%";
    } else if (a.indexOf("‰") !== -1) {
      let c = Math.min(e.toString().length + 3, 21);
      e *= 1e3, e = parseFloat(e.toPrecision(c)), n = "‰";
    }
    if (a.indexOf("e") !== -1) {
      let c;
      t.decimals.passive >= 0 ? c = e.toExponential(t.decimals.passive).split("e") : c = e.toExponential().split("e"), e = Number(c[0]), n = "e" + c[1], t.modSpacing && (n = " " + n);
    } else if (t.decimals.passive === 0)
      e = Math.round(e);
    else if (t.decimals.passive > 0) {
      let c = Math.pow(10, t.decimals.passive);
      e = Math.round(e * c) / c;
    }
    let o = "", l = Tf(e).split("."), u = l[0];
    if (u.length < t.thousands.active && (u = Array(t.thousands.active - u.length + 1).join("0") + u), t.thousands.interval > 0) {
      let c = [], f = u.split("").reverse().join("");
      for (let d = 0, g = u.length; d <= g; d += t.thousands.interval) {
        let p = f.substr(d, t.thousands.interval).split("").reverse().join("");
        p !== "" && c.unshift(p);
      }
      u = c.join(t.thousands.separator);
    }
    o += u, l.length === 1 && l.push("");
    let h = l[1];
    return h.length < t.decimals.active && (h += Array(t.decimals.active - h.length + 1).join("0")), h !== "" && (o += t.decimals.separator + h), o === "" && (o = "0"), e !== 0 && s && a.indexOf("s") === -1 && (o = "-" + o), r && (o = r + o), n && (o += n), o;
  }
  applyPrefix(e, t, s = !1) {
    let r = e, n = "", a = "", o = !1, l = 1;
    for (let u = 0, h = t.length; u < h; u++)
      t[u].number <= e && (t[u].number === 0 ? r = 0 : (r = e / t[u].number, l = t[u].number), n = t[u].prefix, a = t[u].suffix, o = !0);
    return !o && s && t.length && e != 0 && (r = e / t[0].number, n = t[0].prefix, a = t[0].suffix, o = !0), o && (r = parseFloat(r.toPrecision(Math.min(l.toString().length + Math.floor(r).toString().replace(/[^0-9]*/g, "").length, 21)))), [r, n, a];
  }
  /**
   * Replaces brackets with temporary placeholders.
   *
   * @ignore Exclude from docs
   * @param text  Input text
   * @return Escaped text
   */
  escape(e) {
    return e.replace("||", Ss);
  }
  /**
   * Replaces placeholders back to brackets.
   *
   * @ignore Exclude from docs
   * @param text  Escaped text
   * @return Unescaped text
   */
  unescape(e) {
    return e.replace(Ss, "|");
  }
}
function gp(i, e) {
  let t = 0, s = 0, r = 1, n = 0, a = 0, o = 0, l = 0, u = 0;
  return i.formatToParts(e).forEach((h) => {
    switch (h.type) {
      case "year":
        t = +h.value;
        break;
      case "month":
        s = +h.value - 1;
        break;
      case "day":
        r = +h.value;
        break;
      case "hour":
        n = +h.value;
        break;
      case "minute":
        a = +h.value;
        break;
      case "second":
        o = +h.value;
        break;
      case "fractionalSecond":
        l = +h.value;
        break;
      case "weekday":
        switch (h.value) {
          case "Sun":
            u = 0;
            break;
          case "Mon":
            u = 1;
            break;
          case "Tue":
            u = 2;
            break;
          case "Wed":
            u = 3;
            break;
          case "Thu":
            u = 4;
            break;
          case "Fri":
            u = 5;
            break;
          case "Sat":
            u = 6;
            break;
        }
    }
  }), n === 24 && (n = 0), { year: t, month: s, day: r, hour: n, minute: a, second: o, millisecond: l, weekday: u };
}
function fh(i, e) {
  const { year: t, month: s, day: r, hour: n, minute: a, second: o, millisecond: l } = gp(i, e);
  return Date.UTC(t, s, r, n, a, o, l);
}
class _p {
  constructor(e, t) {
    if (Object.defineProperty(this, "_utc", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_dtf", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), !t)
      throw new Error("You cannot use `new Class()`, instead use `Class.new()`");
    this.name = e, this._utc = new Intl.DateTimeFormat("UTC", {
      hour12: !1,
      timeZone: "UTC",
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
      weekday: "short",
      fractionalSecondDigits: 3
    }), this._dtf = new Intl.DateTimeFormat("UTC", {
      hour12: !1,
      timeZone: e,
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
      weekday: "short",
      fractionalSecondDigits: 3
    });
  }
  /**
   * Use this method to create an instance of this class.
   *
   * @see {@link https://www.amcharts.com/docs/v5/getting-started/#New_element_syntax} for more info
   * @param   timezone  IANA timezone
   * @return            Instantiated object
   */
  static new(e) {
    return new this(e, !0);
  }
  convertLocal(e) {
    const t = this.offsetUTC(e), s = e.getTimezoneOffset(), r = new Date(e);
    r.setUTCMinutes(r.getUTCMinutes() - (t - s));
    const n = r.getTimezoneOffset();
    return s != n && r.setUTCMinutes(r.getUTCMinutes() + n - s), r;
  }
  offsetUTC(e) {
    const t = fh(this._utc, e), s = fh(this._dtf, e);
    return (t - s) / 6e4;
  }
  parseDate(e) {
    return gp(this._dtf, e);
  }
}
class mp extends Oe {
  _setDefaults() {
    this._setDefault("capitalize", !0), this._setDefault("dateFormat", "yyyy-MM-dd"), super._setDefaults();
  }
  _beforeChanged() {
    super._beforeChanged();
  }
  format(e, t) {
    (typeof t > "u" || t === "") && (t = this.get("dateFormat", "yyyy-MM-dd"));
    let s, r = e;
    if (Ys(t))
      try {
        const o = this.get("intlLocales");
        return o ? new Intl.DateTimeFormat(o, t).format(r) : new Intl.DateTimeFormat(void 0, t).format(r);
      } catch {
        return "Invalid";
      }
    let n = this.parseFormat(t);
    const a = this._root.timezone;
    return a && !this._root.utc && (r = a.convertLocal(r)), S(r.getTime()) ? (s = this.applyFormat(r, n), this.get("capitalize") && (s = s.replace(/^.{1}/, s.substr(0, 1).toUpperCase())), s) : "Invalid date";
  }
  /**
   * Applies format to Date.
   *
   * @param date      Date object
   * @param info      Parsed format information
   * @return Formatted date string
   */
  applyFormat(e, t) {
    let s = t.template, r, n, a, o, l, u, h, c, f = e.getTime();
    this._root.utc ? (r = e.getUTCFullYear(), n = e.getUTCMonth(), a = e.getUTCDay(), o = e.getUTCDate(), l = e.getUTCHours(), u = e.getUTCMinutes(), h = e.getUTCSeconds(), c = e.getUTCMilliseconds()) : (r = e.getFullYear(), n = e.getMonth(), a = e.getDay(), o = e.getDate(), l = e.getHours(), u = e.getMinutes(), h = e.getSeconds(), c = e.getMilliseconds());
    for (let d = 0, g = t.parts.length; d < g; d++) {
      let p = "";
      switch (t.parts[d]) {
        case "G":
          p = this._t(r < 0 ? "_era_bc" : "_era_ad");
          break;
        case "yyyy":
          p = Math.abs(r).toString(), r < 0 && (p += this._t("_era_bc"));
          break;
        case "yyy":
        case "yy":
        case "y":
          p = Math.abs(r).toString().substr(-t.parts[d].length), r < 0 && (p += this._t("_era_bc"));
          break;
        case "YYYY":
        case "YYY":
        case "YY":
        case "Y":
          let _ = Gf(e, this._root.utc);
          t.parts[d] == "YYYY" ? p = Math.abs(_).toString() : p = Math.abs(_).toString().substr(-t.parts[d].length), _ < 0 && (p += this._t("_era_bc"));
          break;
        case "u":
          break;
        case "q":
          p = "" + Math.ceil((e.getMonth() + 1) / 3);
          break;
        case "MMMMM":
          p = this._t(this._getMonth(n)).substr(0, 1);
          break;
        case "MMMM":
          p = this._t(this._getMonth(n));
          break;
        case "MMM":
          p = this._t(this._getShortMonth(n));
          break;
        case "MM":
          p = Fe(n + 1, 2, "0");
          break;
        case "M":
          p = (n + 1).toString();
          break;
        case "ww":
          p = Fe(ur(e, this._root.utc), 2, "0");
          break;
        case "w":
          p = ur(e, this._root.utc).toString();
          break;
        case "W":
          p = Zf(e, this._root.utc).toString();
          break;
        case "dd":
          p = Fe(o, 2, "0");
          break;
        case "d":
          p = o.toString();
          break;
        case "DD":
        case "DDD":
          p = Fe(Zl(e, this._root.utc).toString(), t.parts[d].length, "0");
          break;
        case "D":
          p = Zl(e, this._root.utc).toString();
          break;
        case "F":
          break;
        case "g":
          break;
        case "t":
          p = this._root.language.translateFunc("_dateOrd").call(this, o);
          break;
        case "E":
          p = (a || 7).toString();
          break;
        case "EE":
          p = Fe((a || 7).toString(), 2, "0");
          break;
        case "EEE":
        case "eee":
          p = this._t(this._getShortWeekday(a));
          break;
        case "EEEE":
        case "eeee":
          p = this._t(this._getWeekday(a));
          break;
        case "EEEEE":
        case "eeeee":
          p = this._t(this._getShortWeekday(a)).substr(0, 1);
          break;
        case "e":
        case "ee":
          p = (a - (this._root.locale.firstDayOfWeek || 1) + 1).toString(), t.parts[d] == "ee" && (p = Fe(p, 2, "0"));
          break;
        case "a":
          l >= 12 ? p = this._t("PM") : p = this._t("AM");
          break;
        case "aa":
          l >= 12 ? p = this._t("P.M.") : p = this._t("A.M.");
          break;
        case "aaa":
          l >= 12 ? p = this._t("P") : p = this._t("A");
          break;
        case "h":
          p = Br(l).toString();
          break;
        case "hh":
          p = Fe(Br(l), 2, "0");
          break;
        case "H":
          p = l.toString();
          break;
        case "HH":
          p = Fe(l, 2, "0");
          break;
        case "K":
          p = Br(l, 0).toString();
          break;
        case "KK":
          p = Fe(Br(l, 0), 2, "0");
          break;
        case "k":
          p = (l + 1).toString();
          break;
        case "kk":
          p = Fe(l + 1, 2, "0");
          break;
        case "m":
          p = u.toString();
          break;
        case "mm":
          p = Fe(u, 2, "0");
          break;
        case "s":
          p = h.toString();
          break;
        case "ss":
          p = Fe(h, 2, "0");
          break;
        case "S":
        case "SS":
        case "SSS":
          p = Math.round(c / 1e3 * Math.pow(10, t.parts[d].length)).toString();
          break;
        case "x":
          p = f.toString();
          break;
        case "n":
        case "nn":
        case "nnn":
          p = Fe(c, t.parts[d].length, "0");
          break;
        case "z":
          p = Hr(e, !1, !1, this._root.utc);
          break;
        case "zz":
          p = Hr(e, !0, !1, this._root.utc);
          break;
        case "zzz":
          p = Hr(e, !1, !0, this._root.utc);
          break;
        case "zzzz":
          p = Hr(e, !0, !0, this._root.utc);
          break;
        case "Z":
        case "ZZ":
          let m = this._root.utc ? "UTC" : this._root.timezone;
          m instanceof _p && (m = m.name);
          const v = m ? qf(m) : e.getTimezoneOffset();
          let b = Math.abs(v) / 60, y = Math.floor(b), x = b * 60 - y * 60;
          this._root.utc && (y = 0, x = 0), t.parts[d] == "Z" ? (p = "GMT", p += v > 0 ? "-" : "+", p += Fe(y, 2) + ":" + Fe(x, 2)) : (p = v > 0 ? "-" : "+", p += Fe(y, 2) + Fe(x, 2));
          break;
        case "i":
          p = e.toISOString();
          break;
        case "I":
          p = e.toUTCString();
          break;
      }
      s = s.replace(Oi, p);
    }
    return s;
  }
  /**
   * Parses format into structured infromation.
   *
   * @param format Format template
   */
  parseFormat(e) {
    let t = {
      template: "",
      parts: []
    }, s = Ht.chunk(e, !0);
    for (let r = 0; r < s.length; r++) {
      let n = s[r];
      if (n.type === "value") {
        if (n.text.match(/^date$/i)) {
          let o = this.get("dateFormat", "yyyy-MM-dd");
          Gi(o) || (o = "yyyy-MM-dd"), n.text = o;
        }
        let a = n.text.match(/G|yyyy|yyy|yy|y|YYYY|YYY|YY|Y|u|q|MMMMM|MMMM|MMM|MM|M|ww|w|W|dd|d|DDD|DD|D|F|g|EEEEE|EEEE|EEE|EE|E|eeeee|eeee|eee|ee|e|aaa|aa|a|hh|h|HH|H|KK|K|kk|k|mm|m|ss|s|SSS|SS|S|A|zzzz|zzz|zz|z|ZZ|Z|t|x|nnn|nn|n|i|I/g);
        if (a)
          for (let o = 0; o < a.length; o++)
            t.parts.push(a[o]), n.text = n.text.replace(a[o], Oi);
      }
      t.template += n.text;
    }
    return t;
  }
  _months() {
    return ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
  }
  _getMonth(e) {
    return this._months()[e];
  }
  _shortMonths() {
    return ["Jan", "Feb", "Mar", "Apr", "May(short)", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
  }
  _getShortMonth(e) {
    return this._shortMonths()[e];
  }
  _weekdays() {
    return ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
  }
  _getWeekday(e) {
    return this._weekdays()[e];
  }
  _shortWeekdays() {
    return ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
  }
  _getShortWeekday(e) {
    return this._shortWeekdays()[e];
  }
  parse(e, t) {
    if (e instanceof Date)
      return e;
    if (S(e))
      return new Date(e);
    Gi(e) || (e = e.toString());
    let s, r = "";
    t = Po(t), t = t.substr(0, e.length);
    let n = this.parseFormat(t), a = {
      year: -1,
      year3: -1,
      year2: -1,
      year1: -1,
      month: -1,
      monthShort: -1,
      monthLong: -1,
      weekdayShort: -1,
      weekdayLong: -1,
      day: -1,
      yearDay: -1,
      week: -1,
      hourBase0: -1,
      hour12Base0: -1,
      hourBase1: -1,
      hour12Base1: -1,
      minute: -1,
      second: -1,
      millisecond: -1,
      millisecondDigits: -1,
      am: -1,
      zone: -1,
      timestamp: -1,
      iso: -1
    }, o = {
      year: 1970,
      month: 0,
      day: 1,
      hour: 0,
      minute: 0,
      second: 0,
      millisecond: 0,
      timestamp: null,
      offset: 0,
      utc: this._root.utc
    }, l = 0, u = 0;
    for (let f = 0; f < n.parts.length; f++) {
      switch (u = f + l + 1, n.parts[f]) {
        case "yyyy":
        case "YYYY":
          r += "([0-9]{4})", a.year = u;
          break;
        case "yyy":
        case "YYY":
          r += "([0-9]{3})", a.year3 = u;
          break;
        case "yy":
        case "YY":
          r += "([0-9]{2})", a.year2 = u;
          break;
        case "y":
        case "Y":
          r += "([0-9]{1})", a.year1 = u;
          break;
        case "MMMM":
          r += "(" + this.getStringList(this._months()).join("|") + ")", a.monthLong = u;
          break;
        case "MMM":
          r += "(" + this.getStringList(this._shortMonths()).join("|") + ")", a.monthShort = u;
          break;
        case "MM":
        case "M":
          r += "([0-9]{2}|[0-9]{1})", a.month = u;
          break;
        case "ww":
        case "w":
          r += "([0-9]{2}|[0-9]{1})", a.week = u;
          break;
        case "dd":
        case "d":
          r += "([0-9]{2}|[0-9]{1})", a.day = u;
          break;
        case "DDD":
        case "DD":
        case "D":
          r += "([0-9]{3}|[0-9]{2}|[0-9]{1})", a.yearDay = u;
          break;
        case "dddd":
          r += "(" + this.getStringList(this._weekdays()).join("|") + ")", a.weekdayLong = u;
          break;
        case "ddd":
          r += "(" + this.getStringList(this._shortWeekdays()).join("|") + ")", a.weekdayShort = u;
          break;
        case "aaa":
        case "aa":
        case "a":
          r += "(" + this.getStringList(["AM", "PM", "A.M.", "P.M.", "A", "P"]).join("|") + ")", a.am = u;
          break;
        case "hh":
        case "h":
          r += "([0-9]{2}|[0-9]{1})", a.hour12Base1 = u;
          break;
        case "HH":
        case "H":
          r += "([0-9]{2}|[0-9]{1})", a.hourBase0 = u;
          break;
        case "KK":
        case "K":
          r += "([0-9]{2}|[0-9]{1})", a.hour12Base0 = u;
          break;
        case "kk":
        case "k":
          r += "([0-9]{2}|[0-9]{1})", a.hourBase1 = u;
          break;
        case "mm":
        case "m":
          r += "([0-9]{2}|[0-9]{1})", a.minute = u;
          break;
        case "ss":
        case "s":
          r += "([0-9]{2}|[0-9]{1})", a.second = u;
          break;
        case "SSS":
        case "SS":
        case "S":
          r += "([0-9]{3}|[0-9]{2}|[0-9]{1})", a.millisecond = u, a.millisecondDigits = n.parts[f].length;
          break;
        case "nnn":
        case "nn":
        case "n":
          r += "([0-9]{3}|[0-9]{2}|[0-9]{1})", a.millisecond = u;
          break;
        case "x":
          r += "([0-9]{1,})", a.timestamp = u;
          break;
        case "Z":
          r += "GMT([-+]+[0-9]{2}:[0-9]{2})", a.zone = u;
          break;
        case "ZZ":
          r += "([\\-+]+[0-9]{2}[0-9]{2})", a.zone = u;
          break;
        case "i":
          r += "([0-9]{4})-?([0-9]{2})-?([0-9]{2})T?([0-9]{2}):?([0-9]{2}):?([0-9]{2})\\.?([0-9]{0,3})([zZ]|[+\\-][0-9]{2}:?[0-9]{2}|$)", a.iso = u, l += 7;
          break;
        case "G":
        case "YYYY":
        case "YYY":
        case "YY":
        case "Y":
        case "MMMMM":
        case "W":
        case "EEEEE":
        case "EEEE":
        case "EEE":
        case "EE":
        case "E":
        case "eeeee":
        case "eeee":
        case "eee":
        case "ee":
        case "e":
        case "zzzz":
        case "zzz":
        case "zz":
        case "z":
        case "t":
          l--;
          break;
      }
      r += "[^0-9]*";
    }
    let h = new RegExp(r), c = e.match(h);
    if (c) {
      if (a.year > -1 && (o.year = parseInt(c[a.year])), a.year3 > -1) {
        let f = parseInt(c[a.year3]);
        f += 1e3, o.year = f;
      }
      if (a.year2 > -1) {
        let f = parseInt(c[a.year2]);
        f > 50 ? f += 1e3 : f += 2e3, o.year = f;
      }
      if (a.year1 > -1) {
        let f = parseInt(c[a.year1]);
        f = Math.floor((/* @__PURE__ */ new Date()).getFullYear() / 10) * 10 + f, o.year = f;
      }
      if (a.monthLong > -1 && (o.month = this.resolveMonth(c[a.monthLong])), a.monthShort > -1 && (o.month = this.resolveShortMonth(c[a.monthShort])), a.month > -1 && (o.month = parseInt(c[a.month]) - 1), a.week > -1 && a.day === -1 && (o.month = 0, o.day = Kf(parseInt(c[a.week]), o.year, 1, this._root.utc)), a.day > -1 && (o.day = parseInt(c[a.day])), a.yearDay > -1 && (o.month = 0, o.day = parseInt(c[a.yearDay])), a.hourBase0 > -1 && (o.hour = parseInt(c[a.hourBase0])), a.hourBase1 > -1 && (o.hour = parseInt(c[a.hourBase1]) - 1), a.hour12Base0 > -1) {
        let f = parseInt(c[a.hour12Base0]);
        f == 11 && (f = 0), a.am > -1 && !this.isAm(c[a.am]) && (f += 12), o.hour = f;
      }
      if (a.hour12Base1 > -1) {
        let f = parseInt(c[a.hour12Base1]);
        f == 12 && (f = 0), a.am > -1 && !this.isAm(c[a.am]) && (f += 12), o.hour = f;
      }
      if (a.minute > -1 && (o.minute = parseInt(c[a.minute])), a.second > -1 && (o.second = parseInt(c[a.second])), a.millisecond > -1) {
        let f = parseInt(c[a.millisecond]);
        a.millisecondDigits == 2 ? f *= 10 : a.millisecondDigits == 1 && (f *= 100), o.millisecond = f;
      }
      if (a.timestamp > -1) {
        o.timestamp = parseInt(c[a.timestamp]);
        const f = new Date(o.timestamp);
        o.year = f.getUTCFullYear(), o.month = f.getUTCMonth(), o.day = f.getUTCDate(), o.hour = f.getUTCHours(), o.minute = f.getUTCMinutes(), o.second = f.getUTCSeconds(), o.millisecond = f.getUTCMilliseconds();
      }
      a.zone > -1 && (o.offset = this.resolveTimezoneOffset(new Date(o.year, o.month, o.day), c[a.zone])), a.iso > -1 && (o.year = yt(c[a.iso + 0]), o.month = yt(c[a.iso + 1]) - 1, o.day = yt(c[a.iso + 2]), o.hour = yt(c[a.iso + 3]), o.minute = yt(c[a.iso + 4]), o.second = yt(c[a.iso + 5]), o.millisecond = yt(c[a.iso + 6]), c[a.iso + 7] == "Z" || c[a.iso + 7] == "z" ? o.utc = !0 : c[a.iso + 7] != "" && (o.offset = this.resolveTimezoneOffset(new Date(o.year, o.month, o.day), c[a.iso + 7]))), o.utc ? s = new Date(Date.UTC(o.year, o.month, o.day, o.hour, o.minute, o.second, o.millisecond)) : s = new Date(o.year, o.month, o.day, o.hour, o.minute + o.offset, o.second, o.millisecond);
    } else
      s = new Date(e);
    return s;
  }
  resolveTimezoneOffset(e, t) {
    if (t.match(/([+\-]?)([0-9]{2}):?([0-9]{2})/)) {
      let r = t.match(/([+\-]?)([0-9]{2}):?([0-9]{2})/), n = r[1], a = r[2], o = r[3], l = parseInt(a) * 60 + parseInt(o);
      n == "+" && (l *= -1);
      let u = (e || /* @__PURE__ */ new Date()).getTimezoneOffset();
      return l - u;
    }
    return 0;
  }
  /**
   * Resolves month name (i.e. "December") into a month number (11).
   *
   * @param value  Month name
   * @return Month number
   */
  resolveMonth(e) {
    let t = this._months().indexOf(e);
    return t > -1 || !this._root.language.isDefault() && (t = this._root.language.translateAll(this._months()).indexOf(e), t > -1) ? t : 0;
  }
  /**
   * Resolves short month name (i.e. "Dec") into a month number.
   *
   * @param value  Short month name
   * @return Month number
   */
  resolveShortMonth(e) {
    let t = this._shortMonths().indexOf(e);
    return t > -1 || (t = this._months().indexOf(e), t > -1) || this._root.language && !this._root.language.isDefault() && (t = this._root.language.translateAll(this._shortMonths()).indexOf(e), t > -1) ? t : 0;
  }
  /**
   * Checks if passed in string represents AM/PM notation in many of its
   * versions.
   *
   * @param value  Source string
   * @return Is it AM/PM?
   */
  isAm(e) {
    return this.getStringList(["AM", "A.M.", "A"]).indexOf(e.toUpperCase()) > -1;
  }
  /**
   * Translates list of strings.
   *
   * @param list  Source strings
   * @return Translated strings
   */
  getStringList(e) {
    let t = [];
    for (let s = 0; s < e.length; s++)
      this._root.language ? t.push(Gl(this._t(e[s]))) : t.push(Gl(e[s]));
    return t;
  }
}
class bp extends Oe {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_unitAliases", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {
        Y: "y",
        D: "d",
        H: "h",
        K: "h",
        k: "h",
        n: "S"
      }
    });
  }
  _setDefaults() {
    const e = "_duration_millisecond", t = "_duration_second", s = "_duration_minute", r = "_duration_hour", n = "_duration_day", a = "_duration_week", o = "_duration_month", l = "_duration_year", u = "_second", h = "_minute", c = "_hour", f = "_day", d = "_week", g = "_week", p = "_year";
    this._setDefault("negativeBase", 0), this._setDefault("baseUnit", "second"), this._setDefault("durationFormats", {
      millisecond: {
        millisecond: this._t(e),
        second: this._t(e + u),
        minute: this._t(e + h),
        hour: this._t(e + c),
        day: this._t(e + f),
        week: this._t(e + d),
        month: this._t(e + g),
        year: this._t(e + p)
      },
      second: {
        second: this._t(t),
        minute: this._t(t + h),
        hour: this._t(t + c),
        day: this._t(t + f),
        week: this._t(t + d),
        month: this._t(t + g),
        year: this._t(t + p)
      },
      minute: {
        minute: this._t(s),
        hour: this._t(s + c),
        day: this._t(s + f),
        week: this._t(s + d),
        month: this._t(s + g),
        year: this._t(s + p)
      },
      hour: {
        hour: this._t(r),
        day: this._t(r + f),
        week: this._t(r + d),
        month: this._t(r + g),
        year: this._t(r + p)
      },
      day: {
        day: this._t(n),
        week: this._t(n + d),
        month: this._t(n + g),
        year: this._t(n + p)
      },
      week: {
        week: this._t(a),
        month: this._t(a + g),
        year: this._t(a + p)
      },
      month: {
        month: this._t(o),
        year: this._t(o + p)
      },
      year: {
        year: this._t(l)
      }
    }), super._setDefaults();
  }
  _beforeChanged() {
    super._beforeChanged();
  }
  /**
   * Formats the number as duration.
   *
   * For example `1000` (base unit seconds) would be converted to `16:40` as in
   * 16 minutes and 40 seconds.
   *
   * @param value   Value to format
   * @param format  Format to apply
   * @param base    Override base unit
   * @return Formatted number
   */
  format(e, t, s) {
    let r = s || this.get("baseUnit");
    (typeof t > "u" || t === "") && (this.get("durationFormat") != null ? t = this.get("durationFormat") : t = this.getFormat(yt(e), void 0, r)), t = Po(t);
    let n = this.parseFormat(t, r), a = Number(e), o;
    a > this.get("negativeBase") ? o = n.positive : a < this.get("negativeBase") ? o = n.negative : o = n.zero;
    let l = this.applyFormat(a, o);
    return o.color !== "" && (l = "[" + o.color + "]" + l + "[/]"), l;
  }
  /**
   * Parses supplied format into structured object which can be used to format
   * the number.
   *
   * @param format  Format string, i.e. "#,###.00"
   * @param base    Override base unit
   * @return Parsed information
   */
  parseFormat(e, t) {
    let s = t || this.get("baseUnit"), r = {
      positive: {
        color: "",
        template: "",
        parts: [],
        source: "",
        baseUnit: s,
        parsed: !1,
        absolute: !1
      },
      negative: {
        color: "",
        template: "",
        parts: [],
        source: "",
        baseUnit: s,
        parsed: !1,
        absolute: !1
      },
      zero: {
        color: "",
        template: "",
        parts: [],
        source: "",
        baseUnit: s,
        parsed: !1,
        absolute: !1
      }
    };
    e = e.replace("||", Ss);
    let n = e.split("|");
    return r.positive.source = n[0], typeof n[2] > "u" ? r.zero = r.positive : r.zero.source = n[2], typeof n[1] > "u" ? r.negative = r.positive : r.negative.source = n[1], ye(r, (a, o) => {
      if (o.parsed)
        return;
      let l = o.source, u = [];
      u = o.source.match(/^\[([^\]]*)\]/), u && u.length && u[0] !== "" && (l = o.source.substr(u[0].length), o.color = u[1]);
      let h = Ht.chunk(l, !0);
      for (let c = 0; c < h.length; c++) {
        let f = h[c];
        if (f.text = f.text.replace(Ss, "|"), f.type === "value") {
          f.text.match(/[yYMdDwhHKkmsSn]+a/) && (o.absolute = !0, f.text = f.text.replace(/([yYMdDwhHKkmsSn]+)a/, "$1"));
          let d = f.text.match(/y+|Y+|M+|d+|D+|w+|h+|H+|K+|k+|m+|s+|S+|n+/g);
          if (d)
            for (let g = 0; g < d.length; g++)
              d[g] == null && (d[g] = this._unitAliases[d[g]]), o.parts.push(d[g]), f.text = f.text.replace(d[g], Oi);
        }
        o.template += f.text;
      }
      o.parsed = !0;
    }), r;
  }
  /**
   * Applies parsed format to a numeric value.
   *
   * @param value    Value
   * @param details  Parsed format as returned by {parseFormat}
   * @return Formatted duration
   */
  applyFormat(e, t) {
    let s = !t.absolute && e < this.get("negativeBase");
    e = Math.abs(e);
    let r = this.toTimeStamp(e, t.baseUnit), n = t.template;
    for (let a = 0, o = t.parts.length; a < o; a++) {
      let l = t.parts[a], u = this._toTimeUnit(l.substr(0, 1)), h = l.length, c = Math.floor(r / this._getUnitValue(u));
      n = n.replace(Oi, Fe(c, h, "0")), r -= c * this._getUnitValue(u);
    }
    return s && (n = "-" + n), n;
  }
  /**
   * Converts numeric value to timestamp in milliseconds.
   *
   * @param value     A source value
   * @param baseUnit  Base unit the source value is in: "q", "s", "i", "h", "d", "w", "m", "y"
   * @return Value representation as a timestamp in milliseconds
   */
  toTimeStamp(e, t) {
    return e * this._getUnitValue(t);
  }
  _toTimeUnit(e) {
    switch (e) {
      case "S":
        return "millisecond";
      case "s":
        return "second";
      case "m":
        return "minute";
      case "h":
        return "hour";
      case "d":
        return "day";
      case "w":
        return "week";
      case "M":
        return "month";
      case "y":
        return "year";
    }
  }
  /**
   * Returns appropriate default format for the value.
   *
   * If `maxValue` is sepcified, it will use that value to determine the time
   * unit for the format.
   *
   * For example if your `baseUnit` is `"second"` and you pass in `10`, you
   * will get `"10"`.
   *
   * However, you might want it to be formatted in the context of bigger scale,
   * say 10 minutes (600 seconds). If you pass in `600` as `maxValue`, all
   * values, including small ones will use format with minutes, e.g.:
   * `00:10`, `00:50`, `12: 30`, etc.
   *
   * @param value     Value to format
   * @param maxValue  Maximum value to be used to determine format
   * @param baseUnit  Base unit of the value
   * @return Format
   */
  getFormat(e, t, s) {
    if (this.get("durationFormat") != null)
      return this.get("durationFormat");
    if (s || (s = this.get("baseUnit")), t != null && e != t) {
      e = Math.abs(e), t = Math.abs(t);
      let r = this.getValueUnit(Math.max(e, t), s);
      return this.get("durationFormats")[s][r];
    } else {
      let r = this.getValueUnit(e, s);
      return this.get("durationFormats")[s][r];
    }
  }
  /**
   * Returns value's closest denominator time unit, e.g 100 seconds is
   * `"minute"`, while 59 seconds would still be `second`.
   *
   * @param value     Source duration value
   * @param baseUnit  Base unit
   * @return Denominator
   */
  getValueUnit(e, t) {
    t || (t = this.get("baseUnit"));
    let s, r = this.getMilliseconds(e, t);
    return jf(this._getUnitValues(), (n, a) => {
      if (n == t || s) {
        if (r / a <= 1)
          return s || (s = n), !1;
        s = n;
      }
      return !0;
    }), s;
  }
  /**
   * Converts value to milliseconds according to `baseUnit`.
   *
   * @param value     Source duration value
   * @param baseUnit  Base unit
   * @return Value in milliseconds
   */
  getMilliseconds(e, t) {
    return t || (t = this.get("baseUnit")), e * this._getUnitValue(t);
  }
  _getUnitValue(e) {
    return this._getUnitValues()[e];
  }
  _getUnitValues() {
    return {
      millisecond: 1,
      second: 1e3,
      minute: 6e4,
      hour: 36e5,
      day: 864e5,
      week: 6048e5,
      month: 2592e6,
      year: 31536e6
    };
  }
}
const yp = {
  firstDayOfWeek: 1,
  // Number formatting options.
  // 
  // Please check with the local standards which separator is accepted to be
  // used for separating decimals, and which for thousands.
  _decimalSeparator: ".",
  _thousandSeparator: ",",
  // Position of the percent sign in numbers
  _percentPrefix: null,
  _percentSuffix: "%",
  // Suffixes for numbers
  // When formatting numbers, big or small numers might be reformatted to
  // shorter version, by applying a suffix.
  // 
  // For example, 1000000 might become "1m".
  // Or 1024 might become "1KB" if we're formatting byte numbers.
  // 
  // This section defines such suffixes for all such cases.
  _big_number_suffix_3: "k",
  _big_number_suffix_6: "M",
  _big_number_suffix_9: "G",
  _big_number_suffix_12: "T",
  _big_number_suffix_15: "P",
  _big_number_suffix_18: "E",
  _big_number_suffix_21: "Z",
  _big_number_suffix_24: "Y",
  _small_number_suffix_3: "m",
  _small_number_suffix_6: "μ",
  _small_number_suffix_9: "n",
  _small_number_suffix_12: "p",
  _small_number_suffix_15: "f",
  _small_number_suffix_18: "a",
  _small_number_suffix_21: "z",
  _small_number_suffix_24: "y",
  _byte_suffix_B: "B",
  _byte_suffix_KB: "KB",
  _byte_suffix_MB: "MB",
  _byte_suffix_GB: "GB",
  _byte_suffix_TB: "TB",
  _byte_suffix_PB: "PB",
  // Default date formats for various periods.
  // 
  // This should reflect official or de facto formatting universally accepted
  // in the country translation is being made for
  // Available format codes here:
  // https://www.amcharts.com/docs/v5/concepts/formatters/formatting-dates/#Format_codes
  // 
  // This will be used when formatting date/time for particular granularity,
  // e.g. "_date_hour" will be shown whenever we need to show time as hours.
  // 
  // "date" is used as in default date format when showing standalone dates.
  _date: "yyyy-MM-dd",
  _date_millisecond: "mm:ss SSS",
  _date_millisecond_full: "HH:mm:ss SSS",
  _date_second: "HH:mm:ss",
  _date_second_full: "HH:mm:ss",
  _date_minute: "HH:mm",
  _date_minute_full: "HH:mm - MMM dd, yyyy",
  _date_hour: "HH:mm",
  _date_hour_full: "HH:mm - MMM dd, yyyy",
  _date_day: "MMM dd",
  _date_day_full: "MMM dd, yyyy",
  _date_week: "ww",
  _date_week_full: "MMM dd, yyyy",
  _date_month: "MMM",
  _date_month_full: "MMM, yyyy",
  _date_year: "yyyy",
  // Default duration formats for various base units.
  // 
  // This will be used by DurationFormatter to format numeric values into
  // duration.
  // 
  // Notice how each duration unit comes in several versions. This is to ensure
  // that each base unit is shown correctly.
  // 
  // For example, if we have baseUnit set to "second", meaning our duration is
  // in seconds.
  // 
  // If we pass in `50` to formatter, it will know that we have just 50 seconds
  // (less than a minute) so it will use format in `"_duration_second"` ("ss"),
  // and the formatted result will be in like `"50"`.
  // 
  // If we pass in `70`, which is more than a minute, the formatter will switch
  // to `"_duration_second_minute"` ("mm:ss"), resulting in "01:10" formatted
  // text.
  // 
  // Available codes here:
  // https://www.amcharts.com/docs/v4/concepts/formatters/formatting-duration/#Available_Codes
  _duration_millisecond: "SSS",
  _duration_millisecond_second: "ss.SSS",
  _duration_millisecond_minute: "mm:ss SSS",
  _duration_millisecond_hour: "hh:mm:ss SSS",
  _duration_millisecond_day: "d'd' mm:ss SSS",
  _duration_millisecond_week: "d'd' mm:ss SSS",
  _duration_millisecond_month: "M'm' dd'd' mm:ss SSS",
  _duration_millisecond_year: "y'y' MM'm' dd'd' mm:ss SSS",
  _duration_second: "ss",
  _duration_second_minute: "mm:ss",
  _duration_second_hour: "hh:mm:ss",
  _duration_second_day: "d'd' hh:mm:ss",
  _duration_second_week: "d'd' hh:mm:ss",
  _duration_second_month: "M'm' dd'd' hh:mm:ss",
  _duration_second_year: "y'y' MM'm' dd'd' hh:mm:ss",
  _duration_minute: "mm",
  _duration_minute_hour: "hh:mm",
  _duration_minute_day: "d'd' hh:mm",
  _duration_minute_week: "d'd' hh:mm",
  _duration_minute_month: "M'm' dd'd' hh:mm",
  _duration_minute_year: "y'y' MM'm' dd'd' hh:mm",
  _duration_hour: "hh'h'",
  _duration_hour_day: "d'd' hh'h'",
  _duration_hour_week: "d'd' hh'h'",
  _duration_hour_month: "M'm' dd'd' hh'h'",
  _duration_hour_year: "y'y' MM'm' dd'd' hh'h'",
  _duration_day: "d'd'",
  _duration_day_week: "d'd'",
  _duration_day_month: "M'm' dd'd'",
  _duration_day_year: "y'y' MM'm' dd'd'",
  _duration_week: "w'w'",
  _duration_week_month: "w'w'",
  _duration_week_year: "w'w'",
  _duration_month: "M'm'",
  _duration_month_year: "y'y' MM'm'",
  _duration_year: "y'y'",
  // Era translations
  _era_ad: "AD",
  _era_bc: "BC",
  // Day part, used in 12-hour formats, e.g. 5 P.M.
  // Please note that these come in 3 variants:
  // * one letter (e.g. "A")
  // * two letters (e.g. "AM")
  // * two letters with dots (e.g. "A.M.")
  // 
  // All three need to to be translated even if they are all the same. Some
  // users might use one, some the other.
  A: "",
  P: "",
  AM: "",
  PM: "",
  "A.M.": "",
  "P.M.": "",
  // Date-related stuff.
  // 
  // When translating months, if there's a difference, use the form which is
  // best for a full date, e.g. as you would use it in "2018 January 1".
  // 
  // Note that May is listed twice. This is because in English May is the same
  // in both long and short forms, while in other languages it may not be the
  // case. Translate "May" to full word, while "May(short)" to shortened
  // version.
  // 
  // Should month names and weekdays be capitalized or not?
  // 
  // Rule of thumb is this: if the names should always be capitalized,
  // regardless of name position within date ("January", "21st January 2018",
  // etc.) use capitalized names. Otherwise enter all lowercase.
  // 
  // The date formatter will automatically capitalize names if they are the
  // first (or only) word in resulting date.
  January: "",
  February: "",
  March: "",
  April: "",
  May: "",
  June: "",
  July: "",
  August: "",
  September: "",
  October: "",
  November: "",
  December: "",
  Jan: "",
  Feb: "",
  Mar: "",
  Apr: "",
  "May(short)": "May",
  Jun: "",
  Jul: "",
  Aug: "",
  Sep: "",
  Oct: "",
  Nov: "",
  Dec: "",
  // Weekdays.
  Sunday: "",
  Monday: "",
  Tuesday: "",
  Wednesday: "",
  Thursday: "",
  Friday: "",
  Saturday: "",
  Sun: "",
  Mon: "",
  Tue: "",
  Wed: "",
  Thu: "",
  Fri: "",
  Sat: "",
  // Date ordinal function.
  // 
  // This is used when adding number ordinal when formatting days in dates.
  // 
  // E.g. "January 1st", "February 2nd".
  // 
  // The function accepts day number, and returns a string to be added to the
  // day, like in default English translation, if we pass in 2, we will receive
  // "nd" back.
  _dateOrd: function(i) {
    let e = "th";
    if (i < 11 || i > 13)
      switch (i % 10) {
        case 1:
          e = "st";
          break;
        case 2:
          e = "nd";
          break;
        case 3:
          e = "rd";
          break;
      }
    return e;
  },
  // Various chart controls.
  // Shown as a tooltip on zoom out button.
  "Zoom Out": "",
  // Timeline buttons
  Play: "",
  Stop: "",
  // Chart's Legend screen reader title.
  Legend: "",
  // Legend's item screen reader indicator.
  "Press ENTER to toggle": "",
  // Shown when the chart is busy loading something.
  Loading: "",
  // Shown as the first button in the breadcrumb navigation, e.g.:
  // Home > First level > ...
  Home: "",
  // Chart types.
  // Those are used as default screen reader titles for the main chart element
  // unless developer has set some more descriptive title.
  Chart: "",
  "Serial chart": "",
  "X/Y chart": "",
  "Pie chart": "",
  "Gauge chart": "",
  "Radar chart": "",
  "Sankey diagram": "",
  "Flow diagram": "",
  "Chord diagram": "",
  "TreeMap chart": "",
  "Force directed tree": "",
  "Sliced chart": "",
  // Series types.
  // Used to name series by type for screen readers if they do not have their
  // name set.
  Series: "",
  "Candlestick Series": "",
  "OHLC Series": "",
  "Column Series": "",
  "Line Series": "",
  "Pie Slice Series": "",
  "Funnel Series": "",
  "Pyramid Series": "",
  "X/Y Series": "",
  // Map-related stuff.
  Map: "",
  "Press ENTER to zoom in": "",
  "Press ENTER to zoom out": "",
  "Use arrow keys to zoom in and out": "",
  "Use plus and minus keys on your keyboard to zoom in and out": "",
  // Export-related stuff.
  // These prompts are used in Export menu labels.
  // 
  // "Export" is the top-level menu item.
  // 
  // "Image", "Data", "Print" as second-level indicating type of export
  // operation.
  // 
  // Leave actual format untranslated, unless you absolutely know that they
  // would convey more meaning in some other way.
  Export: "",
  Image: "",
  Data: "",
  Print: "",
  "Press ENTER or use arrow keys to navigate": "",
  "Press ENTER to open": "",
  "Press ENTER to print.": "",
  "Press ENTER to export as %1.": "",
  "(Press ESC to close this message)": "",
  "Image Export Complete": "",
  "Export operation took longer than expected. Something might have gone wrong.": "",
  "Saved from": "",
  PNG: "",
  JPG: "",
  GIF: "",
  SVG: "",
  PDF: "",
  JSON: "",
  CSV: "",
  XLSX: "",
  HTML: "",
  // Scrollbar-related stuff.
  // 
  // Scrollbar is a control which can zoom and pan the axes on the chart.
  // 
  // Each scrollbar has two grips: left or right (for horizontal scrollbar) or
  // upper and lower (for vertical one).
  // 
  // Prompts change in relation to whether Scrollbar is vertical or horizontal.
  // 
  // The final section is used to indicate the current range of selection.
  "Use TAB to select grip buttons or left and right arrows to change selection": "",
  "Use left and right arrows to move selection": "",
  "Use left and right arrows to move left selection": "",
  "Use left and right arrows to move right selection": "",
  "Use TAB select grip buttons or up and down arrows to change selection": "",
  "Use up and down arrows to move selection": "",
  "Use up and down arrows to move lower selection": "",
  "Use up and down arrows to move upper selection": "",
  "From %1 to %2": "",
  "From %1": "",
  "To %1": "",
  // Data loader-related.
  "No parser available for file: %1": "",
  "Error parsing file: %1": "",
  "Unable to load file: %1": "",
  "Invalid date": "",
  // Common actions
  Close: "",
  Minimize: ""
};
class Tk extends Oe {
  _setDefaults() {
    this.setPrivate("defaultLocale", yp), super._setDefaults();
  }
  /**
   * Returns a prompt translation.
   *
   * @param   prompt   Prompt to translate
   * @param   locale   Target locale
   * @param   ...rest  Parameters
   * @return           Translation
   */
  translate(e, t, ...s) {
    t || (t = this._root.locale || this.getPrivate("defaultLocale"));
    let r = e, n = t[e];
    if (n === null)
      r = "";
    else if (n != null)
      n && (r = n);
    else if (t !== this.getPrivate("defaultLocale"))
      return this.translate(e, this.getPrivate("defaultLocale"), ...s);
    if (s.length)
      for (let a = s.length, o = 0; o < a; ++o)
        r = r.split("%" + (o + 1)).join(s[o]);
    return r;
  }
  /**
   * Returns a prompt translation, including custom prompts.
   *
   * @param   prompt   Prompt to translate
   * @param   locale   Target locale
   * @param   ...rest  Parameters
   * @return           Translation
   */
  translateAny(e, t, ...s) {
    return this.translate(e, t, ...s);
  }
  /**
   * Add a custom prompt to locale.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/locales/creating-translations/#Extending_locale_with_custom_prompts}
   * @param  prompt       Source prompt
   * @param  translation  Tanslation
   * @param  locale       Target locale
   */
  setTranslationAny(e, t, s) {
    const r = s || this._root.locale;
    r[e] = t;
  }
  /**
   * Add a batch of custom prompts.
   *
   * @since 5.3.3
   * @see {@link https://www.amcharts.com/docs/v5/concepts/locales/creating-translations/#Extending_locale_with_custom_prompts}
   * @param  translations  Translations
   * @param  locale        Target locale
   */
  setTranslationsAny(e, t) {
    ye(e, (s, r) => {
      this.setTranslationAny(s, r, t);
    });
  }
  translateEmpty(e, t, ...s) {
    let r = this.translate(e, t, ...s);
    return r == e ? "" : r;
  }
  translateFunc(e, t) {
    return this._root.locale[e] ? this._root.locale[e] : t !== this.getPrivate("defaultLocale") ? this.translateFunc(e, this.getPrivate("defaultLocale")) : () => "";
  }
  /**
   * Translates a btach of prompts.
   *
   * @param  list    Array of prompts to translate
   * @param  locale  Target locale
   * @return         Array of translations
   */
  translateAll(e, t) {
    return this.isDefault() ? e : Ta(e, (s) => this.translate(s, t));
  }
  /**
   * Returns `true` if the currently selected locale is a default locale.
   *
   * @return `true` if locale is default; `false` if it is not.
   */
  isDefault() {
    return this.getPrivate("defaultLocale") === this._root.locale;
  }
}
class Bs {
  constructor(e, t) {
    if (Object.defineProperty(this, "_root", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_rules", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), this._root = e, !t)
      throw new Error("You cannot use `new Class()`, instead use `Class.new()`");
  }
  /**
   * Use this method to create an instance of this class.
   *
   * @see {@link https://www.amcharts.com/docs/v5/getting-started/#New_element_syntax} for more info
   * @param   root      Root element
   * @param   settings  Settings
   * @param   template  Template
   * @return            Instantiated object
   */
  static new(e) {
    const t = new this(e, !0);
    return t.setupDefaultRules(), t;
  }
  setupDefaultRules() {
  }
  /**
   * Looks up the rules for a specific theme class.
   *
   * @see {@link https://www.amcharts.com/docs/v5/themes/} for more info
   * @param   themeClass Theme class
   * @return             Array<IRule<A>>
   */
  _lookupRules(e) {
    return this._rules[e];
  }
  /**
   * Creates a [[Template]] for specific theme class and tags.
   *
   * NOTE: the difference from `rule()` is that `ruleRaw()` does not do any
   * type checks.
   *
   * @see {@link https://www.amcharts.com/docs/v5/themes/} for more info
   * @param   themeClass Theme class
   * @param   themeTags  Theme tags
   * @return             Template
   */
  ruleRaw(e, t = []) {
    let s = this._rules[e];
    s || (s = this._rules[e] = []), t.sort($t);
    const { index: r, found: n } = Wi(s, (a) => {
      const o = $t(a.tags.length, t.length);
      return o === 0 ? hp(a.tags, t, $t) : o;
    });
    if (n)
      return s[r].template;
    {
      const a = be.new({});
      return s.splice(r, 0, {
        tags: t,
        template: a
      }), a;
    }
  }
  /**
   * Creates a [[Template]] for specific theme class and tags.
   *
   * @see {@link https://www.amcharts.com/docs/v5/themes/} for more info
   * @param   themeClass Theme class
   * @param   themeTags  Theme tags
   * @return             Template
   */
  rule(e, t = []) {
    return this.ruleRaw(e, t);
  }
}
function Q(i, e, t, s) {
  i.set(e, t.get(s)), t.on(s, (r) => {
    i.set(e, r);
  });
}
class kk extends Bs {
  setupDefaultRules() {
    super.setupDefaultRules();
    const e = this._root.language, t = this._root.interfaceColors, s = this._root.horizontalLayout, r = this._root.verticalLayout, n = this.rule.bind(this);
    n("InterfaceColors").setAll({
      stroke: V.fromHex(15066597),
      fill: V.fromHex(15987699),
      primaryButton: V.fromHex(6788316),
      primaryButtonHover: V.fromHex(6779356),
      primaryButtonDown: V.fromHex(6872182),
      primaryButtonActive: V.fromHex(6872182),
      primaryButtonText: V.fromHex(16777215),
      primaryButtonStroke: V.fromHex(16777215),
      secondaryButton: V.fromHex(14277081),
      secondaryButtonHover: V.fromHex(10724259),
      secondaryButtonDown: V.fromHex(9276813),
      secondaryButtonActive: V.fromHex(15132390),
      secondaryButtonText: V.fromHex(0),
      secondaryButtonStroke: V.fromHex(16777215),
      grid: V.fromHex(0),
      background: V.fromHex(16777215),
      alternativeBackground: V.fromHex(0),
      text: V.fromHex(0),
      alternativeText: V.fromHex(16777215),
      disabled: V.fromHex(11382189),
      positive: V.fromHex(5288704),
      negative: V.fromHex(11730944)
    });
    {
      const a = n("ColorSet");
      a.setAll({
        passOptions: {
          hue: 0.05,
          saturation: 0,
          lightness: 0
        },
        colors: [
          V.fromHex(6797276)
        ],
        step: 1,
        //baseColor: Color.fromRGB(103, 183, 220),
        //count: 20,
        reuse: !1,
        startIndex: 0
      }), a.setPrivate("currentStep", 0), a.setPrivate("currentPass", 0);
    }
    n("Entity").setAll({
      stateAnimationDuration: 0,
      stateAnimationEasing: Gs(xs)
    }), n("Component").setAll({
      interpolationDuration: 0,
      interpolationEasing: Gs(xs)
    }), n("Sprite").setAll({
      visible: !0,
      scale: 1,
      opacity: 1,
      rotation: 0,
      position: "relative",
      tooltipX: le,
      tooltipY: le,
      tooltipPosition: "fixed",
      isMeasured: !0
    }), n("Sprite").states.create("default", { visible: !0, opacity: 1 }), n("Container").setAll({
      interactiveChildren: !0,
      setStateOnChildren: !1
    }), n("Graphics").setAll({
      strokeWidth: 1
    }), n("Chart").setAll({
      width: R,
      height: R,
      interactiveChildren: !1
    }), n("Sprite", ["horizontal", "center"]).setAll({
      centerX: le,
      x: le
    }), n("Sprite", ["vertical", "center"]).setAll({
      centerY: le,
      y: le
    }), n("Container", ["horizontal", "layout"]).setAll({
      layout: s
    }), n("Container", ["vertical", "layout"]).setAll({
      layout: r
    }), n("Pattern").setAll({
      repetition: "repeat",
      width: 50,
      height: 50,
      rotation: 0,
      fillOpacity: 1
    }), n("LinePattern").setAll({
      gap: 6,
      colorOpacity: 1,
      width: 49,
      height: 49
    }), n("RectanglePattern").setAll({
      gap: 6,
      checkered: !1,
      centered: !0,
      maxWidth: 5,
      maxHeight: 5,
      width: 48,
      height: 48,
      strokeWidth: 0
    }), n("CirclePattern").setAll({
      gap: 5,
      checkered: !1,
      centered: !1,
      radius: 3,
      strokeWidth: 0,
      width: 45,
      height: 45
    }), n("LinearGradient").setAll({
      rotation: 90
    }), n("Legend").setAll({
      fillField: "fill",
      strokeField: "stroke",
      nameField: "name",
      layout: Ki.new(this._root, {}),
      layer: 30,
      clickTarget: "itemContainer"
    }), n("Container", ["legend", "item", "itemcontainer"]).setAll({
      paddingLeft: 5,
      paddingRight: 5,
      paddingBottom: 5,
      paddingTop: 5,
      layout: s,
      setStateOnChildren: !0,
      interactiveChildren: !1,
      ariaChecked: !0,
      focusable: !0,
      ariaLabel: e.translate("Press ENTER to toggle"),
      role: "checkbox"
    });
    {
      const a = n("Rectangle", ["legend", "item", "background"]);
      a.setAll({
        fillOpacity: 0
      }), Q(a, "fill", t, "background");
    }
    n("Container", ["legend", "marker"]).setAll({
      setStateOnChildren: !0,
      centerY: le,
      paddingLeft: 0,
      paddingRight: 0,
      paddingBottom: 0,
      paddingTop: 0,
      width: 18,
      height: 18
    }), n("RoundedRectangle", ["legend", "marker", "rectangle"]).setAll({
      width: R,
      height: R,
      cornerRadiusBL: 3,
      cornerRadiusTL: 3,
      cornerRadiusBR: 3,
      cornerRadiusTR: 3
    });
    {
      const a = n("RoundedRectangle", ["legend", "marker", "rectangle"]).states.create("disabled", {});
      Q(a, "fill", t, "disabled"), Q(a, "stroke", t, "disabled");
    }
    n("Label", ["legend", "label"]).setAll({
      centerY: le,
      marginLeft: 5,
      paddingRight: 0,
      paddingLeft: 0,
      paddingTop: 0,
      paddingBottom: 0,
      populateText: !0
    });
    {
      const a = n("Label", ["legend", "label"]).states.create("disabled", {});
      Q(a, "fill", t, "disabled");
    }
    n("Label", ["legend", "value", "label"]).setAll({
      centerY: le,
      marginLeft: 5,
      paddingRight: 0,
      paddingLeft: 0,
      paddingTop: 0,
      paddingBottom: 0,
      width: 50,
      centerX: R,
      populateText: !0
    });
    {
      const a = n("Label", ["legend", "value", "label"]).states.create("disabled", {});
      Q(a, "fill", t, "disabled");
    }
    n("HeatLegend").setAll({
      stepCount: 1
    }), n("RoundedRectangle", ["heatlegend", "marker"]).setAll({
      cornerRadiusTR: 0,
      cornerRadiusBR: 0,
      cornerRadiusTL: 0,
      cornerRadiusBL: 0
    }), n("RoundedRectangle", ["vertical", "heatlegend", "marker"]).setAll({
      height: R,
      width: 15
    }), n("RoundedRectangle", ["horizontal", "heatlegend", "marker"]).setAll({
      width: R,
      height: 15
    }), n("HeatLegend", ["vertical"]).setAll({
      height: R
    }), n("HeatLegend", ["horizontal"]).setAll({
      width: R
    }), n("Label", ["heatlegend", "start"]).setAll({
      paddingLeft: 5,
      paddingRight: 5,
      paddingTop: 5,
      paddingBottom: 5
    }), n("Label", ["heatlegend", "end"]).setAll({
      paddingLeft: 5,
      paddingRight: 5,
      paddingTop: 5,
      paddingBottom: 5
    });
    {
      const a = n("Label");
      a.setAll({
        paddingTop: 8,
        paddingBottom: 8,
        paddingLeft: 10,
        paddingRight: 10,
        fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"',
        fontSize: "1em",
        populateText: !1
      }), Q(a, "fill", t, "text");
    }
    n("RadialLabel").setAll({
      textType: "regular",
      centerY: le,
      centerX: le,
      inside: !1,
      radius: 0,
      baseRadius: R,
      orientation: "auto",
      textAlign: "center"
    }), n("RoundedRectangle").setAll({
      cornerRadiusTL: 8,
      cornerRadiusBL: 8,
      cornerRadiusTR: 8,
      cornerRadiusBR: 8
    }), n("PointedRectangle").setAll({
      pointerBaseWidth: 15,
      pointerLength: 10,
      cornerRadius: 8
    }), n("Slice").setAll({
      shiftRadius: 0,
      dRadius: 0,
      dInnerRadius: 0
    });
    {
      const a = n("Tick");
      a.setAll({
        strokeOpacity: 0.15,
        isMeasured: !1,
        length: 4.5,
        position: "absolute",
        crisp: !0
      }), Q(a, "stroke", t, "grid");
    }
    n("Bullet").setAll({
      locationX: 0.5,
      locationY: 0.5
    }), n("Tooltip").setAll({
      position: "absolute",
      getFillFromSprite: !0,
      getStrokeFromSprite: !1,
      autoTextColor: !0,
      paddingTop: 9,
      paddingBottom: 8,
      paddingLeft: 10,
      paddingRight: 10,
      marginBottom: 5,
      pointerOrientation: "vertical",
      centerX: le,
      centerY: le,
      animationEasing: Gs(xs),
      exportable: !1
      //layer: 100
    }), n("Polygon").setAll({
      animationEasing: Gs(xs)
    }), n("PointedRectangle", ["tooltip", "background"]).setAll({
      strokeOpacity: 0.9,
      cornerRadius: 4,
      pointerLength: 4,
      pointerBaseWidth: 8,
      fillOpacity: 0.9,
      stroke: V.fromHex(16777215)
    });
    {
      const a = n("Label", ["tooltip"]);
      a.setAll({
        role: "tooltip",
        populateText: !0,
        paddingRight: 0,
        paddingTop: 0,
        paddingLeft: 0,
        paddingBottom: 0
      }), Q(a, "fill", t, "alternativeText");
    }
    n("Button").setAll({
      paddingTop: 8,
      paddingBottom: 8,
      paddingLeft: 10,
      paddingRight: 10,
      interactive: !0,
      layout: s,
      interactiveChildren: !1,
      setStateOnChildren: !0,
      focusable: !0
    }), n("Button").states.create("hover", {}), n("Button").states.create("down", { stateAnimationDuration: 0 }), n("Button").states.create("active", {});
    {
      const a = n("RoundedRectangle", ["button", "background"]);
      Q(a, "fill", t, "primaryButton"), Q(a, "stroke", t, "primaryButtonStroke");
    }
    {
      const a = n("RoundedRectangle", ["button", "background"]).states.create("hover", {});
      Q(a, "fill", t, "primaryButtonHover");
    }
    {
      const a = n("RoundedRectangle", ["button", "background"]).states.create("down", { stateAnimationDuration: 0 });
      Q(a, "fill", t, "primaryButtonDown");
    }
    {
      const a = n("RoundedRectangle", ["button", "background"]).states.create("active", {});
      Q(a, "fill", t, "primaryButtonActive");
    }
    {
      const a = n("Graphics", ["button", "icon"]);
      Q(a, "stroke", t, "primaryButtonText");
    }
    {
      const a = n("Label", ["button"]);
      Q(a, "fill", t, "primaryButtonText");
    }
    n("Button", ["zoom"]).setAll({
      paddingTop: 18,
      paddingBottom: 18,
      paddingLeft: 12,
      paddingRight: 12,
      centerX: 46,
      centerY: -10,
      y: 0,
      x: R,
      role: "button",
      ariaLabel: e.translate("Zoom Out"),
      layer: 30
    });
    {
      const a = n("RoundedRectangle", ["background", "button", "zoom"]);
      a.setAll({
        cornerRadiusBL: 40,
        cornerRadiusBR: 40,
        cornerRadiusTL: 40,
        cornerRadiusTR: 40
      }), Q(a, "fill", t, "primaryButton");
    }
    {
      const a = n("RoundedRectangle", ["background", "button", "zoom"]).states.create("hover", {});
      Q(a, "fill", t, "primaryButtonHover");
    }
    {
      const a = n("RoundedRectangle", ["background", "button", "zoom"]).states.create("down", { stateAnimationDuration: 0 });
      Q(a, "fill", t, "primaryButtonDown");
    }
    {
      const a = n("Graphics", ["icon", "button", "zoom"]);
      a.setAll({
        crisp: !0,
        strokeOpacity: 0.7,
        draw: (o) => {
          o.moveTo(0, 0), o.lineTo(12, 0);
        }
      }), Q(a, "stroke", t, "primaryButtonText");
    }
    n("Button", ["resize"]).setAll({
      paddingTop: 9,
      paddingBottom: 9,
      paddingLeft: 13,
      paddingRight: 13,
      draggable: !0,
      centerX: le,
      centerY: le,
      position: "absolute",
      role: "slider",
      ariaValueMin: "0",
      ariaValueMax: "100",
      ariaLabel: e.translate("Use up and down arrows to move selection")
    });
    {
      const a = n("RoundedRectangle", ["background", "resize", "button"]);
      a.setAll({
        cornerRadiusBL: 40,
        cornerRadiusBR: 40,
        cornerRadiusTL: 40,
        cornerRadiusTR: 40
      }), Q(a, "fill", t, "secondaryButton"), Q(a, "stroke", t, "secondaryButtonStroke");
    }
    {
      const a = n("RoundedRectangle", ["background", "resize", "button"]).states.create("hover", {});
      Q(a, "fill", t, "secondaryButtonHover");
    }
    {
      const a = n("RoundedRectangle", ["background", "resize", "button"]).states.create("down", { stateAnimationDuration: 0 });
      Q(a, "fill", t, "secondaryButtonDown");
    }
    {
      const a = n("Graphics", ["resize", "button", "icon"]);
      a.setAll({
        interactive: !1,
        crisp: !0,
        strokeOpacity: 0.5,
        draw: (o) => {
          o.moveTo(0, 0.5), o.lineTo(0, 12.5), o.moveTo(4, 0.5), o.lineTo(4, 12.5);
        }
      }), Q(a, "stroke", t, "secondaryButtonText");
    }
    n("Button", ["resize", "vertical"]).setAll({
      rotation: 90,
      cursorOverStyle: "ns-resize"
    }), n("Button", ["resize", "horizontal"]).setAll({
      cursorOverStyle: "ew-resize"
    }), n("Button", ["play"]).setAll({
      paddingTop: 13,
      paddingBottom: 13,
      paddingLeft: 14,
      paddingRight: 14,
      ariaLabel: e.translate("Play"),
      toggleKey: "active"
    });
    {
      const a = n("RoundedRectangle", ["play", "background"]);
      a.setAll({
        strokeOpacity: 0.5,
        cornerRadiusBL: 100,
        cornerRadiusBR: 100,
        cornerRadiusTL: 100,
        cornerRadiusTR: 100
      }), Q(a, "fill", t, "primaryButton");
    }
    {
      const a = n("Graphics", ["play", "icon"]);
      a.setAll({
        stateAnimationDuration: 0,
        dx: 1,
        draw: (o) => {
          o.moveTo(0, -5), o.lineTo(8, 0), o.lineTo(0, 5), o.lineTo(0, -5);
        }
      }), Q(a, "fill", t, "primaryButtonText");
    }
    n("Graphics", ["play", "icon"]).states.create("default", {
      stateAnimationDuration: 0
    }), n("Graphics", ["play", "icon"]).states.create("active", {
      stateAnimationDuration: 0,
      draw: (a) => {
        a.moveTo(-4, -5), a.lineTo(-1, -5), a.lineTo(-1, 5), a.lineTo(-4, 5), a.lineTo(-4, -5), a.moveTo(4, -5), a.lineTo(1, -5), a.lineTo(1, 5), a.lineTo(4, 5), a.lineTo(4, -5);
      }
    }), n("Button", ["switch"]).setAll({
      paddingTop: 4,
      paddingBottom: 4,
      paddingLeft: 4,
      paddingRight: 4,
      ariaLabel: e.translate("Press ENTER to toggle"),
      toggleKey: "active",
      width: 40,
      height: 24,
      layout: null
    });
    {
      const a = n("RoundedRectangle", ["switch", "background"]);
      a.setAll({
        strokeOpacity: 0.5,
        cornerRadiusBL: 100,
        cornerRadiusBR: 100,
        cornerRadiusTL: 100,
        cornerRadiusTR: 100
      }), Q(a, "fill", t, "primaryButton");
    }
    {
      const a = n("Circle", ["switch", "icon"]);
      a.setAll({
        radius: 8,
        centerY: 0,
        centerX: 0,
        dx: 0
      }), Q(a, "fill", t, "primaryButtonText");
    }
    n("Graphics", ["switch", "icon"]).states.create("active", {
      dx: 16
    }), n("Scrollbar").setAll({
      start: 0,
      end: 1,
      layer: 30,
      animationEasing: Gs(xs)
    }), n("Scrollbar", ["vertical"]).setAll({
      marginRight: 13,
      marginLeft: 13,
      minWidth: 12,
      height: R
    }), n("Scrollbar", ["horizontal"]).setAll({
      marginTop: 13,
      marginBottom: 13,
      minHeight: 12,
      width: R
    }), this.rule("Button", ["scrollbar"]).setAll({
      exportable: !1
    });
    {
      const a = n("RoundedRectangle", ["scrollbar", "main", "background"]);
      a.setAll({
        cornerRadiusTL: 8,
        cornerRadiusBL: 8,
        cornerRadiusTR: 8,
        cornerRadiusBR: 8,
        fillOpacity: 0.8
      }), Q(a, "fill", t, "fill");
    }
    {
      const a = n("RoundedRectangle", ["scrollbar", "thumb"]);
      a.setAll({
        role: "slider",
        ariaLive: "polite",
        position: "absolute",
        draggable: !0
      }), Q(a, "fill", t, "secondaryButton");
    }
    {
      const a = n("RoundedRectangle", ["scrollbar", "thumb"]).states.create("hover", {});
      Q(a, "fill", t, "secondaryButtonHover");
    }
    {
      const a = n("RoundedRectangle", ["scrollbar", "thumb"]).states.create("down", { stateAnimationDuration: 0 });
      Q(a, "fill", t, "secondaryButtonDown");
    }
    n("RoundedRectangle", ["scrollbar", "thumb", "vertical"]).setAll({
      x: le,
      width: R,
      centerX: le,
      ariaLabel: e.translate("Use up and down arrows to move selection")
    }), n("RoundedRectangle", ["scrollbar", "thumb", "horizontal"]).setAll({
      y: le,
      centerY: le,
      height: R,
      ariaLabel: e.translate("Use left and right arrows to move selection")
    });
    {
      const a = n("PointedRectangle", ["axis", "tooltip", "background"]);
      a.setAll({
        cornerRadius: 0
      }), Q(a, "fill", t, "alternativeBackground");
    }
    n("Label", ["axis", "tooltip"]).setAll({
      role: void 0
    }), n("Label", ["axis", "tooltip", "y"]).setAll({
      textAlign: "right"
    }), n("Label", ["axis", "tooltip", "y", "opposite"]).setAll({
      textAlign: "left"
    }), n("Label", ["axis", "tooltip", "x"]).setAll({
      textAlign: "center"
    }), n("Tooltip", ["categoryaxis"]).setAll({
      labelText: "{category}"
    }), n("Star").setAll({
      spikes: 5,
      innerRadius: 5,
      radius: 10
    }), n("Tooltip", ["stock"]).setAll({
      paddingTop: 6,
      paddingBottom: 5,
      paddingLeft: 7,
      paddingRight: 7
    }), n("PointedRectangle", ["tooltip", "stock", "axis"]).setAll({
      pointerLength: 0,
      pointerBaseWidth: 0,
      cornerRadius: 3
    }), n("Label", ["tooltip", "stock"]).setAll({
      fontSize: "0.8em"
    }), n("SpriteResizer").setAll({
      rotationStep: 10
    }), n("Container", ["resizer", "grip"]).states.create("hover", {});
    {
      const a = n("RoundedRectangle", ["resizer", "grip"]);
      a.setAll({
        strokeOpacity: 0.7,
        strokeWidth: 1,
        fillOpacity: 1,
        width: 12,
        height: 12
      }), Q(a, "fill", t, "background"), Q(a, "stroke", t, "alternativeBackground");
    }
    {
      const a = n("RoundedRectangle", ["resizer", "grip", "outline"]);
      a.setAll({
        strokeOpacity: 0,
        fillOpacity: 0,
        width: 20,
        height: 20
      }), a.states.create("hover", {
        fillOpacity: 0.3
      }), Q(a, "fill", t, "alternativeBackground");
    }
    n("RoundedRectangle", ["resizer", "grip", "left"]).setAll({
      cornerRadiusBL: 0,
      cornerRadiusBR: 0,
      cornerRadiusTL: 0,
      cornerRadiusTR: 0
    }), n("RoundedRectangle", ["resizer", "grip", "right"]).setAll({
      cornerRadiusBL: 0,
      cornerRadiusBR: 0,
      cornerRadiusTL: 0,
      cornerRadiusTR: 0
    });
    {
      const a = n("Rectangle", ["resizer", "rectangle"]);
      a.setAll({
        strokeDasharray: [2, 2],
        strokeOpacity: 0.5,
        strokeWidth: 1
      }), Q(a, "stroke", t, "alternativeBackground");
    }
  }
}
class sl {
  constructor(e = 1, t = 0, s = 0, r = 1, n = 0, a = 0) {
    Object.defineProperty(this, "a", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "b", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "c", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "d", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tx", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "ty", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.a = e, this.b = t, this.c = s, this.d = r, this.tx = n, this.ty = a;
  }
  /**
   * Sets the matrix based on all the available properties
   */
  setTransform(e, t, s, r, n, a = 1) {
    this.a = Math.cos(n) * a, this.b = Math.sin(n) * a, this.c = -Math.sin(n) * a, this.d = Math.cos(n) * a, this.tx = e - (s * this.a + r * this.c), this.ty = t - (s * this.b + r * this.d);
  }
  /**
   * Get a new position with the current transformation applied.
   * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)
   */
  apply(e) {
    return {
      x: this.a * e.x + this.c * e.y + this.tx,
      y: this.b * e.x + this.d * e.y + this.ty
    };
  }
  /**
   * Get a new position with the inverse of the current transformation applied.
   * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)
   */
  applyInverse(e) {
    const t = 1 / (this.a * this.d + this.c * -this.b);
    return {
      x: this.d * t * e.x + -this.c * t * e.y + (this.ty * this.c - this.tx * this.d) * t,
      y: this.a * t * e.y + -this.b * t * e.x + (-this.ty * this.a + this.tx * this.b) * t
    };
  }
  /**
   * Appends the given Matrix to this Matrix.
   */
  append(e) {
    const t = this.a, s = this.b, r = this.c, n = this.d;
    this.a = e.a * t + e.b * r, this.b = e.a * s + e.b * n, this.c = e.c * t + e.d * r, this.d = e.c * s + e.d * n, this.tx = e.tx * t + e.ty * r + this.tx, this.ty = e.tx * s + e.ty * n + this.ty;
  }
  /**
   * Prepends the given Matrix to this Matrix.
   */
  prepend(e) {
    const t = this.tx;
    if (e.a !== 1 || e.b !== 0 || e.c !== 0 || e.d !== 1) {
      const s = this.a, r = this.c;
      this.a = s * e.a + this.b * e.c, this.b = s * e.b + this.b * e.d, this.c = r * e.a + this.d * e.c, this.d = r * e.b + this.d * e.d;
    }
    this.tx = t * e.a + this.ty * e.c + e.tx, this.ty = t * e.b + this.ty * e.d + e.ty;
  }
  /**
   * Copies the other matrix's properties into this matrix
   */
  copyFrom(e) {
    this.a = e.a, this.b = e.b, this.c = e.c, this.d = e.d, this.tx = e.tx, this.ty = e.ty;
  }
}
var Pk = function() {
  function i(e, t) {
    var s = [], r = !0, n = !1, a = void 0;
    try {
      for (var o = e[Symbol.iterator](), l; !(r = (l = o.next()).done) && (s.push(l.value), !(t && s.length === t)); r = !0)
        ;
    } catch (u) {
      n = !0, a = u;
    } finally {
      try {
        !r && o.return && o.return();
      } finally {
        if (n)
          throw a;
      }
    }
    return s;
  }
  return function(e, t) {
    if (Array.isArray(e))
      return e;
    if (Symbol.iterator in Object(e))
      return i(e, t);
    throw new TypeError("Invalid attempt to destructure non-iterable instance");
  };
}(), en = Math.PI * 2, rl = function(e, t, s, r, n, a, o) {
  var l = e.x, u = e.y;
  l *= t, u *= s;
  var h = r * l - n * u, c = n * l + r * u;
  return {
    x: h + a,
    y: c + o
  };
}, Ok = function(e, t) {
  var s = t === 1.5707963267948966 ? 0.551915024494 : t === -1.5707963267948966 ? -0.551915024494 : 1.3333333333333333 * Math.tan(t / 4), r = Math.cos(e), n = Math.sin(e), a = Math.cos(e + t), o = Math.sin(e + t);
  return [{
    x: r - n * s,
    y: n + r * s
  }, {
    x: a + o * s,
    y: o - a * s
  }, {
    x: a,
    y: o
  }];
}, ph = function(e, t, s, r) {
  var n = e * r - t * s < 0 ? -1 : 1, a = e * s + t * r;
  return a > 1 && (a = 1), a < -1 && (a = -1), n * Math.acos(a);
}, Mk = function(e, t, s, r, n, a, o, l, u, h, c, f) {
  var d = Math.pow(n, 2), g = Math.pow(a, 2), p = Math.pow(c, 2), _ = Math.pow(f, 2), m = d * g - d * _ - g * p;
  m < 0 && (m = 0), m /= d * _ + g * p, m = Math.sqrt(m) * (o === l ? -1 : 1);
  var v = m * n / a * f, b = m * -a / n * c, y = h * v - u * b + (e + s) / 2, x = u * v + h * b + (t + r) / 2, D = (c - v) / n, A = (f - b) / a, C = (-c - v) / n, O = (-f - b) / a, T = ph(1, 0, D, A), L = ph(D, A, C, O);
  return l === 0 && L > 0 && (L -= en), l === 1 && L < 0 && (L += en), [y, x, T, L];
}, Ak = function(e) {
  var t = e.px, s = e.py, r = e.cx, n = e.cy, a = e.rx, o = e.ry, l = e.xAxisRotation, u = l === void 0 ? 0 : l, h = e.largeArcFlag, c = h === void 0 ? 0 : h, f = e.sweepFlag, d = f === void 0 ? 0 : f, g = [];
  if (a === 0 || o === 0)
    return [];
  var p = Math.sin(u * en / 360), _ = Math.cos(u * en / 360), m = _ * (t - r) / 2 + p * (s - n) / 2, v = -p * (t - r) / 2 + _ * (s - n) / 2;
  if (m === 0 && v === 0)
    return [];
  a = Math.abs(a), o = Math.abs(o);
  var b = Math.pow(m, 2) / Math.pow(a, 2) + Math.pow(v, 2) / Math.pow(o, 2);
  b > 1 && (a *= Math.sqrt(b), o *= Math.sqrt(b));
  var y = Mk(t, s, r, n, a, o, c, d, p, _, m, v), x = Pk(y, 4), D = x[0], A = x[1], C = x[2], O = x[3], T = Math.abs(O) / (en / 4);
  Math.abs(1 - T) < 1e-7 && (T = 1);
  var L = Math.max(Math.ceil(T), 1);
  O /= L;
  for (var j = 0; j < L; j++)
    g.push(Ok(C, O)), C += O;
  return g.map(function(N) {
    var ee = rl(N[0], a, o, _, p, D, A), z = ee.x, H = ee.y, $ = rl(N[1], a, o, _, p, D, A), Z = $.x, B = $.y, he = rl(N[2], a, o, _, p, D, A), M = he.x, k = he.y;
    return { x1: z, y1: H, x2: Z, y2: B, x: M, y: k };
  });
};
function Lk(i, e, t) {
  if (e !== t)
    throw new Error("Required " + t + " arguments for " + i + " but got " + e);
}
function zr(i, e, t) {
  if (e < t)
    throw new Error("Required at least " + t + " arguments for " + i + " but got " + e);
}
function At(i, e, t) {
  if (zr(i, e, t), e % t !== 0)
    throw new Error("Arguments for " + i + " must be in pairs of " + t);
}
function jk(i) {
  for (let e = 0; e < i.length; e += 7) {
    let t = e + 3, s = i[t];
    if (s.length > 1) {
      const r = /^([01])([01])(.*)$/.exec(s);
      r !== null && (i.splice(t, 0, r[1]), ++t, i.splice(t, 0, r[2]), ++t, r[3].length > 0 ? i[t] = r[3] : i.splice(t, 1));
    }
    if (++t, s = i[t], s.length > 1) {
      const r = /^([01])(.+)$/.exec(s);
      r !== null && (i.splice(t, 0, r[1]), ++t, i[t] = r[2]);
    }
  }
}
function gh(i) {
  if (i === 0 || i === 1)
    return i;
  throw new Error("Flag must be 0 or 1");
}
function Ik(i) {
  const e = [0, 0, 0];
  for (let t = 0; t < 24; t++)
    e[t % 3] <<= 1, e[t % 3] |= i & 1, i >>= 1;
  return (e[2] | 0) + (e[1] << 8) + (e[0] << 16);
}
function Hn(i, e) {
  for (; !(i.interactive && !e(i)); )
    if (i._parent)
      i = i._parent;
    else
      break;
}
function Ek(i, e, t) {
  return Me(i, Ma(e), (s) => {
    const r = hc(s);
    let n = s.touches;
    n ? (n.length == 0 && (n = s.changedTouches), t(Hi(n), r)) : t([s], r);
  });
}
function _h(i) {
  const e = document.createElement("canvas");
  e.width = 1, e.height = 1;
  const t = e.getContext("2d", { willReadFrequently: !0 });
  t.drawImage(i, 0, 0, 1, 1);
  try {
    return t.getImageData(0, 0, 1, 1), !1;
  } catch {
    return console.warn('Image "' + i.src + '" is loaded from different host and is not covered by CORS policy. For more information about the implications read here: https://www.amcharts.com/docs/v5/concepts/cors'), !0;
  }
}
function Vr(i) {
  i.width = 0, i.height = 0, i.style.width = "0px", i.style.height = "0px";
}
class Rk {
  constructor() {
    Object.defineProperty(this, "_x", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_y", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    });
  }
  get x() {
    return this._x;
  }
  get y() {
    return this._y;
  }
  set x(e) {
    this._x = e;
  }
  set y(e) {
    this._y = e;
  }
}
class jo extends Tr {
  constructor(e) {
    super(), Object.defineProperty(this, "_layer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "mask", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "visible", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "exportable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "interactive", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "inactive", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "wheelable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "cancelTouch", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "isMeasured", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "buttonMode", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "alpha", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), Object.defineProperty(this, "compoundAlpha", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), Object.defineProperty(this, "angle", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "scale", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), Object.defineProperty(this, "x", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "y", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "crisp", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "pivot", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new Rk()
    }), Object.defineProperty(this, "filter", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "cursorOverStyle", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_replacedCursorStyle", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_localMatrix", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new sl()
    }), Object.defineProperty(this, "_matrix", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new sl()
    }), Object.defineProperty(this, "_uMatrix", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new sl()
    }), Object.defineProperty(this, "_renderer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_parent", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_localBounds", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_bounds", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_colorId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._renderer = e;
  }
  _dispose() {
    this._renderer._removeObject(this), this.getLayer().dirty = !0;
  }
  getCanvas() {
    return this.getLayer().view;
  }
  getLayer() {
    let e = this;
    for (; ; ) {
      if (e._layer)
        return e._layer;
      if (e._parent)
        e = e._parent;
      else
        return this._renderer.defaultLayer;
    }
  }
  setLayer(e, t) {
    e == null ? this._layer = void 0 : (this._layer = this._renderer.getLayer(e, !0), this._layer.visible = !0, this._layer.margin = t, t && vs(this._layer.view, !1), this._renderer._ghostLayer.setMargin(this._renderer.layers), this._parent && this._parent.registerChildLayer(this._layer), this._layer.dirty = !0, this._renderer.resizeLayer(this._layer), this._renderer.resizeGhost());
  }
  markDirtyLayer() {
    this.getLayer().dirty = !0;
  }
  clear() {
    this.invalidateBounds();
  }
  invalidateBounds() {
    this._localBounds = void 0;
  }
  _addBounds(e) {
  }
  _getColorId() {
    return this._colorId === void 0 && (this._colorId = this._renderer.paintId(this)), this._colorId;
  }
  _isInteractive() {
    return this.inactive == !1 && (this.interactive || this._renderer._forceInteractive > 0);
  }
  _isInteractiveMask() {
    return this._isInteractive();
  }
  contains(e) {
    for (; ; ) {
      if (e === this)
        return !0;
      if (e._parent)
        e = e._parent;
      else
        return !1;
    }
  }
  toGlobal(e) {
    return this._matrix.apply(e);
  }
  toLocal(e) {
    return this._matrix.applyInverse(e);
  }
  getLocalMatrix() {
    return this._uMatrix.setTransform(0, 0, this.pivot.x, this.pivot.y, this.angle * Math.PI / 180, this.scale), this._uMatrix;
  }
  getLocalBounds() {
    return this._localBounds || (this._localBounds = {
      left: 1e7,
      top: 1e7,
      right: -1e7,
      bottom: -1e7
    }, this._addBounds(this._localBounds)), this._localBounds;
  }
  getAdjustedBounds(e) {
    this._setMatrix();
    const t = this.getLocalMatrix(), s = t.apply({ x: e.left, y: e.top }), r = t.apply({ x: e.right, y: e.top }), n = t.apply({ x: e.right, y: e.bottom }), a = t.apply({ x: e.left, y: e.bottom });
    return {
      left: Math.min(s.x, r.x, n.x, a.x),
      top: Math.min(s.y, r.y, n.y, a.y),
      right: Math.max(s.x, r.x, n.x, a.x),
      bottom: Math.max(s.y, r.y, n.y, a.y)
    };
  }
  on(e, t, s) {
    return this.interactive ? this._renderer._addEvent(this, e, t, s) : new Ge(() => {
    });
  }
  _setMatrix() {
    this._localMatrix.setTransform(
      this.x,
      this.y,
      this.pivot.x,
      this.pivot.y,
      // Converts degrees to radians
      this.angle * Math.PI / 180,
      this.scale
    ), this._matrix.copyFrom(this._localMatrix), this._parent && this._matrix.prepend(this._parent._matrix);
  }
  _transform(e, t) {
    const s = this._matrix;
    let r = s.tx * t, n = s.ty * t;
    this.crisp && (r = Math.floor(r) + 0.5, n = Math.floor(n) + 0.5), e.setTransform(s.a * t, s.b * t, s.c * t, s.d * t, r, n);
  }
  _transformMargin(e, t, s) {
    const r = this._matrix;
    e.setTransform(r.a * t, r.b * t, r.c * t, r.d * t, (r.tx + s.left) * t, (r.ty + s.top) * t);
  }
  _transformLayer(e, t, s) {
    s.margin ? this._transformMargin(e, s.scale || t, s.margin) : this._transform(e, s.scale || t);
  }
  render(e) {
    if (this.visible && (this.exportable !== !1 || !this._renderer._omitTainted)) {
      this._setMatrix();
      const t = this._renderer.resolution, s = this._renderer.layers, r = this._renderer._ghostLayer, n = r.context, a = this.mask;
      a && a._setMatrix(), w(s, (o) => {
        if (o) {
          const l = o.context;
          l.save(), a && (a._transformLayer(l, t, o), a._runPath(l), l.clip()), l.globalAlpha = this.compoundAlpha * this.alpha, this._transformLayer(l, t, o), this.filter && (l.filter = this.filter);
        }
      }), n.save(), a && this._isInteractiveMask() && (a._transformMargin(n, t, r.margin), a._runPath(n), n.clip()), this._transformMargin(n, t, r.margin), this._render(e), n.restore(), w(s, (o) => {
        o && o.context.restore();
      });
    }
  }
  _render(e) {
    if (this.exportable === !1) {
      const t = this._layer || e;
      t.tainted = !0;
    }
  }
  hovering() {
    return this._renderer._hovering.has(this);
  }
  dragging() {
    return this._renderer._dragging.some((e) => e.value === this);
  }
  shouldCancelTouch() {
    const e = this._renderer;
    return e.tapToActivate && !e._touchActive ? !1 : this.cancelTouch ? !0 : this._parent ? this._parent.shouldCancelTouch() : !1;
  }
}
class $k extends jo {
  constructor() {
    super(...arguments), Object.defineProperty(this, "interactiveChildren", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "_childLayers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_children", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    });
  }
  _isInteractiveMask() {
    return this.interactiveChildren || super._isInteractiveMask();
  }
  addChild(e) {
    e._parent = this, this._children.push(e), e._layer && this.registerChildLayer(e._layer);
  }
  addChildAt(e, t) {
    e._parent = this, this._children.splice(t, 0, e), e._layer && this.registerChildLayer(e._layer);
  }
  removeChild(e) {
    e._parent = void 0, ht(this._children, e);
  }
  _render(e) {
    super._render(e);
    const t = this._renderer;
    this.interactive && this.interactiveChildren && ++t._forceInteractive;
    const s = this._layer || e;
    w(this._children, (r) => {
      r.compoundAlpha = this.compoundAlpha * this.alpha, r.render(s);
    }), this.interactive && this.interactiveChildren && --t._forceInteractive;
  }
  registerChildLayer(e) {
    this._childLayers || (this._childLayers = []), lr(this._childLayers, e), this._parent && this._parent.registerChildLayer(e);
  }
  markDirtyLayer(e = !1) {
    super.markDirtyLayer(), e && this._childLayers && w(this._childLayers, (t) => t.dirty = !0);
  }
  _dispose() {
    super._dispose(), this._childLayers && w(this._childLayers, (e) => {
      e.dirty = !0;
    });
  }
}
function Xe(i, e) {
  i.left = Math.min(i.left, e.x), i.top = Math.min(i.top, e.y), i.right = Math.max(i.right, e.x), i.bottom = Math.max(i.bottom, e.y);
}
class et {
  colorize(e, t) {
  }
  path(e) {
  }
  addBounds(e) {
  }
}
class Nk extends et {
  colorize(e, t) {
    e.beginPath();
  }
}
class nl extends et {
  constructor(e) {
    super(), Object.defineProperty(this, "color", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
    });
  }
  colorize(e, t) {
    t !== void 0 ? e.fillStyle = t : e.fillStyle = this.color;
  }
}
class Fk extends et {
  constructor(e) {
    super(), Object.defineProperty(this, "clearShadow", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
    });
  }
  colorize(e, t) {
    e.fill(), this.clearShadow && (e.shadowColor = "", e.shadowBlur = 0, e.shadowOffsetX = 0, e.shadowOffsetY = 0);
  }
}
class Yk extends et {
  colorize(e, t) {
    e.stroke();
  }
}
class al extends et {
  constructor(e, t, s) {
    super(), Object.defineProperty(this, "width", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
    }), Object.defineProperty(this, "color", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
    }), Object.defineProperty(this, "lineJoin", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: s
    });
  }
  colorize(e, t) {
    t !== void 0 ? e.strokeStyle = t : e.strokeStyle = this.color, e.lineWidth = this.width, this.lineJoin && (e.lineJoin = this.lineJoin);
  }
}
class Bk extends et {
  constructor(e) {
    super(), Object.defineProperty(this, "dash", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
    });
  }
  colorize(e, t) {
    e.setLineDash(this.dash);
  }
}
class Hk extends et {
  constructor(e) {
    super(), Object.defineProperty(this, "dashOffset", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
    });
  }
  colorize(e, t) {
    e.lineDashOffset = this.dashOffset;
  }
}
class zk extends et {
  constructor(e, t, s, r) {
    super(), Object.defineProperty(this, "x", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
    }), Object.defineProperty(this, "y", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
    }), Object.defineProperty(this, "width", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: s
    }), Object.defineProperty(this, "height", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: r
    });
  }
  path(e) {
    e.rect(this.x, this.y, this.width, this.height);
  }
  addBounds(e) {
    const t = this.x, s = this.y, r = t + this.width, n = s + this.height;
    Xe(e, { x: t, y: s }), Xe(e, { x: r, y: s }), Xe(e, { x: t, y: n }), Xe(e, { x: r, y: n });
  }
}
class Vk extends et {
  constructor(e, t, s) {
    super(), Object.defineProperty(this, "x", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
    }), Object.defineProperty(this, "y", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
    }), Object.defineProperty(this, "radius", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: s
    });
  }
  path(e) {
    e.moveTo(this.x + this.radius, this.y), e.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
  }
  // TODO handle skewing and rotation
  addBounds(e) {
    Xe(e, { x: this.x - this.radius, y: this.y - this.radius }), Xe(e, { x: this.x + this.radius, y: this.y + this.radius });
  }
}
class Xk extends et {
  constructor(e, t, s, r) {
    super(), Object.defineProperty(this, "x", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
    }), Object.defineProperty(this, "y", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
    }), Object.defineProperty(this, "radiusX", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: s
    }), Object.defineProperty(this, "radiusY", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: r
    });
  }
  path(e) {
    e.ellipse(0, 0, this.radiusX, this.radiusY, 0, 0, Math.PI * 2);
  }
  // TODO handle skewing and rotation
  addBounds(e) {
    Xe(e, { x: this.x - this.radiusX, y: this.y - this.radiusY }), Xe(e, { x: this.x + this.radiusX, y: this.y + this.radiusY });
  }
}
class Wk extends et {
  constructor(e, t, s, r, n, a) {
    super(), Object.defineProperty(this, "cx", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
    }), Object.defineProperty(this, "cy", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
    }), Object.defineProperty(this, "radius", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: s
    }), Object.defineProperty(this, "startAngle", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: r
    }), Object.defineProperty(this, "endAngle", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: n
    }), Object.defineProperty(this, "anticlockwise", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: a
    });
  }
  path(e) {
    this.radius > 0 && e.arc(this.cx, this.cy, this.radius, this.startAngle, this.endAngle, this.anticlockwise);
  }
  addBounds(e) {
    let t = ja(this.cx, this.cy, this.startAngle * ks, this.endAngle * ks, this.radius);
    Xe(e, { x: t.left, y: t.top }), Xe(e, { x: t.right, y: t.bottom });
  }
}
class Uk extends et {
  constructor(e, t, s, r, n) {
    super(), Object.defineProperty(this, "x1", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
    }), Object.defineProperty(this, "y1", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
    }), Object.defineProperty(this, "x2", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: s
    }), Object.defineProperty(this, "y2", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: r
    }), Object.defineProperty(this, "radius", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: n
    });
  }
  path(e) {
    this.radius > 0 && e.arcTo(this.x1, this.y1, this.x2, this.y2, this.radius);
  }
  // TODO: add points
  addBounds(e) {
  }
}
class Gk extends et {
  constructor(e, t) {
    super(), Object.defineProperty(this, "x", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
    }), Object.defineProperty(this, "y", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
    });
  }
  path(e) {
    e.lineTo(this.x, this.y);
  }
  addBounds(e) {
    Xe(e, { x: this.x, y: this.y });
  }
}
class Zk extends et {
  constructor(e, t) {
    super(), Object.defineProperty(this, "x", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
    }), Object.defineProperty(this, "y", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
    });
  }
  path(e) {
    e.moveTo(this.x, this.y);
  }
  addBounds(e) {
    Xe(e, { x: this.x, y: this.y });
  }
}
class Kk extends et {
  path(e) {
    e.closePath();
  }
}
class qk extends et {
  constructor(e, t, s, r, n, a) {
    super(), Object.defineProperty(this, "cpX", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
    }), Object.defineProperty(this, "cpY", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
    }), Object.defineProperty(this, "cpX2", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: s
    }), Object.defineProperty(this, "cpY2", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: r
    }), Object.defineProperty(this, "toX", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: n
    }), Object.defineProperty(this, "toY", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: a
    });
  }
  path(e) {
    e.bezierCurveTo(this.cpX, this.cpY, this.cpX2, this.cpY2, this.toX, this.toY);
  }
  // TODO: OK?
  addBounds(e) {
    Xe(e, { x: this.cpX, y: this.cpY }), Xe(e, { x: this.cpX2, y: this.cpY2 }), Xe(e, { x: this.toX, y: this.toY });
  }
}
class Qk extends et {
  constructor(e, t, s, r) {
    super(), Object.defineProperty(this, "cpX", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
    }), Object.defineProperty(this, "cpY", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
    }), Object.defineProperty(this, "toX", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: s
    }), Object.defineProperty(this, "toY", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: r
    });
  }
  path(e) {
    e.quadraticCurveTo(this.cpX, this.cpY, this.toX, this.toY);
  }
  // TODO: OK?
  addBounds(e) {
    Xe(e, { x: this.cpX, y: this.cpY }), Xe(e, { x: this.toX, y: this.toY });
  }
}
class Jk extends et {
  constructor(e, t, s, r, n) {
    super(), Object.defineProperty(this, "color", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
    }), Object.defineProperty(this, "blur", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
    }), Object.defineProperty(this, "offsetX", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: s
    }), Object.defineProperty(this, "offsetY", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: r
    }), Object.defineProperty(this, "opacity", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: n
    });
  }
  colorize(e, t) {
    this.opacity && (e.fillStyle = this.color), e.shadowColor = this.color, e.shadowBlur = this.blur, e.shadowOffsetX = this.offsetX, e.shadowOffsetY = this.offsetY;
  }
}
class eP extends et {
  constructor(e, t, s, r, n) {
    super(), Object.defineProperty(this, "image", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
    }), Object.defineProperty(this, "width", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
    }), Object.defineProperty(this, "height", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: s
    }), Object.defineProperty(this, "x", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: r
    }), Object.defineProperty(this, "y", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: n
    });
  }
  path(e) {
    e.drawImage(this.image, this.x, this.y, this.width, this.height);
  }
  // TODO: OK?
  addBounds(e) {
    Xe(e, { x: this.x, y: this.y }), Xe(e, { x: this.width, y: this.height });
  }
}
class tP extends jo {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_operations", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "blendMode", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Ia.NORMAL
    }), Object.defineProperty(this, "_hasShadows", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_fillAlpha", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_strokeAlpha", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  clear() {
    super.clear(), this._operations.length = 0;
  }
  _pushOp(e) {
    this._operations.push(e);
  }
  beginFill(e, t = 1) {
    this._fillAlpha = t, e ? e instanceof V ? this._pushOp(new nl(e.toCSS(t))) : (this.isMeasured = !0, this._pushOp(new nl(e))) : this._pushOp(new nl("rgba(0, 0, 0, " + t + ")"));
  }
  endFill() {
    this._pushOp(new Fk(this._hasShadows));
  }
  endStroke() {
    this._pushOp(new Yk());
  }
  beginPath() {
    this._pushOp(new Nk());
  }
  lineStyle(e = 0, t, s = 1, r) {
    this._strokeAlpha = s, t ? t instanceof V ? this._pushOp(new al(e, t.toCSS(s), r)) : this._pushOp(new al(e, t, r)) : this._pushOp(new al(e, "rgba(0, 0, 0, " + s + ")", r));
  }
  setLineDash(e) {
    this._pushOp(new Bk(e || []));
  }
  setLineDashOffset(e = 0) {
    this._pushOp(new Hk(e));
  }
  drawRect(e, t, s, r) {
    this._pushOp(new zk(e, t, s, r));
  }
  drawCircle(e, t, s) {
    this._pushOp(new Vk(e, t, s));
  }
  drawEllipse(e, t, s, r) {
    this._pushOp(new Xk(e, t, s, r));
  }
  arc(e, t, s, r, n, a = !1) {
    this._pushOp(new Wk(e, t, s, r, n, a));
  }
  arcTo(e, t, s, r, n) {
    this._pushOp(new Uk(e, t, s, r, n));
  }
  lineTo(e, t) {
    this._pushOp(new Gk(e, t));
  }
  moveTo(e, t) {
    this._pushOp(new Zk(e, t));
  }
  bezierCurveTo(e, t, s, r, n, a) {
    this._pushOp(new qk(e, t, s, r, n, a));
  }
  quadraticCurveTo(e, t, s, r) {
    this._pushOp(new Qk(e, t, s, r));
  }
  closePath() {
    this._pushOp(new Kk());
  }
  shadow(e, t = 0, s = 0, r = 0, n) {
    this._hasShadows = !0, this._pushOp(new Jk(n ? e.toCSS(n) : e.toCSS(this._fillAlpha || this._strokeAlpha), t, s, r));
  }
  image(e, t, s, r, n) {
    this._pushOp(new eP(e, t, s, r, n));
  }
  // https://svgwg.org/svg2-draft/paths.html#DProperty
  // TODO better error checking
  svgPath(e) {
    let t = 0, s = 0, r = null, n = null, a = null, o = null;
    const l = /([MmZzLlHhVvCcSsQqTtAa])([^MmZzLlHhVvCcSsQqTtAa]*)/g, u = /[\u0009\u0020\u000A\u000C\u000D]*([\+\-]?[0-9]*\.?[0-9]+(?:[eE][\+\-]?[0-9]+)?)[\u0009\u0020\u000A\u000C\u000D]*,?/g;
    let h;
    for (; (h = l.exec(e)) !== null; ) {
      const c = h[1], f = h[2], d = [];
      for (; (h = u.exec(f)) !== null; )
        d.push(h[1]);
      switch (c !== "S" && c !== "s" && c !== "C" && c !== "c" && (r = null, n = null), c !== "Q" && c !== "q" && c !== "T" && c !== "t" && (a = null, o = null), c) {
        case "M":
          At(c, d.length, 2), t = +d[0], s = +d[1], this.moveTo(t, s);
          for (let p = 2; p < d.length; p += 2)
            t = +d[p], s = +d[p + 1], this.lineTo(t, s);
          break;
        case "m":
          At(c, d.length, 2), t += +d[0], s += +d[1], this.moveTo(t, s);
          for (let p = 2; p < d.length; p += 2)
            t += +d[p], s += +d[p + 1], this.lineTo(t, s);
          break;
        case "L":
          At(c, d.length, 2);
          for (let p = 0; p < d.length; p += 2)
            t = +d[p], s = +d[p + 1], this.lineTo(t, s);
          break;
        case "l":
          At(c, d.length, 2);
          for (let p = 0; p < d.length; p += 2)
            t += +d[p], s += +d[p + 1], this.lineTo(t, s);
          break;
        case "H":
          zr(c, d.length, 1);
          for (let p = 0; p < d.length; ++p)
            t = +d[p], this.lineTo(t, s);
          break;
        case "h":
          zr(c, d.length, 1);
          for (let p = 0; p < d.length; ++p)
            t += +d[p], this.lineTo(t, s);
          break;
        case "V":
          zr(c, d.length, 1);
          for (let p = 0; p < d.length; ++p)
            s = +d[p], this.lineTo(t, s);
          break;
        case "v":
          zr(c, d.length, 1);
          for (let p = 0; p < d.length; ++p)
            s += +d[p], this.lineTo(t, s);
          break;
        case "C":
          At(c, d.length, 6);
          for (let p = 0; p < d.length; p += 6) {
            const _ = +d[p], m = +d[p + 1];
            r = +d[p + 2], n = +d[p + 3], t = +d[p + 4], s = +d[p + 5], this.bezierCurveTo(_, m, r, n, t, s);
          }
          break;
        case "c":
          At(c, d.length, 6);
          for (let p = 0; p < d.length; p += 6) {
            const _ = +d[p] + t, m = +d[p + 1] + s;
            r = +d[p + 2] + t, n = +d[p + 3] + s, t += +d[p + 4], s += +d[p + 5], this.bezierCurveTo(_, m, r, n, t, s);
          }
          break;
        case "S":
          At(c, d.length, 4), (r === null || n === null) && (r = t, n = s);
          for (let p = 0; p < d.length; p += 4) {
            const _ = 2 * t - r, m = 2 * s - n;
            r = +d[p], n = +d[p + 1], t = +d[p + 2], s = +d[p + 3], this.bezierCurveTo(_, m, r, n, t, s);
          }
          break;
        case "s":
          At(c, d.length, 4), (r === null || n === null) && (r = t, n = s);
          for (let p = 0; p < d.length; p += 4) {
            const _ = 2 * t - r, m = 2 * s - n;
            r = +d[p] + t, n = +d[p + 1] + s, t += +d[p + 2], s += +d[p + 3], this.bezierCurveTo(_, m, r, n, t, s);
          }
          break;
        case "Q":
          At(c, d.length, 4);
          for (let p = 0; p < d.length; p += 4)
            a = +d[p], o = +d[p + 1], t = +d[p + 2], s = +d[p + 3], this.quadraticCurveTo(a, o, t, s);
          break;
        case "q":
          At(c, d.length, 4);
          for (let p = 0; p < d.length; p += 4)
            a = +d[p] + t, o = +d[p + 1] + s, t += +d[p + 2], s += +d[p + 3], this.quadraticCurveTo(a, o, t, s);
          break;
        case "T":
          At(c, d.length, 2), (a === null || o === null) && (a = t, o = s);
          for (let p = 0; p < d.length; p += 2)
            a = 2 * t - a, o = 2 * s - o, t = +d[p], s = +d[p + 1], this.quadraticCurveTo(a, o, t, s);
          break;
        case "t":
          At(c, d.length, 2), (a === null || o === null) && (a = t, o = s);
          for (let p = 0; p < d.length; p += 2)
            a = 2 * t - a, o = 2 * s - o, t += +d[p], s += +d[p + 1], this.quadraticCurveTo(a, o, t, s);
          break;
        case "A":
        case "a":
          const g = c === "a";
          jk(d), At(c, d.length, 7);
          for (let p = 0; p < d.length; p += 7) {
            let _ = +d[p + 5], m = +d[p + 6];
            g && (_ += t, m += s);
            const v = Ak({
              px: t,
              py: s,
              rx: +d[p],
              ry: +d[p + 1],
              xAxisRotation: +d[p + 2],
              largeArcFlag: gh(+d[p + 3]),
              sweepFlag: gh(+d[p + 4]),
              cx: _,
              cy: m
            });
            w(v, (b) => {
              this.bezierCurveTo(b.x1, b.y1, b.x2, b.y2, b.x, b.y), t = b.x, s = b.y;
            });
          }
          break;
        case "Z":
        case "z":
          Lk(c, d.length, 0), this.closePath();
          break;
      }
    }
  }
  _runPath(e) {
    e.beginPath(), w(this._operations, (t) => {
      t.path(e);
    });
  }
  _render(e) {
    super._render(e);
    const t = this._layer || e, s = t.dirty, r = this._isInteractive();
    if (s || r) {
      const n = t.context, a = this._renderer._ghostLayer.context;
      s && (n.globalCompositeOperation = this.blendMode, n.beginPath());
      let o;
      r && (a.beginPath(), o = this._getColorId()), w(this._operations, (l) => {
        s && (l.path(n), l.colorize(n, void 0)), r && (l.path(a), l.colorize(a, o));
      });
    }
  }
  renderDetached(e) {
    if (this.visible) {
      this._setMatrix(), e.save();
      const t = this.mask;
      t && (t._setMatrix(), t._transform(e, 1), t._runPath(e), e.clip()), e.globalAlpha = this.compoundAlpha * this.alpha, this._transform(e, 1), this.filter && (e.filter = this.filter), e.globalCompositeOperation = this.blendMode, e.beginPath(), w(this._operations, (s) => {
        s.path(e), s.colorize(e, void 0);
      }), e.restore();
    }
  }
  _addBounds(e) {
    this.visible && this.isMeasured && w(this._operations, (t) => {
      t.addBounds(e);
    });
  }
}
class vp extends jo {
  constructor(e, t, s) {
    super(e), Object.defineProperty(this, "text", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "style", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "resolution", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), Object.defineProperty(this, "textVisible", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "_textInfo", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_originalScale", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), this.text = t, this.style = s;
  }
  invalidateBounds() {
    super.invalidateBounds(), this._textInfo = void 0;
  }
  _shared(e) {
    this.style.textAlign && (e.textAlign = this.style.textAlign), this.style.direction && (e.direction = this.style.direction), this.style.textBaseline && (e.textBaseline = this.style.textBaseline);
  }
  _prerender(e, t = !1, s = !1) {
    super._render(e);
    const r = e.context, n = this._renderer._ghostLayer.context, a = this.style;
    let o = this._getFontStyle(void 0, s);
    r.font = o, this._isInteractive() && !t && (n.font = o), a.fill && (a.fill instanceof V ? r.fillStyle = a.fill.toCSS(a.fillOpacity != null ? a.fillOpacity : 1) : r.fillStyle = a.fill), a.shadowColor && (e.context.shadowColor = a.shadowColor.toCSS(a.shadowOpacity || 1)), a.shadowBlur && (e.context.shadowBlur = a.shadowBlur), a.shadowOffsetX && (e.context.shadowOffsetX = a.shadowOffsetX), a.shadowOffsetY && (e.context.shadowOffsetY = a.shadowOffsetY), this._shared(r), this._isInteractive() && !t && (n.fillStyle = this._getColorId(), this._shared(n));
  }
  _getFontStyle(e, t = !1) {
    const s = this.style;
    let r = [];
    return e && e.fontVariant ? r.push(e.fontVariant) : s.fontVariant && r.push(s.fontVariant), t || (e && e.fontWeight ? r.push(e.fontWeight) : s.fontWeight && r.push(s.fontWeight)), e && e.fontStyle ? r.push(e.fontStyle) : s.fontStyle && r.push(s.fontStyle), e && e.fontSize ? (S(e.fontSize) && (e.fontSize = e.fontSize + "px"), r.push(e.fontSize)) : s.fontSize && (S(s.fontSize) && (s.fontSize = s.fontSize + "px"), r.push(s.fontSize)), e && e.fontFamily ? r.push(e.fontFamily) : s.fontFamily ? r.push(s.fontFamily) : r.length && r.push("Arial"), r.join(" ");
  }
  _render(e) {
    const t = this._layer || e;
    if (this._textInfo || this._measure(t), this.textVisible) {
      const s = this._isInteractive(), r = t.context, n = t.dirty, a = this._renderer._ghostLayer.context;
      r.save(), a.save(), this._prerender(t), w(this._textInfo, (o, l) => {
        w(o.textChunks, (u, h) => {
          if (u.style && (r.save(), a.save(), r.font = u.style, this._isInteractive() && (a.font = u.style)), u.fill && (r.save(), r.fillStyle = u.fill.toCSS()), n && r.fillText(u.text, u.offsetX, o.offsetY + u.offsetY), u.textDecoration == "underline" || u.textDecoration == "line-through") {
            let c = 1, f = 1, d = u.height, g = u.offsetX;
            switch (this.style.textAlign) {
              case "right":
              case "end":
                g -= u.width;
                break;
              case "center":
                g -= u.width / 2;
                break;
            }
            if (u.style)
              switch (Ht.getTextStyle(u.style).fontWeight) {
                case "bolder":
                case "bold":
                case "700":
                case "800":
                case "900":
                  c = 2;
                  break;
              }
            d && (f = d / 20);
            let p;
            u.textDecoration == "line-through" ? p = c + o.offsetY + u.offsetY - u.height / 2 : p = c + f * 1.5 + o.offsetY + u.offsetY, r.save(), r.beginPath(), u.fill ? r.strokeStyle = u.fill.toCSS() : this.style.fill && this.style.fill instanceof V && (r.strokeStyle = this.style.fill.toCSS()), r.lineWidth = c * f, r.moveTo(g, p), r.lineTo(g + u.width, p), r.stroke(), r.restore();
          }
          s && this.interactive && a.fillText(u.text, u.offsetX, o.offsetY + u.offsetY), u.fill && r.restore(), u.style && (r.restore(), a.restore());
        });
      }), r.restore(), a.restore();
    }
  }
  _addBounds(e) {
    if (this.visible && this.isMeasured) {
      const t = this._measure(this.getLayer());
      Xe(e, { x: t.left, y: t.top }), Xe(e, { x: t.right, y: t.bottom });
    }
  }
  _ignoreFontWeight() {
    return /apple/i.test(navigator.vendor);
  }
  _measure(e) {
    const t = e.context, s = this._renderer._ghostLayer.context, r = this.style.direction == "rtl";
    this._textInfo = [];
    const n = this.style.oversizedBehavior, a = this.style.maxWidth, o = S(a) && n == "truncate", l = S(a) && (n == "wrap" || n == "wrap-no-break");
    t.save(), s.save(), this._prerender(e, !0, this._ignoreFontWeight());
    const u = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ", h = this.text.toString().replace(/\r/g, "").split(/\n/);
    let c = !0, f = 0, d = 0, g = 0, p;
    w(h, (m, v) => {
      let b;
      for (m == "" ? b = [{
        type: "value",
        text: ""
      }] : b = Ht.chunk(m, !1, this.style.ignoreFormatting); b.length > 0; ) {
        let y = {
          offsetY: g,
          ascent: 0,
          width: 0,
          height: 0,
          left: 0,
          right: 0,
          textChunks: []
        };
        const x = this._measureText(u, t), D = x.actualBoundingBoxAscent + x.actualBoundingBoxDescent;
        y.height = D, y.ascent = x.actualBoundingBoxAscent;
        let A, C = this.style.textDecoration, O, T, L = !1, j = !0, N = [], ee;
        ac(b, (z, H) => {
          if (z.type == "format")
            if (z.text == "[/]")
              c || (t.restore(), s.restore(), c = !0), O = void 0, p = void 0, T = void 0, C = this.style.textDecoration, ee = void 0, A = z.text;
            else {
              c || (t.restore(), s.restore());
              let $ = Ht.getTextStyle(z.text);
              const Z = this._getFontStyle($);
              t.save(), s.save(), t.font = Z, p = Z, A = z.text, $.textDecoration && (C = $.textDecoration), $.fill && (O = $.fill), $.width && (T = yt($.width)), $.verticalAlign && (ee = $.verticalAlign), c = !1;
              const B = this._measureText(u, t), he = B.actualBoundingBoxAscent + B.actualBoundingBoxDescent;
              he > y.height && (y.height = he), B.actualBoundingBoxAscent > y.ascent && (y.ascent = B.actualBoundingBoxAscent);
            }
          else if (z.type == "value" && !L) {
            const $ = this._measureText(z.text, t);
            let Z = $.actualBoundingBoxLeft + $.actualBoundingBoxRight;
            if (o) {
              let k = j || this.style.breakWords || !1;
              const P = this.style.ellipsis || "", F = this._measureText(P, t), te = F.actualBoundingBoxLeft + F.actualBoundingBoxRight;
              if (y.width + Z > a) {
                const U = a - y.width - te;
                z.text = this._truncateText(t, z.text, U, k), z.text += P, L = !0;
              }
            } else if (l && y.width + Z > a) {
              const k = a - y.width, P = this._truncateText(t, z.text, k, !1, j && this.style.oversizedBehavior != "wrap-no-break");
              if (P == "")
                return this.textVisible = !0, !1;
              N = b.slice(H + 1), Qr(P) != Qr(z.text) && (N.unshift({
                type: "value",
                text: z.text.substr(P.length)
              }), A && N.unshift({
                type: "format",
                text: A
              })), z.text = Qr(P), b = [], L = !0;
            }
            let B = 1, he = 1;
            if (p && T && T > Z) {
              const k = Z / T;
              switch (this.style.textAlign) {
                case "right":
                case "end":
                  B = k;
                  break;
                case "center":
                  B = k, he = k;
                  break;
                default:
                  he = k;
              }
              Z = T;
            }
            const M = $.actualBoundingBoxAscent + $.actualBoundingBoxDescent;
            M > y.height && (y.height = M), $.actualBoundingBoxAscent > y.ascent && (y.ascent = $.actualBoundingBoxAscent), y.width += Z, y.left += $.actualBoundingBoxLeft / B, y.right += $.actualBoundingBoxRight / he, y.textChunks.push({
              style: p,
              fill: O,
              text: z.text,
              width: Z,
              height: M,
              left: $.actualBoundingBoxLeft,
              right: $.actualBoundingBoxRight,
              ascent: $.actualBoundingBoxAscent,
              offsetX: 0,
              offsetY: 0,
              textDecoration: C,
              verticalAlign: ee
            }), j = !1;
          }
          return !0;
        }), this.style.lineHeight instanceof ae ? (y.height *= this.style.lineHeight.value, y.ascent *= this.style.lineHeight.value) : (y.height *= this.style.lineHeight || 1.2, y.ascent *= this.style.lineHeight || 1.2), f < y.left && (f = y.left), d < y.right && (d = y.right), this._textInfo.push(y), g += y.height, b = N || [];
      }
    }), c || (t.restore(), s.restore()), w(this._textInfo, (m, v) => {
      let b = 0;
      w(m.textChunks, (y) => {
        if (y.offsetX = b + y.left - m.left, y.offsetY += m.height - m.height * (this.style.baselineRatio || 0.19), b += y.width, y.verticalAlign)
          switch (y.verticalAlign) {
            case "super":
              y.offsetY -= m.height / 2 - y.height / 2;
              break;
            case "sub":
              y.offsetY += y.height / 2;
              break;
          }
      });
    });
    const _ = {
      left: r ? -d : -f,
      top: 0,
      right: r ? f : d,
      bottom: g
    };
    if (n !== "none") {
      const m = this._fitRatio(_);
      if (m < 1)
        if (n == "fit")
          S(this.style.minScale) && m < this.style.minScale ? (this.textVisible = !1, _.left = 0, _.top = 0, _.right = 0, _.bottom = 0) : ((!this._originalScale || this._originalScale == 1) && (this._originalScale = this.scale), this.scale = m, this.textVisible = !0);
        else if (n == "hide")
          this.textVisible = !1, _.left = 0, _.top = 0, _.right = 0, _.bottom = 0;
        else {
          switch (this.style.textAlign) {
            case "right":
            case "end":
              _.left = -a, _.right = 0;
              break;
            case "center":
              _.left = -a / 2, _.right = a / 2;
              break;
            default:
              _.left = 0, _.right = a;
          }
          this.scale = this._originalScale || 1, this._originalScale = void 0, this.textVisible = !0;
        }
      else
        this.scale = this._originalScale || 1, this._originalScale = void 0, this.textVisible = !0;
    }
    return t.restore(), s.restore(), _;
  }
  _fitRatio(e) {
    const t = this.style.maxWidth, s = this.style.maxHeight;
    if (!S(t) && !S(s))
      return 1;
    const r = e.right - e.left, n = e.bottom - e.top;
    return Math.min(t / r || 1, s / n || 1);
  }
  _truncateText(e, t, s, r = !1, n = !0) {
    let a;
    do {
      if (r)
        t = t.slice(0, -1);
      else {
        let l = t.replace(/[^,;:!?\\\/\s​]+[,;:!?\\\/\s​]*$/g, "");
        if (l == "" && n)
          r = !0;
        else {
          if (l == "")
            return t;
          t = l;
        }
      }
      const o = this._measureText(t, e);
      a = o.actualBoundingBoxLeft + o.actualBoundingBoxRight;
    } while (a > s && t != "");
    return t;
  }
  _measureText(e, t) {
    let s = t.measureText(e), r = {};
    if (s.actualBoundingBoxAscent == null) {
      const a = document.createElement("div");
      a.innerText = e, a.style.visibility = "hidden", a.style.position = "absolute", a.style.top = "-1000000px;", a.style.fontFamily = this.style.fontFamily || "", a.style.fontSize = this.style.fontSize + "", document.body.appendChild(a);
      const o = a.getBoundingClientRect();
      document.body.removeChild(a);
      const l = o.height, u = s.width;
      r = {
        actualBoundingBoxAscent: l,
        actualBoundingBoxDescent: 0,
        actualBoundingBoxLeft: 0,
        actualBoundingBoxRight: u,
        fontBoundingBoxAscent: l,
        fontBoundingBoxDescent: 0,
        width: u
      };
    } else
      r = {
        actualBoundingBoxAscent: s.actualBoundingBoxAscent,
        actualBoundingBoxDescent: s.actualBoundingBoxDescent,
        actualBoundingBoxLeft: s.actualBoundingBoxLeft,
        actualBoundingBoxRight: s.actualBoundingBoxRight,
        fontBoundingBoxAscent: s.actualBoundingBoxAscent,
        fontBoundingBoxDescent: s.actualBoundingBoxDescent,
        width: s.width
      };
    const n = s.width;
    switch (this.style.textAlign) {
      case "right":
      case "end":
        r.actualBoundingBoxLeft = n, r.actualBoundingBoxRight = 0;
        break;
      case "center":
        r.actualBoundingBoxLeft = n / 2, r.actualBoundingBoxRight = n / 2;
        break;
      default:
        r.actualBoundingBoxLeft = 0, r.actualBoundingBoxRight = n;
    }
    return r;
  }
}
class iP {
  constructor() {
    Object.defineProperty(this, "fill", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "fillOpacity", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "textAlign", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "fontFamily", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "fontSize", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "fontWeight", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "fontStyle", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "fontVariant", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "textDecoration", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shadowColor", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shadowBlur", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shadowOffsetX", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shadowOffsetY", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shadowOpacity", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "lineHeight", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: de(120)
    }), Object.defineProperty(this, "baselineRatio", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0.19
    }), Object.defineProperty(this, "direction", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "textBaseline", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "oversizedBehavior", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "none"
    }), Object.defineProperty(this, "breakWords", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "ellipsis", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "…"
    }), Object.defineProperty(this, "maxWidth", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "maxHeight", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "minScale", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "ignoreFormatting", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    });
  }
}
class sP extends vp {
  constructor() {
    super(...arguments), Object.defineProperty(this, "textType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "circular"
    }), Object.defineProperty(this, "radius", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "startAngle", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "inside", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "orientation", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "auto"
    }), Object.defineProperty(this, "kerning", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_textReversed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    });
  }
  _render(e) {
    switch (this.textType) {
      case "circular":
        this._renderCircular(e);
        break;
      default:
        super._render(e);
        break;
    }
  }
  _renderCircular(e) {
    if (this.textVisible) {
      const t = this._layer || e;
      this._prerender(t);
      const s = this._isInteractive(), r = t.context, n = t.dirty, a = this._renderer._ghostLayer.context;
      r.save(), s && a.save(), this._textInfo || this._measure(t);
      let o = this.radius || 0, l = this.startAngle || 0, u = 0, h = this.orientation, c = h == "auto" ? "auto" : h == "inward";
      const f = this.inside, d = this.style.textAlign || "left", g = this.kerning || 0;
      let p = d == "left" ? 1 : -1;
      const _ = !this._textReversed;
      if (c == "auto") {
        let m = 0, v = 0;
        w(this._textInfo, (b, y) => {
          const x = l + b.width / (o - b.height) / 2 * -p;
          x > m && (m = x);
        }), d == "left" ? v = (m + u / 2) * ks : d == "right" ? v = (m - u / 2) * ks : v = l * ks, v = Ms(v), c = v >= 270 || v <= 90;
      }
      c == !0 && _ && (this._textInfo.reverse(), this._textReversed = !0), w(this._textInfo, (m, v) => {
        const b = m.height;
        f || (o += b), (p == -1 && c || p == 1 && !c) && _ && m.textChunks.reverse();
        let y = l;
        u = 0, d == "center" && (y += m.width / (o - b) / 2 * -p, u = y - l), y += Math.PI * (c ? 0 : 1), r.save(), s && a.save(), r.rotate(y), s && a.rotate(y);
        let x = 0;
        w(m.textChunks, (D, A) => {
          const C = D.text, O = D.width;
          x = O / 2 / (o - b) * p, r.rotate(x), s && a.rotate(x), D.style && (r.save(), a.save(), r.font = D.style, s && (a.font = D.style)), D.fill && (r.save(), r.fillStyle = D.fill.toCSS()), r.textBaseline = "middle", r.textAlign = "center", s && (a.textBaseline = "middle", a.textAlign = "center"), n && r.fillText(C, 0, (c ? 1 : -1) * (0 - o + b / 2)), s && a.fillText(C, 0, (c ? 1 : -1) * (0 - o + b / 2)), D.fill && r.restore(), D.style && (r.restore(), a.restore()), x = (O / 2 + g) / (o - b) * p, r.rotate(x), s && a.rotate(x);
        }), r.restore(), s && a.restore(), f && (o -= b);
      }), r.restore(), s && a.restore();
    }
  }
  _measure(e) {
    switch (this.textType) {
      case "circular":
        return this._measureCircular(e);
      default:
        return super._measure(e);
    }
  }
  _measureCircular(e) {
    const t = e.context, s = this._renderer._ghostLayer.context, r = this.style.direction == "rtl", n = this.style.oversizedBehavior, a = this.style.maxWidth, o = S(a) && n == "truncate", l = this.style.ellipsis || "";
    let u;
    this.textVisible = !0, this._textInfo = [], this._textReversed = !1, t.save(), s.save(), this._prerender(e, !0);
    const h = this.text.toString().replace(/\r/g, "").split(/\n/);
    let c = !0, f = 0, d = 0;
    return w(h, (g, p) => {
      let _ = Ht.chunk(g, !1, this.style.ignoreFormatting), m = {
        offsetY: d,
        ascent: 0,
        width: 0,
        height: 0,
        left: 0,
        right: 0,
        textChunks: []
      }, v, b, y;
      w(_, (x, D) => {
        if (x.type == "format") {
          if (x.text == "[/]")
            c || (t.restore(), s.restore(), c = !0), b = void 0, v = void 0, y = void 0;
          else {
            let A = Ht.getTextStyle(x.text);
            const C = this._getFontStyle(A);
            t.save(), s.save(), t.font = C, v = C, A.fill && (b = A.fill), A.width && (y = yt(A.width)), c = !1;
          }
          o && (u = this._measureText(l, t));
        } else if (x.type == "value") {
          const A = x.text.match(/./ug) || [];
          r && A.reverse();
          for (let C = 0; C < A.length; C++) {
            const O = A[C], T = this._measureText(O, t);
            let L = T.width;
            v && y && y > L && (L = y);
            const j = T.actualBoundingBoxAscent + T.actualBoundingBoxDescent;
            if (j > m.height && (m.height = j), T.actualBoundingBoxAscent > m.ascent && (m.ascent = T.actualBoundingBoxAscent), m.width += L, m.left += T.actualBoundingBoxLeft, m.right += T.actualBoundingBoxRight, m.textChunks.push({
              style: v,
              fill: b,
              text: O,
              width: L,
              height: j + T.actualBoundingBoxDescent,
              left: T.actualBoundingBoxLeft,
              right: T.actualBoundingBoxRight,
              ascent: T.actualBoundingBoxAscent,
              offsetX: 0,
              offsetY: j,
              textDecoration: void 0
            }), f += L, o) {
              u || (u = this._measureText(l, t));
              const N = u.actualBoundingBoxLeft + u.actualBoundingBoxRight;
              if (f += N, f + N > a) {
                m.textChunks.length == 1 ? this.textVisible = !1 : (m.width += N, m.left += u.actualBoundingBoxLeft, m.right += u.actualBoundingBoxRight, m.textChunks.push({
                  style: v,
                  fill: b,
                  text: l,
                  width: N,
                  height: j + u.actualBoundingBoxDescent,
                  left: u.actualBoundingBoxLeft,
                  right: u.actualBoundingBoxRight,
                  ascent: u.actualBoundingBoxAscent,
                  offsetX: 0,
                  offsetY: j,
                  textDecoration: void 0
                }));
                break;
              }
            }
            if (r)
              break;
          }
        }
      }), this.style.lineHeight instanceof ae ? m.height *= this.style.lineHeight.value : m.height *= this.style.lineHeight || 1.2, this._textInfo.push(m), d += m.height;
    }), c || (t.restore(), s.restore()), n == "hide" && f > a && (this.textVisible = !1), w(this._textInfo, (g) => {
      w(g.textChunks, (p) => {
        p.offsetY += Math.round((g.height - p.height + (g.ascent - p.ascent)) / 2);
      });
    }), t.restore(), s.restore(), {
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
  }
}
class rP extends jo {
  constructor(e, t) {
    super(e), Object.defineProperty(this, "width", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "height", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "image", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tainted", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shadowColor", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shadowBlur", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shadowOffsetX", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shadowOffsetY", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shadowOpacity", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_imageMask", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.image = t;
  }
  _dispose() {
    super._dispose(), this._imageMask && Vr(this._imageMask);
  }
  getLocalBounds() {
    if (!this._localBounds) {
      let e = 0, t = 0;
      this.width && (e = this.width), this.height && (t = this.height), this._localBounds = {
        left: 0,
        top: 0,
        right: e,
        bottom: t
      }, this._addBounds(this._localBounds);
    }
    return this._localBounds;
  }
  _render(e) {
    if (super._render(e), this.image) {
      const t = this._layer || e;
      if (this.tainted === void 0 && (this.tainted = _h(this.image), t.tainted = !0), this.tainted && this._renderer._omitTainted)
        return;
      if (t.dirty) {
        this.shadowColor && (t.context.shadowColor = this.shadowColor.toCSS(this.shadowOpacity || 1)), this.shadowBlur && (t.context.shadowBlur = this.shadowBlur), this.shadowOffsetX && (t.context.shadowOffsetX = this.shadowOffsetX), this.shadowOffsetY && (t.context.shadowOffsetY = this.shadowOffsetY);
        const s = this.width || this.image.naturalWidth, r = this.height || this.image.naturalHeight;
        t.context.drawImage(this.image, 0, 0, s, r);
      }
      if (this.interactive && this._isInteractive()) {
        const s = this._getMask(this.image);
        this._renderer._ghostLayer.context.drawImage(s, 0, 0);
      }
    }
  }
  clear() {
    super.clear(), this.image = void 0, this._imageMask = void 0;
  }
  _getMask(e) {
    if (this._imageMask === void 0) {
      const t = this.width || e.naturalWidth, s = this.height || e.naturalHeight, r = document.createElement("canvas");
      r.width = t, r.height = s;
      const n = r.getContext("2d");
      n.imageSmoothingEnabled = !1, n.fillStyle = this._getColorId(), n.fillRect(0, 0, t, s), _h(e) || (n.globalCompositeOperation = "destination-in", n.drawImage(e, 0, 0, t, s)), this._imageMask = r;
    }
    return this._imageMask;
  }
}
class nP {
  constructor(e, t, s, r) {
    Object.defineProperty(this, "event", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
    }), Object.defineProperty(this, "originalPoint", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
    }), Object.defineProperty(this, "point", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: s
    }), Object.defineProperty(this, "bbox", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: r
    }), Object.defineProperty(this, "id", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "simulated", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "native", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), ei("touchevents") && e instanceof Touch ? this.id = e.identifier : this.id = null;
  }
}
class aP extends Lf {
  /*protected _mouseMoveThrottler: Throttler = new Throttler(() => {
      this._dispatchGlobalMousemove(this._lastPointerMoveEvent.event, this._lastPointerMoveEvent.native);
  });
  */
  constructor(e) {
    if (super(), Object.defineProperty(this, "view", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: document.createElement("div")
    }), Object.defineProperty(this, "_layerDom", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: document.createElement("div")
    }), Object.defineProperty(this, "layers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_dirtyLayers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "defaultLayer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.getLayer(0)
    }), Object.defineProperty(this, "_ghostLayer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new oP()
    }), Object.defineProperty(this, "_patternCanvas", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: document.createElement("canvas")
    }), Object.defineProperty(this, "_patternContext", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._patternCanvas.getContext("2d")
    }), Object.defineProperty(this, "_domWidth", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_domHeight", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_canvasWidth", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_canvasHeight", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "resolution", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "interactionsEnabled", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "_listeners", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_events", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_colorId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_colorMap", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_forceInteractive", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_omitTainted", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_hovering", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Set()
    }), Object.defineProperty(this, "_dragging", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_mousedown", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_lastPointerMoveEvent", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tapToActivate", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "tapToActivateTimeout", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 3e3
    }), Object.defineProperty(this, "_touchActive", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_touchActiveTimeout", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), e == null ? this.resolution = window.devicePixelRatio : this.resolution = e, this.view.style.position = "absolute", this.view.setAttribute("aria-hidden", "true"), this.view.appendChild(this._layerDom), this._disposers.push(new Ge(() => {
      ye(this._events, (t, s) => {
        s.disposer.dispose();
      }), w(this.layers, (t) => {
        Vr(t.view), t.exportableView && Vr(t.exportableView);
      }), Vr(this._ghostLayer.view), Vr(this._patternCanvas);
    })), this._disposers.push(cc(() => {
      e == null && (this.resolution = window.devicePixelRatio);
    })), ei("touchevents")) {
      const t = (s) => {
        this._dragging.length !== 0 && ac(this._dragging, (r) => r.value.shouldCancelTouch() ? (s.preventDefault(), !1) : !0), this._touchActiveTimeout && this._delayTouchDeactivate();
      };
      this._disposers.push(Me(window, "touchstart", t, { passive: !1 })), this._disposers.push(Me(this.view, "touchstart", t, { passive: !1 })), this._disposers.push(Me(this.view, "touchmove", () => {
        this._touchActiveTimeout && this._delayTouchDeactivate();
      }, { passive: !0 })), this._disposers.push(Me(window, "click", (s) => {
        this._touchActive = !1;
      }, { passive: !0 })), this._disposers.push(Me(this.view, "click", (s) => {
        window.setTimeout(() => {
          this._touchActive = !0, this._delayTouchDeactivate();
        }, 100);
      }, { passive: !0 }));
    }
    ei("wheelevents") && this._disposers.push(Me(this.view, "wheel", (t) => {
      let s = !1;
      this._hovering.forEach((r) => {
        if (r.wheelable)
          return s = !0, !1;
      }), s && t.preventDefault();
    }, { passive: !1 }));
  }
  _delayTouchDeactivate() {
    this._touchActiveTimeout && clearTimeout(this._touchActiveTimeout), this.tapToActivateTimeout > 0 && (this._touchActiveTimeout = window.setTimeout(() => {
      this._touchActive = !1;
    }, this.tapToActivateTimeout));
  }
  get debugGhostView() {
    return !!this._ghostLayer.view.parentNode;
  }
  set debugGhostView(e) {
    e ? this._ghostLayer.view.parentNode || this.view.appendChild(this._ghostLayer.view) : this._ghostLayer.view.parentNode && this._ghostLayer.view.parentNode.removeChild(this._ghostLayer.view);
  }
  createLinearGradient(e, t, s, r) {
    return this.defaultLayer.context.createLinearGradient(e, t, s, r);
  }
  createRadialGradient(e, t, s, r, n, a) {
    return this.defaultLayer.context.createRadialGradient(e, t, s, r, n, a);
  }
  createPattern(e, t, s, r, n) {
    return this._patternCanvas.width = r, this._patternCanvas.height = n, this._patternContext.clearRect(0, 0, r, n), t.renderDetached(this._patternContext), e.renderDetached(this._patternContext), this._patternContext.createPattern(this._patternCanvas, s);
  }
  makeContainer() {
    return new $k(this);
  }
  makeGraphics() {
    return new tP(this);
  }
  makeText(e, t) {
    return new vp(this, e, t);
  }
  makeTextStyle() {
    return new iP();
  }
  makeRadialText(e, t) {
    return new sP(this, e, t);
  }
  makePicture(e) {
    return new rP(this, e);
  }
  resizeLayer(e) {
    e.resize(this._canvasWidth, this._canvasHeight, this._domWidth, this._domHeight, this.resolution);
  }
  resizeGhost() {
    this._ghostLayer.resize(this._canvasWidth, this._canvasHeight, this._domWidth, this._domHeight, this.resolution);
  }
  resize(e, t, s, r) {
    this._canvasWidth = e, this._canvasHeight = t, this._domWidth = s, this._domHeight = r, w(this.layers, (n) => {
      n && (n.dirty = !0, this.resizeLayer(n));
    }), this.resizeGhost(), this.view.style.width = s + "px", this.view.style.height = r + "px";
  }
  createDetachedLayer(e = !1) {
    const t = document.createElement("canvas"), s = t.getContext("2d", { willReadFrequently: e }), r = new lP(t, s);
    return t.style.position = "absolute", t.style.top = "0px", t.style.left = "0px", r;
  }
  getLayerByOrder(e) {
    const t = this.layers, s = t.length;
    for (let r = 0; r < s; r++) {
      const n = t[r];
      if (n.order == e)
        return n;
    }
  }
  getLayer(e, t = !0) {
    let s = this.getLayerByOrder(e);
    if (s)
      return s;
    const r = this.createDetachedLayer(e == 99);
    r.order = e, r.visible = t, r.visible && this.resizeLayer(r);
    const n = this.layers;
    n.push(r), n.sort((u, h) => u.order > h.order ? 1 : u.order < h.order ? -1 : 0);
    const a = n.length, o = Zi(n, r);
    let l;
    for (let u = o + 1; u < a; u++)
      if (n[u].visible) {
        l = n[u];
        break;
      }
    return r.visible && (l === void 0 ? this._layerDom.appendChild(r.view) : this._layerDom.insertBefore(r.view, l.view)), r;
  }
  render(e) {
    if (this._dirtyLayers.length = 0, w(this.layers, (t) => {
      t && t.dirty && t.visible && (this._dirtyLayers.push(t), t.clear());
    }), this._ghostLayer.clear(), e.render(this.defaultLayer), this._ghostLayer.context.restore(), w(this.layers, (t) => {
      if (t) {
        const s = t.context;
        s.beginPath(), s.moveTo(0, 0), s.stroke();
      }
    }), w(this._dirtyLayers, (t) => {
      t.context.restore(), t.dirty = !1;
    }), this._hovering.size && this._lastPointerMoveEvent) {
      const { events: t, target: s, native: r } = this._lastPointerMoveEvent;
      w(t, (n) => {
        this._dispatchGlobalMousemove(n, s, r);
      });
    }
  }
  paintId(e) {
    const t = Ik(++this._colorId), s = V.fromHex(t).toCSS();
    return this._colorMap[s] = e, s;
  }
  _removeObject(e) {
    e._colorId !== void 0 && delete this._colorMap[e._colorId];
  }
  // protected _identifyObjectByColor(colorId: number): CanvasDisplayObject | undefined {
  // 	return this._colorMap[colorId];
  // }
  _adjustBoundingBox(e) {
    const t = this._ghostLayer.margin;
    return new DOMRect(e.left - t.left, e.top - t.top, e.width + t.left + t.right, e.height + t.top + t.bottom);
  }
  getEvent(e, t = !0) {
    const s = this.view.getBoundingClientRect(), r = {
      x: e.clientX || 0,
      y: e.clientY || 0
    }, n = {
      x: r.x - (t ? s.left : 0),
      y: r.y - (t ? s.top : 0)
    };
    return new nP(e, r, n, this._adjustBoundingBox(s));
  }
  _getHitTarget(e, t, s) {
    if (t.width === 0 || t.height === 0 || e.x < t.left || e.x > t.right || e.y < t.top || e.y > t.bottom || !s || !this._layerDom.contains(s))
      return;
    const r = this._ghostLayer.getImageData(e, t);
    if (r.data[0] === 0 && r.data[1] === 0 && r.data[2] === 0)
      return !1;
    const n = V.fromRGB(r.data[0], r.data[1], r.data[2]).toCSS();
    return this._colorMap[n];
  }
  _withEvents(e, t) {
    const s = this._events[e];
    if (s !== void 0) {
      s.dispatching = !0;
      try {
        t(s);
      } finally {
        s.dispatching = !1, s.cleanup && (s.cleanup = !1, Tn(s.callbacks, (r) => !r.disposed), s.callbacks.length === 0 && (s.disposer.dispose(), delete this._events[e]));
      }
    }
  }
  _dispatchEventAll(e, t) {
    this.interactionsEnabled && this._withEvents(e, (s) => {
      w(s.callbacks, (r) => {
        r.disposed || r.callback.call(r.context, t);
      });
    });
  }
  _dispatchEvent(e, t, s) {
    if (!this.interactionsEnabled)
      return !1;
    let r = !1;
    return this._withEvents(e, (n) => {
      w(n.callbacks, (a) => {
        !a.disposed && a.object === t && (a.callback.call(a.context, s), r = !0);
      });
    }), r;
  }
  _dispatchMousedown(e, t) {
    const s = e.button;
    if (s != 0 && s != 2 && s != 1 && s !== void 0)
      return;
    const r = this.getEvent(e), n = this._getHitTarget(r.originalPoint, r.bbox, t);
    if (n) {
      const a = r.id;
      let o = !1;
      Hn(n, (l) => {
        const u = { id: a, value: l };
        return this._mousedown.push(u), !o && this._dispatchEvent("pointerdown", l, r) && (o = !0, this._dragging.some((c) => c.value === l && c.id === a) || this._dragging.push(u)), !0;
      });
    }
  }
  _dispatchGlobalMousemove(e, t, s) {
    const r = this.getEvent(e), n = this._getHitTarget(r.originalPoint, r.bbox, t);
    r.native = s, n ? (this._hovering.forEach((a) => {
      a.contains(n) || (this._hovering.delete(a), a.cursorOverStyle && na(document.body, "cursor", a._replacedCursorStyle), this._dispatchEvent("pointerout", a, r));
    }), r.native && Hn(n, (a) => (this._hovering.has(a) || (this._hovering.add(a), a.cursorOverStyle && (a._replacedCursorStyle = Ff(document.body, "cursor"), na(document.body, "cursor", a.cursorOverStyle)), this._dispatchEvent("pointerover", a, r)), !0))) : (this._hovering.forEach((a) => {
      a.cursorOverStyle && na(document.body, "cursor", a._replacedCursorStyle), this._dispatchEvent("pointerout", a, r);
    }), this._hovering.clear()), this._dispatchEventAll("globalpointermove", r);
  }
  _dispatchGlobalMouseup(e, t) {
    const s = this.getEvent(e);
    s.native = t, this._dispatchEventAll("globalpointerup", s);
  }
  _dispatchDragMove(e) {
    if (this._dragging.length !== 0) {
      const t = this.getEvent(e), s = t.id;
      this._dragging.forEach((r) => {
        r.id === s && this._dispatchEvent("pointermove", r.value, t);
      });
    }
  }
  _dispatchDragEnd(e, t) {
    const s = e.button;
    let r;
    if (s == 0 || s === void 0)
      r = "click";
    else if (s == 2)
      r = "rightclick";
    else if (s == 1)
      r = "middleclick";
    else
      return;
    const n = this.getEvent(e), a = n.id;
    if (this._mousedown.length !== 0) {
      const o = this._getHitTarget(n.originalPoint, n.bbox, t);
      o && this._mousedown.forEach((l) => {
        l.id === a && l.value.contains(o) && this._dispatchEvent(r, l.value, n);
      }), this._mousedown.length = 0;
    }
    this._dragging.length !== 0 && (this._dragging.forEach((o) => {
      o.id === a && this._dispatchEvent("pointerup", o.value, n);
    }), this._dragging.length = 0);
  }
  _dispatchDoubleClick(e, t) {
    const s = this.getEvent(e), r = this._getHitTarget(s.originalPoint, s.bbox, t);
    r && Hn(r, (n) => !this._dispatchEvent("dblclick", n, s));
  }
  _dispatchWheel(e, t) {
    const s = this.getEvent(e), r = this._getHitTarget(s.originalPoint, s.bbox, t);
    r && Hn(r, (n) => !this._dispatchEvent("wheel", n, s));
  }
  _makeSharedEvent(e, t) {
    if (this._listeners[e] === void 0) {
      const s = t();
      this._listeners[e] = new To(() => {
        delete this._listeners[e], s.dispose();
      });
    }
    return this._listeners[e].increment();
  }
  _onPointerEvent(e, t) {
    let s = !1, r = null;
    function n() {
      r = null, s = !1;
    }
    return new ut([
      new Ge(() => {
        r !== null && clearTimeout(r), n();
      }),
      Me(this.view, Ma(e), (a) => {
        s = !0, r !== null && clearTimeout(r), r = window.setTimeout(n, 0);
      }),
      Ek(window, e, (a, o) => {
        r !== null && (clearTimeout(r), r = null), t(a, o, s), s = !1;
      })
    ]);
  }
  // This ensures that only a single DOM event is added (e.g. only a single mousemove event listener)
  _initEvent(e) {
    switch (e) {
      case "globalpointermove":
      case "pointerover":
      case "pointerout":
        return this._makeSharedEvent("pointermove", () => {
          const t = (s, r, n) => {
            this._lastPointerMoveEvent = { events: s, target: r, native: n }, w(s, (a) => {
              this._dispatchGlobalMousemove(a, r, n);
            });
          };
          return new ut([
            this._onPointerEvent("pointerdown", t),
            this._onPointerEvent("pointermove", t)
          ]);
        });
      case "globalpointerup":
        return this._makeSharedEvent("pointerup", () => {
          const t = this._onPointerEvent("pointerup", (r, n, a) => {
            w(r, (o) => {
              this._dispatchGlobalMouseup(o, a);
            }), this._lastPointerMoveEvent = { events: r, target: n, native: a };
          }), s = this._onPointerEvent("pointercancel", (r, n, a) => {
            w(r, (o) => {
              this._dispatchGlobalMouseup(o, a);
            }), this._lastPointerMoveEvent = { events: r, target: n, native: a };
          });
          return new Ge(() => {
            t.dispose(), s.dispose();
          });
        });
      case "click":
      case "rightclick":
      case "middleclick":
      case "pointerdown":
      case "pointermove":
      case "pointerup":
        return this._makeSharedEvent("pointerdown", () => {
          const t = this._onPointerEvent("pointerdown", (a, o) => {
            w(a, (l) => {
              this._dispatchMousedown(l, o);
            });
          }), s = this._onPointerEvent("pointermove", (a) => {
            w(a, (o) => {
              this._dispatchDragMove(o);
            });
          }), r = this._onPointerEvent("pointerup", (a, o) => {
            w(a, (l) => {
              this._dispatchDragEnd(l, o);
            });
          }), n = this._onPointerEvent("pointercancel", (a, o) => {
            w(a, (l) => {
              this._dispatchDragEnd(l, o);
            });
          });
          return new Ge(() => {
            t.dispose(), s.dispose(), r.dispose(), n.dispose();
          });
        });
      case "dblclick":
        return this._makeSharedEvent("dblclick", () => this._onPointerEvent("dblclick", (t, s) => {
          w(t, (r) => {
            this._dispatchDoubleClick(r, s);
          });
        }));
      case "wheel":
        return this._makeSharedEvent("wheel", () => Me(window, Ma("wheel"), (t) => {
          this._dispatchWheel(t, hc(t));
        }, { passive: !1 }));
    }
  }
  _addEvent(e, t, s, r) {
    let n = this._events[t];
    n === void 0 && (n = this._events[t] = {
      disposer: this._initEvent(t),
      callbacks: [],
      dispatching: !1,
      cleanup: !1
    });
    const a = { object: e, context: r, callback: s, disposed: !1 };
    return n.callbacks.push(a), new Ge(() => {
      a.disposed = !0, n.dispatching ? n.cleanup = !0 : (ht(n.callbacks, a), n.callbacks.length === 0 && (n.disposer.dispose(), delete this._events[t]));
    });
  }
  getCanvas(e, t) {
    this.render(e), t || (t = {});
    let s = this.resolution, r = Math.floor(this._canvasWidth * this.resolution), n = Math.floor(this._canvasHeight * this.resolution);
    if (t.minWidth && t.minWidth > r) {
      let d = t.minWidth / r;
      d > s && (s = d * this.resolution);
    }
    if (t.minHeight && t.minHeight > n) {
      let d = t.minHeight / n;
      d > s && (s = d * this.resolution);
    }
    if (t.maxWidth && t.maxWidth < r) {
      let d = t.maxWidth / r;
      d < s && (s = d * this.resolution);
    }
    if (t.maxHeight && t.maxHeight > n) {
      let d = t.maxHeight / n;
      d < s && (s = d * this.resolution);
    }
    t.maintainPixelRatio && (s /= this.resolution);
    const a = [];
    let o = !1;
    const l = document.createElement("canvas");
    s != this.resolution && (o = !0, r = r * s / this.resolution, n = n * s / this.resolution), l.width = r, l.height = n, l.style.position = "fixed", l.style.top = "-10000px", this.view.appendChild(l), a.push(l);
    const u = l.getContext("2d");
    let h = 0, c = 0, f = !1;
    return w(this.layers, (d) => {
      if (d && d.visible && (d.tainted || o)) {
        f = !0, d.exportableView = d.view, d.exportableContext = d.context, d.view = document.createElement("canvas"), d.view.style.position = "fixed", d.view.style.top = "-10000px", this.view.appendChild(d.view), a.push(d.view);
        let g = 0, p = 0;
        d.margin && (g += d.margin.left || 0 + d.margin.right || 0, p += d.margin.top || 0 + d.margin.bottom || 0), d.view.width = r + g, d.view.height = n + p, d.context = d.view.getContext("2d"), d.dirty = !0, d.scale = s;
      }
    }), f && (this._omitTainted = !0, this.render(e), this._omitTainted = !1), w(this.layers, (d) => {
      if (d && d.visible) {
        let g = 0, p = 0;
        d.margin && (g = -(d.margin.left || 0) * this.resolution, p = -(d.margin.top || 0) * this.resolution), u.drawImage(d.view, g, p), d.exportableView && (d.view = d.exportableView, d.exportableView = void 0), d.exportableContext && (d.context = d.exportableContext, d.exportableContext = void 0), h < d.view.clientWidth && (h = d.view.clientWidth), c < d.view.clientHeight && (c = d.view.clientHeight), d.scale = void 0;
      }
    }), l.style.width = h + "px", l.style.height = c + "px", w(a, (d) => {
      d.style.position = "", d.style.top = "", this.view.removeChild(d);
    }), l;
  }
}
class oP {
  constructor() {
    Object.defineProperty(this, "view", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "context", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "margin", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
      }
    }), Object.defineProperty(this, "_width", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_height", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), this.view = document.createElement("canvas"), this.context = this.view.getContext("2d", { alpha: !1, willReadFrequently: !0 }), this.context.imageSmoothingEnabled = !1, this.view.style.position = "absolute", this.view.style.top = "0px", this.view.style.left = "0px";
  }
  resize(e, t, s, r, n) {
    e += this.margin.left + this.margin.right, t += this.margin.top + this.margin.bottom, s += this.margin.left + this.margin.right, r += this.margin.top + this.margin.bottom, this.view.style.left = -this.margin.left + "px", this.view.style.top = -this.margin.top + "px", this._width = Math.floor(e * n), this._height = Math.floor(t * n), this.view.width = this._width, this.view.style.width = s + "px", this.view.height = this._height, this.view.style.height = r + "px";
  }
  getImageData(e, t) {
    return this.context.getImageData(
      // TODO should this round ?
      Math.round((e.x - t.left) / t.width * this._width),
      Math.round((e.y - t.top) / t.height * this._height),
      1,
      1
    );
  }
  setMargin(e) {
    this.margin.left = 0, this.margin.right = 0, this.margin.top = 0, this.margin.bottom = 0, w(e, (t) => {
      t.margin && (this.margin.left = Math.max(this.margin.left, t.margin.left), this.margin.right = Math.max(this.margin.right, t.margin.right), this.margin.top = Math.max(this.margin.top, t.margin.top), this.margin.bottom = Math.max(this.margin.bottom, t.margin.bottom));
    });
  }
  clear() {
    this.context.save(), this.context.fillStyle = "#000", this.context.fillRect(0, 0, this._width, this._height);
  }
}
class lP {
  constructor(e, t) {
    Object.defineProperty(this, "view", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "context", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tainted", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "margin", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "order", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "visible", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "width", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "height", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "scale", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "dirty", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "exportableView", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "exportableContext", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_width", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_height", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), this.view = e, this.context = t;
  }
  resize(e, t, s, r, n) {
    this.width != null && (e = this.width, s = this.width), this.height != null && (t = this.height, r = this.height), this.margin ? (e += this.margin.left + this.margin.right, t += this.margin.top + this.margin.bottom, s += this.margin.left + this.margin.right, r += this.margin.top + this.margin.bottom, this.view.style.left = -this.margin.left + "px", this.view.style.top = -this.margin.top + "px") : (this.view.style.left = "0px", this.view.style.top = "0px"), this._width = Math.floor(e * n), this._height = Math.floor(t * n), this.view.width = this._width, this.view.style.width = s + "px", this.view.height = this._height, this.view.style.height = r + "px";
  }
  clear() {
    this.context.save(), this.context.clearRect(0, 0, this._width, this._height);
  }
}
function mh(i, e) {
  i == null ? requestAnimationFrame(e) : setTimeout(() => {
    requestAnimationFrame(e);
  }, 1e3 / i);
}
class Or {
  constructor(e, t = {}, s) {
    if (Object.defineProperty(this, "dom", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_inner", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_settings", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_isDirty", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_isDirtyParents", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_dirty", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_dirtyParents", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_dirtyBounds", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_dirtyPositions", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_ticker", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "_tickers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_updateTick", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "events", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new kr()
    }), Object.defineProperty(this, "animationTime", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "_animations", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_renderer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_rootContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "container", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tooltipContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_tooltipContainerSettings", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_tooltip", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "language", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Tk.new(this, {})
    }), Object.defineProperty(this, "locale", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: yp
    }), Object.defineProperty(this, "utc", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "timezone", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "fps", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "numberFormatter", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: pp.new(this, {})
    }), Object.defineProperty(this, "dateFormatter", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: mp.new(this, {})
    }), Object.defineProperty(this, "durationFormatter", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: bp.new(this, {})
    }), Object.defineProperty(this, "tabindex", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_tabindexes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_a11yD", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_focusElementDirty", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_focusElementContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_focusedSprite", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_isShift", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_keyboardDragPoint", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_tooltipElementContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_readerAlertElement", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_logo", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_tooltipDiv", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "nonce", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "interfaceColors", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "verticalLayout", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Ls.new(this, {})
    }), Object.defineProperty(this, "horizontalLayout", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: As.new(this, {})
    }), Object.defineProperty(this, "gridLayout", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Ki.new(this, {})
    }), Object.defineProperty(this, "_paused", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "autoResize", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "_fontHash", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ""
    }), Object.defineProperty(this, "_isDisposed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_disposers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_resizeSensorDisposer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_tooltips", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_htmlElementContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_htmlEnabledContainers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), !s)
      throw new Error("You cannot use `new Class()`, instead use `Class.new()`");
    this._settings = t, t.accessible == !1 && (this._a11yD = !0), t.useSafeResolution == null && (t.useSafeResolution = !0);
    let r;
    t.useSafeResolution && (r = zf()), this._renderer = new aP(r);
    let n;
    if (e instanceof HTMLElement ? n = e : n = document.getElementById(e), w(Rt.rootElements, (l) => {
      if (l.dom === n)
        throw new Error("You cannot have multiple Roots on the same DOM node");
    }), this.interfaceColors = an.new(this, {}), n === null)
      throw new Error("Could not find HTML element with id `" + e + "`");
    this.dom = n;
    let a = document.createElement("div");
    a.style.position = "relative", a.style.height = "100%", n.appendChild(a);
    const o = t.tooltipContainerBounds;
    o && (this._tooltipContainerSettings = o), this._inner = a, this._updateComputedStyles(), Rt.rootElements.push(this);
  }
  static new(e, t) {
    const s = new Or(e, t, !0);
    return s._init(), s;
  }
  moveDOM(e) {
    let t;
    if (e instanceof HTMLElement ? t = e : t = document.getElementById(e), t) {
      for (; this.dom.childNodes.length > 0; )
        t.appendChild(this.dom.childNodes[0]);
      this.dom = t, this._initResizeSensor(), this.resize();
    }
  }
  _handleLogo() {
    if (this._logo) {
      const e = this.dom.offsetWidth, t = this.dom.offsetHeight;
      e <= 150 || t <= 60 ? this._logo.hide() : this._logo.show();
    }
  }
  _showBranding() {
    if (!this._logo) {
      const e = this.tooltipContainer.children.push(G.new(this, {
        interactive: !0,
        interactiveChildren: !1,
        position: "absolute",
        setStateOnChildren: !0,
        paddingTop: 9,
        paddingRight: 9,
        paddingBottom: 9,
        paddingLeft: 9,
        scale: 0.6,
        y: de(100),
        centerY: R,
        tooltipText: "Created using amCharts 5",
        tooltipX: R,
        cursorOverStyle: "pointer",
        background: gt.new(this, {
          fill: K(4671320),
          fillOpacity: 0,
          tooltipY: 5
        })
      })), t = pi.new(this, {
        pointerOrientation: "horizontal",
        paddingTop: 4,
        paddingRight: 7,
        paddingBottom: 4,
        paddingLeft: 7
      });
      t.label.setAll({
        fontSize: 12
      }), t.get("background").setAll({
        fill: this.interfaceColors.get("background"),
        stroke: this.interfaceColors.get("grid"),
        strokeOpacity: 0.3
      }), e.set("tooltip", t), e.events.on("click", () => {
        window.open("https://www.amcharts.com/", "_blank");
      }), e.states.create("hover", {}), e.children.push(ce.new(this, {
        stroke: K(13421772),
        strokeWidth: 3,
        svgPath: "M5 25 L13 25h13.6c3.4 0 6 0 10.3-4.3s5.2-12 8.6-12c3.4 0 4.3 8.6 7.7 8.6M83.4 25H79.8c-3.4 0-6 0-10.3-4.3s-5.2-12-8.6-12-4.3 8.6-7.7 8.6"
      })).states.create("hover", { stroke: K(3976191) }), e.children.push(ce.new(this, {
        stroke: K(8947848),
        strokeWidth: 3,
        svgPath: "M83.4 25h-31C37 25 39.5 4.4 28.4 4.4S18.9 24.2 4.3 25H0"
      })).states.create("hover", { stroke: K(4671320) }), this._logo = e, this._handleLogo();
    }
  }
  _getRealSize() {
    return this.dom.getBoundingClientRect();
  }
  _getCalculatedSize(e) {
    return this._settings.calculateSize ? this._settings.calculateSize(e) : {
      width: e.width,
      height: e.height
    };
  }
  _init() {
    const e = this._settings;
    e.accessible !== !1 && (e.focusable && (this._inner.setAttribute("focusable", "true"), this._inner.setAttribute("tabindex", this.tabindex + "")), e.ariaLabel && this._inner.setAttribute("aria-label", e.ariaLabel));
    const t = this._renderer, s = this._getRealSize(), r = this._getCalculatedSize(s), n = Math.floor(r.width), a = Math.floor(r.height), o = Math.floor(s.width), l = Math.floor(s.height), u = G.new(this, {
      visible: !0,
      width: o,
      height: l
    });
    this._rootContainer = u, this._rootContainer._defaultThemes.push(kk.new(this));
    const h = u.children.push(G.new(this, { visible: !0, width: R, height: R }));
    this.container = h, t.resize(o, l, n, a), this._inner.appendChild(t.view), this._initResizeSensor();
    const c = document.createElement("div");
    if (this._htmlElementContainer = c, c.className = "am5-html-container", c.style.position = "absolute", c.style.pointerEvents = "none", this._tooltipContainerSettings || (c.style.overflow = "hidden"), this._inner.appendChild(c), this._a11yD !== !0) {
      const f = document.createElement("div");
      f.className = "am5-reader-container", f.setAttribute("role", "alert"), f.style.position = "absolute", f.style.width = "1px", f.style.height = "1px", f.style.overflow = "hidden", f.style.clip = "rect(1px, 1px, 1px, 1px)", this._readerAlertElement = f, this._inner.appendChild(this._readerAlertElement);
      const d = document.createElement("div");
      d.className = "am5-focus-container", d.style.position = "absolute", d.style.pointerEvents = "none", d.style.top = "0px", d.style.left = "0px", d.style.overflow = "hidden", d.style.width = n + "px", d.style.height = a + "px", d.setAttribute("role", "graphics-document"), vs(d, !1), this._focusElementContainer = d, this._inner.appendChild(this._focusElementContainer);
      const g = document.createElement("div");
      this._tooltipElementContainer = g, g.className = "am5-tooltip-container", this._inner.appendChild(g), ei("keyboardevents") && (this._disposers.push(Me(window, "keydown", (p) => {
        p.keyCode == 16 ? this._isShift = !0 : p.keyCode == 9 && (this._isShift = p.shiftKey);
      })), this._disposers.push(Me(window, "keyup", (p) => {
        p.keyCode == 16 && (this._isShift = !1);
      })), this._disposers.push(Me(d, "keydown", (p) => {
        const _ = this._focusedSprite;
        if (_) {
          p.keyCode == 27 && ($f(), this._focusedSprite = void 0);
          let m = 0, v = 0;
          switch (p.keyCode) {
            case 13:
              p.preventDefault();
              const b = t.getEvent(new MouseEvent("click"));
              _.events.dispatch("click", {
                type: "click",
                originalEvent: b.event,
                point: b.point,
                simulated: !0,
                target: _
              });
              return;
            case 37:
              m = -6;
              break;
            case 39:
              m = 6;
              break;
            case 38:
              v = -6;
              break;
            case 40:
              v = 6;
              break;
            default:
              return;
          }
          if (m != 0 || v != 0) {
            if (p.preventDefault(), !_.isDragging()) {
              this._keyboardDragPoint = {
                x: 0,
                y: 0
              };
              const x = t.getEvent(new MouseEvent("mousedown", {
                clientX: 0,
                clientY: 0
              }));
              _.events.isEnabled("pointerdown") && _.events.dispatch("pointerdown", {
                type: "pointerdown",
                originalEvent: x.event,
                point: x.point,
                simulated: !0,
                target: _
              });
            }
            const b = this._keyboardDragPoint;
            b.x += m, b.y += v;
            const y = t.getEvent(new MouseEvent("mousemove", {
              clientX: b.x,
              clientY: b.y
            }), !1);
            _.events.isEnabled("globalpointermove") && _.events.dispatch("globalpointermove", {
              type: "globalpointermove",
              originalEvent: y.event,
              point: y.point,
              simulated: !0,
              target: _
            });
          }
        }
      })), this._disposers.push(Me(d, "keyup", (p) => {
        if (this._focusedSprite) {
          const _ = this._focusedSprite, m = p.keyCode;
          switch (m) {
            case 37:
            case 39:
            case 38:
            case 40:
              if (_.isDragging()) {
                const v = this._keyboardDragPoint, b = t.getEvent(new MouseEvent("mouseup", {
                  clientX: v.x,
                  clientY: v.y
                }));
                _.events.isEnabled("globalpointerup") && _.events.dispatch("globalpointerup", {
                  type: "globalpointerup",
                  originalEvent: b.event,
                  point: b.point,
                  simulated: !0,
                  target: _
                }), this._keyboardDragPoint = void 0;
                return;
              } else if (_.get("focusableGroup")) {
                const v = _.get("focusableGroup"), b = this._tabindexes.filter((D) => D.get("focusableGroup") == v && D.getPrivate("focusable") !== !1);
                let y = b.indexOf(_);
                const x = b.length - 1;
                y += m == 39 || m == 40 ? 1 : -1, y < 0 ? y = x : y > x && (y = 0), Nf(b[y].getPrivate("focusElement").dom);
              }
              break;
          }
        }
      })));
    }
    this._startTicker(), this.setThemes([]), this._addTooltip(), this._hasLicense() || this._showBranding();
  }
  _initResizeSensor() {
    this._resizeSensorDisposer && this._resizeSensorDisposer.dispose(), this._resizeSensorDisposer = new Ck(this.dom, () => {
      this.autoResize && this.resize();
    }), this._disposers.push(this._resizeSensorDisposer);
  }
  /**
   * If automatic resizing of char is disabled (`root.autoResize = false`), it
   * can be resized manually by calling this method.
   */
  resize() {
    const e = this._getRealSize(), t = this._getCalculatedSize(e), s = Math.floor(t.width), r = Math.floor(t.height);
    if (s > 0 && r > 0) {
      const n = Math.floor(e.width), a = Math.floor(e.height), o = this._htmlElementContainer;
      if (o.style.width = s + "px", o.style.height = r + "px", this._a11yD !== !0) {
        const u = this._focusElementContainer;
        u.style.width = s + "px", u.style.height = r + "px";
      }
      this._renderer.resize(n, a, s, r);
      const l = this._rootContainer;
      l.setPrivate("width", n), l.setPrivate("height", a), this._render(), this._handleLogo();
    }
  }
  _render() {
    this._renderer.render(this._rootContainer._display), this._focusElementDirty && (this._updateCurrentFocus(), this._focusElementDirty = !1);
  }
  _runTickers(e) {
    w(this._tickers, (t) => {
      t(e);
    });
  }
  _runAnimations(e) {
    Tn(this._animations, (t) => t._runAnimation(e));
  }
  _runDirties() {
    let e = {};
    for (; this._isDirtyParents; )
      this._isDirtyParents = !1, Ve(this._dirtyParents).forEach((a) => {
        const o = this._dirtyParents[a];
        delete this._dirtyParents[a], o.isDisposed() || (e[o.uid] = o, o._prepareChildren());
      });
    Ve(e).forEach((a) => {
      e[a]._updateChildren();
    });
    const t = [];
    Ve(this._dirty).forEach((a) => {
      const o = this._dirty[a];
      o.isDisposed() ? delete this._dirty[o.uid] : (t.push(o), o._beforeChanged());
    }), t.forEach((a) => {
      a._changed(), delete this._dirty[a.uid], a._clearDirty();
    }), this._isDirty = !1;
    const s = {}, r = [];
    Ve(this._dirtyBounds).forEach((a) => {
      const o = this._dirtyBounds[a];
      delete this._dirtyBounds[a], o.isDisposed() || (s[o.uid] = o.depth(), r.push(o));
    }), this._positionHTMLElements(), r.sort((a, o) => $t(s[o.uid], s[a.uid])), r.forEach((a) => {
      a._updateBounds();
    });
    const n = this._dirtyPositions;
    Ve(n).forEach((a) => {
      const o = n[a];
      delete n[a], o.isDisposed() || o._updatePosition();
    }), t.forEach((a) => {
      a._afterChanged();
    });
  }
  _renderFrame(e) {
    return this._updateTick ? (this.events.isEnabled("framestarted") && this.events.dispatch("framestarted", {
      type: "framestarted",
      target: this,
      timestamp: e
    }), this._checkComputedStyles(), this._runTickers(e), this._runAnimations(e), this._runDirties(), this._render(), this._positionHTMLElements(), this.events.isEnabled("frameended") && this.events.dispatch("frameended", {
      type: "frameended",
      target: this,
      timestamp: e
    }), this._tickers.length === 0 && this._animations.length === 0 && !this._isDirty) : !0;
  }
  _runTicker(e, t) {
    this.isDisposed() || (this.animationTime = e, this._renderFrame(e) ? (this._ticker = null, this.animationTime = null) : this._paused || (t ? this._ticker : mh(this.fps, this._ticker)));
  }
  _runTickerNow(e = 1e4) {
    if (!this.isDisposed()) {
      const t = performance.now() + e;
      for (; ; ) {
        const s = performance.now();
        if (s >= t) {
          this.animationTime = null;
          break;
        }
        if (this.animationTime = s, this._renderFrame(s)) {
          this.animationTime = null;
          break;
        }
      }
    }
  }
  _startTicker() {
    this._ticker === null && (this.animationTime = null, this._ticker = (e) => {
      this._runTicker(e);
    }, mh(this.fps, this._ticker));
  }
  /**
   * Returns whether the root is updating or not.
   */
  get updateTick() {
    return this._updateTick;
  }
  /**
   * Enables or disables the root updating.
   */
  set updateTick(e) {
    this._updateTick = e, e && this._startTicker();
  }
  _addDirtyEntity(e) {
    this._dirty[e.uid] === void 0 && (this._isDirty = !0, this._dirty[e.uid] = e, this._startTicker());
  }
  _addDirtyParent(e) {
    this._dirtyParents[e.uid] === void 0 && (this._isDirty = !0, this._isDirtyParents = !0, this._dirtyParents[e.uid] = e, this._startTicker());
  }
  _addDirtyBounds(e) {
    this._dirtyBounds[e.uid] === void 0 && (this._isDirty = !0, this._dirtyBounds[e.uid] = e, this._startTicker());
  }
  _addDirtyPosition(e) {
    this._dirtyPositions[e.uid] === void 0 && (this._isDirty = !0, this._dirtyPositions[e.uid] = e, this._startTicker());
  }
  _addAnimation(e) {
    this._animations.indexOf(e) === -1 && (this._animations.push(e), this._startTicker());
  }
  _markDirty() {
    this._isDirty = !0;
  }
  _markDirtyRedraw() {
    this.events.once("frameended", () => {
      this._isDirty = !0, this._startTicker();
    });
  }
  eachFrame(e) {
    return this._tickers.push(e), this._startTicker(), new Ge(() => {
      ht(this._tickers, e);
    });
  }
  markDirtyGlobal(e) {
    e || (e = this.container), e.walkChildren((t) => {
      t instanceof G && this.markDirtyGlobal(t), t.markDirty(), t.markDirtyBounds();
    });
  }
  /**
   * Returns width of the target container, in pixels.
   *
   * @return Width
   */
  width() {
    return Math.floor(this._getCalculatedSize(this._getRealSize()).width);
  }
  /**
   * Returns height of the target container, in pixels.
   *
   * @return Height
   */
  height() {
    return Math.floor(this._getCalculatedSize(this._getRealSize()).height);
  }
  /**
   * Disposes root and all the content in it.
   */
  dispose() {
    this._isDisposed || (this._isDisposed = !0, this._rootContainer.dispose(), this._renderer.dispose(), this.horizontalLayout.dispose(), this.verticalLayout.dispose(), this.interfaceColors.dispose(), w(this._disposers, (e) => {
      e.dispose();
    }), this._inner && Rf(this._inner), St(Rt.rootElements, this));
  }
  /**
   * Returns `true` if root element is disposed.
   *
   * @return Disposed?
   */
  isDisposed() {
    return this._isDisposed;
  }
  /**
   * Triggers screen reader read out a message.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/accessibility/} for more info
   * @param  text  Alert text
   */
  readerAlert(e) {
    this._a11yD !== !0 && (this._readerAlertElement.innerHTML = La(e));
  }
  /**
   * Sets themes to be used for the chart.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/themes/} for more info
   * @param  themes  A list of themes
   */
  setThemes(e) {
    this._rootContainer.set("themes", e);
    const t = this.tooltipContainer;
    t && t._applyThemes();
    const s = this.interfaceColors;
    s && s._applyThemes();
  }
  _addTooltip() {
    if (!this.tooltipContainer) {
      const e = this._tooltipContainerSettings, t = this._rootContainer.children.push(G.new(this, {
        position: "absolute",
        isMeasured: !1,
        width: R,
        height: R,
        layer: e ? 35 : 30,
        layerMargin: e || void 0
      }));
      this.tooltipContainer = t;
      const s = pi.new(this, {});
      this.container.set("tooltip", s), s.hide(0), this._tooltip = s;
    }
  }
  /**
   * Accesibility
   */
  _registerTabindexOrder(e) {
    this._a11yD != !0 && (e.get("focusable") ? lr(this._tabindexes, e) : St(this._tabindexes, e), this._invalidateTabindexes());
  }
  _unregisterTabindexOrder(e) {
    this._a11yD != !0 && (St(this._tabindexes, e), this._invalidateTabindexes());
  }
  _invalidateTabindexes() {
    if (this._a11yD == !0)
      return;
    this._tabindexes.sort((t, s) => {
      const r = t.get("tabindexOrder", 0), n = s.get("tabindexOrder", 0);
      return r == n ? 0 : r > n ? 1 : -1;
    });
    const e = [];
    w(this._tabindexes, (t, s) => {
      t.getPrivate("focusElement") ? this._moveFocusElement(s, t) : this._makeFocusElement(s, t);
      const r = t.get("focusableGroup");
      r && t.getPrivate("focusable") !== !1 && (e.indexOf(r) !== -1 ? t.getPrivate("focusElement").dom.setAttribute("tabindex", "-1") : e.push(r));
    });
  }
  _updateCurrentFocus() {
    this._a11yD != !0 && this._focusedSprite && (this._decorateFocusElement(this._focusedSprite), this._positionFocusElement(this._focusedSprite));
  }
  _decorateFocusElement(e, t) {
    if (this._a11yD == !0 || (t || (t = e.getPrivate("focusElement").dom), !t))
      return;
    e.get("visible") && e.get("role") != "tooltip" && !e.isHidden() && e.getPrivate("focusable") !== !1 ? t.getAttribute("tabindex") != "-1" && t.setAttribute("tabindex", "" + this.tabindex) : t.removeAttribute("tabindex");
    const s = e.get("role");
    s ? t.setAttribute("role", s) : t.removeAttribute("role");
    const r = e.get("ariaLabel");
    if (r) {
      const d = nn(e, r);
      t.setAttribute("aria-label", d);
    } else
      t.removeAttribute("aria-label");
    const n = e.get("ariaLive");
    n ? t.setAttribute("aria-live", n) : t.removeAttribute("aria-live");
    const a = e.get("ariaChecked");
    a != null ? t.setAttribute("aria-checked", a ? "true" : "false") : t.removeAttribute("aria-checked"), e.get("ariaHidden") ? t.setAttribute("aria-hidden", "hidden") : t.removeAttribute("aria-hidden");
    const o = e.get("ariaOrientation");
    o ? t.setAttribute("aria-orientation", o) : t.removeAttribute("aria-orientation");
    const l = e.get("ariaValueNow");
    l ? t.setAttribute("aria-valuenow", l) : t.removeAttribute("aria-valuenow");
    const u = e.get("ariaValueMin");
    u ? t.setAttribute("aria-valuemin", u) : t.removeAttribute("aria-valuemin");
    const h = e.get("ariaValueMax");
    h ? t.setAttribute("aria-valuemax", h) : t.removeAttribute("aria-valuemax");
    const c = e.get("ariaValueText");
    c ? t.setAttribute("aria-valuetext", c) : t.removeAttribute("aria-valuetext");
    const f = e.get("ariaControls");
    f ? t.setAttribute("aria-controls", f) : t.removeAttribute("aria-controls");
  }
  _makeFocusElement(e, t) {
    if (t.getPrivate("focusElement") || this._a11yD == !0)
      return;
    const s = document.createElement("div");
    t.get("role") != "tooltip" && (s.tabIndex = this.tabindex), s.style.position = "absolute", vs(s, !1);
    const r = [];
    t.setPrivate("focusElement", {
      dom: s,
      disposers: r
    }), this._decorateFocusElement(t), r.push(Me(s, "focus", (n) => {
      this._handleFocus(n, e);
    })), r.push(Me(s, "blur", (n) => {
      this._handleBlur(n, e);
    })), this._moveFocusElement(e, t);
  }
  _removeFocusElement(e) {
    if (this._a11yD == !0)
      return;
    St(this._tabindexes, e);
    const t = e.getPrivate("focusElement");
    t && (this._focusElementContainer.removeChild(t.dom), w(t.disposers, (r) => {
      r.dispose();
    }));
  }
  _hideFocusElement(e) {
    if (this._a11yD == !0)
      return;
    const t = e.getPrivate("focusElement");
    t.dom.style.display = "none";
  }
  _moveFocusElement(e, t) {
    if (this._a11yD == !0)
      return;
    const s = this._focusElementContainer, r = t.getPrivate("focusElement").dom;
    if (r === this._focusElementContainer.children[e])
      return;
    const n = this._focusElementContainer.children[e + 1];
    n ? s.insertBefore(r, n) : s.append(r);
  }
  _positionFocusElement(e) {
    if (this._a11yD == !0)
      return;
    const t = e.globalBounds();
    let s = t.right == t.left ? e.width() : t.right - t.left, r = t.top == t.bottom ? e.height() : t.bottom - t.top, n = t.left - 2, a = t.top - 2;
    s < 0 && (n += s, s = Math.abs(s)), r < 0 && (a += r, r = Math.abs(r));
    const o = e.getPrivate("focusElement").dom;
    o.style.top = a + "px", o.style.left = n + "px", o.style.width = s + 4 + "px", o.style.height = r + 4 + "px";
  }
  _handleFocus(e, t) {
    if (this._a11yD == !0)
      return;
    const s = this._tabindexes[t];
    if (!s.isVisibleDeep()) {
      this._focusNext(e.target, this._isShift ? -1 : 1);
      return;
    }
    this._positionFocusElement(s), this._focusedSprite = s, s.events.isEnabled("focus") && s.events.dispatch("focus", {
      type: "focus",
      originalEvent: e,
      target: s
    });
  }
  _focusNext(e, t) {
    if (this._a11yD == !0)
      return;
    const s = Array.from(document.querySelectorAll([
      "a[href]",
      "area[href]",
      "button:not([disabled])",
      "details",
      "input:not([disabled])",
      "iframe:not([disabled])",
      "select:not([disabled])",
      "textarea:not([disabled])",
      '[contentEditable=""]',
      '[contentEditable="true"]',
      '[contentEditable="TRUE"]',
      '[tabindex]:not([tabindex^="-"])'
      //':not([disabled])'
    ].join(",")));
    let r = s.indexOf(e) + t;
    r < 0 ? r = s.length - 1 : r >= s.length && (r = 0), s[r].focus();
  }
  _handleBlur(e, t) {
    if (this._a11yD == !0)
      return;
    const s = this._focusedSprite;
    s && s.events.isEnabled("blur") && s.events.dispatch("blur", {
      type: "blur",
      originalEvent: e,
      target: s
    }), this._focusedSprite = void 0;
  }
  /**
   * @ignore
   */
  updateTooltip(e) {
    if (this._a11yD == !0)
      return;
    const t = La(e._getText());
    let s = e.getPrivate("tooltipElement");
    e.get("role") == "tooltip" && t != "" ? (s || (s = this._makeTooltipElement(e)), s.innerHTML != t && (s.innerHTML = t)) : s && (s.remove(), e.removePrivate("tooltipElement"));
  }
  _makeTooltipElement(e) {
    const t = this._tooltipElementContainer, s = document.createElement("div");
    return s.style.position = "absolute", s.style.width = "1px", s.style.height = "1px", s.style.overflow = "hidden", s.style.clip = "rect(1px, 1px, 1px, 1px)", vs(s, !1), this._decorateFocusElement(e, s), t.append(s), e.setPrivate("tooltipElement", s), s;
  }
  _removeTooltipElement(e) {
    if (this._a11yD == !0)
      return;
    const t = e.getPrivate("tooltipElement");
    if (t) {
      const s = t.parentElement;
      s && s.removeChild(t);
    }
  }
  _invalidateAccessibility(e) {
    if (this._a11yD == !0)
      return;
    this._focusElementDirty = !0;
    const t = e.getPrivate("focusElement");
    e.get("focusable") ? t && (this._decorateFocusElement(e), this._positionFocusElement(e)) : t && this._removeFocusElement(e);
  }
  /**
   * Returns `true` if `target` is currently focused.
   *
   * @param   target  Target
   * @return          Focused?
   */
  focused(e) {
    return this._focusedSprite === e;
  }
  /**
   * Converts document coordinates to coordinates withing root element.
   *
   * @param   point  Document point
   * @return         Root point
   */
  documentPointToRoot(e) {
    const t = this.dom.getBoundingClientRect();
    return {
      x: e.x - t.left,
      y: e.y - t.top
    };
  }
  /**
   * Converts root coordinates to document
   *
   * @param   point  Document point
   * @return         Root point
   */
  rootPointToDocument(e) {
    const t = this.dom.getBoundingClientRect();
    return {
      x: e.x + t.left,
      y: e.y + t.top
    };
  }
  /**
   * @ignore
   */
  addDisposer(e) {
    return this._disposers.push(e), e;
  }
  _updateComputedStyles() {
    const e = window.getComputedStyle(this.dom);
    let t = "";
    ye(e, (r, n) => {
      Gi(r) && r.match(/^font/) && (t += n);
    });
    const s = t != this._fontHash;
    return s && (this._fontHash = t), s;
  }
  _checkComputedStyles() {
    this._updateComputedStyles() && this._invalidateLabelBounds(this.container);
  }
  _invalidateLabelBounds(e) {
    e instanceof G ? e.children.each((t) => {
      this._invalidateLabelBounds(t);
    }) : e instanceof qi && e.markDirtyBounds();
  }
  /**
   * To all the clever heads out there. Yes, we did not make any attempts to
   * scramble this.
   *
   * This is a part of a tool meant for our users to manage their commercial
   * licenses for removal of amCharts branding from charts.
   *
   * The only legit way to do so is to purchase a commercial license for amCharts:
   * https://www.amcharts.com/online-store/
   *
   * Removing or altering this code, or disabling amCharts branding in any other
   * way is against the license and thus illegal.
   */
  _hasLicense() {
    for (let e = 0; e < Rt.licenses.length; e++)
      if (Rt.licenses[e].match(/^AM5C.{5,}/i))
        return !0;
    return !1;
  }
  _licenseApplied() {
    this._logo && this._logo.set("forceHidden", !0);
  }
  /**
   * @ignore
   */
  get debugGhostView() {
    return this._renderer.debugGhostView;
  }
  /**
   * @ignore
   */
  set debugGhostView(e) {
    this._renderer.debugGhostView = e;
  }
  /**
   * Set this to `true` if you need chart to require first a tap onto it before
   * touch gesture related functionality like zoom/pan is turned on.
   *
   * @see {@link https://www.amcharts.com/docs/v5/getting-started/root-element/#Touch_related_options} for more info
   * @default false
   * @since 5.2.9
   * @param  value  Needs a tap to activate touch functions
   */
  set tapToActivate(e) {
    this._renderer.tapToActivate = e;
  }
  /**
   * @return Needs a tap to activate touch functions
   */
  get tapToActivate() {
    return this._renderer.tapToActivate;
  }
  /**
   * If `tapToActivate` is set to `true`, this setting will determine number
   * of milliseconds the chart will stay "active", before releasing the
   * controls back to the page.
   *
   * @see {@link https://www.amcharts.com/docs/v5/getting-started/root-element/#Touch_related_options} for more info
   * @default 3000
   * @since 5.2.9
   * @param  value  Timeout
   */
  set tapToActivateTimeout(e) {
    this._renderer.tapToActivateTimeout = e;
  }
  /**
   * @return Timeout
   */
  get tapToActivateTimeout() {
    return this._renderer.tapToActivateTimeout;
  }
  _makeHTMLElement(e) {
    const t = this._htmlElementContainer, s = document.createElement("div");
    return e.setPrivate("htmlElement", s), s.style.position = "absolute", s.style.overflow = "auto", s.style.boxSizing = "border-box", vs(s, e.get("interactive", !1)), e.events.isEnabled("click") && (vs(s, !0), this._disposers.push(Me(s, "click", (r) => {
      const n = this._renderer.getEvent(r);
      e.events.dispatch("click", {
        type: "click",
        originalEvent: n.event,
        point: n.point,
        simulated: !1,
        target: e
      });
    }))), this._positionHTMLElement(e), t.append(s), lr(this._htmlEnabledContainers, e), s;
  }
  _positionHTMLElements() {
    w(this._htmlEnabledContainers, (e) => {
      this._positionHTMLElement(e);
    });
  }
  _positionHTMLElement(e) {
    const t = e.getPrivate("htmlElement");
    if (t) {
      w(["paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "minWidth", "minHeight", "maxWidth", "maxHeight"], (c) => {
        const f = e.get(c);
        f ? t.style[c] = f + "px" : t.style[c] = "";
      });
      const r = e.compositeOpacity();
      setTimeout(() => {
        t.style.opacity = r + "";
      }, 10);
      const n = e.isVisibleDeep();
      n && (t.style.display = "block");
      const a = e.globalBounds();
      t.style.top = a.top + "px", t.style.left = a.left + "px";
      const o = e.get("width"), l = e.get("height");
      let u = 0, h = 0;
      if (o && (u = e.width()), l && (h = e.height()), !o || !l) {
        t.style.position = "fixed", t.style.width = "", t.style.height = "";
        const c = t.getBoundingClientRect();
        t.style.position = "absolute", u = c.width, h = c.height, e._adjustedLocalBounds = { left: 0, right: 0, top: 0, bottom: 0 }, e.setPrivate("minWidth", u), e.setPrivate("minHeight", h);
      } else
        e.removePrivate("minWidth"), e.removePrivate("minHeight");
      u > 0 && (t.style.minWidth = u + "px"), h > 0 && (t.style.minHeight = h + "px"), (!n || r == 0) && (t.style.display = "none");
    }
  }
  _setHTMLContent(e, t) {
    let s = e.getPrivate("htmlElement");
    s || (s = this._makeHTMLElement(e)), s.innerHTML != t && (s.innerHTML = t);
  }
  _removeHTMLContent(e) {
    let t = e.getPrivate("htmlElement");
    t && this._htmlElementContainer.removeChild(t), St(this._htmlEnabledContainers, e);
  }
}
let zn;
function uP(i, e, t) {
  const s = e.interfaceColors, r = s.get("secondaryButton").toCSS(), n = s.get("text").toCSS(), a = s.get("alternativeBackground").toCSS(0.45);
  if (!zn) {
    const o = new ut([
      new tt(i, ".am5-modal", {
        width: "100%",
        height: "100%",
        position: "absolute",
        "z-index": "100000",
        top: "0",
        left: "0"
      }),
      new tt(i, ".am5-modal-curtain", {
        top: "0",
        left: "0",
        width: "100%",
        height: "100%",
        position: "absolute",
        background: s.get("background").toCSS(0.5),
        "z-index": "100"
      }),
      new tt(i, ".am5-modal-wrapper", {
        top: "0",
        left: "0",
        width: "100%",
        height: "100%",
        position: "absolute",
        "text-align": "center",
        "white-space": "nowrap",
        background: s.get("background").toCSS(0.5),
        "z-index": "101"
      }),
      new tt(i, ".am5-modal-wrapper:before", {
        content: "''",
        display: "inline-block",
        height: "100%",
        "vertical-align": "middle",
        "margin-right": "-0.25em"
      }),
      new tt(i, ".am5-modal-content", {
        display: "inline-block",
        padding: "1.2em",
        "vertical-align": "middle",
        "text-align": "left",
        "white-space": "normal",
        background: s.get("background").toCSS(),
        //"border": "1px solid " + ic.get("alternativeBackground")!.toCSS(),
        "border-radius": "4px",
        "-webkit-box-shadow": "0px 0px 36px 0px " + a,
        "box-shadow": "0px 0px 36px 0px " + a,
        color: n
      }),
      new tt(i, ".am5-modal-content h1", {
        "font-size": "1em",
        margin: "0 0 0.5em 0"
      }),
      new tt(i, ".am5-modal-table", {
        display: "table",
        margin: "1em 0"
      }),
      new tt(i, ".am5-modal-table-row", {
        display: "table-row"
      }),
      new tt(i, ".am5-modal-table-heading", {
        display: "table-heading",
        padding: "3px 10px 3px 0"
      }),
      new tt(i, ".am5-modal-table-cell", {
        display: "table-cell",
        padding: "3px 0 3px 0"
      }),
      new tt(i, ".am5-modal-table-cell > *", {
        "vertical-align": "middle"
      }),
      new tt(i, ".am5-modal-content input[type=text], .am5-modal-content input[type=number], .am5-modal-content select", {
        border: "1px solid " + r,
        "border-radius": "4px",
        padding: "3px 5px",
        margin: "2px"
      }),
      new tt(i, ".am5-modal-input-narrow", {
        width: "50px"
      }),
      new tt(i, ".am5-modal-button", {
        "font-weight": "400",
        color: s.get("secondaryButtonText").toCSS(),
        "line-height": "1.5",
        "text-align": "center",
        "text-decoration": "none",
        "vertical-align": "middle",
        cursor: "pointer",
        padding: "0.2em 0.8em",
        "font-size": "1em",
        "border-radius": "0.25em",
        margin: "0 0.25em 0 0",
        border: "1px solid " + s.get("secondaryButtonStroke").toCSS(),
        background: s.get("secondaryButton").toCSS()
      }),
      new tt(i, ".am5-modal-button:hover", {
        background: s.get("secondaryButtonHover").toCSS()
      }),
      new tt(i, ".am5-modal-button.am5-modal-primary", {
        color: s.get("primaryButtonText").toCSS(),
        border: "1px solid " + s.get("primaryButtonStroke").toCSS(),
        background: s.get("primaryButton").toCSS()
      }),
      new tt(i, ".am5-modal-button.am5-modal-primary:hover", {
        background: s.get("primaryButtonHover").toCSS()
      })
    ]);
    zn = new To(() => {
      zn = void 0, o.dispose();
    });
  }
  return zn.increment();
}
class Ea extends Oe {
  //protected _currentPass: number = 0;
  _afterNew() {
    super._afterNewApplyThemes(), this._setRawDefault("deactivateRoot", !0), uP(Bf(this._root.dom), this._root);
    const e = document.createElement("div");
    e.className = "am5-modal", e.style.display = "none", this.root._inner.appendChild(e), this.setPrivate("container", e);
    const t = document.createElement("div");
    t.className = "am5-modal-curtain", e.appendChild(t), this.setPrivate("curtain", t), this._disposers.push(Me(t, "click", () => {
      this.cancel();
    }));
    const s = document.createElement("div");
    s.className = "am5-modal-wrapper", e.appendChild(s), this.setPrivate("wrapper", s);
    const r = document.createElement("div");
    r.className = "am5-modal-content", s.appendChild(r), this.setPrivate("content", r);
    const n = this.get("content");
    n && (r.innerHTML = n), ei("keyboardevents") && this._disposers.push(Me(document, "keydown", (a) => {
      this.isOpen() && a.keyCode == 27 && this.cancel();
    }));
  }
  _beforeChanged() {
    super._beforeChanged(), this.isDirty("content") && (this.getPrivate("content").innerHTML = this.get("content", ""));
  }
  /**
   * Returns `true` if modal is currently open.
   *
   * @return  Modal open?
   */
  isOpen() {
    return this.getPrivate("container").style.display != "none";
  }
  /**
   * Opens modal.
   */
  open() {
    this.getPrivate("container").style.display = "block", this.get("deactivateRoot") && this.setTimeout(() => {
      this._root._renderer.interactionsEnabled = !1;
    }, 10), this.events.dispatch("opened", {
      type: "opened",
      target: this
    });
  }
  /**
   * Closes modal.
   */
  close() {
    this.getPrivate("container").style.display = "none", this.get("deactivateRoot") && (this._root._renderer.interactionsEnabled = !0), this.events.dispatch("closed", {
      type: "closed",
      target: this
    });
  }
  /**
   * Closes modal and invokes `cancelled` event.
   */
  cancel() {
    this.getPrivate("container").style.display = "none", this.get("deactivateRoot") && (this._root._renderer.interactionsEnabled = !0), this.events.dispatch("cancelled", {
      type: "cancelled",
      target: this
    });
  }
  /**
   * Disposes modal.
   */
  dispose() {
    super.dispose(), this.root.dom.removeChild(this.getPrivate("container"));
  }
}
Object.defineProperty(Ea, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Modal"
});
Object.defineProperty(Ea, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Oe.classNames.concat([Ea.className])
});
class oi extends Oe {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_index", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "series", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  _afterNew() {
    super._afterNewApplyThemes();
  }
  _beforeChanged() {
    if (super._beforeChanged(), this.isDirty("sprite")) {
      const e = this.get("sprite");
      e && (e.setAll({ position: "absolute", role: "figure" }), this._disposers.push(e));
    }
    (this.isDirty("locationX") || this.isDirty("locationY")) && this.series && this.series._positionBullet(this);
  }
}
Object.defineProperty(oi, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Bullet"
});
Object.defineProperty(oi, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Oe.classNames.concat([oi.className])
});
class Pe extends gt {
  _beforeChanged() {
    super._beforeChanged(), (this.isDirty("cornerRadiusTL") || this.isDirty("cornerRadiusTR") || this.isDirty("cornerRadiusBR") || this.isDirty("cornerRadiusBL")) && (this._clear = !0);
  }
  _draw() {
    let e = this.width(), t = this.height(), s = e, r = t, n = s / Math.abs(e), a = r / Math.abs(t);
    if (S(s) && S(r)) {
      let o = Math.min(s, r) / 2, l = Te(this.get("cornerRadiusTL", 8), o), u = Te(this.get("cornerRadiusTR", 8), o), h = Te(this.get("cornerRadiusBR", 8), o), c = Te(this.get("cornerRadiusBL", 8), o), f = Math.min(Math.abs(s / 2), Math.abs(r / 2));
      l = Re(l, 0, f), u = Re(u, 0, f), h = Re(h, 0, f), c = Re(c, 0, f);
      const d = this._display;
      d.moveTo(l * n, 0), d.lineTo(s - u * n, 0), u > 0 && d.arcTo(s, 0, s, u * a, u), d.lineTo(s, r - h * a), h > 0 && d.arcTo(s, r, s - h * n, r, h), d.lineTo(c * n, r), c > 0 && d.arcTo(0, r, 0, r - c * a, c), d.lineTo(0, l * a), l > 0 && d.arcTo(0, 0, l * n, 0, l), d.closePath();
    }
  }
}
Object.defineProperty(Pe, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "RoundedRectangle"
});
Object.defineProperty(Pe, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: gt.classNames.concat([Pe.className])
});
class hr extends G {
  _afterNew() {
    this._settings.themeTags = se(this._settings.themeTags, ["button"]), super._afterNew(), this._settings.background || this.set("background", Pe.new(this._root, {
      themeTags: se(this._settings.themeTags, ["background"])
    }));
  }
  _prepareChildren() {
    if (super._prepareChildren(), this.isDirty("icon")) {
      const e = this._prevSettings.icon, t = this.get("icon");
      t !== e && (this._disposeProperty("icon"), e && e.dispose(), t && this.children.push(t), this._prevSettings.icon = t);
    }
    if (this.isDirty("label")) {
      const e = this._prevSettings.label, t = this.get("label");
      t !== e && (this._disposeProperty("label"), e && e.dispose(), t && this.children.push(t), this._prevSettings.label = t);
    }
  }
}
Object.defineProperty(hr, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Button"
});
Object.defineProperty(hr, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: G.classNames.concat([hr.className])
});
class li extends ce {
  _beforeChanged() {
    super._beforeChanged(), this.isDirty("radius") && (this._clear = !0);
  }
  _changed() {
    super._changed(), this._clear && this._display.drawCircle(0, 0, this.get("radius", 10));
  }
}
Object.defineProperty(li, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Circle"
});
Object.defineProperty(li, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: ce.classNames.concat([li.className])
});
class Ra extends ce {
  constructor() {
    super(...arguments), Object.defineProperty(this, "morphAnimation", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  _beforeChanged() {
    if (super._beforeChanged(), this.isDirty("coordinates")) {
      const e = [], t = this.get("coordinates");
      t && w(t, (s) => {
        e.push({ x: s[0], y: s[1] });
      }), this.set("points", e);
    }
    if (this.isPrivateDirty("points") && (this._clear = !0), this.isDirty("points")) {
      this._clear = !0;
      const e = this.get("points"), t = this._prevSettings.points;
      if (t) {
        if (e) {
          let o = Hi(e), l = Hi(t), u = o.length, h = l.length;
          if (u > h) {
            let c = Hi(o);
            for (let f = 0; f < u; f++) {
              let d = Math.floor(f / u * h);
              c[f] = { x: l[d].x, y: l[d].y };
            }
            l = c;
          } else if (h > u) {
            let c = Hi(l);
            for (let f = 0; f < h; f++) {
              let d = Math.floor(f / h * u);
              c[f] = { x: o[d].x, y: o[d].y };
            }
            o = c;
          }
          this.setPrivateRaw("previousPoints", l), this.setPrivateRaw("points", o), this.morphAnimation = this.animatePrivate({ key: "morphProgress", from: 0, to: 1, duration: this.get("animationDuration", 0), easing: this.get("animationEasing") });
        }
      } else
        this.setPrivateRaw("previousPoints", e), this.setPrivateRaw("points", e);
      let s = 1 / 0, r = -1 / 0, n = 1 / 0, a = -1 / 0;
      if (e)
        for (let o = 1, l = e.length; o < l; o++) {
          const u = e[o];
          s = Math.min(s, u.x), r = Math.max(r, u.x), n = Math.min(n, u.y), a = Math.max(a, u.y);
        }
      this.setPrivate("minX", s), this.setPrivate("maxX", r), this.setPrivate("minY", n), this.setPrivate("maxY", n);
    }
    this.isPrivateDirty("morphProgress") && (this._clear = !0);
  }
  _changed() {
    super._changed(), this._clear && this._draw();
  }
  _draw() {
    const e = this.getPrivate("previousPoints"), t = this.getPrivate("points"), s = this.getPrivate("morphProgress", 1);
    if (t && e) {
      const r = t[0], n = e[0];
      r && this._display.moveTo(n.x + (r.x - n.x) * s, n.y + (r.y - n.y) * s);
      for (let a = 1, o = t.length; a < o; a++) {
        const l = t[a], u = e[a];
        this._display.lineTo(u.x + (l.x - u.x) * s, u.y + (l.y - u.y) * s);
      }
      this._display.closePath();
    }
  }
  _updateSize() {
    this.markDirty(), this._clear = !0;
  }
}
Object.defineProperty(Ra, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Polygon"
});
Object.defineProperty(Ra, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: ce.classNames.concat([Ra.className])
});
class $a extends ce {
  _beforeChanged() {
    super._beforeChanged(), (this.isDirty("radiusX") || this.isDirty("radiusY") || this.isDirty("rotation")) && (this._clear = !0);
  }
  _changed() {
    super._changed(), this._clear && this._display.drawEllipse(0, 0, Math.abs(this.get("radiusX")), Math.abs(this.get("radiusY")));
  }
}
Object.defineProperty($a, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Ellipse"
});
Object.defineProperty($a, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: ce.classNames.concat([$a.className])
});
class Na extends ce {
  _beforeChanged() {
    super._beforeChanged(), (this.isDirty("radius") || this.isDirty("innerRadius") || this.isDirty("spikes")) && (this._clear = !0);
  }
  _changed() {
    if (super._changed(), this._clear) {
      const e = this._display, t = this.get("radius", 0), s = Te(this.get("innerRadius", 0), t), r = this.get("spikes", 0), n = Math.PI / r;
      let a = Math.PI / 2 * 3;
      e.moveTo(0, -t);
      for (let o = 0; o < r; o++)
        e.lineTo(Math.cos(a) * t, Math.sin(a) * t), a += n, e.lineTo(Math.cos(a) * s, Math.sin(a) * s), a += n;
      e.lineTo(0, -t), e.closePath();
    }
  }
}
Object.defineProperty(Na, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Star"
});
Object.defineProperty(Na, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: ce.classNames.concat([Na.className])
});
class xp extends Pr {
  constructor() {
    super(...arguments), Object.defineProperty(this, "processor", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  /**
   * @ignore
   */
  incrementRef() {
  }
  /**
   * @ignore
   */
  decrementRef() {
  }
  _onPush(e) {
    this.processor && this.processor.processRow(e), super._onPush(e);
  }
  _onInsertIndex(e, t) {
    this.processor && this.processor.processRow(t), super._onInsertIndex(e, t);
  }
  _onSetIndex(e, t, s) {
    this.processor && this.processor.processRow(s), super._onSetIndex(e, t, s);
  }
}
class cP {
  constructor(e) {
    Object.defineProperty(this, "processor", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_value", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._value = e;
  }
  incrementRef() {
  }
  decrementRef() {
  }
}
class ti extends dp {
  constructor(e, t, s) {
    super(s), Object.defineProperty(this, "component", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "dataContext", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "bullets", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "open", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "close", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.dataContext = t, this.component = e, this._settings.visible = !0, this._checkDirty();
  }
  /**
   * @ignore
   */
  markDirty() {
    this.component.markDirtyValues(this);
  }
  _startAnimation() {
    this.component._root._addAnimation(this);
  }
  _animationTime() {
    return this.component._root.animationTime;
  }
  _dispose() {
    this.component && this.component.disposeDataItem(this), super._dispose();
  }
  /**
   * Shows a data item that's currently hidden.
   */
  show(e) {
    this.setRaw("visible", !0), this.component && this.component.showDataItem(this, e);
  }
  /**
   * Hides a data item that's currently visible.
   */
  hide(e) {
    this.setRaw("visible", !1), this.component && this.component.hideDataItem(this, e);
  }
  isHidden() {
    return !this.get("visible");
  }
}
class Qi extends G {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new xp()
    }), Object.defineProperty(this, "_dataItems", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_mainDataItems", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._dataItems
    }), Object.defineProperty(this, "valueFields", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "fields", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["id"]
    }), Object.defineProperty(this, "_valueFields", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_valueFieldsF", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_fields", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_fieldsF", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_valuesDirty", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_dataChanged", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_dataGrouped", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "inited", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    });
  }
  /**
   * Component's data.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/data/} for more info
   */
  set data(e) {
    e.incrementRef(), this._data.decrementRef(), this._data = e;
  }
  /**
   * @return  Data
   */
  get data() {
    return this._data;
  }
  _dispose() {
    super._dispose(), this._data.decrementRef();
  }
  _onDataClear() {
  }
  _afterNew() {
    super._afterNew(), this._data.incrementRef(), this._updateFields(), this._disposers.push(this.data.events.onAll((e) => {
      const t = this._mainDataItems;
      if (this.markDirtyValues(), this._markDirtyGroup(), this._dataChanged = !0, e.type === "clear")
        w(t, (s) => {
          s.dispose();
        }), t.length = 0, this._onDataClear();
      else if (e.type === "push") {
        const s = new ti(this, e.newValue, this._makeDataItem(e.newValue));
        t.push(s), this.processDataItem(s);
      } else if (e.type === "setIndex") {
        const s = t[e.index], r = this._makeDataItem(e.newValue);
        s.bullets && s.bullets.length == 0 && (s.bullets = void 0), Ve(r).forEach((n) => {
          s.animate({
            key: n,
            to: r[n],
            duration: this.get("interpolationDuration", 0),
            easing: this.get("interpolationEasing")
          });
        }), s.dataContext = e.newValue;
      } else if (e.type === "insertIndex") {
        const s = new ti(this, e.newValue, this._makeDataItem(e.newValue));
        t.splice(e.index, 0, s), this.processDataItem(s);
      } else if (e.type === "removeIndex")
        t[e.index].dispose(), t.splice(e.index, 1);
      else if (e.type === "moveIndex") {
        const s = t[e.oldIndex];
        t.splice(e.oldIndex, 1), t.splice(e.newIndex, 0, s);
      } else
        throw new Error("Unknown IStreamEvent type");
      this._afterDataChange();
    }));
  }
  _updateFields() {
    this.valueFields && (this._valueFields = [], this._valueFieldsF = {}, w(this.valueFields, (e) => {
      this.get(e + "Field") && (this._valueFields.push(e), this._valueFieldsF[e] = { fieldKey: e + "Field", workingKey: e + "Working" });
    })), this.fields && (this._fields = [], this._fieldsF = {}, w(this.fields, (e) => {
      this.get(e + "Field") && (this._fields.push(e), this._fieldsF[e] = e + "Field");
    }));
  }
  /**
   * A list of component's data items.
   *
   * @return  Data items
   */
  get dataItems() {
    return this._dataItems;
  }
  processDataItem(e) {
  }
  _makeDataItem(e) {
    const t = {};
    return this._valueFields && w(this._valueFields, (s) => {
      const r = this.get(this._valueFieldsF[s].fieldKey);
      t[s] = e[r], t[this._valueFieldsF[s].workingKey] = t[s];
    }), this._fields && w(this._fields, (s) => {
      const r = this.get(this._fieldsF[s]);
      t[s] = e[r];
    }), t;
  }
  /**
   * @ignore
   */
  makeDataItem(e) {
    let t = new ti(this, void 0, e);
    return this.processDataItem(t), t;
  }
  /**
   * @ignore
   */
  pushDataItem(e) {
    const t = this.makeDataItem(e);
    return this._mainDataItems.push(t), t;
  }
  /**
   * @ignore
   */
  disposeDataItem(e) {
  }
  /**
   * Shows component's data item.
   *
   * @param   dataItem   Data item
   * @param   _duration  Animation duration in milliseconds
   * @return             Promise
   */
  showDataItem(e, t) {
    return Ze(this, void 0, void 0, function* () {
      e.set("visible", !0);
    });
  }
  /**
   * Hides component's data item.
   *
   * @param   dataItem   Data item
   * @param   _duration  Animation duration in milliseconds
   * @return             Promise
   */
  hideDataItem(e, t) {
    return Ze(this, void 0, void 0, function* () {
      e.set("visible", !1);
    });
  }
  _clearDirty() {
    super._clearDirty(), this._valuesDirty = !1;
  }
  _afterDataChange() {
  }
  _afterChanged() {
    if (super._afterChanged(), this._dataChanged) {
      const e = "datavalidated";
      this.events.isEnabled(e) && this.events.dispatch(e, { type: e, target: this }), this._dataChanged = !1;
    }
    this.inited = !0;
  }
  /**
   * Forces a repaint of the element which relies on data.
   *
   * @since 5.0.21
   */
  markDirtyValues(e) {
    this.markDirty(), this._valuesDirty = !0;
  }
  _markDirtyGroup() {
    this._dataGrouped = !1;
  }
  /**
   * @ignore
   */
  markDirtySize() {
    this._sizeDirty = !0, this.markDirty();
  }
}
Object.defineProperty(Qi, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Component"
});
Object.defineProperty(Qi, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: G.classNames.concat([Qi.className])
});
class Ji extends Oe {
  _afterNew() {
    super._afterNewApplyThemes();
  }
  /**
   * @ignore
   */
  getFill(e) {
    return {
      addColorStop: (t, s) => {
      }
    };
  }
  _changed() {
    super._changed();
  }
  /**
   * @ignore
   */
  getBounds(e) {
    const t = this.get("target");
    if (t) {
      let s = t.globalBounds();
      const r = e.toLocal({ x: s.left, y: s.top }), n = e.toLocal({ x: s.right, y: s.top }), a = e.toLocal({ x: s.right, y: s.bottom }), o = e.toLocal({ x: s.left, y: s.bottom });
      return {
        left: Math.min(r.x, n.x, a.x, o.x),
        top: Math.min(r.y, n.y, a.y, o.y),
        right: Math.max(r.x, n.x, a.x, o.x),
        bottom: Math.max(r.y, n.y, a.y, o.y)
      };
    }
    return e._display.getLocalBounds();
  }
}
Object.defineProperty(Ji, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Gradient"
});
Object.defineProperty(Ji, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Oe.classNames.concat([Ji.className])
});
class on extends Ji {
  /**
   * @ignore
   */
  getFill(e) {
    const t = this.get("rotation", 0);
    let s = this.getBounds(e), r = s.left || 0, n = s.right || 0, a = s.top || 0, o = s.bottom || 0, l = pt(t), u = it(t), h = l * (n - r), c = u * (o - a), f = Math.max(h, c);
    const d = this._root._renderer.createLinearGradient(r, a, r + f * l, a + f * u), g = this.get("stops");
    if (g) {
      let p = 0;
      w(g, (_) => {
        let m = _.offset;
        S(m) || (m = p / (g.length - 1));
        let v = _.opacity;
        S(v) || (v = 1);
        let b = _.color;
        if (b) {
          const y = _.lighten;
          y && (b = V.lighten(b, y));
          const x = _.brighten;
          x && (b = V.brighten(b, x)), d.addColorStop(m, "rgba(" + b.r + "," + b.g + "," + b.b + "," + v + ")");
        }
        p++;
      });
    }
    return d;
  }
}
Object.defineProperty(on, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "LinearGradient"
});
Object.defineProperty(on, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Ji.classNames.concat([on.className])
});
class Fa extends G {
  constructor() {
    super(...arguments), Object.defineProperty(this, "labelContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.children.push(G.new(this._root, {}))
    }), Object.defineProperty(this, "markerContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.children.push(G.new(this._root, {}))
    }), Object.defineProperty(this, "startLabel", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.labelContainer.children.push(Je.new(this._root, { themeTags: ["start"] }))
    }), Object.defineProperty(this, "endLabel", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.labelContainer.children.push(Je.new(this._root, { themeTags: ["end"] }))
    }), Object.defineProperty(this, "markers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new $e(be.new({}), () => Pe._new(this._root, {
        themeTags: se(this.markers.template.get("themeTags", []), [this.get("orientation"), "heatlegend", "marker"])
      }, [this.markers.template]))
    });
  }
  _afterNew() {
    this._settings.themeTags = se(this._settings.themeTags, ["heatlegend", this._settings.orientation]), super._afterNew(), this.set("tooltip", pi.new(this._root, {
      themeTags: ["heatlegend"]
    }));
  }
  /**
   * @ignore
   */
  makeMarker() {
    const e = this.markers.make();
    return e.states.create("disabled", {}), e;
  }
  /**
   * Moves and shows tooltip at specific value.
   *
   * Can also specify optional text to show in tooltip, as well as the color.
   *
   * @param  value  Value
   * @param  text   Text
   * @param  color  Color
   */
  showValue(e, t, s) {
    const r = this.getTooltip();
    if (r && S(e)) {
      const n = this.get("startValue", 0), a = this.get("endValue", 1), o = (e - n) / (a - n), l = this.get("startColor"), u = this.get("endColor");
      t || (t = this.getNumberFormatter().format(e)), s || (s = V.interpolate(o, l, u)), r.label.set("text", t);
      let h;
      this.get("orientation") == "vertical" ? h = this.markerContainer.toGlobal({ x: 0, y: this.innerHeight() * (1 - o) }) : h = this.markerContainer.toGlobal({ x: this.innerWidth() * o, y: 0 });
      let c = r.get("background");
      c && c.set("fill", V.interpolate(o, l, u)), r.set("pointTo", h), r.show();
    }
  }
  _prepareChildren() {
    super._prepareChildren();
    const e = this.labelContainer, t = this.get("orientation"), s = this.startLabel, r = this.endLabel, n = this.getTooltip();
    if (this.isDirty("orientation") && (t == "vertical" ? (this.markerContainer.setAll({ layout: this._root.verticalLayout, height: R }), this.set("layout", this._root.horizontalLayout), s.setAll({ y: R, x: void 0, centerY: R, centerX: R }), r.setAll({ y: 0, x: void 0, centerY: 0, centerX: R }), e.setAll({ height: R, width: void 0 }), n && n.set("pointerOrientation", "horizontal")) : (this.markerContainer.setAll({ layout: this._root.horizontalLayout, width: R }), this.set("layout", this._root.verticalLayout), s.setAll({ x: 0, y: void 0, centerX: 0, centerY: 0 }), r.setAll({ x: R, y: void 0, centerX: R, centerY: 0 }), e.setAll({ width: R, height: void 0 }), n && n.set("pointerOrientation", "vertical"))), this.isDirty("stepCount")) {
      const a = this.get("stepCount", 1), o = this.get("startColor"), l = this.get("endColor");
      if (this.markerContainer.children.clear(), a > 1)
        for (let u = 0; u < a; u++) {
          const h = this.makeMarker();
          t == "vertical" ? this.markerContainer.children.moveValue(h, 0) : this.markerContainer.children.push(h), o && l && h.set("fill", V.interpolate(u / a, o, l));
        }
      else if (a == 1) {
        const u = this.makeMarker();
        this.markerContainer.children.push(u);
        const h = on.new(this._root, { stops: [{ color: o }, { color: l }] });
        if (t == "vertical") {
          h.set("rotation", 90);
          let c = h.get("stops");
          c && c.reverse();
        } else
          h.set("rotation", 0);
        o && l && u.set("fillGradient", h);
      }
    }
    (this.isDirty("startText") || this.isDirty("startValue")) && s.set("text", this.get("startText", this.getNumberFormatter().format(this.get("startValue", 0)))), (this.isDirty("endText") || this.isDirty("endValue")) && r.set("text", this.get("endText", this.getNumberFormatter().format(this.get("endValue", 1))));
  }
}
Object.defineProperty(Fa, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "HeatLegend"
});
Object.defineProperty(Fa, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: G.classNames.concat([Fa.className])
});
function wp(i) {
  return new Promise((e, t) => {
    setTimeout(e, i);
  });
}
let Io = {
  millisecond: 1,
  second: 1e3,
  minute: 6e4,
  hour: 36e5,
  day: 864e5,
  week: 6048e5,
  month: 365.242 / 12 * 864e5,
  year: 31536e6
};
function kn(i) {
  switch (i) {
    case "year":
      return;
    case "month":
      return "year";
    case "week":
      return "month";
    case "day":
      return "month";
    case "hour":
      return "day";
    case "minute":
      return "hour";
    case "second":
      return "minute";
    case "millisecond":
      return "second";
  }
}
function Dt(i, e) {
  return e == null && (e = 1), Io[i] * e;
}
function It(i) {
  return i ? Io[i.timeUnit] * i.count : 0;
}
function oa(i, e, t, s, r) {
  const n = i.timeUnit, a = i.count;
  if (n == "hour" || n == "minute" || n == "second" || n == "millisecond")
    return Io[i.timeUnit] * i.count;
  {
    const o = Ke(new Date(e.getTime()), n, a, t, s, void 0, r).getTime();
    let l = o + a * Dt(n) * 1.05;
    return l = Ke(new Date(l), n, 1, t, s, void 0, r).getTime(), l - o;
  }
}
function Sp() {
  return /* @__PURE__ */ new Date();
}
function hP() {
  return Sp().getTime();
}
function dP(i) {
  return new Date(i.getTime());
}
function Pn(i, e, t, s, r) {
  if (e - i > Dt(t, 1.2))
    return !0;
  let n = new Date(i), a = new Date(e);
  r && (n = r.convertLocal(n), a = r.convertLocal(a));
  let o = 0, l = 0;
  !s && t != "millisecond" && (o = n.getTimezoneOffset(), n.setUTCMinutes(n.getUTCMinutes() - o), l = a.getTimezoneOffset(), a.setUTCMinutes(a.getUTCMinutes() - l));
  let u = !1;
  switch (t) {
    case "year":
      n.getUTCFullYear() != a.getUTCFullYear() && (u = !0);
      break;
    case "month":
      (n.getUTCFullYear() != a.getUTCFullYear() || n.getUTCMonth() != a.getUTCMonth()) && (u = !0);
      break;
    case "day":
      (n.getUTCMonth() != a.getUTCMonth() || n.getUTCDate() != a.getUTCDate()) && (u = !0);
      break;
    case "hour":
      n.getUTCHours() != a.getUTCHours() && (u = !0);
      break;
    case "minute":
      n.getUTCMinutes() != a.getUTCMinutes() && (u = !0);
      break;
    case "second":
      n.getUTCSeconds() != a.getUTCSeconds() && (u = !0);
      break;
    case "millisecond":
      n.getTime() != a.getTime() && (u = !0);
      break;
  }
  if (u)
    return u;
  let h = kn(t);
  return h ? Pn(i, e, h, s, r) : !1;
}
function Dp(i, e, t, s, r) {
  let n = 0;
  switch (!s && e != "millisecond" && (n = i.getTimezoneOffset(), r && (n -= r.offsetUTC(i)), i.setUTCMinutes(i.getUTCMinutes() - n)), e) {
    case "day":
      let a = i.getUTCDate();
      i.setUTCDate(a + t);
      break;
    case "second":
      let o = i.getUTCSeconds();
      i.setUTCSeconds(o + t);
      break;
    case "millisecond":
      let l = i.getUTCMilliseconds();
      i.setUTCMilliseconds(l + t);
      break;
    case "hour":
      let u = i.getUTCHours();
      i.setUTCHours(u + t);
      break;
    case "minute":
      let h = i.getUTCMinutes();
      i.setUTCMinutes(h + t);
      break;
    case "year":
      let c = i.getUTCFullYear();
      i.setUTCFullYear(c + t);
      break;
    case "month":
      let f = i.getUTCMonth();
      i.setUTCMonth(f + t);
      break;
    case "week":
      let d = i.getUTCDate();
      i.setUTCDate(d + t * 7);
      break;
  }
  if (!s && e != "millisecond" && (i.setUTCMinutes(i.getUTCMinutes() + n), e == "day" || e == "week" || e == "month" || e == "year")) {
    let a = i.getTimezoneOffset();
    if (r && (a += r.offsetUTC(i)), a != n) {
      let o = a - n;
      i.setUTCMinutes(i.getUTCMinutes() + o), i.getTimezoneOffset() != a && i.setUTCMinutes(i.getUTCMinutes() - o);
    }
  }
  return i;
}
function Ke(i, e, t, s, r, n, a) {
  if (!a || r) {
    let o = 0;
    switch (!r && e != "millisecond" && (o = i.getTimezoneOffset(), i.setUTCMinutes(i.getUTCMinutes() - o)), e) {
      case "day":
        let l = i.getUTCDate();
        if (t > 1) {
          if (n) {
            n = Ke(n, "day", 1);
            let m = i.getTime() - n.getTime(), v = Math.floor(m / Dt("day") / t), b = Dt("day", v * t);
            i.setTime(n.getTime() + b - o * Dt("minute"));
          }
        } else
          i.setUTCDate(l);
        i.setUTCHours(0, 0, 0, 0);
        break;
      case "second":
        let u = i.getUTCSeconds();
        t > 1 && (u = Math.floor(u / t) * t), i.setUTCSeconds(u, 0);
        break;
      case "millisecond":
        if (t == 1)
          return i;
        let h = i.getUTCMilliseconds();
        h = Math.floor(h / t) * t, i.setUTCMilliseconds(h);
        break;
      case "hour":
        let c = i.getUTCHours();
        t > 1 && (c = Math.floor(c / t) * t), i.setUTCHours(c, 0, 0, 0);
        break;
      case "minute":
        let f = i.getUTCMinutes();
        t > 1 && (f = Math.floor(f / t) * t), i.setUTCMinutes(f, 0, 0);
        break;
      case "month":
        let d = i.getUTCMonth();
        t > 1 && (d = Math.floor(d / t) * t), i.setUTCMonth(d, 1), i.setUTCHours(0, 0, 0, 0);
        break;
      case "year":
        let g = i.getUTCFullYear();
        t > 1 && (g = Math.floor(g / t) * t), i.setUTCFullYear(g, 0, 1), i.setUTCHours(0, 0, 0, 0);
        break;
      case "week":
        let p = i.getUTCDate(), _ = i.getUTCDay();
        S(s) || (s = 1), _ >= s ? p = p - _ + s : p = p - (7 + _) + s, i.setUTCDate(p), i.setUTCHours(0, 0, 0, 0);
        break;
    }
    if (!r && e != "millisecond" && (i.setUTCMinutes(i.getUTCMinutes() + o), e == "day" || e == "week" || e == "month" || e == "year")) {
      let l = i.getTimezoneOffset();
      if (l != o) {
        let u = l - o;
        i.setUTCMinutes(i.getUTCMinutes() + u);
      }
    }
    return i;
  } else {
    if (isNaN(i.getTime()))
      return i;
    let o = a.offsetUTC(i), l = i.getTimezoneOffset(), u = a.parseDate(i), h = u.year, c = u.month, f = u.day, d = u.hour, g = u.minute, p = u.second, _ = u.millisecond, m = u.weekday;
    switch (e) {
      case "day":
        if (t > 1 && n) {
          n = Ke(n, "day", 1, s, r, void 0, a);
          let b = i.getTime() - n.getTime(), y = Math.floor(b / Dt("day") / t), x = Dt("day", y * t);
          i.setTime(n.getTime() + x), u = a.parseDate(i), h = u.year, c = u.month, f = u.day;
        }
        d = 0, g = o - l, p = 0, _ = 0;
        break;
      case "second":
        g += o - l, t > 1 && (p = Math.floor(p / t) * t), _ = 0;
        break;
      case "millisecond":
        g += o - l, t > 1 && (_ = Math.floor(_ / t) * t);
        break;
      case "hour":
        t > 1 && (d = Math.floor(d / t) * t), g = o - l, p = 0, _ = 0;
        break;
      case "minute":
        t > 1 && (g = Math.floor(g / t) * t), g += o - l, p = 0, _ = 0;
        break;
      case "month":
        t > 1 && (c = Math.floor(c / t) * t), f = 1, d = 0, g = o - l, p = 0, _ = 0;
        break;
      case "year":
        t > 1 && (h = Math.floor(h / t) * t), c = 0, f = 1, d = 0, g = o - l, p = 0, _ = 0;
        break;
      case "week":
        S(s) || (s = 1), m >= s ? f = f - m + s : f = f - (7 + m) + s, d = 0, g = o - l, p = 0, _ = 0;
        break;
    }
    i = new Date(h, c, f, d, g, p, _);
    let v = i.getTimezoneOffset();
    return v != l && i.setTime(i.getTime() + (l - v) * 6e4), i;
  }
}
function dr(i, e, t, s) {
  let r = s[i], n = It(r), a = s.length - 1;
  if (i >= a)
    return Object.assign({}, s[a]);
  let o = Math.ceil(e / n);
  return e < n && i > 0 ? Object.assign({}, s[i - 1]) : o <= t ? Object.assign({}, s[i]) : i + 1 < s.length ? dr(i + 1, e, t, s) : Object.assign({}, s[i]);
}
function Cp(i, e) {
  switch (e) {
    case "day":
      return i.getDate();
    case "second":
      return i.getSeconds();
    case "millisecond":
      return i.getMilliseconds();
    case "hour":
      return i.getHours();
    case "minute":
      return i.getMinutes();
    case "month":
      return i.getMonth();
    case "year":
      return i.getFullYear();
    case "week":
      return ur(i);
  }
}
const fP = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  add: Dp,
  checkChange: Pn,
  chooseInterval: dr,
  copy: dP,
  getDateIntervalDuration: oa,
  getDuration: Dt,
  getIntervalDuration: It,
  getNextUnit: kn,
  getTime: hP,
  getUnitValue: Cp,
  now: Sp,
  round: Ke,
  sleep: wp,
  timeUnitDurations: Io
}, Symbol.toStringTag, { value: "Module" }));
class gi extends Qi {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_aggregatesCalculated", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_selectionAggregatesCalculated", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_dataProcessed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_psi", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_pei", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "chart", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "bullets", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new Pr()
    }), Object.defineProperty(this, "bulletsContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: G.new(this._root, { width: R, height: R, position: "absolute" })
    });
  }
  _afterNew() {
    this.valueFields.push("value"), super._afterNew(), this.setPrivate("customData", {}), this._disposers.push(this.bullets.events.onAll((e) => {
      if (e.type === "clear")
        this._handleBullets(this.dataItems);
      else if (e.type === "push")
        this._handleBullets(this.dataItems);
      else if (e.type === "setIndex")
        this._handleBullets(this.dataItems);
      else if (e.type === "insertIndex")
        this._handleBullets(this.dataItems);
      else if (e.type === "removeIndex")
        this._handleBullets(this.dataItems);
      else if (e.type === "moveIndex")
        this._handleBullets(this.dataItems);
      else
        throw new Error("Unknown IListEvent type");
    }));
  }
  _dispose() {
    this.bulletsContainer.dispose(), super._dispose();
  }
  startIndex() {
    let e = this.dataItems.length;
    return Math.min(this.getPrivate("startIndex", 0), e);
  }
  endIndex() {
    let e = this.dataItems.length;
    return Math.min(this.getPrivate("endIndex", e), e);
  }
  _handleBullets(e) {
    w(e, (t) => {
      const s = t.bullets;
      s && (w(s, (r) => {
        r.dispose();
      }), t.bullets = void 0);
    }), this.markDirtyValues();
  }
  /**
   * Looks up and returns a data item by its ID.
   *
   * @param   id  ID
   * @return      Data item
   */
  getDataItemById(e) {
    return lc(this.dataItems, (t) => t.get("id") == e);
  }
  _makeBullets(e) {
    this._shouldMakeBullet(e) && (e.bullets = [], this.bullets.each((t) => {
      this._makeBullet(e, t);
    }));
  }
  _shouldMakeBullet(e) {
    return !0;
  }
  _makeBullet(e, t, s) {
    const r = t(this._root, this, e);
    if (r) {
      let n = r.get("sprite");
      n && (n._setDataItem(e), n.setRaw("position", "absolute"), this.bulletsContainer.children.push(n)), r._index = s, r.series = this, e.bullets.push(r);
    }
    return r;
  }
  _clearDirty() {
    super._clearDirty(), this._aggregatesCalculated = !1, this._selectionAggregatesCalculated = !1;
  }
  _prepareChildren() {
    super._prepareChildren();
    let e = this.startIndex(), t = this.endIndex();
    if (this.isDirty("heatRules") && (this._valuesDirty = !0), this.isPrivateDirty("baseValueSeries")) {
      const r = this.getPrivate("baseValueSeries");
      r && this._disposers.push(r.onPrivate("startIndex", () => {
        this.markDirtyValues();
      }));
    }
    if (this.get("calculateAggregates") && (this._valuesDirty && !this._dataProcessed && (this._aggregatesCalculated || (this._calculateAggregates(0, this.dataItems.length), this._aggregatesCalculated = !0)), (this._psi != e || this._pei != t) && !this._selectionAggregatesCalculated && (e === 0 && t === this.dataItems.length && this._aggregatesCalculated || this._calculateAggregates(e, t), this._selectionAggregatesCalculated = !0)), this.isDirty("tooltip")) {
      let r = this.get("tooltip");
      r && (r.hide(0), r.set("tooltipTarget", this));
    }
    if (this.isDirty("fill") || this.isDirty("stroke")) {
      let r;
      const n = this.get("legendDataItem");
      if (n && (r = n.get("markerRectangle"), r && this.isVisible())) {
        if (this.isDirty("stroke")) {
          let a = this.get("stroke");
          r.set("stroke", a);
        }
        if (this.isDirty("fill")) {
          let a = this.get("fill");
          r.set("fill", a);
        }
      }
      this.updateLegendMarker(void 0);
    }
    if (this.bullets.length > 0) {
      let r = this.startIndex(), n = this.endIndex();
      n < this.dataItems.length && n++;
      for (let a = r; a < n; a++) {
        let o = this.dataItems[a];
        o.bullets || this._makeBullets(o);
      }
    }
  }
  _calculateAggregates(e, t) {
    let s = this._valueFields;
    if (!s)
      throw new Error("No value fields are set for the series.");
    const r = {}, n = {}, a = {}, o = {}, l = {}, u = {}, h = {}, c = {}, f = {};
    w(s, (d) => {
      r[d] = 0, n[d] = 0, a[d] = 0;
    }), w(s, (d) => {
      let g = d + "Change", p = d + "ChangePercent", _ = d + "ChangePrevious", m = d + "ChangePreviousPercent", v = d + "ChangeSelection", b = d + "ChangeSelectionPercent", y = "valueY";
      (d == "valueX" || d == "openValueX" || d == "lowValueX" || d == "highValueX") && (y = "valueX");
      const x = this.getPrivate("baseValueSeries");
      for (let D = e; D < t; D++) {
        const A = this.dataItems[D];
        let C = A.get(d);
        C != null && (a[d]++, r[d] += C, n[d] += Math.abs(C), c[d] = r[d] / a[d], (o[d] > C || o[d] == null) && (o[d] = C), (l[d] < C || l[d] == null) && (l[d] = C), h[d] = C, u[d] == null && (u[d] = C, f[d] = C, x && (u[y] = x._getBase(y))), e === 0 && (A.setRaw(g, C - u[y]), A.setRaw(p, (C - u[y]) / u[y] * 100)), A.setRaw(_, C - f[y]), A.setRaw(m, (C - f[y]) / f[y] * 100), A.setRaw(v, C - u[y]), A.setRaw(b, (C - u[y]) / u[y] * 100), f[d] = C);
      }
    }), w(s, (d) => {
      this.setPrivate(d + "AverageSelection", c[d]), this.setPrivate(d + "CountSelection", a[d]), this.setPrivate(d + "SumSelection", r[d]), this.setPrivate(d + "AbsoluteSumSelection", n[d]), this.setPrivate(d + "LowSelection", o[d]), this.setPrivate(d + "HighSelection", l[d]), this.setPrivate(d + "OpenSelection", u[d]), this.setPrivate(d + "CloseSelection", h[d]);
    }), e === 0 && t === this.dataItems.length && w(s, (d) => {
      this.setPrivate(d + "Average", c[d]), this.setPrivate(d + "Count", a[d]), this.setPrivate(d + "Sum", r[d]), this.setPrivate(d + "AbsoluteSum", n[d]), this.setPrivate(d + "Low", o[d]), this.setPrivate(d + "High", l[d]), this.setPrivate(d + "Open", u[d]), this.setPrivate(d + "Close", h[d]);
    });
  }
  _updateChildren() {
    super._updateChildren(), this._psi = this.startIndex(), this._pei = this.endIndex(), this.isDirty("visible") && this.bulletsContainer.set("visible", this.get("visible"));
    const e = this.get("heatRules");
    if (this._valuesDirty && e && e.length > 0 && w(e, (t) => {
      const s = t.minValue || this.getPrivate(t.dataField + "Low") || 0, r = t.maxValue || this.getPrivate(t.dataField + "High") || 0;
      w(t.target._entities, (n) => {
        const a = n.dataItem.get(t.dataField);
        if (!S(a)) {
          t.neutral && n.set(t.key, t.neutral);
          return;
        }
        if (t.customFunction)
          t.customFunction.call(this, n, s, r, a);
        else {
          let o;
          t.logarithmic ? o = (Math.log(a) * Math.LOG10E - Math.log(s) * Math.LOG10E) / (Math.log(r) * Math.LOG10E - Math.log(s) * Math.LOG10E) : o = (a - s) / (r - s), S(a) && (!S(o) || Math.abs(o) == 1 / 0) && (o = 0.5);
          let l;
          S(t.min) ? l = t.min + (t.max - t.min) * o : t.min instanceof V ? l = V.interpolate(o, t.min, t.max) : t.min instanceof ae && (l = sp(o, t.min, t.max)), n.set(t.key, l);
        }
      });
    }), this.get("visible") && this.bullets.length > 0) {
      let t = this.dataItems.length, s = this.startIndex(), r = this.endIndex();
      r < t && r++, s > 0 && s--;
      for (let n = 0; n < s; n++)
        this._hideBullets(this.dataItems[n]);
      for (let n = s; n < r; n++)
        this._positionBullets(this.dataItems[n]);
      for (let n = r; n < t; n++)
        this._hideBullets(this.dataItems[n]);
    }
  }
  _positionBullets(e) {
    e.bullets && w(e.bullets, (t) => {
      this._positionBullet(t);
      const s = t.get("sprite");
      t.get("dynamic") && (s && (s._markDirtyKey("fill"), s.markDirtySize()), s instanceof G && s.walkChildren((r) => {
        r._markDirtyKey("fill"), r.markDirtySize(), r instanceof Je && r.text.markDirtyText();
      })), s instanceof Je && s.get("populateText") && s.text.markDirtyText();
    });
  }
  _hideBullets(e) {
    e.bullets && w(e.bullets, (t) => {
      let s = t.get("sprite");
      s && s.setPrivate("visible", !1);
    });
  }
  _positionBullet(e) {
  }
  _placeBulletsContainer(e) {
    e.bulletsContainer.children.moveValue(this.bulletsContainer);
  }
  _removeBulletsContainer() {
    const e = this.bulletsContainer;
    e.parent && e.parent.children.removeValue(e);
  }
  /**
   * @ignore
   */
  disposeDataItem(e) {
    const t = e.bullets;
    t && w(t, (s) => {
      s.dispose();
    });
  }
  _getItemReaderLabel() {
    return "";
  }
  /**
   * Shows series's data item.
   *
   * @param   dataItem  Data item
   * @param   duration  Animation duration in milliseconds
   * @return            Promise
   */
  showDataItem(e, t) {
    const s = Object.create(null, {
      showDataItem: { get: () => super.showDataItem }
    });
    return Ze(this, void 0, void 0, function* () {
      const r = [s.showDataItem.call(this, e, t)], n = e.bullets;
      n && w(n, (a) => {
        r.push(a.get("sprite").show(t));
      }), yield Promise.all(r);
    });
  }
  /**
   * Hides series's data item.
   *
   * @param   dataItem  Data item
   * @param   duration  Animation duration in milliseconds
   * @return            Promise
   */
  hideDataItem(e, t) {
    const s = Object.create(null, {
      hideDataItem: { get: () => super.hideDataItem }
    });
    return Ze(this, void 0, void 0, function* () {
      const r = [s.hideDataItem.call(this, e, t)], n = e.bullets;
      n && w(n, (a) => {
        r.push(a.get("sprite").hide(t));
      }), yield Promise.all(r);
    });
  }
  _sequencedShowHide(e, t) {
    return Ze(this, void 0, void 0, function* () {
      if (this.get("sequencedInterpolation"))
        if (S(t) || (t = this.get("interpolationDuration", 0)), t > 0) {
          const s = this.startIndex(), r = this.endIndex();
          yield Promise.all(Ta(this.dataItems, (n, a) => Ze(this, void 0, void 0, function* () {
            let o = t || 0;
            (a < s - 10 || a > r + 10) && (o = 0);
            let l = this.get("sequencedDelay", 0) + o / (r - s);
            yield wp(l * (a - s)), e ? yield this.showDataItem(n, o) : yield this.hideDataItem(n, o);
          })));
        } else
          yield Promise.all(Ta(this.dataItems, (s) => e ? this.showDataItem(s, 0) : this.hideDataItem(s, 0)));
    });
  }
  /**
   * @ignore
   */
  updateLegendValue(e) {
    if (e) {
      const t = e.get("legendDataItem");
      if (t) {
        const s = t.get("valueLabel");
        if (s) {
          const n = s.text;
          let a = "";
          s._setDataItem(e), a = this.get("legendValueText", n.get("text", "")), s.set("text", a), n.markDirtyText();
        }
        const r = t.get("label");
        if (r) {
          const n = r.text;
          let a = "";
          r._setDataItem(e), a = this.get("legendLabelText", n.get("text", "")), r.set("text", a), n.markDirtyText();
        }
      }
    }
  }
  /**
   * @ignore
   */
  updateLegendMarker(e) {
  }
  _onHide() {
    super._onHide();
    const e = this.getTooltip();
    e && e.hide();
  }
  /**
   * @ignore
   */
  hoverDataItem(e) {
  }
  /**
   * @ignore
   */
  unhoverDataItem(e) {
  }
  /**
   * @ignore
   */
  _getBase(e) {
    const t = this.dataItems[this.startIndex()];
    return t ? t.get(e) : 0;
  }
}
Object.defineProperty(gi, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Series"
});
Object.defineProperty(gi, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Qi.classNames.concat([gi.className])
});
class js extends gi {
  constructor() {
    super(...arguments), Object.defineProperty(this, "itemContainers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new $e(be.new({}), () => G._new(this._root, {
        themeTags: se(this.itemContainers.template.get("themeTags", []), ["legend", "item"]),
        themeTagsSelf: se(this.itemContainers.template.get("themeTagsSelf", []), ["itemcontainer"]),
        background: Pe.new(this._root, {
          themeTags: se(this.itemContainers.template.get("themeTags", []), ["legend", "item", "background"]),
          themeTagsSelf: se(this.itemContainers.template.get("themeTagsSelf", []), ["itemcontainer"])
        })
      }, [this.itemContainers.template]))
    }), Object.defineProperty(this, "markers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new $e(be.new({}), () => G._new(this._root, {
        themeTags: se(this.markers.template.get("themeTags", []), ["legend", "marker"])
      }, [this.markers.template]))
    }), Object.defineProperty(this, "labels", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new $e(be.new({}), () => Je._new(this._root, {
        themeTags: se(this.labels.template.get("themeTags", []), ["legend", "label"])
      }, [this.labels.template]))
    }), Object.defineProperty(this, "valueLabels", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new $e(be.new({}), () => Je._new(this._root, {
        themeTags: se(this.valueLabels.template.get("themeTags", []), ["legend", "label", "value"])
      }, [this.valueLabels.template]))
    }), Object.defineProperty(this, "markerRectangles", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new $e(be.new({}), () => Pe._new(this._root, {
        themeTags: se(this.markerRectangles.template.get("themeTags", []), ["legend", "marker", "rectangle"])
      }, [this.markerRectangles.template]))
    });
  }
  _afterNew() {
    this._settings.themeTags = se(this._settings.themeTags, ["legend"]), this.fields.push("name", "stroke", "fill"), super._afterNew();
  }
  /**
   * @ignore
   */
  makeItemContainer(e) {
    const t = this.children.push(this.itemContainers.make());
    return t._setDataItem(e), this.itemContainers.push(t), t.states.create("disabled", {}), t;
  }
  /**
   * @ignore
   */
  makeMarker() {
    const e = this.markers.make();
    return this.markers.push(e), e.states.create("disabled", {}), e;
  }
  /**
   * @ignore
   */
  makeLabel() {
    const e = this.labels.make();
    return e.states.create("disabled", {}), e;
  }
  /**
   * @ignore
   */
  makeValueLabel() {
    const e = this.valueLabels.make();
    return e.states.create("disabled", {}), e;
  }
  /**
   * @ignore
   */
  makeMarkerRectangle() {
    const e = this.markerRectangles.make();
    return e.states.create("disabled", {}), e;
  }
  processDataItem(e) {
    super.processDataItem(e);
    const t = this.makeItemContainer(e), s = this.get("nameField"), r = this.get("fillField"), n = this.get("strokeField");
    if (t) {
      const a = this.get("clickTarget", "itemContainer"), o = e.dataContext;
      o && o.set && o.set("legendDataItem", e), t._setDataItem(e), e.set("itemContainer", t);
      const l = this.makeMarker();
      if (l) {
        t.children.push(l), l._setDataItem(e), e.set("marker", l);
        const c = this.get("useDefaultMarker"), f = l.children.push(this.makeMarkerRectangle());
        let d = e.get("fill"), g = e.get("stroke");
        e.set("markerRectangle", f), o && o.get && (d = o.get(r, d), g = o.get(n, g)), g || (g = d), c ? o.on && (o.on(r, () => {
          f.set("fill", o.get(r));
        }), o.on(n, () => {
          f.set("stroke", o.get(n));
        })) : o && o.createLegendMarker && o.createLegendMarker(), f.setAll({ fill: d, stroke: g });
        const p = o.component;
        p && p.updateLegendMarker && p.updateLegendMarker(o);
      }
      const u = this.makeLabel();
      if (u) {
        t.children.push(u), u._setDataItem(e), e.set("label", u), u.text.on("text", () => {
          t.setRaw("ariaLabel", u.text._getText() + (this.get("clickTarget") !== "none" ? "; " + this._t("Press ENTER to toggle") : "")), t.markDirtyAccessibility();
        }), o && o.get && e.set("name", o.get(s));
        let c = e.get("name");
        c && u.set("text", c);
      }
      const h = this.makeValueLabel();
      if (h && (t.children.push(h), h._setDataItem(e), e.set("valueLabel", h)), o && o.show && (o.on("visible", (c) => {
        t.set("disabled", !c);
      }), o.get("visible") || t.set("disabled", !0), a != "none")) {
        let c = t;
        a == "marker" && (c = l), this._addClickEvents(c, o, e);
      }
      this.children.values.sort((c, f) => {
        const d = c.dataItem.dataContext, g = f.dataItem.dataContext;
        if (d && g) {
          const p = this.data.indexOf(d), _ = this.data.indexOf(g);
          if (p > _)
            return 1;
          if (p < _)
            return -1;
        }
        return 0;
      }), o && o.updateLegendValue && o.updateLegendValue();
    }
  }
  _addClickEvents(e, t, s) {
    e.set("cursorOverStyle", "pointer"), e.events.on("pointerover", () => {
      const r = t.component;
      r && r.hoverDataItem && r.hoverDataItem(t);
    }), e.events.on("pointerout", () => {
      const r = t.component;
      r && r.hoverDataItem && r.unhoverDataItem(t);
    }), e.events.on("click", () => {
      const r = s.get("label").text._getText();
      t.show && t.isHidden && (t.isHidden() || t.get("visible") === !1) ? (t.show(), e.set("disabled", !1), this._root.readerAlert(this._t("%1 shown", this._root.locale, r))) : t.hide && (t.hide(), e.set("disabled", !0), this._root.readerAlert(this._t("%1 hidden", this._root.locale, r)));
    });
  }
  /**
   * @ignore
   */
  disposeDataItem(e) {
    super.disposeDataItem(e);
    const t = e.dataContext;
    t && t.get && t.get("legendDataItem") == e && t.set("legendDataItem", void 0);
    let s = e.get("itemContainer");
    s && (this.itemContainers.removeValue(s), s.dispose());
    let r = e.get("marker");
    r && (this.markers.removeValue(r), r.dispose());
    let n = e.get("markerRectangle");
    n && (this.markerRectangles.removeValue(n), n.dispose());
    let a = e.get("label");
    a && (this.labels.removeValue(a), a.dispose());
    let o = e.get("valueLabel");
    o && (this.valueLabels.removeValue(o), o.dispose());
  }
}
Object.defineProperty(js, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Legend"
});
Object.defineProperty(js, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: gi.classNames.concat([js.className])
});
function bh(i, e) {
  for (let t = 0, s = e.length; t < s; t++) {
    const r = e[t];
    if (r.length > 0) {
      let n = r[0];
      if (n.length > 0) {
        let a = n[0];
        i.moveTo(a.x, a.y);
        for (let o = 0, l = r.length; o < l; o++)
          pP(i, r[o]);
      }
    }
  }
}
function pP(i, e) {
  for (let t = 0, s = e.length; t < s; t++) {
    const r = e[t];
    i.lineTo(r.x, r.y);
  }
}
class fr extends ce {
  _beforeChanged() {
    super._beforeChanged(), (this.isDirty("points") || this.isDirty("segments") || this._sizeDirty || this.isPrivateDirty("width") || this.isPrivateDirty("height")) && (this._clear = !0);
  }
  _changed() {
    if (super._changed(), this._clear) {
      const e = this.get("points"), t = this.get("segments");
      if (e && e.length > 0) {
        let s = e[0];
        this._display.moveTo(s.x, s.y), bh(this._display, [[e]]);
      } else if (t)
        bh(this._display, t);
      else if (!this.get("draw")) {
        let s = this.width(), r = this.height();
        this._display.moveTo(0, 0), this._display.lineTo(s, r);
      }
    }
  }
}
Object.defineProperty(fr, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Line"
});
Object.defineProperty(fr, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: ce.classNames.concat([fr.className])
});
class Ya extends kt {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_display", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._root._renderer.makePicture(void 0)
    });
  }
  _changed() {
    if (super._changed(), this.isDirty("width")) {
      const e = this.get("width");
      this._display.width = S(e) ? e : void 0;
    }
    if (this.isDirty("height")) {
      const e = this.get("height");
      this._display.height = S(e) ? e : void 0;
    }
    if (this.isDirty("shadowColor")) {
      this._display.clear();
      const e = this.get("shadowColor");
      this._display.shadowColor = e ?? void 0;
    }
    this.isDirty("shadowBlur") && (this._display.clear(), this._display.shadowBlur = this.get("shadowBlur")), this.isDirty("shadowOffsetX") && (this._display.clear(), this._display.shadowOffsetX = this.get("shadowOffsetX")), this.isDirty("shadowOffsetY") && (this._display.clear(), this._display.shadowOffsetY = this.get("shadowOffsetY")), this.isDirty("shadowOpacity") && (this._display.clear(), this._display.shadowOpacity = this.get("shadowOpacity")), (this.isDirty("src") || this.isDirty("cors")) && (this._display.clear(), this._load());
  }
  _load() {
    const e = this.get("src");
    if (e) {
      let t = "loaded";
      const s = new Image();
      s.crossOrigin = this.get("cors", "anonymous"), s.src = e, s.decode().then(() => {
        this._display.image = s, this._updateSize();
      }).catch((r) => {
        t = "loaderror";
      }), this.events.isEnabled(t) && this.events.dispatch(t, { type: t, target: this });
    }
  }
  _updateSize() {
    super._updateSize();
    const e = this._display.image;
    if (e) {
      let t = this.getPrivate("width", this.get("width")), s = this.getPrivate("height", this.get("height"));
      const r = e.width && e.height ? e.width / e.height : 0;
      S(t) && S(s) ? (this._display.width = t, this._display.height = s) : S(t) && r ? s = t / r : S(s) && r ? t = s * r : (t = e.width, s = e.height), S(t) && (this._display.width = t), S(s) && (this._display.height = s), this.markDirtyBounds(), this.markDirty();
    }
  }
}
Object.defineProperty(Ya, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Picture"
});
Object.defineProperty(Ya, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: kt.classNames.concat([Ya.className])
});
class ln extends qi {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_display", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._root._renderer.makeRadialText("", this.textStyle)
    });
  }
  _afterNew() {
    super._afterNew();
  }
  _beforeChanged() {
    super._beforeChanged(), this._display.clear(), this.isDirty("textType") && (this._display.textType = this.get("textType"), this.markDirtyBounds()), this.isDirty("radius") && (this._display.radius = this.get("radius"), this.markDirtyBounds()), this.isDirty("startAngle") && (this._display.startAngle = (this.get("startAngle", 0) + 90) * Os, this.markDirtyBounds()), this.isDirty("inside") && (this._display.inside = this.get("inside"), this.markDirtyBounds()), this.isDirty("orientation") && (this._display.orientation = this.get("orientation"), this.markDirtyBounds()), this.isDirty("kerning") && (this._display.kerning = this.get("kerning"), this.markDirtyBounds());
  }
}
Object.defineProperty(ln, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "RadialText"
});
Object.defineProperty(ln, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: qi.classNames.concat([ln.className])
});
class Is extends Je {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_flipped", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    });
  }
  _afterNew() {
    this._textKeys.push("textType", "kerning"), super._afterNew();
  }
  _makeText() {
    this._text = this.children.push(ln.new(this._root, {}));
  }
  /**
   * Returns base radius in pixels.
   *
   * @return Base radius
   */
  baseRadius() {
    const e = this.getPrivate("radius", 0), t = this.getPrivate("innerRadius", 0), s = this.get("baseRadius", 0);
    return t + Te(s, e - t);
  }
  /**
   * Returns radius adjustment in pixels.
   *
   * @return Radius
   */
  radius() {
    const e = this.get("inside", !1);
    return this.baseRadius() + this.get("radius", 0) * (e ? -1 : 1);
  }
  _updateChildren() {
    if (super._updateChildren(), this.isDirty("baseRadius") || this.isPrivateDirty("radius") || this.isPrivateDirty("innerRadius") || this.isDirty("labelAngle") || this.isDirty("radius") || this.isDirty("inside") || this.isDirty("orientation") || this.isDirty("textType")) {
      const e = this.get("textType", "adjusted"), t = this.get("inside", !1), s = this.get("orientation");
      let r = Ms(this.get("labelAngle", 0));
      this._text.set("startAngle", this.get("labelAngle", 0)), this._text.set("inside", t);
      const n = it(r), a = pt(r);
      let o = this.baseRadius(), l = this.radius();
      if (this._display.angle = 0, e == "circular")
        this.setAll({
          paddingTop: 0,
          paddingBottom: 0,
          paddingLeft: 0,
          paddingRight: 0
        }), this._text.set("orientation", s), this._text.set("radius", l);
      else {
        o == 0 && (r = 0, l = 0);
        let u = l * a, h = l * n;
        e == "radial" ? (this.setRaw("x", u), this.setRaw("y", h), r < 90 || r > 270 || s != "auto" ? (this._display.angle = r, this._flipped = !1) : (this._display.angle = r + 180, this._flipped = !0), this._dirty.rotation = !1) : e == "adjusted" ? (this.setRaw("centerX", le), this.setRaw("centerY", le), this.setRaw("x", u), this.setRaw("y", h)) : e == "regular" && (this.setRaw("x", u), this.setRaw("y", h));
      }
      this.markDirtyPosition(), this.markDirtyBounds();
    }
  }
  _updatePosition() {
    const e = this.get("textType", "regular"), t = this.get("inside", !1);
    let s = 0, r = 0, n = this.get("labelAngle", 0), a = this.localBounds(), o = a.right - a.left, l = a.bottom - a.top;
    if (e == "radial") {
      if (this._flipped) {
        let u = this.get("centerX");
        u instanceof ae && (o = o * (1 - u.value * 2)), s = o * pt(n), r = o * it(n);
      }
    } else
      !t && e == "adjusted" && (s = o / 2 * pt(n), r = l / 2 * it(n));
    this.setRaw("dx", s), this.setRaw("dy", r), super._updatePosition();
  }
  /**
   * @ignore
   */
  get text() {
    return this._text;
  }
}
Object.defineProperty(Is, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "RadialLabel"
});
Object.defineProperty(Is, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Je.classNames.concat([Is.className])
});
class Ba extends ce {
  _beforeChanged() {
    super._beforeChanged(), (this.isDirty("width") || this.isDirty("height") || this.isPrivateDirty("width") || this.isPrivateDirty("height")) && (this._clear = !0);
  }
  _changed() {
    super._changed(), this._clear && !this.get("draw") && this._draw();
  }
  _draw() {
    const e = this.width(), t = this.height(), s = this._display;
    s.moveTo(-e / 2, t / 2), s.lineTo(0, -t / 2), s.lineTo(e / 2, t / 2), s.lineTo(-e / 2, t / 2), s.closePath();
  }
  _updateSize() {
    this.markDirty(), this._clear = !0;
  }
}
Object.defineProperty(Ba, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Triangle"
});
Object.defineProperty(Ba, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: ce.classNames.concat([Ba.className])
});
class es extends G {
  constructor() {
    super(...arguments), Object.defineProperty(this, "thumb", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._makeThumb()
    }), Object.defineProperty(this, "startGrip", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._makeButton()
    }), Object.defineProperty(this, "endGrip", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._makeButton()
    }), Object.defineProperty(this, "_thumbBusy", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_startDown", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_endDown", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_thumbDown", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_gripDown", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  _addOrientationClass() {
    this._settings.themeTags = se(this._settings.themeTags, ["scrollbar", this._settings.orientation]), this._settings.background || (this._settings.background = Pe.new(this._root, {
      themeTags: se(this._settings.themeTags, ["main", "background"])
    }));
  }
  _makeButton() {
    return this.children.push(hr.new(this._root, {
      themeTags: ["resize", "button", this.get("orientation")],
      icon: ce.new(this._root, {
        themeTags: ["icon"]
      })
    }));
  }
  _makeThumb() {
    return this.children.push(Pe.new(this._root, {
      themeTags: ["thumb", this.get("orientation")]
    }));
  }
  _handleAnimation(e) {
    e && this._disposers.push(e.events.on("stopped", () => {
      this.setPrivateRaw("isBusy", !1), this._thumbBusy = !1;
    }));
  }
  _afterNew() {
    this._addOrientationClass(), super._afterNew();
    const e = this.startGrip, t = this.endGrip, s = this.thumb, r = this.get("background");
    r && this._disposers.push(r.events.on("click", (n) => {
      this.setPrivateRaw("isBusy", !0);
      const a = this._display.toLocal(n.point), o = this.width(), l = this.height(), u = this.get("orientation");
      let h;
      u == "vertical" ? h = (a.y - s.height() / 2) / l : h = (a.x - s.width() / 2) / o;
      let c, f;
      u == "vertical" ? (c = h * l, f = "y") : (c = h * o, f = "x");
      const d = this.get("animationDuration", 0);
      d > 0 ? (this._thumbBusy = !0, this._handleAnimation(this.thumb.animate({ key: f, to: c, duration: d, easing: this.get("animationEasing") }))) : (this.thumb.set(f, c), this._root.events.once("frameended", () => {
        this.setPrivateRaw("isBusy", !1);
      }));
    })), this._disposers.push(s.events.on("dblclick", (n) => {
      if (!ko(n.originalEvent, this))
        return;
      const a = this.get("animationDuration", 0), o = this.get("animationEasing");
      this.animate({ key: "start", to: 0, duration: a, easing: o }), this.animate({ key: "end", to: 1, duration: a, easing: o });
    })), this._disposers.push(e.events.on("pointerdown", () => {
      this.setPrivateRaw("isBusy", !0), this._startDown = !0, this._gripDown = "start";
    })), this._disposers.push(t.events.on("pointerdown", () => {
      this.setPrivateRaw("isBusy", !0), this._endDown = !0, this._gripDown = "end";
    })), this._disposers.push(s.events.on("pointerdown", () => {
      this.setPrivateRaw("isBusy", !0), this._thumbDown = !0, this._gripDown = void 0;
    })), this._disposers.push(e.events.on("globalpointerup", () => {
      this._startDown && this.setPrivateRaw("isBusy", !1), this._startDown = !1;
    })), this._disposers.push(t.events.on("globalpointerup", () => {
      this._endDown && this.setPrivateRaw("isBusy", !1), this._endDown = !1;
    })), this._disposers.push(s.events.on("globalpointerup", () => {
      this._thumbDown && this.setPrivateRaw("isBusy", !1), this._thumbDown = !1;
    })), this._disposers.push(e.on("x", () => {
      this._updateThumb();
    })), this._disposers.push(t.on("x", () => {
      this._updateThumb();
    })), this._disposers.push(e.on("y", () => {
      this._updateThumb();
    })), this._disposers.push(t.on("y", () => {
      this._updateThumb();
    })), this._disposers.push(s.events.on("positionchanged", () => {
      this._updateGripsByThumb();
    })), this.get("orientation") == "vertical" ? (e.set("x", 0), t.set("x", 0), this._disposers.push(s.adapters.add("y", (n) => Math.max(Math.min(Number(n), this.height() - s.height()), 0))), this._disposers.push(s.adapters.add("x", (n) => this.width() / 2)), this._disposers.push(e.adapters.add("x", (n) => this.width() / 2)), this._disposers.push(t.adapters.add("x", (n) => this.width() / 2)), this._disposers.push(e.adapters.add("y", (n) => Math.max(Math.min(Number(n), this.height()), 0))), this._disposers.push(t.adapters.add("y", (n) => Math.max(Math.min(Number(n), this.height()), 0)))) : (e.set("y", 0), t.set("y", 0), this._disposers.push(s.adapters.add("x", (n) => Math.max(Math.min(Number(n), this.width() - s.width()), 0))), this._disposers.push(s.adapters.add("y", (n) => this.height() / 2)), this._disposers.push(e.adapters.add("y", (n) => this.height() / 2)), this._disposers.push(t.adapters.add("y", (n) => this.height() / 2)), this._disposers.push(e.adapters.add("x", (n) => Math.max(Math.min(Number(n), this.width()), 0))), this._disposers.push(t.adapters.add("x", (n) => Math.max(Math.min(Number(n), this.width()), 0))));
  }
  _updateChildren() {
    super._updateChildren(), (this.isDirty("end") || this.isDirty("start") || this._sizeDirty) && this.updateGrips();
  }
  _changed() {
    if (super._changed(), this.isDirty("start") || this.isDirty("end")) {
      const e = "rangechanged";
      this.events.isEnabled(e) && this.events.dispatch(e, { type: e, target: this, start: this.get("start", 0), end: this.get("end", 1), grip: this._gripDown });
    }
  }
  /**
   * @ignore
   */
  updateGrips() {
    const e = this.startGrip, t = this.endGrip, s = this.get("orientation"), r = this.height(), n = this.width();
    s == "vertical" ? (e.set("y", r * this.get("start", 0)), t.set("y", r * this.get("end", 1))) : (e.set("x", n * this.get("start", 0)), t.set("x", n * this.get("end", 1)));
    const a = this.getPrivate("positionTextFunction"), o = Math.round(this.get("start", 0) * 100), l = Math.round(this.get("end", 0) * 100);
    let u, h;
    a ? (u = a.call(this, this.get("start", 0)), h = a.call(this, this.get("end", 0))) : (u = o + "%", h = l + "%"), e.set("ariaLabel", this._t("From %1", void 0, u)), e.set("ariaValueNow", "" + o), e.set("ariaValueText", o + "%"), e.set("ariaValueMin", "0"), e.set("ariaValueMax", "100"), t.set("ariaLabel", this._t("To %1", void 0, h)), t.set("ariaValueNow", "" + l), t.set("ariaValueText", l + "%"), t.set("ariaValueMin", "0"), t.set("ariaValueMax", "100");
  }
  _updateThumb() {
    const e = this.thumb, t = this.startGrip, s = this.endGrip, r = this.height(), n = this.width();
    let a = t.x(), o = s.x(), l = t.y(), u = s.y(), h = 0, c = 1;
    this.get("orientation") == "vertical" ? S(l) && S(u) && (!this._thumbBusy && !e.isDragging() && (e.set("height", u - l), e.set("y", l)), h = l / r, c = u / r) : S(a) && S(o) && (!this._thumbBusy && !e.isDragging() && (e.set("width", o - a), e.set("x", a)), h = a / n, c = o / n), this.getPrivate("isBusy") && (this.get("start") != h || this.get("end") != c) && (this.set("start", h), this.set("end", c));
    const f = this.getPrivate("positionTextFunction"), d = Math.round(this.get("start", 0) * 100), g = Math.round(this.get("end", 0) * 100);
    let p, _;
    f ? (p = f.call(this, this.get("start", 0)), _ = f.call(this, this.get("end", 0))) : (p = d + "%", _ = g + "%"), e.set("ariaLabel", this._t("From %1 to %2", void 0, p, _)), e.set("ariaValueNow", "" + d), e.set("ariaValueText", d + "%");
  }
  _updateGripsByThumb() {
    const e = this.thumb, t = this.startGrip, s = this.endGrip;
    if (this.get("orientation") == "vertical") {
      const r = e.height();
      t.set("y", e.y()), s.set("y", e.y() + r);
    } else {
      const r = e.width();
      t.set("x", e.x()), s.set("x", e.x() + r);
    }
  }
}
Object.defineProperty(es, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Scrollbar"
});
Object.defineProperty(es, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: G.classNames.concat([es.className])
});
let Ha = class extends es {
  _afterNew() {
    this._addOrientationClass(), super._afterNew(), this.endGrip.setPrivate("visible", !1), this.thumb.setPrivate("visible", !1);
  }
  /**
   * @ignore
   */
  updateGrips() {
    super.updateGrips();
    const e = this.startGrip;
    this.endGrip.setAll({ x: e.x(), y: e.y() }), this.setRaw("end", this.get("start"));
  }
};
Object.defineProperty(Ha, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Slider"
});
Object.defineProperty(Ha, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: es.classNames.concat([Ha.className])
});
var tu = Math.PI, iu = 2 * tu, ys = 1e-6, gP = iu - ys;
function su() {
  this._x0 = this._y0 = // start of current subpath
  this._x1 = this._y1 = null, this._ = "";
}
function Eo() {
  return new su();
}
su.prototype = Eo.prototype = {
  constructor: su,
  moveTo: function(i, e) {
    this._ += "M" + (this._x0 = this._x1 = +i) + "," + (this._y0 = this._y1 = +e);
  },
  closePath: function() {
    this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._ += "Z");
  },
  lineTo: function(i, e) {
    this._ += "L" + (this._x1 = +i) + "," + (this._y1 = +e);
  },
  quadraticCurveTo: function(i, e, t, s) {
    this._ += "Q" + +i + "," + +e + "," + (this._x1 = +t) + "," + (this._y1 = +s);
  },
  bezierCurveTo: function(i, e, t, s, r, n) {
    this._ += "C" + +i + "," + +e + "," + +t + "," + +s + "," + (this._x1 = +r) + "," + (this._y1 = +n);
  },
  arcTo: function(i, e, t, s, r) {
    i = +i, e = +e, t = +t, s = +s, r = +r;
    var n = this._x1, a = this._y1, o = t - i, l = s - e, u = n - i, h = a - e, c = u * u + h * h;
    if (r < 0)
      throw new Error("negative radius: " + r);
    if (this._x1 === null)
      this._ += "M" + (this._x1 = i) + "," + (this._y1 = e);
    else if (c > ys)
      if (!(Math.abs(h * o - l * u) > ys) || !r)
        this._ += "L" + (this._x1 = i) + "," + (this._y1 = e);
      else {
        var f = t - n, d = s - a, g = o * o + l * l, p = f * f + d * d, _ = Math.sqrt(g), m = Math.sqrt(c), v = r * Math.tan((tu - Math.acos((g + c - p) / (2 * _ * m))) / 2), b = v / m, y = v / _;
        Math.abs(b - 1) > ys && (this._ += "L" + (i + b * u) + "," + (e + b * h)), this._ += "A" + r + "," + r + ",0,0," + +(h * f > u * d) + "," + (this._x1 = i + y * o) + "," + (this._y1 = e + y * l);
      }
  },
  arc: function(i, e, t, s, r, n) {
    i = +i, e = +e, t = +t, n = !!n;
    var a = t * Math.cos(s), o = t * Math.sin(s), l = i + a, u = e + o, h = 1 ^ n, c = n ? s - r : r - s;
    if (t < 0)
      throw new Error("negative radius: " + t);
    this._x1 === null ? this._ += "M" + l + "," + u : (Math.abs(this._x1 - l) > ys || Math.abs(this._y1 - u) > ys) && (this._ += "L" + l + "," + u), t && (c < 0 && (c = c % iu + iu), c > gP ? this._ += "A" + t + "," + t + ",0,1," + h + "," + (i - a) + "," + (e - o) + "A" + t + "," + t + ",0,1," + h + "," + (this._x1 = l) + "," + (this._y1 = u) : c > ys && (this._ += "A" + t + "," + t + ",0," + +(c >= tu) + "," + h + "," + (this._x1 = i + t * Math.cos(r)) + "," + (this._y1 = e + t * Math.sin(r))));
  },
  rect: function(i, e, t, s) {
    this._ += "M" + (this._x0 = this._x1 = +i) + "," + (this._y0 = this._y1 = +e) + "h" + +t + "v" + +s + "h" + -t + "Z";
  },
  toString: function() {
    return this._;
  }
};
function ze(i) {
  return function() {
    return i;
  };
}
var yh = Math.abs, lt = Math.atan2, gs = Math.cos, _P = Math.max, ol = Math.min, ai = Math.sin, Qs = Math.sqrt, xt = 1e-12, un = Math.PI, za = un / 2, mP = 2 * un;
function bP(i) {
  return i > 1 ? 0 : i < -1 ? un : Math.acos(i);
}
function vh(i) {
  return i >= 1 ? za : i <= -1 ? -za : Math.asin(i);
}
function yP(i) {
  return i.innerRadius;
}
function vP(i) {
  return i.outerRadius;
}
function xP(i) {
  return i.startAngle;
}
function wP(i) {
  return i.endAngle;
}
function SP(i) {
  return i && i.padAngle;
}
function DP(i, e, t, s, r, n, a, o) {
  var l = t - i, u = s - e, h = a - r, c = o - n, f = c * l - h * u;
  if (!(f * f < xt))
    return f = (h * (e - n) - c * (i - r)) / f, [i + f * l, e + f * u];
}
function Vn(i, e, t, s, r, n, a) {
  var o = i - t, l = e - s, u = (a ? n : -n) / Qs(o * o + l * l), h = u * l, c = -u * o, f = i + h, d = e + c, g = t + h, p = s + c, _ = (f + g) / 2, m = (d + p) / 2, v = g - f, b = p - d, y = v * v + b * b, x = r - n, D = f * p - g * d, A = (b < 0 ? -1 : 1) * Qs(_P(0, x * x * y - D * D)), C = (D * b - v * A) / y, O = (-D * v - b * A) / y, T = (D * b + v * A) / y, L = (-D * v + b * A) / y, j = C - _, N = O - m, ee = T - _, z = L - m;
  return j * j + N * N > ee * ee + z * z && (C = T, O = L), {
    cx: C,
    cy: O,
    x01: -h,
    y01: -c,
    x11: C * (r / x - 1),
    y11: O * (r / x - 1)
  };
}
function CP() {
  var i = yP, e = vP, t = ze(0), s = null, r = xP, n = wP, a = SP, o = null;
  function l() {
    var u, h, c = +i.apply(this, arguments), f = +e.apply(this, arguments), d = r.apply(this, arguments) - za, g = n.apply(this, arguments) - za, p = yh(g - d), _ = g > d;
    if (o || (o = u = Eo()), f < c && (h = f, f = c, c = h), !(f > xt))
      o.moveTo(0, 0);
    else if (p > mP - xt)
      o.moveTo(f * gs(d), f * ai(d)), o.arc(0, 0, f, d, g, !_), c > xt && (o.moveTo(c * gs(g), c * ai(g)), o.arc(0, 0, c, g, d, _));
    else {
      var m = d, v = g, b = d, y = g, x = p, D = p, A = a.apply(this, arguments) / 2, C = A > xt && (s ? +s.apply(this, arguments) : Qs(c * c + f * f)), O = ol(yh(f - c) / 2, +t.apply(this, arguments)), T = O, L = O, j, N;
      if (C > xt) {
        var ee = vh(C / c * ai(A)), z = vh(C / f * ai(A));
        (x -= ee * 2) > xt ? (ee *= _ ? 1 : -1, b += ee, y -= ee) : (x = 0, b = y = (d + g) / 2), (D -= z * 2) > xt ? (z *= _ ? 1 : -1, m += z, v -= z) : (D = 0, m = v = (d + g) / 2);
      }
      var H = f * gs(m), $ = f * ai(m), Z = c * gs(y), B = c * ai(y);
      if (O > xt) {
        var he = f * gs(v), M = f * ai(v), k = c * gs(b), P = c * ai(b), F;
        if (p < un && (F = DP(H, $, k, P, he, M, Z, B))) {
          var te = H - F[0], U = $ - F[1], _e = he - F[0], Se = M - F[1], Ot = 1 / ai(bP((te * _e + U * Se) / (Qs(te * te + U * U) * Qs(_e * _e + Se * Se))) / 2), cs = Qs(F[0] * F[0] + F[1] * F[1]);
          T = ol(O, (c - cs) / (Ot - 1)), L = ol(O, (f - cs) / (Ot + 1));
        }
      }
      D > xt ? L > xt ? (j = Vn(k, P, H, $, f, L, _), N = Vn(he, M, Z, B, f, L, _), o.moveTo(j.cx + j.x01, j.cy + j.y01), L < O ? o.arc(j.cx, j.cy, L, lt(j.y01, j.x01), lt(N.y01, N.x01), !_) : (o.arc(j.cx, j.cy, L, lt(j.y01, j.x01), lt(j.y11, j.x11), !_), o.arc(0, 0, f, lt(j.cy + j.y11, j.cx + j.x11), lt(N.cy + N.y11, N.cx + N.x11), !_), o.arc(N.cx, N.cy, L, lt(N.y11, N.x11), lt(N.y01, N.x01), !_))) : (o.moveTo(H, $), o.arc(0, 0, f, m, v, !_)) : o.moveTo(H, $), !(c > xt) || !(x > xt) ? o.lineTo(Z, B) : T > xt ? (j = Vn(Z, B, he, M, c, -T, _), N = Vn(H, $, k, P, c, -T, _), o.lineTo(j.cx + j.x01, j.cy + j.y01), T < O ? o.arc(j.cx, j.cy, T, lt(j.y01, j.x01), lt(N.y01, N.x01), !_) : (o.arc(j.cx, j.cy, T, lt(j.y01, j.x01), lt(j.y11, j.x11), !_), o.arc(0, 0, c, lt(j.cy + j.y11, j.cx + j.x11), lt(N.cy + N.y11, N.cx + N.x11), _), o.arc(N.cx, N.cy, T, lt(N.y11, N.x11), lt(N.y01, N.x01), !_))) : o.arc(0, 0, c, y, b, _);
    }
    if (o.closePath(), u)
      return o = null, u + "" || null;
  }
  return l.centroid = function() {
    var u = (+i.apply(this, arguments) + +e.apply(this, arguments)) / 2, h = (+r.apply(this, arguments) + +n.apply(this, arguments)) / 2 - un / 2;
    return [gs(h) * u, ai(h) * u];
  }, l.innerRadius = function(u) {
    return arguments.length ? (i = typeof u == "function" ? u : ze(+u), l) : i;
  }, l.outerRadius = function(u) {
    return arguments.length ? (e = typeof u == "function" ? u : ze(+u), l) : e;
  }, l.cornerRadius = function(u) {
    return arguments.length ? (t = typeof u == "function" ? u : ze(+u), l) : t;
  }, l.padRadius = function(u) {
    return arguments.length ? (s = u == null ? null : typeof u == "function" ? u : ze(+u), l) : s;
  }, l.startAngle = function(u) {
    return arguments.length ? (r = typeof u == "function" ? u : ze(+u), l) : r;
  }, l.endAngle = function(u) {
    return arguments.length ? (n = typeof u == "function" ? u : ze(+u), l) : n;
  }, l.padAngle = function(u) {
    return arguments.length ? (a = typeof u == "function" ? u : ze(+u), l) : a;
  }, l.context = function(u) {
    return arguments.length ? (o = u ?? null, l) : o;
  }, l;
}
function Tp(i) {
  this._context = i;
}
Tp.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(i, e) {
    switch (i = +i, e = +e, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(i, e) : this._context.moveTo(i, e);
        break;
      case 1:
        this._point = 2;
      default:
        this._context.lineTo(i, e);
        break;
    }
  }
};
function kp(i) {
  return new Tp(i);
}
function Pp(i) {
  return i[0];
}
function Op(i) {
  return i[1];
}
function Mp() {
  var i = Pp, e = Op, t = ze(!0), s = null, r = kp, n = null;
  function a(o) {
    var l, u = o.length, h, c = !1, f;
    for (s == null && (n = r(f = Eo())), l = 0; l <= u; ++l)
      !(l < u && t(h = o[l], l, o)) === c && ((c = !c) ? n.lineStart() : n.lineEnd()), c && n.point(+i(h, l, o), +e(h, l, o));
    if (f)
      return n = null, f + "" || null;
  }
  return a.x = function(o) {
    return arguments.length ? (i = typeof o == "function" ? o : ze(+o), a) : i;
  }, a.y = function(o) {
    return arguments.length ? (e = typeof o == "function" ? o : ze(+o), a) : e;
  }, a.defined = function(o) {
    return arguments.length ? (t = typeof o == "function" ? o : ze(!!o), a) : t;
  }, a.curve = function(o) {
    return arguments.length ? (r = o, s != null && (n = r(s)), a) : r;
  }, a.context = function(o) {
    return arguments.length ? (o == null ? s = n = null : n = r(s = o), a) : s;
  }, a;
}
function TP() {
  var i = Pp, e = null, t = ze(0), s = Op, r = ze(!0), n = null, a = kp, o = null;
  function l(h) {
    var c, f, d, g = h.length, p, _ = !1, m, v = new Array(g), b = new Array(g);
    for (n == null && (o = a(m = Eo())), c = 0; c <= g; ++c) {
      if (!(c < g && r(p = h[c], c, h)) === _)
        if (_ = !_)
          f = c, o.areaStart(), o.lineStart();
        else {
          for (o.lineEnd(), o.lineStart(), d = c - 1; d >= f; --d)
            o.point(v[d], b[d]);
          o.lineEnd(), o.areaEnd();
        }
      _ && (v[c] = +i(p, c, h), b[c] = +t(p, c, h), o.point(e ? +e(p, c, h) : v[c], s ? +s(p, c, h) : b[c]));
    }
    if (m)
      return o = null, m + "" || null;
  }
  function u() {
    return Mp().defined(r).curve(a).context(n);
  }
  return l.x = function(h) {
    return arguments.length ? (i = typeof h == "function" ? h : ze(+h), e = null, l) : i;
  }, l.x0 = function(h) {
    return arguments.length ? (i = typeof h == "function" ? h : ze(+h), l) : i;
  }, l.x1 = function(h) {
    return arguments.length ? (e = h == null ? null : typeof h == "function" ? h : ze(+h), l) : e;
  }, l.y = function(h) {
    return arguments.length ? (t = typeof h == "function" ? h : ze(+h), s = null, l) : t;
  }, l.y0 = function(h) {
    return arguments.length ? (t = typeof h == "function" ? h : ze(+h), l) : t;
  }, l.y1 = function(h) {
    return arguments.length ? (s = h == null ? null : typeof h == "function" ? h : ze(+h), l) : s;
  }, l.lineX0 = l.lineY0 = function() {
    return u().x(i).y(t);
  }, l.lineY1 = function() {
    return u().x(i).y(s);
  }, l.lineX1 = function() {
    return u().x(e).y(t);
  }, l.defined = function(h) {
    return arguments.length ? (r = typeof h == "function" ? h : ze(!!h), l) : r;
  }, l.curve = function(h) {
    return arguments.length ? (a = h, n != null && (o = a(n)), l) : a;
  }, l.context = function(h) {
    return arguments.length ? (h == null ? n = o = null : o = a(n = h), l) : n;
  }, l;
}
function xh(i, e, t) {
  i._context.bezierCurveTo(
    i._x1 + i._k * (i._x2 - i._x0),
    i._y1 + i._k * (i._y2 - i._y0),
    i._x2 + i._k * (i._x1 - e),
    i._y2 + i._k * (i._y1 - t),
    i._x2,
    i._y2
  );
}
function Ap(i, e) {
  this._context = i, this._k = (1 - e) / 6;
}
Ap.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        xh(this, this._x1, this._y1);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(i, e) {
    switch (i = +i, e = +e, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(i, e) : this._context.moveTo(i, e);
        break;
      case 1:
        this._point = 2, this._x1 = i, this._y1 = e;
        break;
      case 2:
        this._point = 3;
      default:
        xh(this, i, e);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = i, this._y0 = this._y1, this._y1 = this._y2, this._y2 = e;
  }
};
const wh = function i(e) {
  function t(s) {
    return new Ap(s, e);
  }
  return t.tension = function(s) {
    return i(+s);
  }, t;
}(0);
function Lp(i, e) {
  this._context = i, this._t = e;
}
Lp.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN, this._point = 0;
  },
  lineEnd: function() {
    0 < this._t && this._t < 1 && this._point === 2 && this._context.lineTo(this._x, this._y), (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line >= 0 && (this._t = 1 - this._t, this._line = 1 - this._line);
  },
  point: function(i, e) {
    switch (i = +i, e = +e, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(i, e) : this._context.moveTo(i, e);
        break;
      case 1:
        this._point = 2;
      default: {
        if (this._t <= 0)
          this._context.lineTo(this._x, e), this._context.lineTo(i, e);
        else {
          var t = this._x * (1 - this._t) + i * this._t;
          this._context.lineTo(t, this._y), this._context.lineTo(t, e);
        }
        break;
      }
    }
    this._x = i, this._y = e;
  }
};
function kP(i) {
  return new Lp(i, 1);
}
class cn extends ce {
  constructor() {
    super(...arguments), Object.defineProperty(this, "ix", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "iy", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_generator", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: CP()
    });
  }
  _getTooltipPoint() {
    let e = this.get("tooltipX"), t = this.get("tooltipY"), s = 0, r = 0;
    S(e) && (s = e), S(t) && (r = t);
    let n = this.get("radius", 0), a = this.get("innerRadius", 0), o = this.get("dRadius", 0), l = this.get("dInnerRadius", 0);
    return n += o, a += l, a < 0 && (a = n + a), e instanceof ae && (s = this.ix * (a + (n - a) * e.value)), t instanceof ae && (r = this.iy * (a + (n - a) * t.value)), this.get("arc") >= 360 && a == 0 && (s = 0, r = 0), { x: s, y: r };
  }
  _beforeChanged() {
    super._beforeChanged(), (this.isDirty("radius") || this.isDirty("arc") || this.isDirty("innerRadius") || this.isDirty("startAngle") || this.isDirty("dRadius") || this.isDirty("dInnerRadius") || this.isDirty("cornerRadius")) && (this._clear = !0);
  }
  _changed() {
    if (super._changed(), this._clear) {
      let e = this.get("startAngle", 0), t = this.get("arc", 0);
      const s = this._generator;
      t < 0 && (e = e + t, t = t * -1), t > 0.1 && s.cornerRadius(this.get("cornerRadius", 0)), s.context(this._display);
      let r = this.get("radius", 0), n = this.get("innerRadius", 0), a = this.get("dRadius", 0), o = this.get("dInnerRadius", 0);
      r += a, n += o, n < 0 && (n = r + n), s({ innerRadius: n, outerRadius: r, startAngle: (e + 90) * Os, endAngle: (e + t + 90) * Os });
      let l = e + t / 2;
      this.ix = pt(l), this.iy = it(l);
    }
    if (this.isDirty("shiftRadius")) {
      const e = this.get("shiftRadius", 0);
      this.setRaw("dx", this.ix * e), this.setRaw("dy", this.iy * e), this.markDirtyPosition();
    }
  }
}
Object.defineProperty(cn, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Slice"
});
Object.defineProperty(cn, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: ce.classNames.concat([cn.className])
});
class pr extends G {
  constructor() {
    super(...arguments), Object.defineProperty(this, "chartContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.children.push(G.new(this._root, { width: R, height: R, interactiveChildren: !1 }))
    }), Object.defineProperty(this, "bulletsContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: G.new(this._root, { interactiveChildren: !1, isMeasured: !1, position: "absolute", width: R, height: R })
    });
  }
}
Object.defineProperty(pr, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Chart"
});
Object.defineProperty(pr, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: G.classNames.concat([pr.className])
});
class ts extends pr {
  constructor() {
    super(...arguments), Object.defineProperty(this, "seriesContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: G.new(this._root, { width: R, height: R, isMeasured: !1 })
    }), Object.defineProperty(this, "series", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new Oa()
    });
  }
  _afterNew() {
    super._afterNew(), this._disposers.push(this.series);
    const e = this.seriesContainer.children;
    this._disposers.push(this.series.events.onAll((t) => {
      if (t.type === "clear") {
        w(t.oldValues, (r) => {
          this._removeSeries(r);
        });
        const s = this.get("colors");
        s && s.reset();
      } else if (t.type === "push")
        e.moveValue(t.newValue), this._processSeries(t.newValue);
      else if (t.type === "setIndex")
        e.setIndex(t.index, t.newValue), this._processSeries(t.newValue);
      else if (t.type === "insertIndex")
        e.insertIndex(t.index, t.newValue), this._processSeries(t.newValue);
      else if (t.type === "removeIndex")
        this._removeSeries(t.oldValue);
      else if (t.type === "moveIndex")
        e.moveValue(t.value, t.newIndex), this._processSeries(t.value);
      else
        throw new Error("Unknown IListEvent type");
    }));
  }
  _processSeries(e) {
    e.chart = this, e._placeBulletsContainer(this);
  }
  _removeSeries(e) {
    e.isDisposed() || (this.seriesContainer.children.removeValue(e), e._removeBulletsContainer());
  }
}
Object.defineProperty(ts, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "SerialChart"
});
Object.defineProperty(ts, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: pr.classNames.concat([ts.className])
});
class Es extends fr {
}
Object.defineProperty(Es, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Tick"
});
Object.defineProperty(Es, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: fr.classNames.concat([Es.className])
});
class Va extends Ji {
  /**
   * @ignore
   */
  getFill(e) {
    const t = this.getBounds(e);
    let s = 0, r = 0, n = t.left || 0, a = t.right || 0, o = t.top || 0, l = t.bottom || 0;
    const u = a - n, h = l - o;
    let c = e.get("radius");
    S(c) ? (s = 0, r = 0) : (c = Math.min(u, h) / 2, s = u / 2, r = h / 2);
    let f = this.get("x"), d = this.get("y");
    f != null && (s = Te(f, u)), d != null && (r = Te(d, h));
    const g = this._root._renderer.createRadialGradient(s, r, 0, s, r, c), p = this.get("stops");
    if (p) {
      let _ = 0;
      w(p, (m) => {
        let v = m.offset;
        S(v) || (v = _ / (p.length - 1));
        let b = m.opacity;
        S(b) || (b = 1);
        let y = m.color;
        if (y) {
          const x = m.lighten;
          x && (y = V.lighten(y, x));
          const D = m.brighten;
          D && (y = V.brighten(y, D)), g.addColorStop(v, "rgba(" + y.r + "," + y.g + "," + y.b + "," + b + ")");
        }
        _++;
      });
    }
    return g;
  }
}
Object.defineProperty(Va, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "RadialGradient"
});
Object.defineProperty(Va, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Ji.classNames.concat([Va.className])
});
class Xa extends Pt {
  _beforeChanged() {
    super._beforeChanged(), this.isDirty("gap") && (this._clear = !0);
  }
  _draw() {
    super._draw();
    const e = this.get("checkered", !1), t = this.get("centered", !0), s = this.get("gap", 0), r = this.get("rotation", 0);
    let n = this.get("width", 100), a = this.get("height", 100), o = this.get("radius", 3), l = o * 2 + s, u = o * 2 + s, h = Math.round(n / l), c = Math.round(a / u);
    l = n / h, u = a / c, r != 0 && (this._display.x = l * pt(r), this._display.y = u * it(r));
    const f = this.get("color"), d = this.get("colorOpacity");
    (f || d) && this._display.beginFill(f, d);
    for (let g = r == 0 ? 0 : -c * 2; g < c * 2; g++)
      for (let p = r == 0 ? 0 : -h * 2; p < h * 2; p++)
        if (!e || (g & 1) != 1 && (p & 1) != 1 || (g & 1) == 1 && (p & 1) == 1) {
          let _ = p * l, m = g * u;
          t && (_ += l + s / 2, m += u + s / 2), this._display.drawCircle(_ - o, m - o, o);
        }
    e ? (n = n / 2 - s * 2, a = a / 2 - s * 2) : (n -= s, a -= s), (f || d) && this._display.endFill();
  }
}
Object.defineProperty(Xa, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "CirclePattern"
});
Object.defineProperty(Xa, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Pt.classNames.concat([Xa.className])
});
class Wa extends Pt {
  _beforeChanged() {
    super._beforeChanged(), this.isDirty("gap") && (this._clear = !0);
  }
  _draw() {
    super._draw();
    const e = this.get("width", 100), t = this.get("height", 100), s = this.get("gap", 0), r = this.get("strokeWidth", 1);
    if (!s)
      this._display.moveTo(0, 0), this._display.lineTo(e, 0);
    else {
      let o = s + r, l = t / o;
      for (let u = -l; u < l * 2; u++) {
        const h = Math.round(u * o - o / 2) + 0.5;
        this._display.moveTo(-e, h), this._display.lineTo(e * 2, h);
      }
    }
    this._display.lineStyle(r, this.get("color"), this.get("colorOpacity"));
    let n = this.get("strokeDasharray");
    S(n) && (n < 0.5 ? n = [0] : n = [n]), this._display.setLineDash(n);
    const a = this.get("strokeDashoffset");
    a && this._display.setLineDashOffset(a), this._display.endStroke();
  }
}
Object.defineProperty(Wa, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "LinePattern"
});
Object.defineProperty(Wa, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Pt.classNames.concat([Wa.className])
});
class Ua extends Pt {
  _beforeChanged() {
    super._beforeChanged(), this.isDirty("gap") && (this._clear = !0);
  }
  _draw() {
    super._draw();
    const e = this.get("checkered", !1), t = this.get("centered", !0), s = this.get("gap", 0), r = this.get("rotation", 0);
    let n = this.get("width", 100), a = this.get("height", 100), o = this.get("maxWidth", 5), l = this.get("maxHeight", 5), u = o + s, h = l + s, c = Math.round(n / u), f = Math.round(a / h);
    u = n / c, h = a / f, r != 0 && (this._display.x = u / 2 * pt(r), this._display.y = -h / 2 * it(r));
    for (let p = r == 0 ? 0 : -f * 2; p < f * 2; p++)
      for (let _ = r == 0 ? 0 : -c * 2; _ < c * 2; _++)
        if (!e || (p & 1) != 1 && (_ & 1) != 1 || (p & 1) == 1 && (_ & 1) == 1) {
          let m = _ * u, v = p * h;
          t && (m += (u - o) / 2, v += (h - l) / 2), this._display.drawRect(m, v, o, l);
        }
    e ? (n = n / 2 - s * 2, a = a / 2 - s * 2) : (n -= s, a -= s);
    const d = this.get("color"), g = this.get("colorOpacity");
    (d || g) && (this._display.beginFill(d, g), this._display.endFill());
  }
}
Object.defineProperty(Ua, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "RectanglePattern"
});
Object.defineProperty(Ua, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Pt.classNames.concat([Ua.className])
});
class Ga extends Pt {
  _beforeChanged() {
    super._beforeChanged(), this.isDirty("svgPath") && (this._clear = !0);
  }
  _draw() {
    super._draw();
    const e = this.get("svgPath");
    e != null && this._display.svgPath(e);
    const t = this.get("color"), s = this.get("colorOpacity");
    (t || s) && (this._display.beginFill(t, s), this._display.endFill());
  }
}
Object.defineProperty(Ga, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "PathPattern"
});
Object.defineProperty(Ga, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Pt.classNames.concat([Ga.className])
});
class Rs extends Oe {
  //protected _currentPass: number = 0;
  _afterNew() {
    super._afterNewApplyThemes(), this._dirty.colors = !1;
  }
  _beforeChanged() {
    this.isDirty("colors") && this.reset();
  }
  /**
   * @ignore
   */
  generateColors() {
    this.setPrivate("currentPass", this.getPrivate("currentPass", 0) + 1);
    const e = this.getPrivate("currentPass"), t = this.get("colors", [this.get("baseColor", V.fromHex(16711680))]);
    this.getPrivate("numColors") || this.setPrivate("numColors", t.length);
    const s = this.getPrivate("numColors"), r = 0, n = this.get("passOptions"), a = this.get("reuse");
    for (let o = r; o < s; o++)
      if (a)
        t.push(t[o]);
      else {
        const l = t[o].toHSL();
        let u = l.h + (n.hue || 0) * e;
        for (; u > 1; )
          u -= 1;
        let h = l.s + (n.saturation || 0) * e;
        h > 1 && (h = 1), h < 0 && (h = 0);
        let c = l.l + (n.lightness || 0) * e;
        for (; c > 1; )
          c -= 1;
        t.push(V.fromHSL(u, h, c));
      }
  }
  /**
   * Returns a [[Color]] at specific index.
   *
   * If there's no color at this index, a new color is generated.
   *
   * @param   index  Index
   * @return         Color
   */
  getIndex(e) {
    const t = this.get("colors", []), s = this.get("saturation");
    return e >= t.length ? (this.generateColors(), this.getIndex(e)) : s != null ? V.saturate(t[e], s) : t[e];
  }
  /**
   * Returns next [[Color]] in the list.
   *
   * If the list is out of colors, new ones are generated dynamically.
   */
  next() {
    let e = this.getPrivate("currentStep", this.get("startIndex", 0));
    return this.setPrivate("currentStep", e + this.get("step", 1)), this.getIndex(e);
  }
  /**
   * Resets counter to the start of the list, so the next call for `next()` will
   * return the first color.
   */
  reset() {
    this.setPrivate("currentStep", this.get("startIndex", 0)), this.setPrivate("currentPass", 0);
  }
}
Object.defineProperty(Rs, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "ColorSet"
});
Object.defineProperty(Rs, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Oe.classNames.concat([Rs.className])
});
class PP {
  /**
   * Parses JSON string.
   *
   * @param   input    JSON
   * @param   options  Options
   * @return           Data
   */
  static parse(e, t) {
    t = this._applyDefaults(t);
    try {
      if (Gi(e)) {
        let s = JSON.parse(e);
        return t.reverse && Ca(s) && s.reverse(), s;
      } else {
        if (Ca(e) || Ys(e))
          return e;
        throw "Unable to parse JSON data";
      }
    } catch {
      return;
    }
  }
  static _applyDefaults(e) {
    const t = {}, s = {
      reverse: !1
    };
    return e || (e = {}), ye(s, (r, n) => {
      t[r] = e[r] || n;
    }), t;
  }
}
class OP {
  /**
   * Parses CSV string.
   *
   * @param   input    CSV
   * @param   options  Options
   * @return           Data
   */
  static parse(e, t) {
    t = this._applyDefaults(t);
    let s = this.CSVToArray(e, t.delimiter), r = [], n = [], a, o;
    for (o = 0; o < t.skipRows; o++)
      s.shift();
    if (t.useColumnNames) {
      n = s.shift();
      for (let u = 0; u < n.length; u++)
        a = n[u] != null ? n[u].replace(/^\s+|\s+$/gm, "") : "", a === "" && (a = "col" + u), n[u] = a;
    }
    let l;
    for (; l = t.reverse ? s.pop() : s.shift(), !!l; ) {
      if (t.skipEmpty && l.length === 1 && l[0] === "")
        continue;
      let u = {};
      for (o = 0; o < l.length; o++)
        a = n[o] === void 0 ? "col" + o : n[o], u[a] = l[o];
      r.push(u);
    }
    return r;
  }
  /**
   * @ignore
   */
  static CSVToArray(e, t) {
    t = t || ",";
    let s = new RegExp(
      // Delimiters.
      "(\\" + t + '|\\r?\\n|\\r|^)(?:"([^"]*(?:""[^"]*)*)"|([^"\\' + t + "\\r\\n]*))",
      "gi"
    ), r = [
      []
    ], n = null;
    for (; n = s.exec(e), !!n; ) {
      let a = n[1];
      a.length && a !== t && r.push([]);
      let o;
      n[2] ? o = n[2].replace(new RegExp('""', "g"), '"') : o = n[3], r[r.length - 1].push(o);
    }
    return r;
  }
  static _applyDefaults(e) {
    const t = {}, s = {
      delimiter: ",",
      reverse: !1,
      skipRows: 0,
      skipEmpty: !0,
      useColumnNames: !1
    };
    return e || (e = {}), ye(s, (r, n) => {
      t[r] = e[r] || n;
    }), t;
  }
}
class MP extends Oe {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_checkDates", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_checkNumbers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_checkColors", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_checkEmpty", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_checkDeep", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    });
  }
  _afterNew() {
    super._afterNew(), this._checkFeatures(), this.on("dateFields", () => this._checkFeatures()), this.on("dateFormat", () => this._checkFeatures()), this.on("numericFields", () => this._checkFeatures()), this.on("colorFields", () => this._checkFeatures()), this.on("emptyAs", () => this._checkFeatures());
  }
  _checkFeatures() {
    (this.isDirty("dateFields") || this.isDirty("dateFormat")) && (this._checkDates = this.get("dateFields") && this.get("dateFields").length > 0), this.isDirty("numericFields") && (this._checkNumbers = this.get("numericFields") && this.get("numericFields").length > 0), this.isDirty("colorFields") && (this._checkColors = this.get("colorFields") && this.get("colorFields").length > 0), this.isDirty("emptyAs") && (this._checkEmpty = this.get("emptyAs") != null), this._checkDeepFeatures();
  }
  _checkDeepFeatures() {
    const e = [];
    w(["dateFields", "numericFields", "colorFields"], (t) => {
      w(this.get(t, []), (s) => {
        const r = s.split(".");
        for (r.pop(); r.length > 0; )
          e.push(r.join(".")), r.pop();
      });
    }), this._checkDeep = e.length > 0, this.setPrivate("deepFields", e);
  }
  /**
   * Processess entire array of data.
   *
   * NOTE: calling this will modify original array!
   */
  processMany(e) {
    Ca(e) && (this._checkDates || this._checkNumbers || this._checkColors || this._checkEmpty) && w(e, (t) => {
      this.processRow(t);
    });
  }
  /**
   * Processes a row (object) of data.
   *
   * NOTE: calling this will modify values of the original object!
   */
  processRow(e, t = "") {
    ye(e, (s, r) => {
      const n = t + s;
      this._checkEmpty && (e[s] = this._maybeToEmpty(e[s])), this._checkNumbers && (e[s] = this._maybeToNumber(n, e[s])), this._checkDates && (e[s] = this._maybeToDate(n, e[s])), this._checkColors && (e[s] = this._maybeToColor(n, e[s])), this._checkDeep && this.getPrivate("deepFields", []).indexOf(n) !== -1 && Ys(e[s]) && this.processRow(e[s], n + ".");
    });
  }
  _maybeToNumber(e, t) {
    return this.get("numericFields").indexOf(e) !== -1 ? yt(t) : t;
  }
  _maybeToDate(e, t) {
    return this.get("dateFields").indexOf(e) !== -1 ? this._root.dateFormatter.parse(t, this.get("dateFormat", "")).getTime() : t;
  }
  _maybeToEmpty(e) {
    return (e == null || e == "") && this.get("emptyAs") != null ? this.get("emptyAs") : e;
  }
  _maybeToColor(e, t) {
    return this.get("colorFields").indexOf(e) !== -1 ? V.fromAny(t) : t;
  }
}
class Za extends G {
  constructor() {
    super(...arguments), Object.defineProperty(this, "rectangle", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.children.push(gt.new(this._root, { themeTags: ["rectangle"], fillOpacity: 0, fill: K(16777215) }))
    }), Object.defineProperty(this, "gripL", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._createGrip("left")
    }), Object.defineProperty(this, "gripR", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._createGrip("right")
    }), Object.defineProperty(this, "gripT", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._createGrip("top")
    }), Object.defineProperty(this, "gripB", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._createGrip("bottom")
    }), Object.defineProperty(this, "_is", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), Object.defineProperty(this, "_ix", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_iw", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_positionDP", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_isHover", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    });
  }
  _afterNew() {
    super._afterNew(), this.addTag("resizer"), this.set("visible", !1), this.gripL.events.on("dragged", (e) => {
      this._resize(e.target, -1);
    }), this.gripR.events.on("dragged", (e) => {
      this._resize(e.target, 1);
    }), this.gripL.events.on("dragstart", (e) => {
      this._resizeStart(e.target);
    }), this.gripR.events.on("dragstart", (e) => {
      this._resizeStart(e.target);
    }), this.gripT.events.on("dragged", (e) => {
      this._rotate(e, 90);
    }), this.gripB.events.on("dragged", (e) => {
      this._rotate(e, -90);
    }), this.gripT.events.on("dragstart", (e) => {
      this._resizeStart(e.target);
    }), this.gripB.events.on("dragstart", (e) => {
      this._resizeStart(e.target);
    });
  }
  _resizeStart(e) {
    const t = this.get("sprite");
    t && (this._is = t.get("scale", 1), this._ix = e.x(), this._iw = this.width() / 2);
  }
  _resize(e, t) {
    const s = this.get("sprite"), r = this.get("spriteTemplate");
    if (s) {
      const n = Math.max(0.01, this._is * (1 + t * (e.x() - this._ix) / this._iw));
      r ? r.set("scale", n) : s.set("scale", n), s.states.lookup("default").set("scale", n), this._updatePositions();
    }
  }
  _rotate(e, t) {
    const s = this.get("sprite"), r = this.get("spriteTemplate");
    if (s) {
      const n = this.parent;
      if (n) {
        const a = this.get("rotationStep", 10);
        let o = Math.round((op({ x: this.x(), y: this.y() }, n.toLocal(e.point)) + t) / a) * a;
        r ? r.set("rotation", o) : s.set("rotation", o), s.states.lookup("default").set("rotation", o), this._updatePositions();
      }
    }
  }
  _createGrip(e) {
    const t = this.children.push(G.new(this._root, {
      themeTags: ["grip", e],
      setStateOnChildren: !0,
      draggable: !0
    }));
    return t.children.push(Pe.new(this._root, {
      themeTags: ["outline"],
      centerX: le,
      centerY: le
    })), t.children.push(Pe.new(this._root, {
      centerX: le,
      centerY: le
    })), t;
  }
  _updateChildren() {
    if (super._updateChildren(), this.isDirty("sprite")) {
      const e = this.get("sprite");
      if (e) {
        this.show(0), this.setPrivate("visible", !0), this._updatePositions();
        const t = e.parent;
        t && t.children.moveValue(this, 0), this._positionDP = e.events.on("positionchanged", () => {
          this._updatePositions();
        });
      } else
        this.hide(0), this.setPrivate("visible", !1), this._positionDP && this._positionDP.dispose();
    }
    (this.isDirty("width") || this.isDirty("height") || this.isDirty("rotation")) && this._updatePositions();
  }
  _updatePositions() {
    const e = this.get("sprite");
    if (e) {
      let t = e.localBounds(), s = e.get("scale", 1), r = 20, n = (t.right - t.left) * s + r, a = (t.bottom - t.top) * s + r, o = e.get("rotation", 0);
      const l = this.rectangle;
      let u = e.get("centerX", le), h = e.get("centerY", le), c = 0;
      u instanceof ae && (c = u.value);
      let f = 0;
      h instanceof ae && (f = h.value), l.setAll({ centerX: u, centerY: h, width: n, height: a }), this.setAll({ x: e.x() + r * (c - 0.5) * pt(o) - r * (f - 0.5) * it(o), y: e.y() + r * (f - 0.5) * pt(o) + r * (c - 0.5) * it(o), width: n, height: a, rotation: o }), this.gripT.setAll({ x: (0.5 - c) * n, y: -f * a }), this.gripB.setAll({ x: (0.5 - c) * n, y: (1 - f) * a }), this.gripL.setAll({ x: -c * n, y: (0.5 - f) * a }), this.gripR.setAll({ x: (1 - c) * n, y: (0.5 - f) * a }), this.rectangle.setAll({ width: n, height: a });
    }
  }
}
Object.defineProperty(Za, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "SpriteResizer"
});
Object.defineProperty(Za, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: G.classNames.concat([Za.className])
});
function AP(i, e, t) {
  return new Promise((s, r) => {
    let n = t != null && t.responseType == "blob", a = new XMLHttpRequest();
    if (a.onload = () => {
      if (a.status === 200) {
        let o, l;
        if (n) {
          l = a.response, jp(l).then((h) => {
            let c = {
              xhr: a,
              error: !1,
              response: h,
              blob: l,
              type: a.getResponseHeader("Content-Type"),
              target: e
            };
            s(c);
          });
          return;
        } else
          o = a.responseText || a.response;
        let u = {
          xhr: a,
          error: !1,
          response: o,
          blob: l,
          type: a.getResponseHeader("Content-Type"),
          target: e
        };
        s(u);
      } else
        r({
          xhr: a,
          error: !0,
          type: a.getResponseHeader("Content-Type"),
          target: e
        });
    }, a.onerror = () => {
      r({
        xhr: a,
        error: !0,
        type: a.getResponseHeader("Content-Type"),
        target: e
      });
    }, a.open("GET", i, !0), t && t.withCredentials && (a.withCredentials = !0), t != null) {
      if (t.requestHeaders != null)
        for (let o = 0; o < t.requestHeaders.length; o++) {
          let l = t.requestHeaders[o];
          a.setRequestHeader(l.key, l.value);
        }
      t.responseType != null && (a.responseType = t.responseType);
    }
    a.send();
  });
}
function jp(i) {
  return new Promise((e, t) => {
    const s = new FileReader();
    s.onload = (r) => {
      e(s.result);
    }, s.onerror = (r) => {
      t(r);
    }, s.readAsText(i);
  });
}
const LP = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  load: AP,
  readBlob: jp
}, Symbol.toStringTag, { value: "Module" })), ar = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ArrayDisposer: Lf,
  Bullet: oi,
  Button: hr,
  CSVParser: OP,
  Chart: pr,
  Circle: li,
  CirclePattern: Xa,
  Color: V,
  ColorSet: Rs,
  Component: Qi,
  Container: G,
  CounterDisposer: To,
  DataItem: ti,
  DataProcessor: MP,
  DateFormatter: mp,
  Disposer: Ge,
  DurationFormatter: bp,
  Ellipse: $a,
  Entity: Oe,
  Gradient: Ji,
  Graphics: ce,
  GridLayout: Ki,
  HeatLegend: Fa,
  HorizontalLayout: As,
  InterfaceColors: an,
  JSONParser: PP,
  JsonData: cP,
  Label: Je,
  Layout: fi,
  Legend: js,
  Line: fr,
  LinePattern: Wa,
  LinearGradient: on,
  ListData: xp,
  Modal: Ea,
  MultiDisposer: ut,
  MutableValueDisposer: mT,
  NumberFormatter: pp,
  PathPattern: Ga,
  Pattern: Pt,
  Percent: ae,
  Picture: Ya,
  PicturePattern: cr,
  PointedRectangle: Ps,
  Polygon: Ra,
  RadialGradient: Va,
  RadialLabel: Is,
  RadialText: ln,
  Rectangle: gt,
  RectanglePattern: Ua,
  Root: Or,
  RoundedRectangle: Pe,
  Scrollbar: es,
  SerialChart: ts,
  Series: gi,
  Slice: cn,
  Slider: Ha,
  Sprite: kt,
  SpriteResizer: Za,
  Star: Na,
  Template: be,
  Text: qi,
  TextFormatter: Ht,
  Theme: Bs,
  Tick: Es,
  Timezone: _p,
  Tooltip: pi,
  Triangle: Ba,
  VerticalLayout: Ls,
  addLicense: Mo,
  array: _T,
  color: K,
  disposeAllRootElements: _k,
  ease: dk,
  math: XT,
  net: LP,
  object: wT,
  p0: yT,
  p100: R,
  p50: le,
  percent: de,
  ready: Ef,
  registry: Rt,
  time: fP,
  type: sT,
  utils: LT
}, Symbol.toStringTag, { value: "Module" }));
class Ip extends Bs {
  setupDefaultRules() {
    super.setupDefaultRules();
    const e = this._root.interfaceColors, t = this._root.language, s = this.rule.bind(this);
    s("XYChart").setAll({
      colors: Rs.new(this._root, {}),
      paddingLeft: 20,
      paddingRight: 20,
      paddingTop: 16,
      paddingBottom: 16,
      panX: !1,
      panY: !1,
      wheelStep: 0.25,
      arrangeTooltips: !0,
      pinchZoomX: !1,
      pinchZoomY: !1
    }), s("XYSeries").setAll({
      legendLabelText: "{name}"
    }), s("XYChart", ["scrollbar", "chart"]).setAll({
      paddingBottom: 0,
      paddingLeft: 0,
      paddingTop: 0,
      paddingRight: 0,
      colors: Rs.new(this._root, {
        saturation: 0
      })
    });
    {
      const l = s("Graphics", ["scrollbar", "overlay"]);
      l.setAll({
        fillOpacity: 0.5
      }), Q(l, "fill", e, "background");
    }
    s("RoundedRectangle", ["xy", "scrollbar", "thumb"]).setAll({
      cornerRadiusTR: 0,
      cornerRadiusTL: 0,
      cornerRadiusBR: 0,
      cornerRadiusBL: 0,
      fillOpacity: 0,
      focusable: !0
    }), s("RoundedRectangle", ["xy", "scrollbar", "thumb"]).states.create("hover", { fillOpacity: 0.4 }), s("RoundedRectangle", ["xy", "scrollbar", "chart", "background"]).setAll({
      cornerRadiusTL: 0,
      cornerRadiusBL: 0,
      cornerRadiusTR: 0,
      cornerRadiusBR: 0
    }), s("RoundedRectangle", ["xy", "scrollbar", "chart", "background", "resize", "button"]).setAll({
      cornerRadiusBL: 40,
      cornerRadiusBR: 40,
      cornerRadiusTL: 40,
      cornerRadiusTR: 40
    }), s("AxisRendererX", ["xy", "chart", "scrollbar"]).setAll({
      strokeOpacity: 0,
      inside: !0
    }), s("AxisRendererY", ["xy", "chart", "scrollbar"]).setAll({
      strokeOpacity: 0,
      inside: !0,
      minGridDistance: 5
    }), s("AxisLabel", ["xy", "scrollbar", "x"]).setAll({
      opacity: 0.5,
      centerY: R,
      minPosition: 0.01,
      maxPosition: 0.99,
      fontSize: "0.8em"
    }), s("AxisLabel", ["category"]).setAll({
      text: "{category}",
      populateText: !0
    }), s("AxisLabel", ["x"]).setAll({
      centerY: 0
    }), s("AxisLabel", ["x", "inside"]).setAll({
      centerY: R
    }), s("AxisLabel", ["x", "inside", "opposite"]).setAll({
      centerY: 0
    }), s("AxisLabel", ["x", "opposite"]).setAll({
      centerY: R
    }), s("AxisLabel", ["y"]).setAll({
      centerX: R
    }), s("AxisLabel", ["y", "inside"]).setAll({
      centerX: 0
    }), s("AxisLabel", ["y", "inside", "opposite"]).setAll({
      centerX: R
    }), s("AxisLabel", ["y", "opposite"]).setAll({
      centerX: 0
    }), s("AxisLabel", ["xy", "scrollbar", "y"]).setAll({
      visible: !1
    }), s("Grid", ["xy", "scrollbar", "y"]).setAll({
      visible: !1
    }), s("Grid", ["xy", "scrollbar", "x"]).setAll({
      opacity: 0.5
    }), s("XYCursor").setAll({
      behavior: "none",
      layer: 30,
      exportable: !1,
      snapToSeriesBy: "xy",
      moveThreshold: 1
    });
    {
      const l = s("Grid", ["cursor", "x"]);
      l.setAll({
        strokeOpacity: 0.8,
        strokeDasharray: [2, 2],
        ariaLabel: t.translate("Use left and right arrows to move selection")
      }), Q(l, "stroke", e, "alternativeBackground");
    }
    {
      const l = s("Grid", ["cursor", "y"]);
      l.setAll({
        strokeOpacity: 0.8,
        strokeDasharray: [2, 2],
        ariaLabel: t.translate("Use up and down arrows to move selection")
      }), Q(l, "stroke", e, "alternativeBackground");
    }
    {
      const l = s("Graphics", ["cursor", "selection"]);
      l.setAll({
        fillOpacity: 0.15
      }), Q(l, "fill", e, "alternativeBackground");
    }
    s("Axis").setAll({
      start: 0,
      end: 1,
      minZoomCount: 1,
      maxZoomCount: 1 / 0,
      maxZoomFactor: 1e3,
      maxDeviation: 0.1,
      snapTooltip: !0,
      tooltipLocation: 0.5,
      panX: !0,
      panY: !0,
      zoomX: !0,
      zoomY: !0,
      fixAxisSize: !0
    }), s("AxisLabel").setAll({
      location: 0.5,
      multiLocation: 0,
      centerX: le,
      centerY: le,
      paddingTop: 3,
      paddingBottom: 3,
      paddingLeft: 5,
      paddingRight: 5
    }), s("Container", ["axis", "header"]).setAll({
      layer: 30
    }), s("Rectangle", ["axis", "header", "background"]).setAll({
      crisp: !0
    });
    {
      const l = s("AxisRenderer");
      l.setAll({
        crisp: !0,
        strokeOpacity: 0
      }), Q(l, "stroke", e, "grid");
    }
    s("AxisRendererX").setAll({
      minGridDistance: 120,
      opposite: !1,
      inversed: !1,
      cellStartLocation: 0,
      cellEndLocation: 1,
      width: R
    }), s("AxisRendererY").setAll({
      minGridDistance: 40,
      opposite: !1,
      inversed: !1,
      cellStartLocation: 0,
      cellEndLocation: 1,
      height: R
    });
    {
      const l = s("Rectangle", ["axis", "thumb"]);
      l.setAll({
        fillOpacity: 0
      }), Q(l, "fill", e, "alternativeBackground"), l.states.create("hover", { fillOpacity: 0.1 });
    }
    s("Rectangle", ["axis", "thumb", "x"]).setAll({
      cursorOverStyle: "ew-resize"
    }), s("Rectangle", ["axis", "thumb", "y"]).setAll({
      cursorOverStyle: "ns-resize"
    });
    {
      const l = s("Grid");
      l.setAll({
        location: 0,
        strokeOpacity: 0.15,
        crisp: !0
      }), Q(l, "stroke", e, "grid");
    }
    s("Grid", ["base"]).setAll({
      strokeOpacity: 0.3
    });
    {
      const l = s("Graphics", ["axis", "fill"]);
      l.setAll({
        visible: !1,
        isMeasured: !1,
        position: "absolute",
        fillOpacity: 0.05
      }), Q(l, "fill", e, "alternativeBackground");
    }
    s("Graphics", ["axis", "fill", "range"]).setAll({
      isMeasured: !0
    }), s("Graphics", ["series", "fill", "range"]).setAll({
      visible: !1,
      isMeasured: !0
    }), s("Grid", ["series", "range"]).setAll({
      visible: !1
    }), s("AxisTick", ["series", "range"]).setAll({
      visible: !1
    }), s("AxisLabel", ["series", "range"]).setAll({
      visible: !1
    });
    {
      const l = s("AxisTick");
      l.setAll({
        location: 0.5,
        multiLocation: 0,
        strokeOpacity: 1,
        isMeasured: !1,
        position: "absolute",
        visible: !1
      }), Q(l, "stroke", e, "grid");
    }
    s("CategoryAxis").setAll({
      startLocation: 0,
      endLocation: 1,
      fillRule: (l, u) => {
        const h = l.get("axisFill");
        h && (!S(u) || u % 2 == 0 ? h.setPrivate("visible", !0) : h.setPrivate("visible", !1));
      }
    });
    const r = [
      { timeUnit: "millisecond", count: 1 },
      { timeUnit: "millisecond", count: 5 },
      { timeUnit: "millisecond", count: 10 },
      { timeUnit: "millisecond", count: 50 },
      { timeUnit: "millisecond", count: 100 },
      { timeUnit: "millisecond", count: 500 },
      { timeUnit: "second", count: 1 },
      { timeUnit: "second", count: 5 },
      { timeUnit: "second", count: 10 },
      { timeUnit: "second", count: 30 },
      { timeUnit: "minute", count: 1 },
      { timeUnit: "minute", count: 5 },
      { timeUnit: "minute", count: 10 },
      { timeUnit: "minute", count: 15 },
      { timeUnit: "minute", count: 30 },
      { timeUnit: "hour", count: 1 },
      { timeUnit: "hour", count: 3 },
      { timeUnit: "hour", count: 6 },
      { timeUnit: "hour", count: 12 },
      { timeUnit: "day", count: 1 },
      { timeUnit: "day", count: 2 },
      { timeUnit: "day", count: 3 },
      { timeUnit: "day", count: 4 },
      { timeUnit: "day", count: 5 },
      { timeUnit: "week", count: 1 },
      { timeUnit: "month", count: 1 },
      { timeUnit: "month", count: 2 },
      { timeUnit: "month", count: 3 },
      { timeUnit: "month", count: 6 },
      { timeUnit: "year", count: 1 },
      { timeUnit: "year", count: 2 },
      { timeUnit: "year", count: 5 },
      { timeUnit: "year", count: 10 },
      { timeUnit: "year", count: 50 },
      { timeUnit: "year", count: 100 },
      { timeUnit: "year", count: 200 },
      { timeUnit: "year", count: 500 },
      { timeUnit: "year", count: 1e3 },
      { timeUnit: "year", count: 2e3 },
      { timeUnit: "year", count: 5e3 },
      { timeUnit: "year", count: 1e4 },
      { timeUnit: "year", count: 1e5 }
    ], n = {
      millisecond: t.translate("_date_millisecond"),
      second: t.translate("_date_second"),
      minute: t.translate("_date_minute"),
      hour: t.translate("_date_hour"),
      day: t.translate("_date_day"),
      week: t.translate("_date_day"),
      month: t.translate("_date_month"),
      year: t.translate("_date_year")
    }, a = {
      millisecond: t.translate("_date_millisecond"),
      second: t.translate("_date_second"),
      minute: t.translate("_date_minute"),
      hour: t.translate("_date_day"),
      day: t.translate("_date_day"),
      week: t.translate("_date_day"),
      month: t.translate("_date_month") + " " + t.translate("_date_year"),
      year: t.translate("_date_year")
    }, o = {
      millisecond: t.translate("_date_millisecond_full"),
      second: t.translate("_date_second_full"),
      minute: t.translate("_date_minute_full"),
      hour: t.translate("_date_hour_full"),
      day: t.translate("_date_day_full"),
      week: t.translate("_date_week_full"),
      month: t.translate("_date_month_full"),
      year: t.translate("_date_year")
    };
    s("CategoryDateAxis").setAll({
      markUnitChange: !0,
      gridIntervals: Hi(r),
      dateFormats: zi(n),
      periodChangeDateFormats: zi(a)
    }), s("DateAxis").setAll({
      maxZoomFactor: null,
      strictMinMax: !0,
      startLocation: 0,
      endLocation: 1,
      markUnitChange: !0,
      groupData: !1,
      groupCount: 500,
      gridIntervals: Hi(r),
      dateFormats: zi(n),
      periodChangeDateFormats: zi(a),
      tooltipDateFormats: o,
      groupIntervals: [
        { timeUnit: "millisecond", count: 1 },
        { timeUnit: "millisecond", count: 10 },
        { timeUnit: "millisecond", count: 100 },
        { timeUnit: "second", count: 1 },
        { timeUnit: "second", count: 10 },
        { timeUnit: "minute", count: 1 },
        { timeUnit: "minute", count: 10 },
        { timeUnit: "hour", count: 1 },
        { timeUnit: "day", count: 1 },
        { timeUnit: "week", count: 1 },
        { timeUnit: "month", count: 1 },
        { timeUnit: "year", count: 1 }
      ],
      fillRule: (l) => {
        const u = l.get("axisFill");
        if (u) {
          const h = l.component, c = l.get("value"), f = l.get("endValue"), d = h.intervalDuration(), g = h.getPrivate("baseInterval"), p = h.getPrivate("gridInterval", g);
          let _ = h.getPrivate("min", 0);
          if (_ = Ke(new Date(_), p.timeUnit, p.count, this._root.locale.firstDayOfWeek, this._root.utc, void 0, this._root.timezone).getTime(), c != null && f != null) {
            const m = Math.round(Math.round((c - _) / d)) / 2;
            m == Math.round(m) ? u.setPrivate("visible", !0) : u.setPrivate("visible", !1);
          }
        }
      }
    }), s("GaplessDateAxis").setAll({
      fillRule: (l) => {
        const u = l.get("axisFill");
        if (u) {
          const h = l.get("index");
          let c = !1;
          (!S(h) || h % 2 == 0) && (c = !0), u.setPrivate("visible", c);
        }
      }
    }), s("ValueAxis").setAll({
      baseValue: 0,
      logarithmic: !1,
      strictMinMax: !1,
      autoZoom: !0,
      fillRule: (l) => {
        const u = l.get("axisFill");
        if (u) {
          const h = l.component, c = l.get("value"), f = h.getPrivate("step");
          S(c) && S(f) && (rt(c / f / 2, 5) == Math.round(c / f / 2) ? u.setPrivate("visible", !1) : u.setPrivate("visible", !0));
        }
      }
    }), s("DurationAxis").setAll({
      baseUnit: "second"
    }), s("XYSeries").setAll({
      maskBullets: !0,
      stackToNegative: !0,
      locationX: 0.5,
      locationY: 0.5,
      snapTooltip: !1,
      openValueXGrouped: "open",
      openValueYGrouped: "open",
      valueXGrouped: "close",
      valueYGrouped: "close",
      seriesTooltipTarget: "series"
    }), s("BaseColumnSeries").setAll({
      adjustBulletPosition: !0
    }), s("ColumnSeries").setAll({
      clustered: !0
    }), s("RoundedRectangle", ["series", "column"]).setAll({
      position: "absolute",
      isMeasured: !1,
      width: de(70),
      height: de(70),
      strokeWidth: 1,
      strokeOpacity: 1,
      cornerRadiusBL: 0,
      cornerRadiusTL: 0,
      cornerRadiusBR: 0,
      cornerRadiusTR: 0,
      fillOpacity: 1,
      role: "figure"
    }), s("LineSeries").setAll({
      connect: !0,
      autoGapCount: 1.1,
      stackToNegative: !1
    }), s("Graphics", ["series", "stroke"]).setAll({
      position: "absolute",
      strokeWidth: 1,
      strokeOpacity: 1,
      isMeasured: !1
    }), s("Graphics", ["series", "fill"]).setAll({
      visible: !1,
      fillOpacity: 0,
      position: "absolute",
      strokeWidth: 0,
      strokeOpacity: 0,
      isMeasured: !1
    }), s("Graphics", ["line", "series", "legend", "marker", "stroke"]).setAll({
      draw: (l, u) => {
        const h = u.parent;
        if (h) {
          const c = h.height(), f = h.width();
          l.moveTo(0, c / 2), l.lineTo(f, c / 2);
        }
      }
    });
    {
      const l = s("Graphics", ["line", "series", "legend", "marker", "stroke"]).states.create("disabled", {});
      Q(l, "stroke", e, "disabled");
    }
    s("Graphics", ["line", "series", "legend", "marker", "fill"]).setAll({
      draw: (l, u) => {
        const h = u.parent;
        if (h) {
          const c = h.height(), f = h.width();
          l.moveTo(0, 0), l.lineTo(f, 0), l.lineTo(f, c), l.lineTo(0, c), l.lineTo(0, 0);
        }
      }
    });
    {
      const l = s("Graphics", ["line", "series", "legend", "marker", "fill"]).states.create("disabled", {});
      Q(l, "stroke", e, "disabled");
    }
    s("SmoothedXYLineSeries").setAll({
      tension: 0.5
    }), s("SmoothedXLineSeries").setAll({
      tension: 0.5
    }), s("SmoothedYLineSeries").setAll({
      tension: 0.5
    }), s("Candlestick").setAll({
      position: "absolute",
      isMeasured: !1,
      width: de(50),
      height: de(50),
      strokeWidth: 1,
      strokeOpacity: 1,
      cornerRadiusBL: 0,
      cornerRadiusTL: 0,
      cornerRadiusBR: 0,
      cornerRadiusTR: 0,
      fillOpacity: 1,
      role: "figure"
    }), s("OHLC").setAll({
      width: de(80),
      height: de(80)
    }), s("CandlestickSeries").setAll({
      lowValueXGrouped: "low",
      lowValueYGrouped: "low",
      highValueXGrouped: "high",
      highValueYGrouped: "high",
      openValueXGrouped: "open",
      openValueYGrouped: "open",
      valueXGrouped: "close",
      valueYGrouped: "close"
    });
    {
      const l = s("Rectangle", ["column", "autocolor"]).states.create("riseFromOpen", {});
      Q(l, "fill", e, "positive"), Q(l, "stroke", e, "positive");
    }
    {
      const l = s("Rectangle", ["column", "autocolor"]).states.create("dropFromOpen", {});
      Q(l, "fill", e, "negative"), Q(l, "stroke", e, "negative");
    }
    s("Rectangle", ["column", "autocolor", "pro"]).states.create("riseFromOpen", { fillOpacity: 0 }), s("Rectangle", ["column", "autocolor", "pro"]).states.create("dropFromOpen", { fillOpacity: 1 });
    {
      const l = s("Rectangle", ["column", "autocolor", "pro"]).states.create("riseFromPrevious", {});
      Q(l, "fill", e, "positive"), Q(l, "stroke", e, "positive");
    }
    {
      const l = s("Rectangle", ["column", "autocolor", "pro"]).states.create("dropFromPrevious", {});
      Q(l, "fill", e, "negative"), Q(l, "stroke", e, "negative");
    }
  }
}
let gr = class extends ts {
  constructor() {
    super(...arguments), Object.defineProperty(this, "xAxes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new Oa()
    }), Object.defineProperty(this, "yAxes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new Oa()
    }), Object.defineProperty(this, "topAxesContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.chartContainer.children.push(G.new(this._root, { width: R, layout: this._root.verticalLayout }))
    }), Object.defineProperty(this, "yAxesAndPlotContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.chartContainer.children.push(G.new(this._root, { width: R, height: R, layout: this._root.horizontalLayout }))
    }), Object.defineProperty(this, "bottomAxesContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.chartContainer.children.push(G.new(this._root, { width: R, layout: this._root.verticalLayout }))
    }), Object.defineProperty(this, "leftAxesContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.yAxesAndPlotContainer.children.push(G.new(this._root, { height: R, layout: this._root.horizontalLayout }))
    }), Object.defineProperty(this, "plotsContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.yAxesAndPlotContainer.children.push(G.new(this._root, { width: R, height: R, maskContent: !1 }))
    }), Object.defineProperty(this, "plotContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.plotsContainer.children.push(G.new(this._root, { width: R, height: R }))
    }), Object.defineProperty(this, "topPlotContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.plotsContainer.children.push(G.new(this._root, { width: R, height: R }))
    }), Object.defineProperty(this, "gridContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.plotContainer.children.push(G.new(this._root, { width: R, height: R, isMeasured: !1 }))
    }), Object.defineProperty(this, "topGridContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: G.new(this._root, { width: R, height: R, isMeasured: !1 })
    }), Object.defineProperty(this, "rightAxesContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.yAxesAndPlotContainer.children.push(G.new(this._root, { height: R, layout: this._root.horizontalLayout }))
    }), Object.defineProperty(this, "axisHeadersContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.plotContainer.children.push(G.new(this._root, {}))
    }), Object.defineProperty(this, "zoomOutButton", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.topPlotContainer.children.push(hr.new(this._root, {
        themeTags: ["zoom"],
        icon: ce.new(this._root, {
          themeTags: ["button", "icon"]
        })
      }))
    }), Object.defineProperty(this, "_movePoint", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: { x: 0, y: 0 }
    }), Object.defineProperty(this, "_wheelDp", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_otherCharts", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_movePoints", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_downStartX", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_downEndX", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_downStartY", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_downEndY", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  _afterNew() {
    this._defaultThemes.push(Ip.new(this._root)), super._afterNew(), this._disposers.push(this.xAxes), this._disposers.push(this.yAxes);
    const e = this._root;
    let t = this._root.verticalLayout;
    const s = this.zoomOutButton;
    s.events.on("click", () => {
      this.zoomOut();
    }), s.set("opacity", 0), s.states.lookup("default").set("opacity", 1), this.chartContainer.set("layout", t);
    const r = this.plotContainer;
    r.children.push(this.seriesContainer), this._disposers.push(this._processAxis(this.xAxes, this.bottomAxesContainer)), this._disposers.push(this._processAxis(this.yAxes, this.leftAxesContainer)), r.children.push(this.topGridContainer), r.children.push(this.bulletsContainer), r.set("interactive", !0), r.set("interactiveChildren", !1), r.set("background", gt.new(e, {
      themeTags: ["xy", "background"],
      fill: V.fromHex(0),
      fillOpacity: 0
    })), this._disposers.push(r.events.on("pointerdown", (n) => {
      this._handlePlotDown(n.originalEvent);
    })), this._disposers.push(r.events.on("globalpointerup", (n) => {
      this._handlePlotUp(n.originalEvent);
    })), this._disposers.push(r.events.on("globalpointermove", (n) => {
      this._handlePlotMove(n.originalEvent);
    })), this._maskGrid(), this._setUpTouch();
  }
  _beforeChanged() {
    super._beforeChanged(), (this.isDirty("pinchZoomX") || this.isDirty("pinchZoomY") || this.get("panX") || this.get("panY")) && this._setUpTouch();
  }
  _setUpTouch() {
    this.plotContainer._display.cancelTouch || (this.plotContainer._display.cancelTouch = !!(this.get("pinchZoomX") || this.get("pinchZoomY") || this.get("panX") || this.get("panY")));
  }
  _maskGrid() {
    this.gridContainer.set("maskContent", !0), this.topGridContainer.set("maskContent", !0);
  }
  _removeSeries(e) {
    e._unstack(), e._posXDp && e._posXDp.dispose(), e._posYDp && e._posYDp.dispose(), e.set("baseAxis", void 0);
    const t = e.get("xAxis");
    t && (St(t.series, e), t.markDirtyExtremes());
    const s = e.get("yAxis");
    s && (St(s.series, e), s.markDirtyExtremes());
    const r = this.get("cursor");
    if (r) {
      const n = r.get("snapToSeries");
      n && St(n, e);
    }
    super._removeSeries(e);
  }
  /**
   * This method is invoked when mouse wheel is used over chart's plot
   * container, and handles zooming/pan.
   *
   * You can invoke this method manually, if you need to mimic chart's wheel
   * behavior over other elements of the chart.
   */
  handleWheel(e) {
    const t = this.get("wheelX"), s = this.get("wheelY"), r = this.plotContainer, n = e.originalEvent;
    if (ko(n, this))
      n.preventDefault();
    else
      return;
    const a = r.toLocal(this._root.documentPointToRoot({ x: n.clientX, y: n.clientY })), o = this.get("wheelStep", 0.2), l = n.deltaY / 100, u = n.deltaX / 100, h = this.get("wheelZoomPositionX"), c = this.get("wheelZoomPositionY");
    (t === "zoomX" || t === "zoomXY") && u != 0 && this.xAxes.each((f) => {
      if (f.get("zoomX")) {
        let d = f.get("start"), g = f.get("end"), p = f.fixPosition(a.x / r.width());
        h != null && (p = h);
        let _ = d - o * (g - d) * u * p, m = g + o * (g - d) * u * (1 - p);
        1 / (m - _) < f.getPrivate("maxZoomFactor", 1 / 0) / f.get("minZoomCount", 1) && this._handleWheelAnimation(f.zoom(_, m));
      }
    }), (s === "zoomX" || s === "zoomXY") && l != 0 && this.xAxes.each((f) => {
      if (f.get("zoomX")) {
        let d = f.get("start"), g = f.get("end"), p = f.fixPosition(a.x / r.width());
        h != null && (p = h);
        let _ = d - o * (g - d) * l * p, m = g + o * (g - d) * l * (1 - p);
        1 / (m - _) < f.getPrivate("maxZoomFactor", 1 / 0) / f.get("minZoomCount", 1) && this._handleWheelAnimation(f.zoom(_, m));
      }
    }), (t === "zoomY" || t === "zoomXY") && u != 0 && this.yAxes.each((f) => {
      if (f.get("zoomY")) {
        let d = f.get("start"), g = f.get("end"), p = f.fixPosition(a.y / r.height());
        c != null && (p = c);
        let _ = d - o * (g - d) * u * p, m = g + o * (g - d) * u * (1 - p);
        1 / (m - _) < f.getPrivate("maxZoomFactor", 1 / 0) / f.get("minZoomCount", 1) && this._handleWheelAnimation(f.zoom(_, m));
      }
    }), (s === "zoomY" || s === "zoomXY") && l != 0 && this.yAxes.each((f) => {
      if (f.get("zoomY")) {
        let d = f.get("start"), g = f.get("end"), p = f.fixPosition(a.y / r.height());
        c != null && (p = c);
        let _ = d - o * (g - d) * l * p, m = g + o * (g - d) * l * (1 - p);
        1 / (m - _) < f.getPrivate("maxZoomFactor", 1 / 0) / f.get("minZoomCount", 1) && this._handleWheelAnimation(f.zoom(_, m));
      }
    }), (t === "panX" || t === "panXY") && u != 0 && this.xAxes.each((f) => {
      if (f.get("panX")) {
        let d = f.get("start"), g = f.get("end"), p = this._getWheelSign(f) * o * (g - d) * u, _ = d + p, m = g + p, v = this._fixWheel(_, m);
        _ = v[0], m = v[1], this._handleWheelAnimation(f.zoom(_, m));
      }
    }), (s === "panX" || s === "panXY") && l != 0 && this.xAxes.each((f) => {
      if (f.get("panX")) {
        let d = f.get("start"), g = f.get("end"), p = this._getWheelSign(f) * o * (g - d) * l, _ = d + p, m = g + p, v = this._fixWheel(_, m);
        _ = v[0], m = v[1], this._handleWheelAnimation(f.zoom(_, m));
      }
    }), (t === "panY" || t === "panXY") && u != 0 && this.yAxes.each((f) => {
      if (f.get("panY")) {
        let d = f.get("start"), g = f.get("end"), p = this._getWheelSign(f) * o * (g - d) * u, _ = d + p, m = g + p, v = this._fixWheel(_, m);
        _ = v[0], m = v[1], this._handleWheelAnimation(f.zoom(_, m));
      }
    }), (s === "panY" || s === "panXY") && l != 0 && this.yAxes.each((f) => {
      if (f.get("panY")) {
        let d = f.get("start"), g = f.get("end"), p = this._getWheelSign(f) * o * (g - d) * l, _ = d - p, m = g - p, v = this._fixWheel(_, m);
        _ = v[0], m = v[1], this._handleWheelAnimation(f.zoom(_, m));
      }
    });
  }
  _handleSetWheel() {
    const e = this.get("wheelX"), t = this.get("wheelY"), s = this.plotContainer;
    e !== "none" || t !== "none" ? (this._wheelDp = s.events.on("wheel", (r) => {
      this.handleWheel(r);
    }), this._disposers.push(this._wheelDp)) : this._wheelDp && this._wheelDp.dispose();
  }
  _getWheelSign(e) {
    let t = 1;
    return e.get("renderer").get("inversed") && (t = -1), t;
  }
  _fixWheel(e, t) {
    const s = t - e;
    return e < 0 && (e = 0, t = e + s), t > 1 && (t = 1, e = t - s), [e, t];
  }
  _handlePlotDown(e) {
    if (e.button == 2)
      return;
    const t = this.plotContainer;
    let s = t.toLocal(this._root.documentPointToRoot({ x: e.clientX, y: e.clientY }));
    if ((this.get("pinchZoomX") || this.get("pinchZoomY")) && e.pointerId && Ve(t._downPoints).length > 0) {
      const a = this.xAxes.getIndex(0), o = this.yAxes.getIndex(0);
      a && (this._downStartX = a.get("start", 0), this._downEndX = a.get("end", 1)), o && (this._downStartY = o.get("start", 0), this._downEndY = o.get("end", 1));
    }
    if ((this.get("panX") || this.get("panY")) && s.x >= 0 && s.y >= 0 && s.x <= t.width() && s.y <= this.height()) {
      this._downPoint = { x: e.clientX, y: e.clientY };
      const r = this.get("panX"), n = this.get("panY");
      r && this.xAxes.each((o) => {
        o._panStart = o.get("start"), o._panEnd = o.get("end");
      }), n && this.yAxes.each((o) => {
        o._panStart = o.get("start"), o._panEnd = o.get("end");
      });
      const a = "panstarted";
      this.events.isEnabled(a) && this.events.dispatch(a, { type: a, target: this, originalEvent: e });
    }
  }
  _handleWheelAnimation(e) {
    e ? e.events.on("stopped", () => {
      this._dispatchWheelAnimation();
    }) : this._dispatchWheelAnimation();
  }
  _dispatchWheelAnimation() {
    const e = "wheelended";
    this.events.isEnabled(e) && this.events.dispatch(e, { type: e, target: this });
  }
  _handlePlotUp(e) {
    const t = this._downPoint;
    if (t && (this.get("panX") || this.get("panY"))) {
      let s = this.plotContainer.toLocal(this._root.documentPointToRoot({ x: e.clientX, y: e.clientY }));
      if (s.x == t.x && s.y == t.y) {
        const n = "pancancelled";
        this.events.isEnabled(n) && this.events.dispatch(n, { type: n, target: this, originalEvent: e });
      }
      const r = "panended";
      this.events.isEnabled(r) && this.events.dispatch(r, { type: r, target: this, originalEvent: e });
    }
    this._downPoint = void 0, this.xAxes.each((s) => {
      s._isPanning = !1;
    }), this.yAxes.each((s) => {
      s._isPanning = !1;
    });
  }
  _handlePlotMove(e) {
    const t = this.plotContainer;
    if (this.get("pinchZoomX") || this.get("pinchZoomY")) {
      const n = e.pointerId;
      if (n && (this._movePoints[n] = this._root.documentPointToRoot({ x: e.clientX, y: e.clientY }), Ve(t._downPoints).length > 1)) {
        this._handlePinch();
        return;
      }
    }
    let s = this._downPoint;
    if (s) {
      s = t.toLocal(this._root.documentPointToRoot(s));
      let r = t.toLocal(this._root.documentPointToRoot({ x: e.clientX, y: e.clientY }));
      const n = this.get("panX"), a = this.get("panY");
      if (n) {
        let o = this.get("scrollbarX");
        o && o.events.disableType("rangechanged"), this.xAxes.each((l) => {
          if (l.get("panX")) {
            l._isPanning = !0;
            let u = l._panStart, h = l._panEnd, f = (h - u) * (s.x - r.x) / t.width();
            l.get("renderer").get("inversed") && (f *= -1);
            let d = u + f, g = h + f;
            g - d < 1 + l.get("maxDeviation", 1) * 2 && (l.set("start", d), l.set("end", g));
          }
        }), o && o.events.enableType("rangechanged");
      }
      if (a) {
        let o = this.get("scrollbarY");
        o && o.events.disableType("rangechanged"), this.yAxes.each((l) => {
          if (l.get("panY")) {
            l._isPanning = !0;
            let u = l._panStart, h = l._panEnd, f = (h - u) * (s.y - r.y) / t.height();
            l.get("renderer").get("inversed") && (f *= -1);
            let d = u - f, g = h - f;
            g - d < 1 + l.get("maxDeviation", 1) * 2 && (l.set("start", d), l.set("end", g));
          }
        }), o && o.events.enableType("rangechanged");
      }
    }
  }
  _handlePinch() {
    const e = this.plotContainer;
    let t = 0, s = [], r = [];
    if (ye(e._downPoints, (n, a) => {
      s[t] = a;
      let o = this._movePoints[n];
      o && (r[t] = o), t++;
    }), s.length > 1 && r.length > 1) {
      const n = e.width(), a = e.height();
      let o = s[0], l = s[1], u = r[0], h = r[1];
      if (o && l && u && h) {
        if (u = e.toLocal(u), h = e.toLocal(h), o = e.toLocal(o), l = e.toLocal(l), this.get("pinchZoomX")) {
          const c = this._downStartX, f = this._downEndX;
          if (c != null && f != null) {
            o.x > l.x && ([o, l] = [l, o], [u, h] = [h, u]);
            let d = c + o.x / n * (f - c), g = c + l.x / n * (f - c), p = c + u.x / n * (f - c), _ = c + h.x / n * (f - c), m = Math.max(1e-3, g - d), v = Math.max(1e-3, _ - p), b = m / v, y = c * b + d - p * b, x = f * b + g - _ * b;
            this.xAxes.each((D) => {
              let A = D.fixPosition(y), C = D.fixPosition(x);
              D.zoom(A, C, 0);
            });
          }
        }
        if (this.get("pinchZoomY")) {
          const c = this._downStartY, f = this._downEndY;
          if (c != null && f != null) {
            o.y < l.y && ([o, l] = [l, o], [u, h] = [h, u]);
            let d = c + (1 - o.y / a) * (f - c), g = c + (1 - l.y / a) * (f - c), p = c + (1 - u.y / a) * (f - c), _ = c + (1 - h.y / a) * (f - c), m = Math.max(1e-3, g - d), v = Math.max(1e-3, _ - p), b = m / v, y = c * b + d - p * b, x = f * b + g - _ * b;
            this.yAxes.each((D) => {
              let A = D.fixPosition(y), C = D.fixPosition(x);
              D.zoom(A, C, 0);
            });
          }
        }
      }
    }
  }
  _handleCursorPosition() {
    const e = this.get("cursor");
    if (e) {
      const t = e.getPrivate("point");
      let s = e.get("snapToSeries");
      if (e._downPoint && (s = void 0), s && t) {
        const r = e.get("snapToSeriesBy"), n = [];
        w(s, (l) => {
          if (!l.isHidden() && !l.isHiding())
            if (r != "x!" && r != "y!") {
              const u = l.startIndex(), h = l.endIndex();
              for (let c = u; c < h; c++) {
                const f = l.dataItems[c];
                f && !f.isHidden() && n.push(f);
              }
            } else {
              const u = l.get("tooltipDataItem");
              u && n.push(u);
            }
        });
        let a = 1 / 0, o;
        if (w(n, (l) => {
          const u = l.get("point");
          if (u) {
            let h = 0;
            r == "x" || r == "x!" ? h = Math.abs(t.x - u.x) : r == "y" || r == "y!" ? h = Math.abs(t.y - u.y) : h = Math.hypot(t.x - u.x, t.y - u.y), h < a && (a = h, o = l);
          }
        }), w(s, (l) => {
          const u = l.get("tooltip");
          u && u._setDataItem(void 0);
        }), o) {
          let l = o.component;
          l.showDataItemTooltip(o);
          const u = o.get("point");
          u && e.handleMove(l.toGlobal({ x: u.x - l.x(), y: u.y - l.y() }), !0);
        }
      }
    }
  }
  _updateCursor() {
    let e = this.get("cursor");
    e && e.handleMove();
  }
  _addCursor(e) {
    this.plotContainer.children.push(e);
  }
  _prepareChildren() {
    if (super._prepareChildren(), this.series.each((e) => {
      this._colorize(e);
    }), (this.isDirty("wheelX") || this.isDirty("wheelY")) && this._handleSetWheel(), this.isDirty("cursor")) {
      const e = this._prevSettings.cursor, t = this.get("cursor");
      t !== e && (this._disposeProperty("cursor"), e && e.dispose(), t && (t._setChart(this), this._addCursor(t), this._pushPropertyDisposer("cursor", t.events.on("selectended", () => {
        this._handleCursorSelectEnd();
      }))), this._prevSettings.cursor = t);
    }
    if (this.isDirty("scrollbarX")) {
      const e = this._prevSettings.scrollbarX, t = this.get("scrollbarX");
      t !== e && (this._disposeProperty("scrollbarX"), e && e.dispose(), t && (t.parent || this.topAxesContainer.children.push(t), this._pushPropertyDisposer("scrollbarX", t.events.on("rangechanged", (s) => {
        this._handleScrollbar(this.xAxes, s.start, s.end, s.grip);
      })), t.setPrivate("positionTextFunction", (s) => {
        const r = this.xAxes.getIndex(0);
        return r && r.getTooltipText(s, !1) || "";
      })), this._prevSettings.scrollbarX = t);
    }
    if (this.isDirty("scrollbarY")) {
      const e = this._prevSettings.scrollbarY, t = this.get("scrollbarY");
      t !== e && (this._disposeProperty("scrollbarY"), e && e.dispose(), t && (t.parent || this.rightAxesContainer.children.push(t), this._pushPropertyDisposer("scrollbarY", t.events.on("rangechanged", (s) => {
        this._handleScrollbar(this.yAxes, s.start, s.end, s.grip);
      })), t.setPrivate("positionTextFunction", (s) => {
        const r = this.yAxes.getIndex(0);
        return r && r.getTooltipText(s, !1) || "";
      })), this._prevSettings.scrollbarY = t);
    }
    this._handleZoomOut();
  }
  _processSeries(e) {
    super._processSeries(e);
    const t = e.get("xAxis"), s = e.get("yAxis");
    ka(t.series, e), ka(s.series, e), e._posXDp = e.addDisposer(t.events.on("positionchanged", () => {
      e._fixPosition();
    })), e._posXDp = e.addDisposer(s.events.on("positionchanged", () => {
      e._fixPosition();
    })), e.get("baseAxis") || (s.isType("CategoryAxis") || s.isType("DateAxis") ? e.set("baseAxis", s) : e.set("baseAxis", t)), e.get("stacked") && (e._markDirtyKey("stacked"), w(e.dataItems, (r) => {
      r.set("stackToItemY", void 0), r.set("stackToItemX", void 0);
    })), e._markDirtyAxes(), s.markDirtyExtremes(), t.markDirtyExtremes(), this._colorize(e);
  }
  _colorize(e) {
    const t = this.get("colors");
    if (t && e.get("fill") == null) {
      const s = t.next();
      e._setSoft("stroke", s), e._setSoft("fill", s);
    }
  }
  _handleCursorSelectEnd() {
    const e = this.get("cursor"), t = e.get("behavior"), s = e.getPrivate("downPositionX", 0), r = e.getPrivate("downPositionY", 0), n = e.getPrivate("positionX", 0.5), a = e.getPrivate("positionY", 0.5);
    this.xAxes.each((o) => {
      if (t === "zoomX" || t === "zoomXY") {
        let l = o.toAxisPosition(s), u = o.toAxisPosition(n);
        o.zoom(l, u);
      }
      o.setPrivate("updateScrollbar", !0);
    }), this.yAxes.each((o) => {
      if (t === "zoomY" || t === "zoomXY") {
        let l = o.toAxisPosition(r), u = o.toAxisPosition(a);
        o.zoom(l, u);
      }
      o.setPrivate("updateScrollbar", !0);
    });
  }
  _handleScrollbar(e, t, s, r) {
    e.each((n) => {
      let a = n.fixPosition(t), o = n.fixPosition(s), l = n.zoom(a, o, void 0, r);
      const u = "updateScrollbar";
      n.setPrivateRaw(u, !1), l ? l.events.on("stopped", () => {
        n.setPrivateRaw(u, !0);
      }) : n.setPrivateRaw(u, !0);
    });
  }
  _processAxis(e, t) {
    return e.events.onAll((s) => {
      if (s.type === "clear")
        w(s.oldValues, (r) => {
          this._removeAxis(r);
        });
      else if (s.type === "push")
        t.children.push(s.newValue), s.newValue.processChart(this);
      else if (s.type === "setIndex")
        t.children.setIndex(s.index, s.newValue), s.newValue.processChart(this);
      else if (s.type === "insertIndex")
        t.children.insertIndex(s.index, s.newValue), s.newValue.processChart(this);
      else if (s.type === "removeIndex")
        this._removeAxis(s.oldValue);
      else if (s.type === "moveIndex")
        t.children.moveValue(s.value, s.newIndex), s.value.processChart(this);
      else
        throw new Error("Unknown IListEvent type");
    });
  }
  _removeAxis(e) {
    if (!e.isDisposed()) {
      const t = e.parent;
      t && t.children.removeValue(e);
      const s = e.gridContainer, r = s.parent;
      r && r.children.removeValue(s);
      const n = e.topGridContainer, a = n.parent;
      a && a.children.removeValue(n);
    }
  }
  _updateChartLayout() {
    const e = this.leftAxesContainer.width(), t = this.rightAxesContainer.width(), s = this.bottomAxesContainer;
    s.set("paddingLeft", e), s.set("paddingRight", t);
    const r = this.topAxesContainer;
    r.set("paddingLeft", e), r.set("paddingRight", t);
  }
  /**
   * @ignore
   */
  processAxis(e) {
  }
  _handleAxisSelection(e, t) {
    let s = e.fixPosition(e.get("start", 0)), r = e.fixPosition(e.get("end", 1));
    if (s > r && ([s, r] = [r, s]), this.xAxes.indexOf(e) != -1) {
      if (t || e.getPrivate("updateScrollbar")) {
        let n = this.get("scrollbarX");
        n && (!n.getPrivate("isBusy") || t) && (n.setRaw("start", s), n.setRaw("end", r), n.updateGrips());
      }
    } else if (this.yAxes.indexOf(e) != -1 && (t || e.getPrivate("updateScrollbar"))) {
      let n = this.get("scrollbarY");
      n && (!n.getPrivate("isBusy") || t) && (n.setRaw("start", s), n.setRaw("end", r), n.updateGrips());
    }
    this._handleZoomOut();
  }
  _handleZoomOut() {
    let e = this.zoomOutButton;
    if (e && e.parent) {
      let t = !1;
      this.xAxes.each((s) => {
        (s.get("start") != 0 || s.get("end") != 1) && (t = !0);
      }), this.yAxes.each((s) => {
        (s.get("start") != 0 || s.get("end") != 1) && (t = !0);
      }), t ? e.isHidden() && e.show() : e.hide();
    }
  }
  /**
   * Checks if point is within plot area.
   *
   * @param   point  Reference point
   * @return         Is within plot area?
   */
  inPlot(e) {
    const t = this.plotContainer, s = this.getPrivate("otherCharts", this._otherCharts), r = t.toGlobal(e);
    if (e.x >= -0.5 && e.y >= -0.5 && e.x <= t.width() + 0.5 && e.y <= t.height() + 0.5)
      return !0;
    if (s)
      for (let n = s.length - 1; n >= 0; n--) {
        const a = s[n];
        if (a != this) {
          const o = a.plotContainer, l = this._root.rootPointToDocument(r), u = a._root.documentPointToRoot(l), h = o.toLocal(u);
          if (h.x >= -0.1 && h.y >= -0.1 && h.x <= o.width() + 0.1 && h.y <= o.height() + 0.1)
            return !0;
        }
      }
    return !1;
  }
  /**
   * @ignore
   */
  arrangeTooltips() {
    const e = this.plotContainer, t = e.width(), s = e.height(), r = this.height();
    let n = e._display.toGlobal({ x: 0, y: 0 }), a = e._display.toGlobal({ x: t, y: s });
    const o = [];
    let l = 0, u = 1 / 0, h = this._movePoint, c = this.get("maxTooltipDistance"), f = this.get("maxTooltipDistanceBy", "xy"), d, g;
    S(c) && this.series.each((_) => {
      if (!_.isHidden()) {
        const m = _.get("tooltip");
        if (m) {
          let v = m.get("pointTo");
          if (v) {
            let b = Math.hypot(h.x - v.x, h.y - v.y);
            f == "x" ? b = Math.abs(h.x - v.x) : f == "y" && (b = Math.abs(h.y - v.y)), b < u && (u = b, d = _, g = v);
          }
        }
      }
    });
    const p = [];
    if (this.series.each((_) => {
      const m = _.get("tooltip");
      if (m) {
        let v = !1, b = m.get("pointTo");
        if (b) {
          if (c >= 0) {
            let y = m.get("pointTo");
            if (y && _ != d) {
              let x = Math.hypot(g.x - y.x, g.y - y.y);
              f == "x" ? x = Math.abs(g.x - y.x) : f == "y" && (x = Math.abs(g.y - y.y)), x > c && (v = !0);
            }
          } else
            c == -1 && _ != d && (v = !0);
          !this.inPlot(this._tooltipToLocal(b)) || !m.dataItem ? v = !0 : v || (l += b.y), v || _.isHidden() || _.isHiding() ? m.hide(0) : (m.show(), o.push(m), p.push(_));
        }
      }
    }), this.setPrivate("tooltipSeries", p), this.get("arrangeTooltips")) {
      const _ = this._root.tooltipContainer, m = o.length;
      if (l / m > s / 2 + n.y) {
        o.sort((y, x) => dh(x.get("pointTo").y, y.get("pointTo").y));
        let b = a.y;
        if (w(o, (y) => {
          let x = y.height(), D = y.get("centerY");
          D instanceof ae && (x *= D.value), x += y.get("marginBottom", 0), y.set("bounds", { left: n.x, top: n.y, right: a.x, bottom: b }), y.setPrivate("customData", { left: n.x, top: n.y, right: a.x, bottom: b }), b = Math.min(b - x, y._fy - x), y.parent == _ && _.children.moveValue(y, 0);
        }), b < 0) {
          o.reverse();
          let y = b;
          w(o, (x) => {
            let D = x.get("bounds");
            if (D) {
              let A = D.top - b, C = D.bottom - b;
              A < y && (A = y, C = A + x.height()), x.set("bounds", { left: D.left, top: A, right: D.right, bottom: C }), y = D.bottom - b + x.get("marginBottom", 0);
            }
          });
        }
      } else {
        o.reverse(), o.sort((y, x) => dh(y.get("pointTo").y, x.get("pointTo").y));
        let b = 0;
        if (w(o, (y) => {
          let x = y.height(), D = y.get("centerY");
          D instanceof ae && (x *= D.value), x += y.get("marginBottom", 0), y.set("bounds", { left: n.x, top: b, right: a.x, bottom: Math.max(n.y + r, b + x) }), y.parent == _ && _.children.moveValue(y, 0), b = Math.max(b + x, y._fy + x);
        }), b > r) {
          o.reverse();
          let y = r;
          w(o, (x) => {
            let D = x.get("bounds");
            if (D) {
              let A = D.top - (r - b), C = D.bottom - (r - b);
              C > y && (C = y, A = C - x.height()), x.set("bounds", { left: D.left, top: A, right: D.right, bottom: C }), y = C - x.height() - x.get("marginBottom", 0);
            }
          });
        }
      }
    }
  }
  _tooltipToLocal(e) {
    return this.plotContainer.toLocal(e);
  }
  /**
   * Fully zooms out the chart.
   */
  zoomOut() {
    this.xAxes.each((e) => {
      e.setPrivate("updateScrollbar", !0), e.zoom(0, 1);
    }), this.yAxes.each((e) => {
      e.setPrivate("updateScrollbar", !0), e.zoom(0, 1);
    });
  }
};
Object.defineProperty(gr, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "XYChart"
});
Object.defineProperty(gr, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: ts.classNames.concat([gr.className])
});
class hn extends es {
  constructor() {
    super(...arguments), Object.defineProperty(this, "chart", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.children.push(gr.new(this._root, {
        themeTags: ["chart"],
        interactive: !1,
        interactiveChildren: !1,
        panX: !1,
        panY: !1,
        wheelX: "none",
        wheelY: "none"
      }))
    }), Object.defineProperty(this, "overlay", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.children.push(ce.new(this._root, {
        themeTags: ["overlay"],
        interactive: !1
      }))
    });
  }
  _afterNew() {
    this._addOrientationClass(), this._settings.themeTags = se(this._settings.themeTags, ["scrollbar", "xy", "chart", this._settings.orientation]);
    const e = this.children;
    e.moveValue(this.thumb), e.moveValue(this.startGrip), e.moveValue(this.endGrip), this.thumb.set("opacity", 0), this.thumb.states.create("hover", { opacity: 0.2 });
    const t = this.chart.plotContainer;
    t.set("interactive", !1), t.remove("background"), t.children.removeValue(this.chart.zoomOutButton), super._afterNew();
  }
  _updateThumb() {
    super._updateThumb(), this.overlay.set("draw", (e) => {
      const t = this.startGrip, s = this.endGrip;
      let r = t.x(), n = t.y(), a = s.x(), o = s.y();
      const l = this.height(), u = this.width();
      r > a && ([r, a] = [a, r]), n > o && ([n, o] = [o, n]), this.get("orientation") === "horizontal" ? (e.moveTo(0, 0), e.lineTo(r, 0), e.lineTo(r, l), e.lineTo(0, l), e.lineTo(0, 0), e.moveTo(a, 0), e.lineTo(u, 0), e.lineTo(u, l), e.lineTo(a, l), e.lineTo(a, 0)) : (e.moveTo(0, 0), e.lineTo(0, n), e.lineTo(u, n), e.lineTo(u, 0), e.lineTo(0, 0), e.moveTo(0, o), e.lineTo(0, l), e.lineTo(u, l), e.lineTo(u, o), e.lineTo(0, o));
    });
  }
}
Object.defineProperty(hn, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "XYChartScrollbar"
});
Object.defineProperty(hn, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: es.classNames.concat([hn.className])
});
class $s extends ce {
  _beforeChanged() {
    super._beforeChanged(), (this.isPrivateDirty("width") || this.isPrivateDirty("height")) && (this._clear = !0);
  }
}
Object.defineProperty($s, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Grid"
});
Object.defineProperty($s, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: ce.classNames.concat([$s.className])
});
class dn extends G {
  constructor() {
    super(...arguments), Object.defineProperty(this, "lineX", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.children.push($s.new(this._root, {
        themeTags: ["x"]
      }))
    }), Object.defineProperty(this, "lineY", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.children.push($s.new(this._root, {
        themeTags: ["y"]
      }))
    }), Object.defineProperty(this, "selection", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.children.push(ce.new(this._root, {
        themeTags: ["selection", "cursor"],
        layer: 30
      }))
    }), Object.defineProperty(this, "_movePoint", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_lastPoint", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: { x: 0, y: 0 }
    }), Object.defineProperty(this, "_tooltipX", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_tooltipY", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "chart", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_toX", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_toY", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  _afterNew() {
    this._settings.themeTags = se(this._settings.themeTags, ["xy", "cursor"]), super._afterNew(), this.setAll({ width: R, height: R, isMeasured: !0, position: "absolute" }), this.states.create("hidden", { visible: !0, opacity: 0 }), this._drawLines(), this.setPrivateRaw("visible", !1), this._disposers.push(this.setTimeout(() => {
      this.setPrivate("visible", !0);
    }, 500)), this._disposers.push(this.lineX.events.on("positionchanged", () => {
      this._handleXLine();
    })), this._disposers.push(this.lineY.events.on("positionchanged", () => {
      this._handleYLine();
    })), this._disposers.push(this.lineX.events.on("focus", (e) => this._handleLineFocus(e.target))), this._disposers.push(this.lineX.events.on("blur", (e) => this._handleLineBlur(e.target))), this._disposers.push(this.lineY.events.on("focus", (e) => this._handleLineFocus(e.target))), this._disposers.push(this.lineY.events.on("blur", (e) => this._handleLineBlur(e.target))), ei("keyboardevents") && this._disposers.push(Me(document, "keydown", (e) => {
      this._handleLineMove(e.keyCode);
    }));
  }
  _setUpTouch() {
    const e = this.chart;
    e && (e.plotContainer._display.cancelTouch = this.get("behavior") != "none");
  }
  _handleXLine() {
    let e = this.lineX.x(), t = !0;
    (e < 0 || e > this.width()) && (t = !1), this.lineX.setPrivate("visible", t);
  }
  _handleYLine() {
    let e = this.lineY.y(), t = !0;
    (e < 0 || e > this.height()) && (t = !1), this.lineY.setPrivate("visible", t);
  }
  _handleLineMove(e) {
    let t = "", s = 0, r = 0.1;
    const n = this.chart;
    this._root.focused(this.lineX) ? (n && n.xAxes.length && (r = n.xAxes.getIndex(0).getCellWidthPosition()), s = this.getPrivate("positionX", 0), t = "positionX", e == 37 ? s -= r : e == 39 && (s += r)) : this._root.focused(this.lineY) && (n && n.yAxes.length && (r = n.yAxes.getIndex(0).getCellWidthPosition()), s = this.getPrivate("positionY", 0), t = "positionY", e == 38 ? s -= r : e == 40 && (s += r)), s < 0 ? s = 0 : s > 1 && (s = 1), t != "" && this.set(t, s);
  }
  _handleLineFocus(e) {
    this.setAll({
      positionX: this.getPrivate("positionX"),
      positionY: this.getPrivate("positionY"),
      alwaysShow: !0
    });
  }
  _handleLineBlur(e) {
    this.setAll({
      positionX: void 0,
      positionY: void 0,
      alwaysShow: !1
    });
  }
  _prepareChildren() {
    if (super._prepareChildren(), this.isDirty("xAxis")) {
      this._tooltipX = !1;
      const e = this.get("xAxis");
      if (e) {
        const t = e.get("tooltip");
        t && (this._tooltipX = !0, this._disposers.push(t.on("pointTo", () => {
          this._updateXLine(t);
        })));
      }
    }
    if (this.isDirty("yAxis")) {
      this._tooltipY = !1;
      const e = this.get("yAxis");
      if (e) {
        const t = e.get("tooltip");
        t && (this._tooltipY = !0, this._disposers.push(t.on("pointTo", () => {
          this._updateYLine(t);
        })));
      }
    }
  }
  _handleSyncWith() {
    const e = this.chart;
    if (e) {
      const t = this.get("syncWith"), s = [];
      t && w(t, (r) => {
        const n = r.chart;
        n && s.push(n);
      }), e._otherCharts = s;
    }
  }
  _updateChildren() {
    if (super._updateChildren(), this._handleSyncWith(), this.isDirty("positionX") || this.isDirty("positionY")) {
      const e = this.get("positionX"), t = this.get("positionY");
      e == null && t == null ? this.hide(0) : (this._movePoint = this.toGlobal(this._getPoint(this.get("positionX", 0), this.get("positionY", 0))), this.handleMove());
    }
  }
  _updateXLine(e) {
    let t = rt(this._display.toLocal(e.get("pointTo", { x: 0, y: 0 })).x, 2);
    this._toX != t && (this.lineX.animate({ key: "x", to: t, duration: e.get("animationDuration", 0), easing: e.get("animationEasing") }), this._toX = t);
  }
  _updateYLine(e) {
    let t = rt(this._display.toLocal(e.get("pointTo", { x: 0, y: 0 })).y, 2);
    this._toY != t && (this.lineY.animate({ key: "y", to: t, duration: e.get("animationDuration", 0), easing: e.get("animationEasing") }), this._toY = t);
  }
  _drawLines() {
    this.lineX.set("draw", (e) => {
      e.moveTo(0, 0), e.lineTo(0, this.height());
    }), this.lineY.set("draw", (e) => {
      e.moveTo(0, 0), e.lineTo(this.width(), 0);
    });
  }
  _setChart(e) {
    this.chart = e, this._handleSyncWith();
    const t = e.plotContainer;
    this.events.on("boundschanged", () => {
      this._disposers.push(this.setTimeout(() => {
        this.get("alwaysShow") && (this._movePoint = this.toGlobal(this._getPoint(this.get("positionX", 0), this.get("positionY", 0))), this.handleMove());
      }, 50));
    }), ei("touchevents") && (this._disposers.push(t.events.on("click", (r) => {
      Aa(r.originalEvent) && this._handleMove(r.originalEvent);
    })), this._setUpTouch()), this._disposers.push(t.events.on("pointerdown", (r) => {
      this._handleCursorDown(r.originalEvent);
    })), this._disposers.push(t.events.on("globalpointerup", (r) => {
      this._handleCursorUp(r.originalEvent), !r.native && !this.isHidden() && this._handleMove(r.originalEvent);
    })), this._disposers.push(t.events.on("globalpointermove", (r) => {
      !this.get("syncWith") && Ve(t._downPoints).length == 0 && !r.native && this.isHidden() || this._handleMove(r.originalEvent);
    }));
    const s = this.parent;
    s && s.children.moveValue(this.selection);
  }
  _inPlot(e) {
    const t = this.chart;
    return t ? t.inPlot(e) : !1;
  }
  _handleCursorDown(e) {
    if (e.button == 2)
      return;
    const t = this._root.documentPointToRoot({ x: e.clientX, y: e.clientY });
    let s = this._display.toLocal(t);
    const r = this.chart;
    if (this.selection.set("draw", () => {
    }), r && this._inPlot(s)) {
      if (this._downPoint = s, this.get("behavior") != "none") {
        this.selection.show();
        const o = "selectstarted";
        this.events.isEnabled(o) && this.events.dispatch(o, { type: o, target: this });
      }
      let n = this._getPosition(s).x, a = this._getPosition(s).y;
      this.setPrivate("downPositionX", n), this.setPrivate("downPositionY", a);
    }
  }
  _handleCursorUp(e) {
    if (this._downPoint) {
      const t = this.get("behavior", "none");
      if (t != "none") {
        t.charAt(0) === "z" && this.selection.hide();
        const s = this._root.documentPointToRoot({ x: e.clientX, y: e.clientY });
        let r = this._display.toLocal(s);
        const n = this._downPoint, a = this.get("moveThreshold", 1);
        if (r && n) {
          let o = !1;
          if ((t === "zoomX" || t === "zoomXY" || t === "selectX" || t === "selectXY") && Math.abs(r.x - n.x) > a && (o = !0), (t === "zoomY" || t === "zoomXY" || t === "selectY" || t === "selectXY") && Math.abs(r.y - n.y) > a && (o = !0), o) {
            const l = "selectended";
            this.events.isEnabled(l) && this.events.dispatch(l, { type: l, target: this });
          }
        }
      }
    }
    this._downPoint = void 0;
  }
  _handleMove(e) {
    if (this.getPrivate("visible")) {
      const t = this.chart;
      if (t && Ve(t.plotContainer._downPoints).length > 1) {
        this.set("forceHidden", !0);
        return;
      } else
        this.set("forceHidden", !1);
      const s = this._root.documentPointToRoot({ x: e.clientX, y: e.clientY }), r = this._lastPoint;
      if (Math.round(r.x) === Math.round(s.x) && Math.round(r.y) === Math.round(s.y))
        return;
      this._lastPoint = s, this.setPrivate("lastPoint", s), this.handleMove({ x: s.x, y: s.y });
    }
  }
  _getPosition(e) {
    return { x: e.x / this.width(), y: e.y / this.height() };
  }
  /**
   * Moves the cursor to X/Y coordinates within chart container (`point`).
   *
   * If `skipEvent` parameter is set to `true`, the move will not invoke
   * the `"cursormoved"` event.
   *
   * @param  point      X/Y to move cursor to
   * @param  skipEvent  Do not fire "cursormoved" event
   */
  handleMove(e, t) {
    e || (e = this._movePoint);
    const s = this.get("alwaysShow");
    if (!e) {
      this.hide(0);
      return;
    }
    this._movePoint = e;
    let r = this._display.toLocal(e), n = this.chart;
    if (n && (this._inPlot(r) || this._downPoint)) {
      n._movePoint = e, this.isHidden() && (this.show(), this.get("behavior", "").charAt(0) == "z" && this.selection.set("draw", () => {
      }));
      let a = r.x, o = r.y, l = this._getPosition(r);
      this.setPrivate("point", r);
      let u = this.get("snapToSeries");
      this._downPoint && (u = void 0);
      let h = this.get("positionX"), c = l.x;
      S(h) && (c = h);
      let f = this.get("positionY"), d = l.y;
      S(f) && (d = f), this.setPrivate("positionX", c), this.setPrivate("positionY", d);
      const g = this._getPoint(c, d);
      if (a = g.x, o = g.y, n.xAxes.each((p) => {
        p._handleCursorPosition(c, u), s && p.handleCursorShow();
      }), n.yAxes.each((p) => {
        p._handleCursorPosition(d, u), s && p.handleCursorShow();
      }), !t) {
        n._handleCursorPosition();
        const p = "cursormoved";
        this.events.isEnabled(p) && this.events.dispatch(p, { type: p, target: this });
      }
      this._updateLines(a, o), n.arrangeTooltips();
    } else if (!this._downPoint && !s) {
      this.hide(0);
      const a = "cursorhidden";
      this.events.isEnabled(a) && this.events.dispatch(a, { type: a, target: this });
    }
    this._downPoint && this.get("behavior") != "none" && this._updateSelection(r);
  }
  _getPoint(e, t) {
    return { x: this.width() * e, y: this.height() * t };
  }
  _updateLines(e, t) {
    this._tooltipX || this.lineX.set("x", e), this._tooltipY || this.lineY.set("y", t), this._drawLines();
  }
  _updateSelection(e) {
    const t = this.selection, s = this.get("behavior"), r = this.width(), n = this.height();
    e.x < 0 && (e.x = 0), e.x > r && (e.x = r), e.y < 0 && (e.y = 0), e.y > n && (e.y = n), t.set("draw", (a) => {
      const o = this._downPoint;
      o && (s === "zoomXY" || s === "selectXY" ? (a.moveTo(o.x, o.y), a.lineTo(o.x, e.y), a.lineTo(e.x, e.y), a.lineTo(e.x, o.y), a.lineTo(o.x, o.y)) : s === "zoomX" || s === "selectX" ? (a.moveTo(o.x, 0), a.lineTo(o.x, n), a.lineTo(e.x, n), a.lineTo(e.x, 0), a.lineTo(o.x, 0)) : (s === "zoomY" || s === "selectY") && (a.moveTo(0, o.y), a.lineTo(r, o.y), a.lineTo(r, e.y), a.lineTo(0, e.y), a.lineTo(0, o.y)));
    });
  }
  _onHide() {
    if (this.isHidden()) {
      let e = this.chart;
      e && (e.xAxes.each((t) => {
        t.handleCursorHide();
      }), e.yAxes.each((t) => {
        t.handleCursorHide();
      }), e.series.each((t) => {
        t.handleCursorHide();
      }));
    }
    super._onHide();
  }
  _onShow() {
    if (!this.isHidden()) {
      let e = this.chart;
      e && (e.xAxes.each((t) => {
        t.handleCursorShow();
      }), e.yAxes.each((t) => {
        t.handleCursorShow();
      }));
    }
    super._onShow();
  }
  _dispose() {
    super._dispose(), this.selection.dispose();
  }
}
Object.defineProperty(dn, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "XYCursor"
});
Object.defineProperty(dn, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: G.classNames.concat([dn.className])
});
function jP(i, e) {
  return i == null ? e : e == null ? i : e < i ? e : i;
}
function IP(i, e) {
  return i == null ? e : e == null ? i : e > i ? e : i;
}
class is extends gi {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_xField", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_yField", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_xOpenField", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_yOpenField", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_xLowField", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_xHighField", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_yLowField", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_yHighField", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_axesDirty", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_stackDirty", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_selectionProcessed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_dataSets", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_mainContainerMask", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_x", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_y", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "mainContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.children.push(G.new(this._root, {}))
    }), Object.defineProperty(this, "axisRanges", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new Pr()
    }), Object.defineProperty(this, "_skipped", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_couldStackTo", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_reallyStackedTo", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_stackedSeries", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_aLocationX0", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_aLocationX1", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), Object.defineProperty(this, "_aLocationY0", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_aLocationY1", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), Object.defineProperty(this, "_showBullets", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "valueXFields", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: [
        "valueX",
        "openValueX",
        "lowValueX",
        "highValueX"
      ]
    }), Object.defineProperty(this, "valueYFields", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: [
        "valueY",
        "openValueY",
        "lowValueY",
        "highValueY"
      ]
    }), Object.defineProperty(this, "_valueXFields", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_valueYFields", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_valueXShowFields", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_valueYShowFields", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "__valueXShowFields", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "__valueYShowFields", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_emptyDataItem", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new ti(this, void 0, {})
    }), Object.defineProperty(this, "_dataSetId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_tooltipFieldX", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_tooltipFieldY", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_posXDp", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_posYDp", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  _afterNew() {
    this.fields.push("categoryX", "categoryY", "openCategoryX", "openCategoryY"), this.valueFields.push("valueX", "valueY", "openValueX", "openValueY", "lowValueX", "lowValueY", "highValueX", "highValueY"), this._setRawDefault("vcx", 1), this._setRawDefault("vcy", 1), this._setRawDefault("valueXShow", "valueXWorking"), this._setRawDefault("valueYShow", "valueYWorking"), this._setRawDefault("openValueXShow", "openValueXWorking"), this._setRawDefault("openValueYShow", "openValueYWorking"), this._setRawDefault("lowValueXShow", "lowValueXWorking"), this._setRawDefault("lowValueYShow", "lowValueYWorking"), this._setRawDefault("highValueXShow", "highValueXWorking"), this._setRawDefault("highValueYShow", "highValueYWorking"), this._setRawDefault("lowValueXGrouped", "low"), this._setRawDefault("lowValueYGrouped", "low"), this._setRawDefault("highValueXGrouped", "high"), this._setRawDefault("highValueYGrouped", "high"), super._afterNew(), this.set("maskContent", !0), this._disposers.push(this.axisRanges.events.onAll((e) => {
      if (e.type === "clear")
        w(e.oldValues, (t) => {
          this._removeAxisRange(t);
        });
      else if (e.type === "push")
        this._processAxisRange(e.newValue);
      else if (e.type === "setIndex")
        this._processAxisRange(e.newValue);
      else if (e.type === "insertIndex")
        this._processAxisRange(e.newValue);
      else if (e.type === "removeIndex")
        this._removeAxisRange(e.oldValue);
      else if (e.type === "moveIndex")
        this._processAxisRange(e.value);
      else
        throw new Error("Unknown IStreamEvent type");
    })), this.states.create("hidden", { opacity: 1, visible: !1 }), this._makeFieldNames();
  }
  _processAxisRange(e) {
    const t = G.new(this._root, {});
    e.container = t, this.children.push(t), e.series = this;
    const s = e.axisDataItem;
    s.setRaw("isRange", !0);
    const r = s.component;
    if (r) {
      r._processAxisRange(s, ["range", "series"]);
      const n = s.get("bullet");
      if (n) {
        const o = n.get("sprite");
        o && o.setPrivate("visible", !1);
      }
      const a = s.get("axisFill");
      a && t.set("mask", a), r._seriesAxisRanges.push(s);
    }
  }
  _removeAxisRange(e) {
    const t = e.axisDataItem, s = t.component;
    s.disposeDataItem(t), St(s._seriesAxisRanges, t);
    const r = e.container;
    r && r.dispose();
  }
  _updateFields() {
    super._updateFields(), this._valueXFields = [], this._valueYFields = [], this._valueXShowFields = [], this._valueYShowFields = [], this.__valueXShowFields = [], this.__valueYShowFields = [], this.valueXFields && w(this.valueXFields, (e) => {
      if (this.get(e + "Field")) {
        this._valueXFields.push(e);
        let s = this.get(e + "Show");
        this.__valueXShowFields.push(s), s.indexOf("Working") != -1 ? this._valueXShowFields.push(s.split("Working")[0]) : this._valueXShowFields.push(s);
      }
    }), this.valueYFields && w(this.valueYFields, (e) => {
      if (this.get(e + "Field")) {
        this._valueYFields.push(e);
        let s = this.get(e + "Show");
        this.__valueYShowFields.push(s), s.indexOf("Working") != -1 ? this._valueYShowFields.push(s.split("Working")[0]) : this._valueYShowFields.push(s);
      }
    });
  }
  _dispose() {
    super._dispose();
    const e = this.chart;
    e && e.series.removeValue(this), ht(this.get("xAxis").series, this), ht(this.get("yAxis").series, this);
  }
  // TODO use  SelectKeys<this["_privateSettings"], number | undefined>
  _min(e, t) {
    let s = jP(this.getPrivate(e), t);
    this.setPrivate(e, s);
  }
  // TODO use  SelectKeys<this["_privateSettings"], number | undefined>
  _max(e, t) {
    let s = IP(this.getPrivate(e), t);
    this.setPrivate(e, s);
  }
  _shouldMakeBullet(e) {
    const t = this.get("xAxis"), s = this.get("yAxis"), r = this.get("baseAxis");
    if (!t.inited || !s.inited)
      return !1;
    const n = this.get("minBulletDistance", 0);
    if (n > 0) {
      let a = this.startIndex(), l = this.endIndex() - a;
      if (t == r) {
        if (t.get("renderer").axisLength() / l < n / 5)
          return !1;
      } else if (s == r && s.get("renderer").axisLength() / l < n / 5)
        return !1;
    }
    return e.get(this._xField) != null && e.get(this._yField) != null;
  }
  _makeFieldNames() {
    const e = this.get("xAxis"), t = this.get("yAxis"), s = e.getPrivate("name"), r = Kl(s), n = t.getPrivate("name"), a = Kl(n), o = e.get("renderer").getPrivate("letter"), l = t.get("renderer").getPrivate("letter"), u = "open", h = "low", c = "high", f = "Show";
    e.className === "ValueAxis" ? (this._xField = this.get(s + o + f), this._xOpenField = this.get(u + r + o + f), this._xLowField = this.get(h + r + o + f), this._xHighField = this.get(c + r + o + f)) : (this._xField = s + o, this._xOpenField = u + r + o, this._xLowField = h + r + o, this._xHighField = c + r + o), t.className === "ValueAxis" ? (this._yField = this.get(n + l + f), this._yOpenField = this.get(u + a + l + f), this._yLowField = this.get(h + a + l + f), this._yHighField = this.get(c + a + l + f)) : (this._yField = n + l, this._yOpenField = u + a + l, this._yLowField = h + a + l, this._yHighField = c + a + l);
  }
  _fixVC() {
    const e = this.get("xAxis"), t = this.get("yAxis"), s = this.get("baseAxis"), r = this.states.lookup("hidden"), n = this.get("sequencedInterpolation");
    if (r) {
      let a = 0;
      n && (a = 0.999999999999), e === s ? r.set("vcy", a) : (t === s || r.set("vcy", a), r.set("vcx", a));
    }
  }
  _handleMaskBullets() {
    this.isDirty("maskBullets") && this.bulletsContainer.set("maskContent", this.get("maskBullets"));
  }
  _fixPosition() {
    const e = this.get("xAxis"), t = this.get("yAxis");
    this.set("x", e.x() - Te(e.get("centerX", 0), e.width()) - e.parent.get("paddingLeft", 0)), this.set("y", t.y() - Te(t.get("centerY", 0), t.height()) - t.parent.get("paddingTop", 0)), this.bulletsContainer.set("y", this.y()), this.bulletsContainer.set("x", this.x());
  }
  _prepareChildren() {
    super._prepareChildren(), (this.isDirty("valueYShow") || this.isDirty("valueXShow") || this.isDirty("openValueYShow") || this.isDirty("openValueXShow") || this.isDirty("lowValueYShow") || this.isDirty("lowValueXShow") || this.isDirty("highValueYShow") || this.isDirty("highValueXShow")) && (this._updateFields(), this._makeFieldNames(), this._valuesDirty = !0), (this.isDirty("xAxis") || this.isDirty("yAxis")) && (this._valuesDirty = !0), this.set("width", this.get("xAxis").width()), this.set("height", this.get("yAxis").height()), this._handleMaskBullets();
    const e = this.get("xAxis"), t = this.get("yAxis"), s = this.get("baseAxis"), r = this.get("tooltipPositionX");
    let n;
    switch (r) {
      case "open":
        n = this._xOpenField;
        break;
      case "low":
        n = this._xLowField;
        break;
      case "high":
        n = this._xHighField;
        break;
      default:
        n = this._xField;
    }
    this._tooltipFieldX = n;
    const a = this.get("tooltipPositionY");
    let o;
    switch (a) {
      case "open":
        o = this._yOpenField;
        break;
      case "low":
        o = this._yLowField;
        break;
      case "high":
        o = this._yHighField;
        break;
      default:
        o = this._yField;
    }
    this._tooltipFieldY = o, this.isDirty("baseAxis") && this._fixVC(), this._fixPosition();
    const l = this.get("stacked");
    if (this.isDirty("stacked") && (l ? this._valuesDirty && !this._dataProcessed || this._stack() : this._unstack()), this._valuesDirty && !this._dataProcessed && (this._dataProcessed = !0, l && this._stack(), w(this.dataItems, (u) => {
      w(this._valueXShowFields, (h) => {
        let c = u.get(h);
        c != null && (l && (c += this.getStackedXValue(u, h)), this._min("minX", c), this._max("maxX", c));
      }), w(this._valueYShowFields, (h) => {
        let c = u.get(h);
        c != null && (l && (c += this.getStackedYValue(u, h)), this._min("minY", c), this._max("maxY", c));
      }), e.processSeriesDataItem(u, this._valueXFields), t.processSeriesDataItem(u, this._valueYFields);
    }), e._seriesValuesDirty = !0, t._seriesValuesDirty = !0, this.get("ignoreMinMax") || ((this.isPrivateDirty("minX") || this.isPrivateDirty("maxX")) && e.markDirtyExtremes(), (this.isPrivateDirty("minY") || this.isPrivateDirty("maxY")) && t.markDirtyExtremes()), this._markStakedDirtyStack(), this.get("tooltipDataItem") || this.updateLegendValue(void 0)), (this.isDirty("vcx") || this.isDirty("vcy")) && this._markStakedDirtyStack(), this._dataGrouped || (e._groupSeriesData(this), t._groupSeriesData(this), this._dataGrouped = !0), this._valuesDirty || this.isPrivateDirty("startIndex") || this.isPrivateDirty("endIndex") || this.isDirty("vcx") || this.isDirty("vcy") || this._stackDirty) {
      let u = this.startIndex(), h = this.endIndex(), c = this.get("minBulletDistance", 0);
      if (c > 0 && s && (s.get("renderer").axisLength() / (h - u) > c ? this._showBullets = !0 : this._showBullets = !1), (this._psi != u || this._pei != h || this.isDirty("vcx") || this.isDirty("vcy") || this._stackDirty || this._valuesDirty) && !this._selectionProcessed) {
        this._selectionProcessed = !0;
        const f = this.get("vcx", 1), d = this.get("vcy", 1), g = this.get("stacked", !1), p = this.getPrivate("outOfSelection");
        if (s === e || !s)
          if (t._calculateTotals(), this.setPrivateRaw("selectionMinY", void 0), this.setPrivateRaw("selectionMaxY", void 0), p)
            t.markDirtySelectionExtremes();
          else
            for (let _ = u; _ < h; _++)
              this.processYSelectionDataItem(this.dataItems[_], d, g);
        if (s === t || !s)
          if (e._calculateTotals(), this.setPrivateRaw("selectionMinX", void 0), this.setPrivateRaw("selectionMaxX", void 0), p)
            t.markDirtySelectionExtremes();
          else
            for (let _ = u; _ < h; _++)
              this.processXSelectionDataItem(this.dataItems[_], f, g);
        if ((s === e || !s) && this.get("valueYShow") !== "valueYWorking") {
          const _ = this.getPrivate("selectionMinY");
          _ != null && (this.setPrivateRaw("minY", _), t.markDirtyExtremes());
          const m = this.getPrivate("selectionMaxY");
          m != null && (this.setPrivateRaw("maxY", m), t.markDirtyExtremes());
        }
        if ((s === t || !s) && this.get("valueXShow") !== "valueXWorking") {
          const _ = this.getPrivate("selectionMinX");
          _ != null && (this.setPrivateRaw("minX", _), t.markDirtyExtremes());
          const m = this.getPrivate("selectionMaxX");
          m != null && (this.setPrivateRaw("maxX", m), e.markDirtyExtremes());
        }
        (this.isPrivateDirty("selectionMinX") || this.isPrivateDirty("selectionMaxX")) && e.markDirtySelectionExtremes(), (this.isPrivateDirty("selectionMinY") || this.isPrivateDirty("selectionMaxY")) && t.markDirtySelectionExtremes();
      }
    }
  }
  _makeRangeMask() {
    if (this.axisRanges.length > 0) {
      let e = this._mainContainerMask;
      e == null && (e = this.children.push(ce.new(this._root, {})), this._mainContainerMask = e, e.set("draw", (t, s) => {
        const r = this.parent;
        if (r) {
          const n = this._root.container.width(), a = this._root.container.height();
          t.moveTo(-n, -a), t.lineTo(-n, a * 2), t.lineTo(n * 2, a * 2), t.lineTo(n * 2, -a), t.lineTo(-n, -a), this.axisRanges.each((o) => {
            const l = o.axisDataItem.get("axisFill");
            if (r && l) {
              let u = l.get("draw");
              u && u(t, s);
            }
          });
        }
        this.mainContainer._display.mask = e._display;
      })), e.markDirty(), e._markDirtyKey("fill");
    } else
      this.mainContainer._display.mask = null;
  }
  _updateChildren() {
    super._updateChildren(), this._x = this.x(), this._y = this.y(), this._makeRangeMask();
  }
  _stack() {
    const e = this.chart;
    if (e) {
      const t = e.series.indexOf(this);
      if (this._couldStackTo = [], t > 0) {
        let s;
        for (let r = t - 1; r >= 0 && (s = e.series.getIndex(r), !(s.get("xAxis") === this.get("xAxis") && s.get("yAxis") === this.get("yAxis") && s.className === this.className && (this._couldStackTo.push(s), !s.get("stacked")))); r--)
          ;
      }
      this._stackDataItems();
    }
  }
  _unstack() {
    ye(this._reallyStackedTo, (e, t) => {
      delete t._stackedSeries[this.uid];
    }), this._reallyStackedTo = {}, w(this.dataItems, (e) => {
      e.setRaw("stackToItemY", void 0), e.setRaw("stackToItemX", void 0);
    });
  }
  _stackDataItems() {
    const e = this.get("baseAxis"), t = this.get("xAxis"), s = this.get("yAxis");
    let r, n;
    e === t ? (r = "valueY", n = "stackToItemY") : e === s && (r = "valueX", n = "stackToItemX");
    let a = this._couldStackTo.length, o = 0;
    const l = this.get("stackToNegative");
    this._reallyStackedTo = {}, w(this.dataItems, (u) => {
      for (let h = 0; h < a; h++) {
        let c = this._couldStackTo[h], f = c.dataItems[o], d = u.get(r);
        if (f) {
          let g = f.get(r);
          if (l)
            if (S(d)) {
              if (S(g)) {
                if (d >= 0 && g >= 0) {
                  u.setRaw(n, f), this._reallyStackedTo[c.uid] = c, c._stackedSeries[this.uid] = this;
                  break;
                }
                if (d < 0 && g < 0) {
                  u.setRaw(n, f), this._reallyStackedTo[c.uid] = c, c._stackedSeries[this.uid] = this;
                  break;
                }
              }
            } else
              break;
          else if (S(d) && S(g)) {
            u.setRaw(n, f), this._reallyStackedTo[c.uid] = c, c._stackedSeries[this.uid] = this;
            break;
          }
        }
      }
      o++;
    });
  }
  processXSelectionDataItem(e, t, s) {
    w(this.__valueXShowFields, (r) => {
      let n = e.get(r);
      n != null && (s && (n += this.getStackedXValueWorking(e, r)), this._min("selectionMinX", n), this._max("selectionMaxX", n * t));
    });
  }
  processYSelectionDataItem(e, t, s) {
    w(this.__valueYShowFields, (r) => {
      let n = e.get(r);
      n != null && (s && (n += this.getStackedYValueWorking(e, r)), this._min("selectionMinY", n), this._max("selectionMaxY", n * t));
    });
  }
  /**
   * @ignore
   */
  getStackedYValueWorking(e, t) {
    const s = e.get("stackToItemY");
    if (s) {
      const r = s.component;
      return s.get(t, 0) * r.get("vcy", 1) + this.getStackedYValueWorking(s, t);
    }
    return 0;
  }
  /**
   * @ignore
   */
  getStackedXValueWorking(e, t) {
    const s = e.get("stackToItemX");
    if (s) {
      const r = s.component;
      return s.get(t, 0) * r.get("vcx", 1) + this.getStackedXValueWorking(s, t);
    }
    return 0;
  }
  /**
   * @ignore
   */
  getStackedYValue(e, t) {
    const s = e.get("stackToItemY");
    return s ? s.get(t, 0) + this.getStackedYValue(s, t) : 0;
  }
  /**
   * @ignore
   */
  getStackedXValue(e, t) {
    const s = e.get("stackToItemX");
    return s ? s.get(t, 0) + this.getStackedXValue(s, t) : 0;
  }
  /**
   * @ignore
   */
  createLegendMarker(e) {
    this.updateLegendMarker();
  }
  _markDirtyAxes() {
    this._axesDirty = !0, this.markDirty();
  }
  _markDataSetDirty() {
    this._afterDataChange(), this._valuesDirty = !0, this._dataProcessed = !1, this._aggregatesCalculated = !1, this.markDirty();
  }
  _clearDirty() {
    super._clearDirty(), this._axesDirty = !1, this._selectionProcessed = !1, this._stackDirty = !1, this._dataProcessed = !1;
  }
  _positionBullet(e) {
    let t = e.get("sprite");
    if (t) {
      let s = t.dataItem, r = e.get("locationX", s.get("locationX", 0.5)), n = e.get("locationY", s.get("locationY", 0.5)), a = this.get("xAxis"), o = this.get("yAxis");
      const l = a.getDataItemPositionX(s, this._xField, r, this.get("vcx", 1)), u = o.getDataItemPositionY(s, this._yField, n, this.get("vcy", 1));
      let h = this.getPoint(l, u), c = s.get("left", h.x), f = s.get("right", h.x), d = s.get("top", h.y), g = s.get("bottom", h.y);
      if (this._shouldShowBullet(l, u)) {
        e.getPrivate("hidden") ? t.setPrivate("visible", !1) : t.setPrivate("visible", !0);
        let p = f - c, _ = g - d;
        t.isType("Label") && (t.setPrivate("maxWidth", Math.abs(p)), t.setPrivate("maxHeight", Math.abs(_)));
        let m = c + p * r, v = g - _ * n;
        t.set("x", m), t.set("y", v);
      } else
        t.setPrivate("visible", !1);
    }
  }
  _shouldShowBullet(e, t) {
    return this._showBullets;
  }
  /**
   * @ignore
   */
  setDataSet(e) {
    if (this._dataSets[e]) {
      this._handleDataSetChange(), this._dataItems = this._dataSets[e], this._markDataSetDirty(), this._dataSetId = e;
      const t = "datasetchanged";
      this.events.isEnabled(t) && this.events.dispatch(t, { type: t, target: this, id: e });
    }
  }
  _handleDataSetChange() {
    this.bullets.length > 0 && w(this._dataItems, (e) => {
      let t = e.bullets;
      t && w(t, (s) => {
        if (s) {
          let r = s.get("sprite");
          r && r.setPrivate("visible", !1);
        }
      });
    }), this._selectionProcessed = !1;
  }
  /**
   * Shows hidden series.
   *
   * @param   duration  Duration of animation in milliseconds
   * @return            Animation promise
   */
  show(e) {
    const t = Object.create(null, {
      show: { get: () => super.show }
    });
    return Ze(this, void 0, void 0, function* () {
      this._fixVC();
      let s = [];
      s.push(t.show.call(this, e).then(() => {
        this._isShowing = !1;
        let r = this.get("xAxis"), n = this.get("yAxis"), a = this.get("baseAxis");
        n !== a && n.markDirtySelectionExtremes(), r !== a && r.markDirtySelectionExtremes();
      })), s.push(this.bulletsContainer.show(e)), s.push(this._sequencedShowHide(!0, e)), yield Promise.all(s);
    });
  }
  /**
   * Hides series.
   *
   * @param   duration  Duration of animation in milliseconds
   * @return            Animation promise
   */
  hide(e) {
    const t = Object.create(null, {
      hide: { get: () => super.hide }
    });
    return Ze(this, void 0, void 0, function* () {
      this._fixVC();
      let s = [];
      s.push(t.hide.call(this, e).then(() => {
        this._isHiding = !1;
      })), s.push(this.bulletsContainer.hide(e)), s.push(this._sequencedShowHide(!1, e)), yield Promise.all(s);
    });
  }
  /**
   * Shows series's data item.
   *
   * @param   dataItem  Data item
   * @param   duration  Animation duration in milliseconds
   * @return            Promise
   */
  showDataItem(e, t) {
    const s = Object.create(null, {
      showDataItem: { get: () => super.showDataItem }
    });
    return Ze(this, void 0, void 0, function* () {
      const r = [s.showDataItem.call(this, e, t)];
      S(t) || (t = this.get("stateAnimationDuration", 0));
      const n = this.get("stateAnimationEasing");
      w(this._valueFields, (a) => {
        r.push(e.animate({ key: a + "Working", to: e.get(a), duration: t, easing: n }).waitForStop());
      }), yield Promise.all(r);
    });
  }
  /**
   * Hides series's data item.
   *
   * @param   dataItem  Data item
   * @param   duration  Animation duration in milliseconds
   * @return            Promise
   */
  hideDataItem(e, t) {
    const s = Object.create(null, {
      hideDataItem: { get: () => super.hideDataItem }
    });
    return Ze(this, void 0, void 0, function* () {
      const r = [s.hideDataItem.call(this, e, t)], n = this.states.create("hidden", {});
      S(t) || (t = n.get("stateAnimationDuration", this.get("stateAnimationDuration", 0)));
      const a = n.get("stateAnimationEasing", this.get("stateAnimationEasing")), o = this.get("xAxis"), l = this.get("yAxis"), u = this.get("baseAxis"), h = this.get("stacked");
      if ((u === o || !u) && w(this._valueYFields, (c) => {
        let f = l.getPrivate("min"), d = l.baseValue();
        S(f) && f > d && (d = f), h && (d = 0), e.get(c) != null && r.push(e.animate({ key: c + "Working", to: d, duration: t, easing: a }).waitForStop());
      }), u === l || !u) {
        let c = o.getPrivate("min"), f = o.baseValue();
        S(c) && c > f && (f = c), h && (f = 0), w(this._valueXFields, (d) => {
          e.get(d) != null && r.push(e.animate({ key: d + "Working", to: f, duration: t, easing: a }).waitForStop());
        });
      }
      yield Promise.all(r);
    });
  }
  _markDirtyStack() {
    this._stackDirty = !0, this.markDirty(), this._markStakedDirtyStack();
  }
  _markStakedDirtyStack() {
    const e = this._stackedSeries;
    e && ye(e, (t, s) => {
      s._stackDirty || s._markDirtyStack();
    });
  }
  _afterChanged() {
    super._afterChanged(), this._skipped && (this._markDirtyAxes(), this._skipped = !1);
  }
  /**
   * Shows a tooltip for specific data item.
   *
   * @param  dataItem  Data item
   */
  showDataItemTooltip(e) {
    this.updateLegendMarker(e), this.updateLegendValue(e);
    const t = this.get("tooltip");
    if (t) {
      if (this.isHidden())
        this.hideTooltip();
      else if (t._setDataItem(e), e) {
        let s = this.get("locationX", 0), r = this.get("locationY", 1), n = e.get("locationX", s), a = e.get("locationY", r);
        const o = this.get("xAxis"), l = this.get("yAxis"), u = this.get("vcx", 1), h = this.get("vcy", 1), c = o.getDataItemPositionX(e, this._tooltipFieldX, this._aLocationX0 + (this._aLocationX1 - this._aLocationX0) * n, u), f = l.getDataItemPositionY(e, this._tooltipFieldY, this._aLocationY0 + (this._aLocationY1 - this._aLocationY0) * a, h), d = this.getPoint(c, f);
        let g = !0;
        if (w(this._valueFields, (p) => {
          e.get(p) == null && (g = !1);
        }), g) {
          const p = this.chart;
          p && p.inPlot(d) ? (t.label.text.markDirtyText(), t.set("tooltipTarget", this._getTooltipTarget(e)), t.set("pointTo", this._display.toGlobal({ x: d.x, y: d.y }))) : t._setDataItem(void 0);
        } else
          t._setDataItem(void 0);
      }
    }
  }
  hideTooltip() {
    const e = this.get("tooltip");
    return e && e.set("tooltipTarget", this), super.hideTooltip();
  }
  _getTooltipTarget(e) {
    if (this.get("seriesTooltipTarget") == "bullet") {
      const t = e.bullets;
      if (t && t.length > 0) {
        const r = t[0].get("sprite");
        if (r)
          return r;
      }
    }
    return this;
  }
  /**
   * @ignore
   */
  updateLegendValue(e) {
    const t = this.get("legendDataItem");
    if (t) {
      const s = t.get("label");
      if (s) {
        let n = "";
        e ? (s._setDataItem(e), n = this.get("legendLabelText", s.get("text", this.get("name", "")))) : (s._setDataItem(this._emptyDataItem), n = this.get("legendRangeLabelText", this.get("legendLabelText", s.get("text", this.get("name", ""))))), s.set("text", n);
      }
      const r = t.get("valueLabel");
      if (r) {
        let n = "";
        e ? (r._setDataItem(e), n = this.get("legendValueText", r.get("text", ""))) : (r._setDataItem(this._emptyDataItem), n = this.get("legendRangeValueText", r.get("text", ""))), r.set("text", n);
      }
    }
  }
  _getItemReaderLabel() {
    let e = "X: {" + this._xField;
    return this.get("xAxis").isType("DateAxis") && (e += ".formatDate()"), e += "}; Y: {" + this._yField, this.get("yAxis").isType("DateAxis") && (e += ".formatDate()"), e += "}", e;
  }
  /**
   * @ignore
   */
  getPoint(e, t) {
    let s = this.get("xAxis").get("renderer").positionToCoordinate(e), r = this.get("yAxis").get("renderer").positionToCoordinate(t), n = 999999999;
    return r < -n && (r = -n), r > n && (r = n), s < -n && (s = -n), s > n && (s = n), { x: s, y: r };
  }
  _shouldInclude(e) {
    return !0;
  }
  /**
   * @ignore
   */
  handleCursorHide() {
    this.hideTooltip(), this.updateLegendValue(void 0), this.updateLegendMarker(void 0);
  }
  _afterDataChange() {
    super._afterDataChange(), this.get("xAxis")._markDirtyKey("start"), this.get("yAxis")._markDirtyKey("start"), this.resetExtremes();
  }
  // todo description
  resetExtremes() {
    this.setPrivate("selectionMinX", void 0), this.setPrivate("selectionMaxX", void 0), this.setPrivate("selectionMinY", void 0), this.setPrivate("selectionMaxY", void 0), this.setPrivate("minX", void 0), this.setPrivate("minY", void 0), this.setPrivate("maxX", void 0), this.setPrivate("maxY", void 0);
  }
  /**
   * Creates and returns an axis range object.
   *
   * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/axis-ranges/} for more info
   * @param   axisDataItem  Axis data item
   * @return                Axis range
   */
  createAxisRange(e) {
    return this.axisRanges.push({
      axisDataItem: e
    });
  }
  /**
   * A list of series's main (ungrouped) data items.
   *
   * @return  Data items
   */
  get mainDataItems() {
    return this._mainDataItems;
  }
}
Object.defineProperty(is, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "XYSeries"
});
Object.defineProperty(is, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: gi.classNames.concat([is.className])
});
class ss extends is {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_ph", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_pw", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    });
  }
  _makeGraphics(e, t) {
    return this.makeColumn(t, e);
  }
  _makeFieldNames() {
    super._makeFieldNames();
    const e = this.get("xAxis"), t = this.get("yAxis"), s = "CategoryAxis", r = "ValueAxis";
    e.isType(s) && (this.get("openCategoryXField") || (this._xOpenField = this._xField)), e.isType(r) && (this.get("openValueXField") || (this._xOpenField = this._xField)), t.isType(s) && (this.get("openCategoryYField") || (this._yOpenField = this._yField)), t.isType(r) && (this.get("openValueYField") || (this._yOpenField = this._yField));
  }
  _prepareChildren() {
    super._prepareChildren();
    const e = this.get("xAxis"), t = this.get("yAxis"), s = this.dataItems.length, r = Math.max(0, this.startIndex() - 2), n = Math.min(this.endIndex() + 2, s - 1);
    if (e.inited && t.inited)
      for (let a = r; a <= n; a++) {
        let o = this.dataItems[a];
        this._createGraphics(o);
      }
  }
  _updateChildren() {
    const e = this.chart;
    e && (this._ph = e.plotContainer.height(), this._pw = e.plotContainer.width());
    const t = this.get("xAxis"), s = this.get("yAxis"), r = this.get("baseAxis"), n = this.columns.template;
    this.isDirty("fill") && n.get("fill") == null && n.set("fill", this.get("fill")), this.isDirty("stroke") && n.get("stroke") == null && n.set("stroke", this.get("stroke"));
    let a = 0, o = 0, l = 0;
    w(r.series, (m) => {
      if (m instanceof ss) {
        const v = m.get("stacked");
        v && l == 0 && o++, !v && m.get("clustered") && o++;
      }
      m === this && (a = o - 1), l++;
    }), this.get("clustered") || (a = 0, o = 1), o === 0 && (o = 1, a = 0);
    const u = t.get("renderer"), h = s.get("renderer"), c = "cellStartLocation", f = "cellEndLocation", d = u.get(c, 0), g = u.get(f, 1), p = h.get(c, 0), _ = h.get(f, 1);
    if (this._aLocationX0 = d + a / o * (g - d), this._aLocationX1 = d + (a + 1) / o * (g - d), this._aLocationY0 = p + a / o * (_ - p), this._aLocationY1 = p + (a + 1) / o * (_ - p), t.inited && s.inited) {
      if (this._axesDirty || this._valuesDirty || this._stackDirty || this.isDirty("vcx") || this.isDirty("vcy") || this._sizeDirty) {
        const m = this.dataItems.length;
        let v = Math.max(0, this.startIndex() - 2), b = Math.min(this.endIndex() + 2, m - 1);
        for (let x = 0; x < v; x++)
          this._toggleColumn(this.dataItems[x], !1);
        let y = this.dataItems[v];
        for (let x = v; x <= b; x++) {
          let D = this.dataItems[x];
          if (D.get("valueX") != null && D.get("valueY") != null) {
            if (y = D, x > 0 && v > 0)
              for (let A = x - 1; A >= 0; A--) {
                let C = this.dataItems[A];
                if (C.get("valueX") != null && C.get("valueY") != null) {
                  y = C;
                  break;
                }
              }
            break;
          } else
            this._toggleColumn(D, !1);
        }
        for (let x = v; x <= b; x++) {
          let D = this.dataItems[x];
          this._updateGraphics(D, y), D.get("valueX") != null && D.get("valueY") != null && (y = D);
        }
        for (let x = b + 1; x < m; x++)
          this._toggleColumn(this.dataItems[x], !1);
      }
    } else
      this._skipped = !0;
    this.updateLegendMarker(this.get("tooltipDataItem")), super._updateChildren();
  }
  _createGraphics(e) {
    let t = e.get("graphics");
    if (!t) {
      t = this._makeGraphics(this.columns, e), e.set("graphics", t), t._setDataItem(e);
      const s = e.get("legendDataItem");
      if (s) {
        const r = s.get("markerRectangle");
        r && r.setAll({ fill: t.get("fill"), stroke: t.get("stroke") });
      }
      this.axisRanges.each((r) => {
        const n = r.container, a = e.get("rangeGraphics", []);
        e.set("rangeGraphics", a);
        const o = this._makeGraphics(r.columns, e);
        a.push(o), o.setPrivate("list", r.columns), n.children.push(o);
      });
    }
  }
  _updateGraphics(e, t) {
    let s = e.get("graphics");
    const r = this._xField, n = this._yField, a = e.get(r), o = e.get(n);
    if (a != null && o != null) {
      const l = this._xOpenField, u = this._yOpenField, h = this.get("locationX", e.get("locationX", 0.5)), c = this.get("locationY", e.get("locationY", 0.5)), f = this.get("openLocationX", e.get("openLocationX", h)), d = this.get("openLocationY", e.get("openLocationY", c)), g = s.get("width"), p = s.get("height"), _ = this.get("stacked"), m = this.get("xAxis"), v = this.get("yAxis"), b = this.get("baseAxis"), y = m.get("start"), x = m.get("end"), D = v.get("start"), A = v.get("end");
      let C, O, T, L, j = this.get("vcy", 1), N = this.get("vcx", 1), ee = !1, z = !1;
      if (v.isType("CategoryAxis") && m.isType("CategoryAxis")) {
        let $ = this._aLocationX0 + f - 0.5, Z = this._aLocationX1 + h - 0.5;
        if (g instanceof ae) {
          let B = (Z - $) * (1 - g.value) / 2;
          $ += B, Z -= B;
        }
        if (C = m.getDataItemPositionX(e, l, $, N), O = m.getDataItemPositionX(e, r, Z, N), $ = this._aLocationY0 + d - 0.5, Z = this._aLocationY1 + c - 0.5, p instanceof ae) {
          let B = (Z - $) * (1 - p.value) / 2;
          $ += B, Z -= B;
        }
        T = v.getDataItemPositionY(e, u, $, j), L = v.getDataItemPositionY(e, n, Z, j), e.setRaw("point", { x: C + (O - C) / 2, y: T + (L - T) / 2 });
      } else if (m === b) {
        let $ = this._aLocationX0 + f - 0.5, Z = this._aLocationX1 + h - 0.5;
        if (g instanceof ae) {
          let B = (Z - $) * (1 - g.value) / 2;
          $ += B, Z -= B;
        }
        if (C = m.getDataItemPositionX(e, l, $, N), O = m.getDataItemPositionX(e, r, Z, N), T = v.getDataItemPositionY(e, n, c, j), this._yOpenField !== this._yField)
          L = v.getDataItemPositionY(e, u, d, j);
        else if (_) {
          let B = e.get("stackToItemY");
          B ? L = v.getDataItemPositionY(B, n, d, B.component.get("vcy")) : L = v.basePosition();
        } else
          L = v.basePosition();
        e.setRaw("point", { x: C + (O - C) / 2, y: T }), z = !0;
      } else if (v === b) {
        let $ = this._aLocationY0 + d - 0.5, Z = this._aLocationY1 + c - 0.5;
        if (p instanceof ae) {
          let B = (Z - $) * (1 - p.value) / 2;
          $ += B, Z -= B;
        }
        if (T = v.getDataItemPositionY(e, u, $, j), L = v.getDataItemPositionY(e, n, Z, j), O = m.getDataItemPositionX(e, r, h, N), this._xOpenField !== this._xField)
          C = m.getDataItemPositionX(e, l, f, N);
        else if (_) {
          let B = e.get("stackToItemX");
          B ? C = m.getDataItemPositionX(B, r, f, B.component.get("vcx")) : C = m.basePosition();
        } else
          C = m.basePosition();
        ee = !0, e.setRaw("point", { x: O, y: T + (L - T) / 2 });
      }
      this._updateSeriesGraphics(e, s, C, O, T, L, ee, z), C < y && O < y || C > x && O > x || T < D && L <= D || T >= A && L > A || Wt(C) || Wt(T) ? this._toggleColumn(e, !1) : this._toggleColumn(e, !0);
      let H = e.get("rangeGraphics");
      H && w(H, ($) => {
        this._updateSeriesGraphics(e, $, C, O, T, L, ee, z);
      }), this._applyGraphicsStates(e, t);
    }
  }
  _updateSeriesGraphics(e, t, s, r, n, a, o, l) {
    const u = t.get("width"), h = t.get("height"), c = t.get("maxWidth"), f = t.get("maxHeight"), d = this.getPoint(s, n), g = this.getPoint(r, a), p = e.get("point");
    if (p) {
      const _ = this.getPoint(p.x, p.y);
      p.x = _.x + this._x, p.y = _.y + this._y;
    }
    if (s = d.x, r = g.x, n = d.y, a = g.y, S(u)) {
      const _ = (r - s - u) / 2;
      s += _, r -= _;
    }
    if (S(c) && c < Math.abs(r - s)) {
      const _ = (r - s - c) / 2;
      s += _, r -= _;
    }
    if (S(h)) {
      const _ = (a - n - h) / 2;
      n += _, a -= _;
    }
    if (S(f) && f < Math.abs(a - n)) {
      const _ = (a - n - f) / 2;
      n += _, a -= _;
    }
    this.get("adjustBulletPosition") && (o && (r = Math.min(Math.max(0, r), this._pw), s = Math.min(Math.max(0, s), this._pw)), l && (n = Math.min(Math.max(0, n), this._ph), a = Math.min(Math.max(0, a), this._ph))), e.setRaw("left", s), e.setRaw("right", r), e.setRaw("top", n), e.setRaw("bottom", a), t.setPrivate("width", r - s), t.setPrivate("height", a - n), t.set("x", s), t.set("y", a - (a - n));
  }
  _handleDataSetChange() {
    super._handleDataSetChange(), w(this._dataItems, (e) => {
      this._toggleColumn(e, !1);
    });
  }
  _applyGraphicsStates(e, t) {
    const s = e.get("graphics"), r = s.states.lookup("dropFromOpen"), n = s.states.lookup("riseFromOpen"), a = s.states.lookup("dropFromPrevious"), o = s.states.lookup("riseFromPrevious");
    if (r || a || n || o) {
      const l = this.get("xAxis"), u = this.get("yAxis"), h = this.get("baseAxis");
      let c, f, d;
      h === l && u.isType("ValueAxis") ? (c = e.get(this._yOpenField), f = e.get(this._yField), d = t.get(this._yField)) : h === u && l.isType("ValueAxis") && (c = e.get(this._xOpenField), f = e.get(this._xField), d = t.get(this._xField)), S(c) && S(f) && (f < c ? r && r.apply() : n && n.apply(), S(d) && (f < d ? a && a.apply() : o && o.apply()));
    }
  }
  /**
   * @ignore
   */
  disposeDataItem(e) {
    super.disposeDataItem(e);
    const t = e.get("graphics");
    t && (this.columns.removeValue(t), t.dispose());
    const s = e.get("rangeGraphics");
    s && w(s, (r) => {
      const n = r.getPrivate("list");
      n && n.removeValue(r), r.dispose();
    });
  }
  /**
   * Hides series's data item.
   *
   * @param   dataItem  Data item
   * @param   duration  Animation duration in milliseconds
   * @return            Promise
   */
  hideDataItem(e, t) {
    const s = Object.create(null, {
      hideDataItem: { get: () => super.hideDataItem }
    });
    return Ze(this, void 0, void 0, function* () {
      const r = [s.hideDataItem.call(this, e, t)], n = e.get("graphics");
      n && r.push(n.hide(t));
      const a = e.get("rangeGraphics");
      a && w(a, (o) => {
        r.push(o.hide(t));
      }), yield Promise.all(r);
    });
  }
  _toggleColumn(e, t) {
    const s = e.get("graphics");
    s && s.setPrivate("visible", t);
    const r = e.get("rangeGraphics");
    r && w(r, (a) => {
      a.setPrivate("visible", t);
    });
    const n = e.bullets;
    n && w(n, (a) => {
      a.setPrivate("hidden", !t);
    });
  }
  /**
   * Shows series's data item.
   *
   * @param   dataItem  Data item
   * @param   duration  Animation duration in milliseconds
   * @return            Promise
   */
  showDataItem(e, t) {
    const s = Object.create(null, {
      showDataItem: { get: () => super.showDataItem }
    });
    return Ze(this, void 0, void 0, function* () {
      const r = [s.showDataItem.call(this, e, t)], n = e.get("graphics");
      n && r.push(n.show(t));
      const a = e.get("rangeGraphics");
      a && w(a, (o) => {
        r.push(o.show(t));
      }), yield Promise.all(r);
    });
  }
  /**
   * @ignore
   */
  updateLegendMarker(e) {
    let t = this.get("legendDataItem");
    if (this.get("useLastColorForLegendMarker") && !e) {
      const s = this.dataItems[this.endIndex() - 1];
      s && (e = s);
    }
    if (t) {
      let s = this.columns.template;
      if (e) {
        let n = e.get("graphics");
        n && (s = n);
      }
      const r = t.get("markerRectangle");
      r && (t.get("itemContainer").get("disabled") || w(fp, (n) => {
        r.set(n, s.get(n, this.get(n)));
      }));
    }
  }
  _getTooltipTarget(e) {
    if (this.get("seriesTooltipTarget") == "bullet")
      return super._getTooltipTarget(e);
    let t = e.get("graphics");
    return t || this;
  }
}
Object.defineProperty(ss, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "BaseColumnSeries"
});
Object.defineProperty(ss, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: is.classNames.concat([ss.className])
});
class rs extends Qi {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_series", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_isPanning", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "labelsContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.children.push(G.new(this._root, {}))
    }), Object.defineProperty(this, "gridContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: G.new(this._root, { width: R, height: R })
    }), Object.defineProperty(this, "topGridContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: G.new(this._root, { width: R, height: R })
    }), Object.defineProperty(this, "bulletsContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.children.push(G.new(this._root, { isMeasured: !1, width: R, height: R, position: "absolute" }))
    }), Object.defineProperty(this, "chart", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_rangesDirty", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_panStart", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_panEnd", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), Object.defineProperty(this, "_sAnimation", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_eAnimation", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_skipSync", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "axisRanges", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new Pr()
    }), Object.defineProperty(this, "_seriesAxisRanges", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "ghostLabel", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_cursorPosition", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: -1
    }), Object.defineProperty(this, "_snapToSeries", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_seriesValuesDirty", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "axisHeader", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.children.push(G.new(this._root, {
        themeTags: ["axis", "header"],
        position: "absolute",
        background: gt.new(this._root, {
          themeTags: ["header", "background"],
          fill: this._root.interfaceColors.get("background")
        })
      }))
    }), Object.defineProperty(this, "_bullets", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    });
  }
  _dispose() {
    this.gridContainer.dispose(), this.topGridContainer.dispose(), this.bulletsContainer.dispose(), this.labelsContainer.dispose(), this.axisHeader.dispose(), super._dispose();
  }
  _afterNew() {
    super._afterNew(), this.setPrivate("updateScrollbar", !0), this._disposers.push(this.axisRanges.events.onAll((t) => {
      if (t.type === "clear")
        w(t.oldValues, (s) => {
          this.disposeDataItem(s);
        });
      else if (t.type === "push")
        this._processAxisRange(t.newValue, ["range"]);
      else if (t.type === "setIndex")
        this._processAxisRange(t.newValue, ["range"]);
      else if (t.type === "insertIndex")
        this._processAxisRange(t.newValue, ["range"]);
      else if (t.type === "removeIndex")
        this.disposeDataItem(t.oldValue);
      else if (t.type === "moveIndex")
        this._processAxisRange(t.value, ["range"]);
      else
        throw new Error("Unknown IStreamEvent type");
    }));
    const e = this.get("renderer");
    e && (e.axis = this, e.processAxis()), this.children.push(e), this.ghostLabel = e.makeLabel(new ti(this, void 0, {}), []), this.ghostLabel.adapters.disable("text"), this.ghostLabel.setAll({ opacity: 0, tooltipText: void 0, tooltipHTML: void 0, interactive: !1 }), this.ghostLabel.events.disable();
  }
  _updateFinals(e, t) {
  }
  /**
   * Zooms the axis to relative locations.
   *
   * Both `start` and `end` are relative: 0 means start of the axis, 1 - end.
   *
   * @param   start     Relative start
   * @param   end       Relative end
   * @param   duration  Duration of the zoom animation in milliseconds
   * @return            Zoom animation
   */
  zoom(e, t, s, r) {
    if (this._updateFinals(e, t), this.get("start") !== e || this.get("end") != t) {
      let n = this._sAnimation, a = this._eAnimation, o = this.get("maxDeviation", 0.5) * Math.min(1, t - e);
      e < -o && (e = -o), t > 1 + o && (t = 1 + o), e > t && ([e, t] = [t, e]), S(s) || (s = this.get("interpolationDuration", 0)), r || (r = "end");
      let l = this.getPrivate("maxZoomFactor", this.get("maxZoomFactor", 100)), u = l;
      t === 1 && e !== 0 && (e < this.get("start") ? r = "start" : r = "end"), e === 0 && t !== 1 && (t > this.get("end") ? r = "end" : r = "start");
      let h = this.get("minZoomCount"), c = this.get("maxZoomCount");
      S(h) && (l = u / h);
      let f = 1;
      if (S(c) && (f = u / c), r === "start" ? (c > 0 && 1 / (t - e) < f && (t = e + 1 / f), 1 / (t - e) > l && (t = e + 1 / l), t > 1 && t - e < 1 / l && (e = t - 1 / l)) : (c > 0 && 1 / (t - e) < f && (e = t - 1 / f), 1 / (t - e) > l && (e = t - 1 / l), e < 0 && t - e < 1 / l && (t = e + 1 / l)), 1 / (t - e) > l && (t = e + 1 / l), 1 / (t - e) > l && (e = t - 1 / l), c != null && h != null && e == this.get("start") && t == this.get("end")) {
        const d = this.chart;
        d && d._handleAxisSelection(this, !0);
      }
      if ((n && n.playing && n.to == e || this.get("start") == e) && (a && a.playing && a.to == t || this.get("end") == t))
        return;
      if (s > 0) {
        let d = this.get("interpolationEasing"), g, p;
        if (this.get("start") != e && (g = this.animate({ key: "start", to: e, duration: s, easing: d })), this.get("end") != t && (p = this.animate({ key: "end", to: t, duration: s, easing: d })), this._sAnimation = g, this._eAnimation = p, g)
          return g;
        if (p)
          return p;
      } else
        this.set("start", e), this.set("end", t), this._root.events.once("frameended", () => {
          this._markDirtyKey("start"), this._root._markDirty();
        });
    } else
      this._sAnimation && this._sAnimation.stop(), this._eAnimation && this._eAnimation.stop();
  }
  /**
   * A list of series using this axis.
   *
   * @return Series
   */
  get series() {
    return this._series;
  }
  _processAxisRange(e, t) {
    e.setRaw("isRange", !0), this._createAssets(e, t), this._rangesDirty = !0, this._prepareDataItem(e);
    const s = e.get("above"), r = this.topGridContainer, n = e.get("grid");
    s && n && r.children.moveValue(n);
    const a = e.get("axisFill");
    s && a && r.children.moveValue(a);
  }
  _prepareDataItem(e, t) {
  }
  /**
   * @ignore
   */
  markDirtyExtremes() {
  }
  /**
   * @ignore
   */
  markDirtySelectionExtremes() {
  }
  _calculateTotals() {
  }
  _updateAxisRanges() {
    this._bullets = {}, this.axisRanges.each((e) => {
      this._prepareDataItem(e);
    }), w(this._seriesAxisRanges, (e) => {
      this._prepareDataItem(e);
    });
  }
  _prepareChildren() {
    if (super._prepareChildren(), this.get("fixAxisSize") ? this.ghostLabel.set("visible", !0) : this.ghostLabel.set("visible", !1), this.isDirty("start") || this.isDirty("end")) {
      this.chart._updateCursor();
      let t = this.get("start", 0), s = this.get("end", 1), r = this.get("maxDeviation", 0.5) * Math.min(1, s - t);
      if (t < -r) {
        let n = t + r;
        t = -r, this.setRaw("start", t), this.isDirty("end") && this.setRaw("end", s - n);
      }
      if (s > 1 + r) {
        let n = s - 1 - r;
        s = 1 + r, this.setRaw("end", s), this.isDirty("start") && this.setRaw("start", t - n);
      }
    }
    const e = this.get("renderer");
    if (e._start = this.get("start"), e._end = this.get("end"), e._inversed = e.get("inversed", !1), e._axisLength = e.axisLength() / (e._end - e._start), e._updateLC(), this.isDirty("tooltip")) {
      const t = this.get("tooltip");
      if (t) {
        const s = e.get("themeTags");
        t.addTag("axis"), t.addTag(this.className.toLowerCase()), t._applyThemes(), s && (t.set("themeTags", se(t.get("themeTags"), s)), t.label._applyThemes());
      }
    }
  }
  _updateTooltipBounds() {
    const e = this.get("tooltip");
    e && this.get("renderer").updateTooltipBounds(e);
  }
  _updateBounds() {
    super._updateBounds(), this._updateTooltipBounds();
  }
  /**
   * @ignore
   */
  processChart(e) {
    this.chart = e;
    const t = this.get("renderer");
    t.chart = e, e.gridContainer.children.push(this.gridContainer), e.topGridContainer.children.push(this.topGridContainer), e.axisHeadersContainer.children.push(this.axisHeader), this.on("start", () => {
      e._handleAxisSelection(this);
    }), this.on("end", () => {
      e._handleAxisSelection(this);
    }), e.plotContainer.onPrivate("width", () => {
      this.markDirtySize();
    }), e.plotContainer.onPrivate("height", () => {
      this.markDirtySize();
    }), e.processAxis(this);
  }
  /**
   * @ignore
   */
  hideDataItem(e) {
    return this._toggleDataItem(e, !1), super.hideDataItem(e);
  }
  /**
   * @ignore
   */
  showDataItem(e) {
    return this._toggleDataItem(e, !0), super.showDataItem(e);
  }
  _toggleDataItem(e, t) {
    const s = e.get("label");
    s && s.setPrivate("visible", t);
    const r = e.get("grid");
    r && r.setPrivate("visible", t);
    const n = e.get("tick");
    n && n.setPrivate("visible", t);
    const a = e.get("axisFill");
    a && a.setPrivate("visible", t);
    const o = e.get("bullet");
    if (o) {
      const l = o.get("sprite");
      l && l.setPrivate("visible", t);
    }
  }
  _createAssets(e, t) {
    const s = this.get("renderer");
    e.get("label") || s.makeLabel(e, t), e.get("grid") || s.makeGrid(e, t), e.get("tick") || s.makeTick(e, t), e.get("axisFill") || s.makeAxisFill(e, t), this._processBullet(e);
  }
  _processBullet(e) {
    let t = e.get("bullet"), s = this.get("bullet");
    if (!t && s && !e.get("isRange") && (t = s(this._root, this, e)), t) {
      t.axis = this;
      const r = t.get("sprite");
      r && (r._setDataItem(e), e.setRaw("bullet", t), r.parent || this.bulletsContainer.children.push(r));
    }
  }
  _afterChanged() {
    super._afterChanged();
    const e = this.chart;
    e && (e._updateChartLayout(), e.axisHeadersContainer.markDirtySize()), this.get("renderer")._updatePositions();
  }
  /**
   * @ignore
   */
  disposeDataItem(e) {
    super.disposeDataItem(e);
    const t = this.get("renderer"), s = e.get("label");
    s && (t.labels.removeValue(s), s.dispose());
    const r = e.get("tick");
    r && (t.ticks.removeValue(r), r.dispose());
    const n = e.get("grid");
    n && (t.grid.removeValue(n), n.dispose());
    const a = e.get("axisFill");
    a && (t.axisFills.removeValue(a), a.dispose());
    const o = e.get("bullet");
    o && o.dispose();
  }
  _updateGhost() {
    this.setPrivate("cellWidth", this.getCellWidthPosition() * this.get("renderer").axisLength());
    const e = this.ghostLabel;
    if (!e.isHidden()) {
      const r = e.localBounds(), n = r.right - r.left;
      let a = e.get("text");
      w(this.dataItems, (o) => {
        const l = o.get("label");
        if (l && !l.isHidden()) {
          const u = l.localBounds();
          u.right - u.left > n && (a = l.text._getText());
        }
      }), e.set("text", a);
    }
    let t = this.get("start", 0), s = this.get("end", 1);
    this.get("renderer").updateLabel(e, t + (s - t) * 0.5);
  }
  _handleCursorPosition(e, t) {
    e = this.get("renderer").toAxisPosition(e), this._cursorPosition = e, this._snapToSeries = t, this.updateTooltip();
  }
  /**
   * Can be called when axis zoom changes and you need to update tooltip
   * position.
   */
  updateTooltip() {
    const e = this._snapToSeries;
    let t = this._cursorPosition;
    const s = this.get("tooltip"), r = this.get("renderer");
    S(t) && (w(this.series, (n) => {
      if (n.get("baseAxis") === this) {
        const a = this.getSeriesItem(n, t, this.get("tooltipLocation"));
        n.setRaw("tooltipDataItem", a), e && e.indexOf(n) != -1 ? (n.updateLegendMarker(a), n.updateLegendValue(a)) : n.showDataItemTooltip(a);
      }
    }), s && (r.updateTooltipBounds(s), this.get("snapTooltip") && (t = this.roundAxisPosition(t, this.get("tooltipLocation", 0.5))), Wt(t) ? s.hide(0) : (this.setPrivateRaw("tooltipPosition", t), this._updateTooltipText(s, t), r.positionTooltip(s, t), t < this.get("start") || t > this.get("end") ? s.hide(0) : s.show(0))));
  }
  _updateTooltipText(e, t) {
    e.label.set("text", this.getTooltipText(t));
  }
  /**
   * @ignore
   */
  roundAxisPosition(e, t) {
    return e;
  }
  /**
   * @ignore
   */
  handleCursorShow() {
    let e = this.get("tooltip");
    e && e.show();
  }
  /**
   * @ignore
   */
  handleCursorHide() {
    let e = this.get("tooltip");
    e && e.hide();
  }
  /**
   * @ignore
   */
  processSeriesDataItem(e, t) {
  }
  _clearDirty() {
    super._clearDirty(), this._sizeDirty = !1, this._rangesDirty = !1;
  }
  /**
   * Converts pixel coordinate to a relative position on axis.
   *
   * @param   coordinate  Coordinate
   * @return              Relative position
   */
  coordinateToPosition(e) {
    const t = this.get("renderer");
    return t.toAxisPosition(e / t.axisLength());
  }
  /**
   * Converts relative position of the plot area to relative position of the
   * axis with zoom taken into account.
   *
   * @param position Position
   * @return Relative position
   */
  toAxisPosition(e) {
    return this.get("renderer").toAxisPosition(e);
  }
  /**
   * Adjusts position with inversed taken into account.
   *
   * @ignore
   */
  fixPosition(e) {
    return this.get("renderer").fixPosition(e);
  }
  /**
   * @ignore
   */
  shouldGap(e, t, s, r) {
    return !1;
  }
  /**
   * Creates and returns an axis range object.
   *
   * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/axis-ranges/} for more info
   * @param   axisDataItem  Axis data item
   * @return                Axis range
   */
  createAxisRange(e) {
    return this.axisRanges.push(e);
  }
  /**
   * @ignore
   */
  _groupSeriesData(e) {
  }
  /**
   * Returns relative position between two grid lines of the axis.
   *
   * @return Position
   */
  getCellWidthPosition() {
    return 0.05;
  }
}
Object.defineProperty(rs, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Axis"
});
Object.defineProperty(rs, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Qi.classNames.concat([rs.className])
});
class Mi extends rs {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_frequency", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), Object.defineProperty(this, "_itemMap", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    });
  }
  _afterNew() {
    this._settings.themeTags = se(this._settings.themeTags, ["axis"]), this.fields.push("category"), this.setPrivateRaw("name", "category"), this.addTag("category"), super._afterNew();
  }
  _prepareChildren() {
    super._prepareChildren();
    const e = this.dataItems.length;
    let t = 0;
    this._valuesDirty && (this._itemMap = {}, w(this.dataItems, (s) => {
      s.setRaw("index", t), this._itemMap[s.get("category")] = s, t++;
    }), this.setPrivateRaw("maxZoomFactor", e)), this.setPrivateRaw("startIndex", Math.max(Math.round(this.get("start", 0) * e), 0)), this.setPrivateRaw("endIndex", Math.min(Math.round(this.get("end", 1) * e), e)), (this._sizeDirty || this._valuesDirty || this.isDirty("start") || this.isDirty("end") || this.isPrivateDirty("endIndex") || this.isPrivateDirty("startIndex") || this.isPrivateDirty("width") || this.isPrivateDirty("height")) && this.dataItems.length > 0 && (this._handleRangeChange(), this._prepareAxisItems(), this._updateAxisRanges());
  }
  _handleRangeChange() {
    w(this.series, (e) => {
      let t = this.dataItems[this.startIndex()].get("category"), s = this.dataItems[this.endIndex() - 1].get("category"), r = e.get("baseAxis"), n = e.get("xAxis"), a = e.get("yAxis");
      if (n instanceof Mi && a instanceof Mi)
        e._markDirtyAxes();
      else if (r === this) {
        let o, l, u = a;
        if (n === r ? (e.get("categoryXField") && (o = "categoryX"), e.get("openCategoryXField") && (l = "openCategoryX")) : a === r && (e.get("categoryYField") && (o = "categoryY"), e.get("openCategoryYField") && (l = "openCategoryY"), u = n), u.className == "ValueAxis" && (o || l)) {
          let h, c;
          for (let p = 0, _ = e.dataItems.length; p < _; p++) {
            let m = e.dataItems[p];
            if (o && m.get(o) === t) {
              h = m;
              break;
            }
            if (l && m.get(l) === t) {
              h = m;
              break;
            }
          }
          for (let p = e.dataItems.length - 1; p >= 0; p--) {
            let _ = e.dataItems[p];
            if (o && _.get(o) === s) {
              c = _;
              break;
            }
            if (l && _.get(l) === s) {
              c = _;
              break;
            }
          }
          let f = 0, d = e.dataItems.length;
          h && (f = e.dataItems.indexOf(h)), c && (d = e.dataItems.indexOf(c) + 1), e.setPrivate("startIndex", f), e.setPrivate("endIndex", d);
          let g = !1;
          for (let p = f; p < d; p++) {
            const _ = e.dataItems[p];
            if (w(e.__valueXShowFields, (m) => {
              _.get(m) != null && (g = !0);
            }), w(e.__valueYShowFields, (m) => {
              _.get(m) != null && (g = !0);
            }), g)
              break;
          }
          e.setPrivate("outOfSelection", !g);
        }
        e._markDirtyAxes();
      }
    });
  }
  _prepareAxisItems() {
    const e = this.get("renderer"), t = this.dataItems.length;
    let s = this.startIndex();
    s > 0 && s--;
    let r = this.endIndex();
    r < t && r++;
    let n = e.axisLength() / Math.max(e.get("minGridDistance"), 1 / Number.MAX_SAFE_INTEGER), a = Math.max(1, Math.min(t, Math.ceil((r - s) / n)));
    s = Math.floor(s / a) * a, this._frequency = a;
    for (let l = 0; l < t; l++)
      this.dataItems[l].hide();
    let o = this.dataItems[s].get("index", 0);
    for (let l = s; l < r; l = l + a) {
      let u = this.dataItems[l];
      this._createAssets(u, []), u.isHidden() && u.show(), this._prepareDataItem(u, o, a), o++;
    }
    this._updateGhost();
  }
  _prepareDataItem(e, t, s) {
    let r = this.get("renderer"), n = e.get("categoryLocation", 0), a = e.get("endCategoryLocation", 1), o = e.get("index");
    S(o) || (o = this.categoryToIndex(e.get("category")));
    let l = this.indexToPosition(o, n), u = e.get("endCategory"), h;
    u ? (h = this.categoryToIndex(u), S(h) || (h = o)) : h = o;
    let c = this.indexToPosition(h, a), f, d;
    e.get("isRange") ? f = h : f = o + this._frequency - 1, d = this.indexToPosition(f, a), r.updateLabel(e.get("label"), l, c, s), r.updateGrid(e.get("grid"), l, c), r.updateTick(e.get("tick"), l, c, s), r.updateFill(e.get("axisFill"), l, d), this._processBullet(e), r.updateBullet(e.get("bullet"), l, c);
    const g = this.get("fillRule");
    g && g(e, t);
  }
  startIndex() {
    let e = this.dataItems.length;
    return Math.min(Math.max(this.getPrivate("startIndex", 0), 0), e - 1);
  }
  endIndex() {
    let e = this.dataItems.length;
    return Math.max(1, Math.min(this.getPrivate("endIndex", e), e));
  }
  /**
   * @ignore
   */
  baseValue() {
  }
  /**
   * @ignore
   */
  basePosition() {
    return 0;
  }
  /**
   * Returns X coordinate in pixels corresponding to specific category index.
   *
   * @param   value  Index
   * @return         X coordinate
   */
  getX(e) {
    let t = this._itemMap[e];
    return t ? this._settings.renderer.positionToCoordinate(this.indexToPosition(t.get("index", 0))) : NaN;
  }
  /**
   * Returns Y coordinate in pixels corresponding to specific category index.
   *
   * @param   value  Index
   * @return         Y coordinate
   */
  getY(e) {
    let t = this._itemMap[e];
    return t ? this._settings.renderer.positionToCoordinate(this.indexToPosition(t.get("index", 0))) : NaN;
  }
  /**
   * @ignore
   */
  getDataItemPositionX(e, t, s, r) {
    const n = e.get(t), a = this._itemMap[n];
    return a ? this.indexToPosition(a.get("index", 0), s) : NaN;
  }
  /**
   * @ignore
   */
  getDataItemCoordinateX(e, t, s, r) {
    return this._settings.renderer.positionToCoordinate(this.getDataItemPositionX(e, t, s, r));
  }
  /**
   * @ignore
   */
  getDataItemPositionY(e, t, s, r) {
    const n = e.get(t), a = this._itemMap[n];
    return a ? this.indexToPosition(a.get("index", 0), s) : NaN;
  }
  /**
   * @ignore
   */
  getDataItemCoordinateY(e, t, s, r) {
    return this._settings.renderer.positionToCoordinate(this.getDataItemPositionY(e, t, s, r));
  }
  /**
   * Converts category index to a relative position.
   *
   * `location` indicates relative position within category: 0 - start, 1 - end.
   *
   * If not set, will use middle (0.5) of the category.
   *
   * @param   index     Index
   * @param   location  Location
   * @return            Index
   */
  indexToPosition(e, t) {
    S(t) || (t = 0.5);
    let s = this.dataItems.length, r = this.get("startLocation", 0), n = this.get("endLocation", 1);
    s -= r, s -= 1 - n;
    let a = (e + t - r) / s, o = this.dataItems[e];
    return o && (a += o.get("deltaPosition", 0)), a;
  }
  /**
   * Returns an index of a category.
   *
   * @param   category  Category to look up
   * @return            Index
   */
  categoryToIndex(e) {
    let t = this._itemMap[e];
    return t ? t.get("index") : NaN;
  }
  /**
   * @ignore
   */
  dataItemToPosition(e) {
    return this.indexToPosition(e.get("index"));
  }
  /**
   * @ignore
   */
  roundAxisPosition(e, t) {
    return e += (0.5 - t) / this.dataItems.length, this.indexToPosition(this.axisPositionToIndex(e), t);
  }
  /**
   * Returns an index of the category that corresponds to specific pixel
   * position within axis.
   *
   * @param position  Position (px)
   * @return Category index
   */
  axisPositionToIndex(e) {
    let t = this.dataItems.length;
    return Re(Math.floor(e * t), 0, t - 1);
  }
  /**
   * Returns text to be used in an axis tooltip for specific relative position.
   *
   * @param   position  Position
   * @return            Tooltip text
   */
  getTooltipText(e, t) {
    const s = this.dataItems[this.axisPositionToIndex(e)];
    if (s) {
      const r = s.get("label");
      if (r)
        return nn(r, this.get("tooltipText", ""));
    }
  }
  _updateTooltipText(e, t) {
    e._setDataItem(this.dataItems[this.axisPositionToIndex(t)]), e.label.text.markDirtyText();
  }
  /**
   * Returns a data item from series that is closest to the `position`.
   *
   * @param   series    Series
   * @param   position  Relative position
   * @return            Data item
   */
  getSeriesItem(e, t) {
    if (this.dataItems.length > 0) {
      let s = this.getPrivate("name") + this.get("renderer").getPrivate("letter"), r = this.axisPositionToIndex(t), n = e.dataItems[r], a = this.dataItems[r], o = a.get("category");
      if (n && a && n.get(s) === o)
        return n;
      for (let l = 0, u = e.dataItems.length; l < u; l++) {
        let h = e.dataItems[l];
        if (h.get(s) === o)
          return h;
      }
    }
  }
  /**
   * Zooms the axis to specific `start` and `end` indexes.
   *
   * Optional `duration` specifies duration of zoom animation in milliseconds.
   *
   * @param  start     Start index
   * @param  end       End index
   * @param  duration  Duration in milliseconds
   */
  zoomToIndexes(e, t, s) {
    let r = this.dataItems.length;
    this.zoom(e / r, t / r, s);
  }
  zoomToCategories(e, t, s) {
    this.zoomToIndexes(this.categoryToIndex(e), this.categoryToIndex(t) + 1, s);
  }
  /**
   * Returns position span between start and end of a single cell in axis.
   *
   * @since 5.2.30
   * @return Position
   */
  getCellWidthPosition() {
    return this._frequency / this.dataItems.length / (this.get("end", 1) - this.get("start", 0));
  }
}
Object.defineProperty(Mi, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "CategoryAxis"
});
Object.defineProperty(Mi, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: rs.classNames.concat([Mi.className])
});
class Ka extends Mi {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_frequency", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), Object.defineProperty(this, "_itemMap", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    });
  }
  _afterNew() {
    this._settings.themeTags = se(this._settings.themeTags, ["axis"]), this.fields.push("category"), super._afterNew();
  }
  _prepareAxisItems() {
    this.setPrivateRaw("baseInterval", this.get("baseInterval"));
    const e = this.get("renderer"), t = this.dataItems.length;
    let s = this.startIndex();
    s > 0 && s--;
    let r = this.endIndex();
    r < t && r++;
    let n = e.axisLength() / Math.max(e.get("minGridDistance"), 1 / Number.MAX_SAFE_INTEGER), a = Math.min(t, Math.ceil((r - s) / n));
    s = Math.floor(s / a) * a, this._frequency = a;
    for (let y = 0; y < t; y++)
      this.dataItems[y].hide();
    let o = Number(this.dataItems[s].get("category")), l = Number(this.dataItems[r - 1].get("category")), u = l - o;
    r - s < n && (u = l - o - ((l - o) / this.baseDuration() - (r - s)) * this.baseDuration());
    let h = dr(0, u, n, this.get("gridIntervals"));
    const c = kn(h.timeUnit), f = this.getPrivate("baseInterval");
    It(h) < this.baseDuration() && (h = Object.assign({}, f));
    const d = this.get("dateFormats");
    let g = -1 / 0, p = -1 / 0, _ = -1 / 0, m, v = [], b = !1;
    for (let y = s; y < r; y++) {
      let x = this.dataItems[y], D = x.get("index"), A = !1, C = Number(x.get("category")), O = new Date(C), T = Cp(O, h.timeUnit);
      m = d[h.timeUnit];
      let L = !1;
      h.timeUnit != "year" && h.timeUnit != "week" && c && this.get("markUnitChange") && S(g) && Pn(C, g, c, this._root.utc) && (m = this.get("periodChangeDateFormats")[h.timeUnit], D - a * 0.5 < p && v.pop(), v.push({ format: m, dataItem: x }), b = !0, L = !0, p = D, _ = T);
      let j = !1;
      h.timeUnit === "day" || h.timeUnit === "week" ? D - p >= a && (j = !0) : T % h.count === 0 && T != _ && (j = !0), !L && j && (D - a * 0.7 < p && b && (A = !0), A || (v.push({ format: m, dataItem: x }), p = D, _ = T), b = !1), g = C;
    }
    if (v.length > 0) {
      let y = v[0].dataItem.get("index", 0);
      w(v, (x) => {
        const D = x.dataItem, A = x.format;
        this._createAssets(D, []), D.isHidden() && D.show();
        let C = Number(D.get("category")), O = new Date(C);
        const T = D.get("label");
        T && T.set("text", this._root.dateFormatter.format(O, A)), y++, this._prepareDataItem(D, y, a);
      });
    }
  }
  /**
   * Returns a duration of currently active `baseInterval` in milliseconds.
   *
   * @return Duration
   */
  baseDuration() {
    return It(this.getPrivate("baseInterval"));
  }
  /**
   * Returns text to be used in an axis tooltip for specific relative position.
   *
   * @param   position  Position
   * @return            Tooltip text
   */
  getTooltipText(e, t) {
    let s = this.dataItems[this.axisPositionToIndex(e)];
    if (s) {
      let r = this.get("dateFormats")[this.getPrivate("baseInterval").timeUnit];
      return this._root.dateFormatter.format(new Date(s.get("category", 0)), this.get("tooltipDateFormat", r));
    }
  }
  _updateTooltipText(e, t) {
    e.label.set("text", this.getTooltipText(t));
  }
}
Object.defineProperty(Ka, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "CategoryDateAxis"
});
Object.defineProperty(Ka, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Mi.classNames.concat([Ka.className])
});
class ns extends rs {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_dirtyExtremes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_dirtySelectionExtremes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_deltaMinMax", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), Object.defineProperty(this, "_minReal", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_maxReal", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_baseValue", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_syncDp", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_minLogAdjusted", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    });
  }
  /**
   * @ignore
   */
  markDirtyExtremes() {
    this._dirtyExtremes = !0, this.markDirty();
  }
  /**
   * @ignore
   */
  markDirtySelectionExtremes() {
    this._dirtySelectionExtremes = !0, this.markDirty();
  }
  _afterNew() {
    this._settings.themeTags = se(this._settings.themeTags, ["axis"]), this.setPrivateRaw("name", "value"), this.addTag("value"), super._afterNew();
  }
  _prepareChildren() {
    if (super._prepareChildren(), this.isDirty("syncWithAxis")) {
      this._prevSettings.syncWithAxis && this._syncDp && this._syncDp.dispose();
      let t = this.get("syncWithAxis");
      t && (this._syncDp = new ut([
        t.onPrivate("selectionMinFinal", () => {
          this._dirtySelectionExtremes = !0;
        }),
        t.onPrivate("selectionMaxFinal", () => {
          this._dirtySelectionExtremes = !0;
        })
      ]));
    }
    (this._sizeDirty || this._dirtyExtremes || this._valuesDirty || this.isPrivateDirty("width") || this.isPrivateDirty("height") || this.isDirty("min") || this.isDirty("max") || this.isDirty("extraMin") || this.isDirty("extraMax") || this.isDirty("logarithmic") || this.isDirty("treatZeroAs") || this.isDirty("baseValue") || this.isDirty("strictMinMax") || this.isDirty("strictMinMaxSelection") || this.isDirty("maxPrecision") || this.isDirty("numberFormat")) && (this._getMinMax(), this.ghostLabel.set("text", ""), this._dirtyExtremes = !1), this._dirtySelectionExtremes && !this._isPanning && this.get("autoZoom", !0) && (this._getSelectionMinMax(), this._dirtySelectionExtremes = !1), this._groupData(), (this._sizeDirty || this._valuesDirty || this.isDirty("start") || this.isDirty("end") || this.isPrivateDirty("min") || this.isPrivateDirty("selectionMax") || this.isPrivateDirty("selectionMin") || this.isPrivateDirty("max") || this.isPrivateDirty("step") || this.isPrivateDirty("width") || this.isPrivateDirty("height") || this.isDirty("logarithmic")) && (this._handleRangeChange(), this._prepareAxisItems(), this._updateAxisRanges()), this._baseValue = this.baseValue();
  }
  _groupData() {
  }
  _formatText(e) {
    const t = this.get("numberFormat"), s = this.getNumberFormatter();
    let r = "";
    return t ? r = s.format(e, t) : r = s.format(e, void 0, this.getPrivate("stepDecimalPlaces")), r;
  }
  _prepareAxisItems() {
    const e = this.getPrivate("min"), t = this.getPrivate("max");
    if (S(e) && S(t)) {
      const s = this.get("logarithmic"), r = this.getPrivate("step"), n = this.getPrivate("selectionMin"), a = this.getPrivate("selectionMax") + r;
      let o = n - r, l = 0, u = 1, h = e;
      if (s) {
        if (o = this._minLogAdjusted, o < n)
          for (; o < n; )
            o += r;
        h = o, h <= 0 && (h = 1, r < 1 && (h = r)), u = Math.log(a - r) * Math.LOG10E - Math.log(h) * Math.LOG10E, u > 2 && (o = Math.pow(10, Math.log(h) * Math.LOG10E - 5));
      }
      let c = -1 / 0;
      for (; o < a; ) {
        let f;
        this.dataItems.length < l + 1 ? (f = new ti(this, void 0, {}), this._dataItems.push(f), this.processDataItem(f)) : f = this.dataItems[l], this._createAssets(f, []), f.isHidden() && f.show(), f.setRaw("value", o);
        const d = f.get("label");
        if (d && d.set("text", this._formatText(o)), this._prepareDataItem(f), s && u > 2 ? o = Math.pow(10, Math.log(h) * Math.LOG10E + l - 5) : o += r, c == o)
          break;
        let g = Math.pow(10, Math.floor(Math.log(Math.abs(r)) * Math.LOG10E));
        if (g < 1) {
          let p = Math.round(Math.abs(Math.log(Math.abs(g)) * Math.LOG10E)) + 2;
          o = rt(o, p);
        }
        l++, c = o;
      }
      for (let f = l; f < this.dataItems.length; f++)
        this.dataItems[f].hide();
      w(this.series, (f) => {
        f.inited && f._markDirtyAxes();
      }), this._updateGhost();
    }
  }
  _prepareDataItem(e, t) {
    let s = this.get("renderer"), r = e.get("value"), n = e.get("endValue"), a = this.valueToPosition(r), o = a, l = this.valueToPosition(r + this.getPrivate("step"));
    S(n) && (o = this.valueToPosition(n), l = o), e.get("isRange") && n == null && (l = a), s.updateLabel(e.get("label"), a, o, t);
    const u = e.get("grid");
    if (s.updateGrid(u, a, o), u && (r == this.get("baseValue", 0) ? (u.addTag("base"), u._applyThemes()) : u.hasTag("base") && (u.removeTag("base"), u._applyThemes())), s.updateTick(e.get("tick"), a, o, t), s.updateFill(e.get("axisFill"), a, l), this._processBullet(e), s.updateBullet(e.get("bullet"), a, o), !e.get("isRange")) {
      const h = this.get("fillRule");
      h && h(e);
    }
  }
  _handleRangeChange() {
    let e = this.positionToValue(this.get("start", 0)), t = this.positionToValue(this.get("end", 1));
    const s = this.get("renderer").gridCount();
    let r = this._adjustMinMax(e, t, s, !0), n = Vf(r.step);
    this.setPrivateRaw("stepDecimalPlaces", n), e = rt(e, n), t = rt(t, n), r = this._adjustMinMax(e, t, s, !0);
    let a = r.step;
    e = r.min, t = r.max, (this.getPrivate("selectionMin") !== e || this.getPrivate("selectionMax") !== t || this.getPrivate("step") !== a) && (this.setPrivateRaw("selectionMin", e), this.setPrivateRaw("selectionMax", t), this.setPrivateRaw("step", a));
  }
  /**
   * Converts a relative position to a corresponding numeric value from axis
   * scale.
   *
   * @param   position  Relative position
   * @return            Value
   */
  positionToValue(e) {
    const t = this.getPrivate("min"), s = this.getPrivate("max");
    return this.get("logarithmic") ? Math.pow(Math.E, (e * (Math.log(s) * Math.LOG10E - Math.log(t) * Math.LOG10E) + Math.log(t) * Math.LOG10E) / Math.LOG10E) : e * (s - t) + t;
  }
  /**
   * Convers value to a relative position on axis.
   *
   * @param   value  Value
   * @return         Relative position
   */
  valueToPosition(e) {
    const t = this.getPrivate("min"), s = this.getPrivate("max");
    if (this.get("logarithmic")) {
      if (e <= 0) {
        let r = this.get("treatZeroAs");
        S(r) && (e = r);
      }
      return (Math.log(e) * Math.LOG10E - Math.log(t) * Math.LOG10E) / (Math.log(s) * Math.LOG10E - Math.log(t) * Math.LOG10E);
    } else
      return (e - t) / (s - t);
  }
  /**
   * @ignore
   */
  valueToFinalPosition(e) {
    const t = this.getPrivate("minFinal"), s = this.getPrivate("maxFinal");
    if (this.get("logarithmic")) {
      if (e <= 0) {
        let r = this.get("treatZeroAs");
        S(r) && (e = r);
      }
      return (Math.log(e) * Math.LOG10E - Math.log(t) * Math.LOG10E) / (Math.log(s) * Math.LOG10E - Math.log(t) * Math.LOG10E);
    } else
      return (e - t) / (s - t);
  }
  /**
   * Returns X coordinate in pixels corresponding to specific value.
   *
   * @param   value     Numeric value
   * @param   location  Location
   * @param   baseValue Base value
   * @return            X coordinate
   */
  getX(e, t, s) {
    e = s + (e - s) * t;
    const r = this.valueToPosition(e);
    return this._settings.renderer.positionToCoordinate(r);
  }
  /**
   * Returns X coordinate in pixels corresponding to specific value.
   *
   * @param   value     Numeric value
   * @param   location  Location
   * @param   baseValue Base value
   * @return            X coordinate
   */
  getY(e, t, s) {
    e = s + (e - s) * t;
    const r = this.valueToPosition(e);
    return this._settings.renderer.positionToCoordinate(r);
  }
  /**
   * @ignore
   */
  getDataItemCoordinateX(e, t, s, r) {
    return this._settings.renderer.positionToCoordinate(this.getDataItemPositionX(e, t, s, r));
  }
  /**
   * @ignore
   */
  getDataItemPositionX(e, t, s, r) {
    let n = e.get(t);
    if (e.get("stackToItemX")) {
      const o = e.component;
      n = n * r + o.getStackedXValueWorking(e, t);
    } else
      n = this._baseValue + (n - this._baseValue) * r;
    return this.valueToPosition(n);
  }
  /**
   * @ignore
   */
  getDataItemCoordinateY(e, t, s, r) {
    return this._settings.renderer.positionToCoordinate(this.getDataItemPositionY(e, t, s, r));
  }
  /**
   * @ignore
   */
  getDataItemPositionY(e, t, s, r) {
    let n = e.get(t);
    if (e.get("stackToItemY")) {
      const o = e.component;
      n = n * r + o.getStackedYValueWorking(e, t);
    } else
      n = this._baseValue + (n - this._baseValue) * r;
    return this.valueToPosition(n);
  }
  /**
   * Returns relative position of axis' `baseValue`.
   *
   * @return  Base value position
   */
  basePosition() {
    return this.valueToPosition(this.baseValue());
  }
  /**
   * Base value of the [[ValueAxis]], which determines positive and negative
   * values.
   *
   * @return Base value
   */
  baseValue() {
    const e = Math.min(this.getPrivate("minFinal", -1 / 0), this.getPrivate("selectionMin", -1 / 0)), t = Math.max(this.getPrivate("maxFinal", 1 / 0), this.getPrivate("selectionMax", 1 / 0));
    let s = this.get("baseValue", 0);
    return s < e && (s = e), s > t && (s = t), s;
  }
  /**
   * @ignore
   */
  cellEndValue(e) {
    return e;
  }
  fixSmallStep(e) {
    return 1 + e === 1 ? (e *= 2, this.fixSmallStep(e)) : e;
  }
  _fixMin(e) {
    return e;
  }
  _fixMax(e) {
    return e;
  }
  _calculateTotals() {
    if (this.get("calculateTotals")) {
      let e = this.series[0];
      if (e) {
        let t = e.startIndex();
        if (e.dataItems.length > 0) {
          t > 0 && t--;
          let s = e.endIndex();
          s < e.dataItems.length && s++;
          let r, n;
          e.get("yAxis") == this ? (r = "valueY", n = "vcy") : e.get("xAxis") == this && (r = "valueX", n = "vcx");
          let a = r + "Working";
          if (r)
            for (let o = t; o < s; o++) {
              let l = 0, u = 0;
              w(this.series, (h) => {
                if (!h.get("excludeFromTotal")) {
                  let c = h.dataItems[o];
                  if (c) {
                    let f = c.get(a) * h.get(n);
                    Wt(f) || (l += f, u += Math.abs(f));
                  }
                }
              }), w(this.series, (h) => {
                if (!h.get("excludeFromTotal")) {
                  let c = h.dataItems[o];
                  if (c) {
                    let f = c.get(a) * h.get(n);
                    Wt(f) || (c.set(r + "Total", u), c.set(r + "Sum", l), c.set(r + "TotalPercent", f / u * 100));
                  }
                }
              });
            }
        }
      }
    }
  }
  _getSelectionMinMax() {
    const e = this.getPrivate("minFinal"), t = this.getPrivate("maxFinal"), s = this.get("min"), r = this.get("max");
    let n = this.get("extraMin", 0), a = this.get("extraMax", 0);
    this.get("logarithmic") && (this.get("extraMin") == null && (n = 0.1), this.get("extraMax") == null && (a = 0.2));
    const o = this.get("renderer").gridCount(), l = this.get("strictMinMaxSelection"), u = this.get("strictMinMax");
    if (S(e) && S(t)) {
      let h = t, c = e;
      if (w(this.series, (b) => {
        if (!b.get("ignoreMinMax")) {
          let y, x;
          const D = b.getPrivate("outOfSelection");
          b.get("xAxis") === this ? D || (y = b.getPrivate("selectionMinX", b.getPrivate("minX")), x = b.getPrivate("selectionMaxX", b.getPrivate("maxX"))) : b.get("yAxis") === this && (D || (y = b.getPrivate("selectionMinY", b.getPrivate("minY")), x = b.getPrivate("selectionMaxY", b.getPrivate("maxY")))), !b.isHidden() && !b.isShowing() && (S(y) && (h = Math.min(h, y)), S(x) && (c = Math.max(c, x)));
        }
      }), this.axisRanges.each((b) => {
        if (b.get("affectsMinMax")) {
          let y = b.get("value");
          y != null && (h = Math.min(h, y), c = Math.max(c, y)), y = b.get("endValue"), y != null && (h = Math.min(h, y), c = Math.max(c, y));
        }
      }), h > c && ([h, c] = [c, h]), S(s) ? u ? h = s : h = e : u && S(this._minReal) && (h = this._minReal), S(r) ? u ? c = r : c = t : u && S(this._maxReal) && (c = this._maxReal), h === c) {
        h -= this._deltaMinMax, c += this._deltaMinMax;
        let b = this._adjustMinMax(h, c, o, u);
        h = b.min, c = b.max;
      }
      let f = h, d = c;
      h -= (c - h) * n, c += (c - h) * a;
      let g = this._adjustMinMax(h, c, o);
      h = g.min, c = g.max, h = Re(h, e, t), c = Re(c, e, t), g = this._adjustMinMax(h, c, o, !0), u || (h = g.min, c = g.max);
      const p = this.get("syncWithAxis");
      p && (g = this._syncAxes(h, c, g.step, p.getPrivate("selectionMinFinal", p.getPrivate("minFinal", 0)), p.getPrivate("selectionMaxFinal", p.getPrivate("maxFinal", 1)), p.getPrivate("selectionStepFinal", p.getPrivate("step", 1))), h = g.min, c = g.max), u && (S(s) && (h = Math.max(h, s)), S(r) && (c = Math.min(c, r))), l && (h = f - (c - h) * n, c = d + (c - h) * a), this.get("logarithmic") && (h <= 0 && (h = f * (1 - Math.min(n, 0.99))), h < e && (h = e), c > t && (c = t));
      let _ = Math.min(20, Math.ceil(Math.log(this.getPrivate("maxZoomFactor", 100) + 1) / Math.LN10) + 2), m = rt(this.valueToFinalPosition(h), _), v = rt(this.valueToFinalPosition(c), _);
      this.setPrivateRaw("selectionMinFinal", h), this.setPrivateRaw("selectionMaxFinal", c), this.setPrivateRaw("selectionStepFinal", g.step), this.zoom(m, v);
    }
  }
  _getMinMax() {
    let e = this.get("min"), t = this.get("max"), s = 1 / 0, r = -1 / 0, n = this.get("extraMin", 0), a = this.get("extraMax", 0);
    this.get("logarithmic") && (this.get("extraMin") == null && (n = 0.1), this.get("extraMax") == null && (a = 0.2));
    let o = 1 / 0;
    if (w(this.series, (b) => {
      if (!b.get("ignoreMinMax")) {
        let y, x;
        if (b.get("xAxis") === this ? (y = b.getPrivate("minX"), x = b.getPrivate("maxX")) : b.get("yAxis") === this && (y = b.getPrivate("minY"), x = b.getPrivate("maxY")), S(y) && S(x)) {
          s = Math.min(s, y), r = Math.max(r, x);
          let D = x - y;
          D <= 0 && (D = Math.abs(x / 100)), D < o && (o = D);
        }
      }
    }), this.axisRanges.each((b) => {
      if (b.get("affectsMinMax")) {
        let y = b.get("value");
        y != null && (s = Math.min(s, y), r = Math.max(r, y)), y = b.get("endValue"), y != null && (s = Math.min(s, y), r = Math.max(r, y));
      }
    }), this.get("logarithmic")) {
      let b = this.get("treatZeroAs");
      S(b) && s <= 0 && (s = b);
    }
    if (s === 0 && r === 0 && (r = 0.9, s = -0.9), S(e) && (s = e), S(t) && (r = t), s === 1 / 0 || r === -1 / 0) {
      this.setPrivate("minFinal", void 0), this.setPrivate("maxFinal", void 0);
      return;
    }
    const l = s, u = r;
    let h = this.adapters.fold("min", s), c = this.adapters.fold("max", r);
    S(h) && (s = h), S(c) && (r = c), s = this._fixMin(s), r = this._fixMax(r), r - s <= 1 / Math.pow(10, 15) && (r - s !== 0 ? this._deltaMinMax = (r - s) / 2 : this._getDelta(r), s -= this._deltaMinMax, r += this._deltaMinMax), s -= (r - s) * n, r += (r - s) * a, this.get("logarithmic") && (s < 0 && l >= 0 && (s = 0), r > 0 && u <= 0 && (r = 0)), this._minReal = s, this._maxReal = r;
    let f = this.get("strictMinMax"), d = this.get("strictMinMaxSelection", !1);
    d && (f = d);
    let g = f;
    S(t) && (g = !0);
    let p = this.get("renderer").gridCount(), _ = this._adjustMinMax(s, r, p, g);
    s = _.min, r = _.max, _ = this._adjustMinMax(s, r, p, !0), s = _.min, r = _.max, f && (S(e) ? s = e : s = this._minReal, S(t) ? r = t : r = this._maxReal, r - s <= 1e-8 && (s -= this._deltaMinMax, r += this._deltaMinMax), s -= (r - s) * n, r += (r - s) * a), h = this.adapters.fold("min", s), c = this.adapters.fold("max", r), S(h) && (s = h), S(c) && (r = c), o == 1 / 0 && (o = r - s);
    let m = Math.round(Math.abs(Math.log(Math.abs(r - s)) * Math.LOG10E)) + 5;
    s = rt(s, m), r = rt(r, m);
    const v = this.get("syncWithAxis");
    if (v && (_ = this._syncAxes(s, r, _.step, v.getPrivate("minFinal", v.getPrivate("min", 0)), v.getPrivate("maxFinal", v.getPrivate("max", 1)), v.getPrivate("step", 1)), s = _.min, r = _.max), this.setPrivateRaw("maxZoomFactor", Math.max(1, Math.ceil((r - s) / o * this.get("maxZoomFactor", 100)))), this._fixZoomFactor(), this.get("logarithmic") && (this._minLogAdjusted = s, s = this._minReal, r = this._maxReal, s <= 0 && (s = l * (1 - Math.min(n, 0.99)))), S(s) && S(r) && (this.getPrivate("minFinal") !== s || this.getPrivate("maxFinal") !== r)) {
      this.setPrivate("minFinal", s), this.setPrivate("maxFinal", r), this._saveMinMax(s, r);
      const b = this.get("interpolationDuration", 0), y = this.get("interpolationEasing");
      this.animatePrivate({ key: "min", to: s, duration: b, easing: y }), this.animatePrivate({ key: "max", to: r, duration: b, easing: y });
    }
  }
  _fixZoomFactor() {
  }
  _getDelta(e) {
    let t = Math.log(Math.abs(e)) * Math.LOG10E, s = Math.pow(10, Math.floor(t));
    s = s / 10, this._deltaMinMax = s;
  }
  _saveMinMax(e, t) {
  }
  _adjustMinMax(e, t, s, r) {
    s <= 1 && (s = 1), s = Math.round(s);
    let n = e, a = t, o = t - e;
    o === 0 && (o = Math.abs(t));
    let l = Math.log(Math.abs(o)) * Math.LOG10E, u = Math.pow(10, Math.floor(l));
    u = u / 10;
    let h = u;
    r && (h = 0), r ? (e = Math.floor(e / u) * u, t = Math.ceil(t / u) * u) : (e = Math.ceil(e / u) * u - h, t = Math.floor(t / u) * u + h), e < 0 && n >= 0 && (e = 0), t > 0 && a <= 0 && (t = 0), l = Math.log(Math.abs(o)) * Math.LOG10E, u = Math.pow(10, Math.floor(l)), u = u / 100;
    let c = Math.ceil(o / s / u) * u, f = Math.pow(10, Math.floor(Math.log(Math.abs(c)) * Math.LOG10E)), d = Math.ceil(c / f);
    d > 5 ? d = 10 : d <= 5 && d > 2 && (d = 5), c = Math.ceil(c / (f * d)) * f * d;
    let g = this.get("maxPrecision");
    if (S(g)) {
      let v = np(c, g);
      g < Number.MAX_VALUE && c !== v && (c = v);
    }
    let p = 0;
    f < 1 && (p = Math.round(Math.abs(Math.log(Math.abs(f)) * Math.LOG10E)) + 1, c = rt(c, p));
    let _ = Math.floor(e / c);
    e = rt(c * _, p);
    let m;
    return r ? m = Math.floor(t / c) : m = Math.ceil(t / c), m === _ && m++, t = rt(c * m, p), t < a && (t = t + c), e > n && (e = e - c), c = this.fixSmallStep(c), { min: e, max: t, step: c };
  }
  /**
   * Returns text to be used in an axis tooltip for specific relative position.
   *
   * @param   position  Position
   * @return            Tooltip text
   */
  getTooltipText(e, t) {
    const s = this.get("tooltipNumberFormat", this.get("numberFormat")), r = this.getNumberFormatter(), n = this.get("extraTooltipPrecision", 0), a = this.getPrivate("stepDecimalPlaces", 0) + n, o = rt(this.positionToValue(e), a);
    return s ? r.format(o, s) : r.format(o, void 0, a);
  }
  /**
   * Returns a data item from series that is closest to the `position`.
   *
   * @param   series    Series
   * @param   position  Relative position
   * @return            Data item
   */
  getSeriesItem(e, t) {
    let s = this.getPrivate("name") + this.get("renderer").getPrivate("letter"), r = this.positionToValue(t), n, a;
    if (w(e.dataItems, (o, l) => {
      const u = Math.abs(o.get(s) - r);
      (n === void 0 || u < a) && (n = l, a = u);
    }), n != null)
      return e.dataItems[n];
  }
  /**
   * Zooms the axis to specific `start` and `end` values.
   *
   * Optional `duration` specifies duration of zoom animation in milliseconds.
   *
   * @param  start     Start value
   * @param  end       End value
   * @param  duration  Duration in milliseconds
   */
  zoomToValues(e, t, s) {
    const r = this.getPrivate("minFinal", 0), n = this.getPrivate("maxFinal", 0);
    this.getPrivate("min") != null && this.getPrivate("max") != null && this.zoom((e - r) / (n - r), (t - r) / (n - r), s);
  }
  /**
   * Syncs with a target axis.
   *
   * @param  min  Min
   * @param  max  Max
   * @param  step Step
   */
  _syncAxes(e, t, s, r, n, a) {
    if (this.get("syncWithAxis")) {
      let l = Math.round(n - r) / a, u = Math.round((t - e) / s), h = this.get("renderer").gridCount();
      if (S(l) && S(u)) {
        let c = !1, f = 0, d = (t - e) * 0.01, g = e, p = t, _ = s;
        for (; c != !0; )
          if (c = this._checkSync(g, p, _, l), f++, f > 500 && (c = !0), c)
            e = g, t = p, s = _;
          else {
            f / 3 == Math.round(f / 3) ? (g = e - d * f, e >= 0 && g < 0 && (g = 0)) : (p = t + d * f, p <= 0 && p > 0 && (p = 0));
            let m = this._adjustMinMax(g, p, h, !0);
            g = m.min, p = m.max, _ = m.step;
          }
      }
    }
    return { min: e, max: t, step: s };
  }
  /**
   * Returns `true` if axis needs to be resunced with some other axis.
   */
  _checkSync(e, t, s, r) {
    let n = (t - e) / s;
    for (let a = 1; a < r; a++)
      if (rt(n / a, 1) == r || n * a == r)
        return !0;
    return !1;
  }
  /**
   * Returns relative position between two grid lines of the axis.
   *
   * @return Position
   */
  getCellWidthPosition() {
    let e = this.getPrivate("selectionMax", this.getPrivate("max")), t = this.getPrivate("selectionMin", this.getPrivate("min"));
    return S(e) && S(t) ? this.getPrivate("step", 1) / (e - t) : 0.05;
  }
}
Object.defineProperty(ns, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "ValueAxis"
});
Object.defineProperty(ns, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: rs.classNames.concat([ns.className])
});
class _r extends ns {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_dataGrouped", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_seriesDataGrouped", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_groupingCalculated", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_intervalDuration", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), Object.defineProperty(this, "_baseDuration", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), Object.defineProperty(this, "_intervalMax", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_intervalMin", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    });
  }
  _afterNew() {
    this._settings.themeTags = se(this._settings.themeTags, ["axis"]), super._afterNew(), this._setBaseInterval(this.get("baseInterval")), this.on("baseInterval", () => {
      this._setBaseInterval(this.get("baseInterval"));
    });
  }
  _setBaseInterval(e) {
    this.setPrivateRaw("baseInterval", e), this._baseDuration = It(e);
  }
  _fixZoomFactor() {
    const e = this.get("maxZoomFactor");
    e != null && e != 1 / 0 ? this.setPrivateRaw("maxZoomFactor", e) : this.setPrivateRaw("maxZoomFactor", Math.round((this.getPrivate("max", 0) - this.getPrivate("min", 0)) / this.baseMainDuration()));
  }
  _groupData() {
    const e = this.getPrivate("min"), t = this.getPrivate("max");
    if (S(e) && S(t)) {
      this._fixZoomFactor();
      const s = this.getPrivate("groupInterval");
      if (s ? this._setBaseInterval(s) : this._setBaseInterval(this.get("baseInterval")), this.isDirty("groupInterval")) {
        let r = this.get("groupInterval");
        r && this.setRaw("groupIntervals", [r]);
      }
      if (this.isDirty("groupData") && !this._dataGrouped) {
        if (this.get("groupData"))
          w(this.series, (r) => {
            this._groupSeriesData(r);
          }), this._handleRangeChange();
        else {
          let r = this.get("baseInterval"), n = r.timeUnit + r.count;
          w(this.series, (a) => {
            a.setDataSet(n);
          }), this._setBaseInterval(r), this.setPrivateRaw("groupInterval", void 0), this.markDirtyExtremes();
        }
        this._dataGrouped = !0;
      }
    }
  }
  _groupSeriesData(e) {
    if (this.get("groupData") && !e.get("groupDataDisabled")) {
      this._dataGrouped = !0, this._seriesDataGrouped = !0;
      let t = [], s = this.baseMainDuration(), r = this.get("groupIntervals");
      w(r, (_) => {
        It(_) > s && t.push(_);
      }), e._dataSets = {};
      const n = this.getPrivate("name") + this.get("renderer").getPrivate("letter");
      let a;
      const o = e.get("baseAxis");
      e.get("xAxis") === o ? a = e._valueYFields : e.get("yAxis") === o && (a = e._valueXFields);
      let l = e._mainDataItems, u = this.get("baseInterval"), h = u.timeUnit + u.count;
      e._dataSets[h] = l;
      const c = e.get("groupDataCallback");
      let f = e.get("groupDataWithOriginals", !1);
      c && (f = !0);
      const d = this._root.locale.firstDayOfWeek, g = this._root.utc, p = this._root.timezone;
      w(t, (_) => {
        let m = -1 / 0, v = _.timeUnit + _.count;
        e._dataSets[v] = [];
        let b, y = {}, x = {}, D = {}, A = {};
        w(a, (j) => {
          y[j] = 0, x[j] = 0, D[j] = e.get(j + "Grouped"), A[j] = j + "Working";
        });
        let C = Dt(_.timeUnit), O = l[0], T;
        O && (T = new Date(l[0].get(n)));
        let L;
        w(l, (j) => {
          let N = j.get(n), ee = Ke(new Date(N), _.timeUnit, _.count, d, g, T, p).getTime(), z;
          m < ee - C / 24 ? (z = zi(j.dataContext), b = new ti(e, z, e._makeDataItem(z)), b.setRaw(n, ee), e._dataSets[v].push(b), w(a, (H) => {
            let $ = j.get(H);
            S($) ? (b.setRaw(H, $), b.setRaw(A[H], $), x[H] = 1, y[H] = $) : (y[H] = 0, x[H] = 0);
          }), f && b.set("originals", [j]), c && L && c(L, _), L = b) : (w(a, (H) => {
            let $ = D[H], Z = j.get(H);
            if (Z !== void 0) {
              let B = b.get(H);
              switch ($) {
                case "close":
                  b.setRaw(H, Z);
                  break;
                case "sum":
                  Z != null && b.setRaw(H, B + Z);
                  break;
                case "open":
                  break;
                case "low":
                  Z < B && b.setRaw(H, Z);
                  break;
                case "high":
                  Z > B && b.setRaw(H, Z);
                  break;
                case "average":
                  x[H]++, y[H] += Z;
                  let M = y[H] / x[H];
                  b.setRaw(H, M);
                  break;
                case "extreme":
                  Math.abs(Z) > Math.abs(B) && b.setRaw(H, Z);
                  break;
              }
              b.setRaw(A[H], b.get(H));
              let he = zi(j.dataContext);
              he[n] = ee, b.dataContext = he;
            }
          }), f && b.get("originals").push(j)), m = ee;
        }), c && L && c(L, _);
      }), e._dataSetId && e.setDataSet(e._dataSetId), this.markDirtySize();
    }
  }
  _clearDirty() {
    super._clearDirty(), this._groupingCalculated = !1, this._dataGrouped = !1;
  }
  /**
   * Returns a time interval axis would group data to for a specified duration.
   *
   * @since 5.2.1
   */
  getGroupInterval(e) {
    let t = this.get("baseInterval"), s = dr(0, e, this.get("groupCount", 1 / 0), this.get("groupIntervals"));
    return It(s) < It(t) && (s = Object.assign({}, t)), s;
  }
  /**
   * Return `max` of a specified time interval.
   *
   * Will work only if the axis was grouped to this interval at least once.
   *
   * @since 5.2.1
   * @param   interval  Interval
   * @return            Max
   */
  getIntervalMax(e) {
    return this._intervalMax[e.timeUnit + e.count];
  }
  /**
   * Return `min` of a specified time interval.
   *
   * Will work only if the axis was grouped to this interval at least once.
   *
   * @since 5.2.1
   * @param   interval  Interval
   * @return            Min
   */
  getIntervalMin(e) {
    return this._intervalMin[e.timeUnit + e.count];
  }
  _handleRangeChange() {
    super._handleRangeChange();
    let e = Math.round(this.getPrivate("selectionMin")), t = Math.round(this.getPrivate("selectionMax"));
    if (S(e) && S(t)) {
      if (this.get("endLocation") == 0 && (t += 1), this.get("groupData") && !this._groupingCalculated) {
        this._groupingCalculated = !0;
        let s = t - e + (this.get("startLocation", 0) + (1 - this.get("endLocation", 1)) * this.baseDuration()), r = this.get("groupInterval");
        r || (r = this.getGroupInterval(s));
        let n = this.getPrivate("groupInterval");
        if (r && (!n || n.timeUnit !== r.timeUnit || n.count !== r.count || this._seriesDataGrouped)) {
          this._seriesDataGrouped = !1, this.setPrivateRaw("groupInterval", r), this._setBaseInterval(r);
          let a = r.timeUnit + r.count;
          w(this.series, (o) => {
            o.get("baseAxis") === this && o.setDataSet(a);
          }), this.markDirtyExtremes(), this._root.events.once("frameended", () => {
            this._root.events.once("frameended", () => {
              const o = "groupintervalchanged";
              this.events.isEnabled(o) && this.events.dispatch(o, { type: o, target: this });
            });
          });
        }
      }
      w(this.series, (s) => {
        if (s.get("baseAxis") === this) {
          let r = this.getPrivate("name") + this.get("renderer").getPrivate("letter"), a = Wi(s.dataItems, (p) => $t(p.get(r), e)).index;
          a > 0 && (a -= 1), t += this.baseDuration() * (1 - this.get("endLocation", 1));
          let l = Wi(s.dataItems, (p) => $t(p.get(r), t)).index, u = l;
          u > 0 && u--;
          const h = s.dataItems[a], c = s.dataItems[u];
          let f, d;
          h && (d = h.get(r)), c && (f = c.get(r));
          let g = !1;
          f != null && d != null && (f < e || d > t) && (g = !0), s.setPrivate("outOfSelection", g), s.setPrivate("startIndex", a), s.setPrivate("endIndex", l);
        }
      });
    }
  }
  _adjustMinMax(e, t, s, r) {
    return { min: e, max: t, step: (t - e) / s };
  }
  /**
   * @ignore
   */
  intervalDuration() {
    return this._intervalDuration;
  }
  _saveMinMax(e, t) {
    let s = this.getPrivate("groupInterval");
    s || (s = this.get("baseInterval"));
    let r = s.timeUnit + s.count;
    this._intervalMin[r] = e, this._intervalMax[r] = t;
  }
  _getM(e) {
    return e == "month" || e == "year" || e == "day" ? 1.05 : 1.01;
  }
  _prepareAxisItems() {
    const e = this.getPrivate("min"), t = this.getPrivate("max");
    if (S(e) && S(t)) {
      const s = Math.round(this.getPrivate("selectionMin")), r = Math.round(this.getPrivate("selectionMax")), n = this.get("renderer"), a = this.getPrivate("baseInterval");
      let o = s, l = 0;
      const u = this.get("gridIntervals");
      let h = dr(0, r - s, n.gridCount(), u);
      It(h) < this.baseDuration() && (h = Object.assign({}, a));
      const c = It(h);
      this._intervalDuration = c;
      const f = kn(h.timeUnit), d = this._root.locale.firstDayOfWeek, g = this._root.utc, p = this._root.timezone;
      o = Ke(new Date(s - c), h.timeUnit, h.count, d, g, new Date(e), p).getTime();
      let _ = o - c, m;
      const v = this.get("dateFormats");
      for (this.setPrivateRaw("gridInterval", h); o < r + c; ) {
        let b;
        this.dataItems.length < l + 1 ? (b = new ti(this, void 0, {}), this._dataItems.push(b), this.processDataItem(b)) : b = this.dataItems[l], this._createAssets(b, []), b.isHidden() && b.show(), b.setRaw("value", o);
        let y = o + Dt(h.timeUnit, h.count * this._getM(h.timeUnit));
        y = Ke(new Date(y), h.timeUnit, 1, d, g, void 0, p).getTime(), b.setRaw("endValue", y);
        let x = new Date(o);
        m = v[h.timeUnit], f && this.get("markUnitChange") && S(_) && h.timeUnit != "year" && Pn(o, _, f, g, p) && (m = this.get("periodChangeDateFormats")[h.timeUnit]);
        const D = b.get("label");
        if (D && D.set("text", this._root.dateFormatter.format(x, m)), this._prepareDataItem(b, h.count), _ = o, o = y, o == _)
          break;
        l++;
      }
      for (let b = l; b < this.dataItems.length; b++)
        this.dataItems[b].hide();
      w(this.series, (b) => {
        b.inited && b._markDirtyAxes();
      });
    }
    this._updateGhost();
  }
  _updateFinals(e, t) {
    this.setPrivateRaw("selectionMinFinal", this.positionToValue(e)), this.setPrivateRaw("selectionMaxFinal", this.positionToValue(t));
  }
  _getDelta() {
    this._deltaMinMax = this.baseDuration() / 2;
  }
  _fixMin(e) {
    const t = this.getPrivate("baseInterval"), s = this._root.locale.firstDayOfWeek, r = this._root.timezone, n = this._root.utc, a = t.timeUnit;
    let o = Ke(new Date(e), a, t.count, s, n, void 0, r).getTime(), l = o + Dt(a, t.count * this._getM(a));
    return l = Ke(new Date(l), a, 1, s, n, void 0, r).getTime(), o + (l - o) * this.get("startLocation", 0);
  }
  _fixMax(e) {
    const t = this.getPrivate("baseInterval"), s = this._root.locale.firstDayOfWeek, r = this._root.timezone, n = this._root.utc, a = t.timeUnit;
    let o = Ke(new Date(e), a, t.count, s, n, void 0, r).getTime(), l = o + Dt(a, t.count * this._getM(a));
    return l = Ke(new Date(l), a, 1, s, n, void 0, r).getTime(), o + (l - o) * this.get("endLocation", 1);
  }
  _updateDates(e) {
  }
  /**
   * Returns a duration of currently active `baseInterval` in milliseconds.
   *
   * @return Duration
   */
  baseDuration() {
    return this._baseDuration;
  }
  /**
   * Returns a duration of user-defined `baseInterval` in milliseconds.
   *
   * @return Duration
   */
  baseMainDuration() {
    return It(this.get("baseInterval"));
  }
  /**
   * @ignore
   */
  processSeriesDataItem(e, t) {
    const s = this.getPrivate("baseInterval");
    e.open || (e.open = {}), e.close || (e.close = {}), w(t, (r) => {
      let n = e.get(r);
      if (S(n)) {
        let a = e.open[r], o = e.close[r];
        if (!(n >= a && n <= o)) {
          const l = this._root.locale.firstDayOfWeek, u = this._root.utc, h = this._root.timezone, c = s.timeUnit, f = s.count;
          a = Ke(new Date(n), c, f, l, u, void 0, h).getTime(), o = a + Dt(c, f * this._getM(c)), o = Ke(new Date(o), c, 1, l, u, void 0, h).getTime(), e.open[r] = a, e.close[r] = o;
        }
        this._updateDates(a);
      }
    });
  }
  /**
   * @ignore
   */
  getDataItemPositionX(e, t, s, r) {
    let n, a;
    e.open && e.close ? (n = e.open[t], a = e.close[t]) : (n = e.get(t), a = n);
    let o = n + (a - n) * s;
    return o = this._baseValue + (o - this._baseValue) * r, this.valueToPosition(o);
  }
  /**
   * @ignore
   */
  getDataItemCoordinateX(e, t, s, r) {
    return this._settings.renderer.positionToCoordinate(this.getDataItemPositionX(e, t, s, r));
  }
  /**
   * @ignore
   */
  getDataItemPositionY(e, t, s, r) {
    let n, a;
    e.open && e.close ? (n = e.open[t], a = e.close[t]) : (n = e.get(t), a = n);
    let o = n + (a - n) * s;
    return o = this._baseValue + (o - this._baseValue) * r, this.valueToPosition(o);
  }
  /**
   * @ignore
   */
  getDataItemCoordinateY(e, t, s, r) {
    return this._settings.renderer.positionToCoordinate(this.getDataItemPositionY(e, t, s, r));
  }
  /**
   * @ignore
   */
  roundAxisPosition(e, t) {
    let s = this.positionToValue(e);
    s = s - (t - 0.5) * this.baseDuration();
    let r = this.getPrivate("baseInterval");
    if (!Wt(s)) {
      const n = this._root.locale.firstDayOfWeek, a = r.timeUnit, o = this._root.utc, l = this._root.timezone, u = r.count;
      s = Ke(new Date(s), a, u, n, o, new Date(this.getPrivate("min", 0)), l).getTime();
      let h = oa(r, new Date(s), n, o, l);
      return l && (s = Ke(new Date(s + this.baseDuration() * 0.05), a, u, n, o, new Date(this.getPrivate("min", 0)), l).getTime(), h = oa(r, new Date(s + h * t), n, o, l)), this.valueToPosition(s + h * t);
    }
    return NaN;
  }
  /**
   * Returns text to be used in an axis tooltip for specific relative position.
   *
   * NOTE: Unless `adjustPosition` (2nd parameter) is set to `false`, the method
   * will adjust position by `tooltipIntervalOffset`.
   *
   * @param  position        Position
   * @param  adjustPosition  Adjust position
   * @return                 Tooltip text
   */
  getTooltipText(e, t) {
    if (this.getPrivate("min") != null) {
      let s = this.get("tooltipDateFormats")[this.getPrivate("baseInterval").timeUnit], r = this.positionToValue(e), n = new Date(r), a = this.getPrivate("baseInterval"), o = oa(a, n, this._root.locale.firstDayOfWeek, this._root.utc, this._root.timezone);
      return t !== !1 && (n = new Date(r + this.get("tooltipIntervalOffset", -this.get("tooltipLocation", 0.5)) * o)), this._root.dateFormatter.format(n, this.get("tooltipDateFormat", s));
    }
    return "";
  }
  /**
   * Returns a data item from series that is closest to the `position`.
   *
   * @param   series    Series
   * @param   position  Relative position
   * @return            Data item
   */
  getSeriesItem(e, t, s) {
    let r = this.getPrivate("name") + this.get("renderer").getPrivate("letter"), n = this.positionToValue(t);
    s == null && (s = 0.5), n = n - (s - 0.5) * this.baseDuration();
    const a = Wi(e.dataItems, (o) => {
      let l = 0;
      return o.open && (l = o.open[r]), $t(l, n);
    });
    if (e.get("snapTooltip")) {
      let o = e.dataItems[a.index - 1], l = e.dataItems[a.index];
      if (o && l && o.open && l.close) {
        let u = o.open[r], h = l.close[r];
        if (Math.abs(n - u) > Math.abs(n - h))
          return l;
      }
      if (o)
        return o;
      if (l)
        return l;
    } else {
      const o = e.dataItems[a.index - 1];
      if (o && o.open && o.close) {
        let l = o.open[r], u = o.close[r];
        if (n >= l && n <= u)
          return o;
      }
    }
  }
  /**
   * @ignore
   */
  shouldGap(e, t, s, r) {
    const n = e.get(r);
    return t.get(r) - n > this.baseDuration() * s;
  }
  /**
   * Zooms the axis to specific `start` and `end` dates.
   *
   * Optional `duration` specifies duration of zoom animation in milliseconds.
   *
   * @param  start     Start Date
   * @param  end       End Date
   * @param  duration  Duration in milliseconds
   */
  zoomToDates(e, t, s) {
    this.zoomToValues(e.getTime(), t.getTime(), s);
  }
  /**
   * Returns a `Date` object corresponding to specific position within plot
   * area.
   *
   * @param   position  Pposition
   * @return            Date
   */
  positionToDate(e) {
    return new Date(this.positionToValue(e));
  }
  /**
   * Returns a relative position within plot area that corresponds to specific
   * date.
   *
   * @param   date  Date
   * @return        Position
   */
  dateToPosition(e) {
    return this.valueToPosition(e.getTime());
  }
  /**
   * Returns relative position between two grid lines of the axis.
   *
   * @since 5.2.30
   * @return Position
   */
  getCellWidthPosition() {
    let e = this.getPrivate("selectionMax", this.getPrivate("max")), t = this.getPrivate("selectionMin", this.getPrivate("min"));
    return S(e) && S(t) ? this._intervalDuration / (e - t) : 0.05;
  }
}
Object.defineProperty(_r, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "DateAxis"
});
Object.defineProperty(_r, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: ns.classNames.concat([_r.className])
});
class qa extends _r {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_frequency", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), Object.defineProperty(this, "_dates", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    });
  }
  _afterNew() {
    this.valueFields.push("date"), super._afterNew();
  }
  _updateDates(e) {
    const t = this._dates, s = Wi(t, (r) => $t(r, e));
    s.found || nr(t, s.index, e);
  }
  _updateAllDates() {
    this._dates.length = 0, w(this.series, (e) => {
      let t = "valueX";
      e.get("yAxis") == this && (t = "valueY"), w(e.dataItems, (s) => {
        let r = s.get(t);
        S(r) && s.open && this._updateDates(s.open[t]);
      });
    });
  }
  /**
   * Convers value to a relative position on axis.
   *
   * @param   value  Value
   * @return         Relative position
   */
  valueToPosition(e) {
    const t = this._dates, s = this.get("startLocation", 0), r = this.get("endLocation", 1), n = t.length - s - (1 - r), a = Wi(t, (l) => $t(l, e));
    let o = a.index;
    if (a.found)
      return (o - s) / n;
    {
      o > 0 && (o -= 1);
      let l = t[o], u = 0;
      return l > e ? u = l - e : u = e - l, (o - s) / n + u / this.baseDuration() / n;
    }
  }
  /**
   * Converts numeric value from axis scale to index.
   *
   * @param  value  Value
   * @return        Index
   */
  valueToIndex(e) {
    const t = this._dates, s = Wi(t, (n) => $t(n, e));
    let r = s.index;
    return s.found || r > 0 && (r -= 1), r;
  }
  /**
   * Converts a relative position to a corresponding numeric value from axis
   * scale.
   *
   * @param   position  Relative position
   * @return            Value
   */
  positionToValue(e) {
    const t = this.get("startLocation", 0), s = this.get("endLocation", 1);
    let r = Math.round(this._dates.length - t - (1 - s)), n = e * r, a = Math.floor(n);
    return a < 0 && (a = 0), a > r - 1 && (a = r - 1), this._dates[a] + (n - a + t) * this.baseDuration();
  }
  _fixZoomFactor() {
    this.setPrivateRaw("maxZoomFactor", this._dates.length - this.get("startLocation", 0) - (1 - this.get("endLocation", 1)));
  }
  /**
   * Zooms the axis to specific `start` and `end` values.
   *
   * Optional `duration` specifies duration of zoom animation in milliseconds.
   *
   * @param  start     Start value
   * @param  end       End value
   * @param  duration  Duration in milliseconds
   */
  zoomToValues(e, t, s) {
    const r = this.getPrivate("min", 0), n = this.getPrivate("max", 0);
    e = Re(e, r, n), t = Re(t, r, n), this.zoom(this.valueToPosition(e), this.valueToPosition(t), s);
  }
  _prepareAxisItems() {
    let e = this.getPrivate("selectionMin", 0), t = this.getPrivate("selectionMax", 0);
    if (S(e) && S(t)) {
      this._seriesValuesDirty && (this._seriesValuesDirty = !1, this._updateAllDates());
      const s = this._dates, r = this.get("renderer"), n = s.length;
      let a = this.valueToIndex(e);
      a > 0 && a--;
      let o = this.valueToIndex(t);
      o < n - 1 && o++;
      let l = r.axisLength() / Math.max(r.get("minGridDistance"), 1 / Number.MAX_SAFE_INTEGER), u = Math.min(n, Math.ceil((o - a) / l));
      u = Math.max(1, u), a = Math.floor(a / u) * u, this._frequency = u;
      for (let D = 0, A = this.dataItems.length; D < A; D++)
        this.dataItems[D].hide();
      let h = t - e - ((t - e) / this.baseDuration() - (o - a)) * this.baseDuration(), c = dr(0, h, l, this.get("gridIntervals"));
      const f = this.getPrivate("baseInterval");
      let d = It(c);
      d < this.baseDuration() && (c = Object.assign({}, f), d = It(c)), this._intervalDuration = d;
      const g = this.get("dateFormats");
      let p = [], _ = /* @__PURE__ */ new Date();
      this._dates[0] && (_ = new Date(this._dates[0]));
      let m = Ke(new Date(this.getPrivate("min", 0)), c.timeUnit, c.count, this._root.locale.firstDayOfWeek, this._root.utc, _, this._root.timezone), v = Dp(m, c.timeUnit, -1, this._root.utc, this._root.timezone).getTime(), b = this.getPrivate("selectionMax"), y = -1 / 0, x = (this.get("end", 1) - this.get("start", 0)) / l;
      for (; v <= b; ) {
        let D = this.valueToIndex(v), A = this._dates[D];
        if (A < v) {
          for (let T = D, L = this._dates.length; T < L; T++)
            if (this._dates[T] >= v) {
              D = T;
              break;
            }
        }
        let C = this.valueToPosition(A);
        C - y >= x * 0.95 && (ka(p, D), y = C);
        let O = v;
        if (v += Dt(c.timeUnit, c.count * this._getM(c.timeUnit)), v = Ke(new Date(v), c.timeUnit, c.count, this._root.locale.firstDayOfWeek, this._root.utc, void 0, this._root.timezone).getTime(), v == O)
          break;
      }
      if (p.length > 0) {
        let D = 0, A = v - d * 10;
        const C = kn(c.timeUnit);
        w(p, (O) => {
          let T;
          this.dataItems.length < D + 1 ? (T = new ti(this, void 0, {}), this._dataItems.push(T), this.processDataItem(T)) : T = this.dataItems[D];
          let L = s[O], j = new Date(L), N = L;
          if (D < p.length - 1 ? N = s[p[D + 1]] : N += d, T.setRaw("value", L), T.setRaw("endValue", N), T.setRaw("index", D), O > a - 100 && O < o + 100) {
            let ee = g[c.timeUnit];
            ee = g[c.timeUnit], C && this.get("markUnitChange") && S(A) && c.timeUnit != "year" && Pn(L, A, C, this._root.utc, this._root.timezone) && (ee = this.get("periodChangeDateFormats")[c.timeUnit]), this._createAssets(T, []);
            const z = T.get("label");
            z && z.set("text", this._root.dateFormatter.format(j, ee)), T.isHidden() && T.show(), this._prepareDataItem(T, c.count);
          }
          D++, A = L;
        });
      }
      w(this.series, (D) => {
        D.inited && D._markDirtyAxes();
      });
    }
    this._updateGhost();
  }
}
Object.defineProperty(qa, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "GaplessDateAxis"
});
Object.defineProperty(qa, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: _r.classNames.concat([qa.className])
});
class Qa extends ns {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_dataGrouped", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_groupingCalculated", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_intervalDuration", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    });
  }
  _afterNew() {
    this._settings.themeTags = se(this._settings.themeTags, ["axis"]), super._afterNew();
  }
  _adjustMinMax(e, t, s, r) {
    let n;
    const a = this.getDurationFormatter(), o = this.get("baseUnit");
    if (this.setRaw("maxPrecision", 0), o == "millisecond" || o == "second" || o == "minute" || o == "hour") {
      s <= 1 && (s = 1), s = Math.round(s);
      let l = t - e;
      l === 0 && (l = Math.abs(t));
      let u = l / s, h = [60, 30, 20, 15, 10, 2, 1], c = 1;
      o == "hour" && (h = [24, 12, 6, 4, 2, 1]);
      for (let m of h)
        if (l / m > s) {
          c = m;
          break;
        }
      let f = Math.ceil((t - e) / c / s), d = Math.log(Math.abs(f)) * Math.LOG10E, g = Math.pow(10, Math.floor(d)) / 10, p = f / g;
      f = lp(h, p) * g, u = c * f, e = Math.floor(e / u) * u, t = Math.ceil(t / u) * u, n = { min: e, max: t, step: u };
    } else
      n = super._adjustMinMax(e, t, s, r);
    return this.setPrivateRaw("durationFormat", a.getFormat(n.step, n.max, o)), n;
  }
  _formatText(e) {
    return this.getDurationFormatter().format(e, this.getPrivate("durationFormat"), this.get("baseUnit"));
  }
  /**
   * Returns text to be used in an axis tooltip for specific relative position.
   *
   * @param   position  Position
   * @return            Tooltip text
   */
  getTooltipText(e, t) {
    const s = this.getDurationFormatter(), r = this.get("extraTooltipPrecision", 0), n = this.getPrivate("stepDecimalPlaces", 0) + r, a = rt(this.positionToValue(e), n);
    return s.format(a, this.getPrivate("durationFormat"), this.get("baseUnit"));
  }
}
Object.defineProperty(Qa, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "DurationAxis"
});
Object.defineProperty(Qa, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: ns.classNames.concat([Qa.className])
});
class Ja extends Oe {
  constructor() {
    super(...arguments), Object.defineProperty(this, "axis", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  _beforeChanged() {
    super._beforeChanged();
    const e = this.get("sprite");
    if (this.isDirty("sprite") && e && (e.setAll({ position: "absolute", role: "figure" }), this._disposers.push(e)), this.isDirty("location")) {
      const t = e.dataItem;
      this.axis && e && t && this.axis._prepareDataItem(t);
    }
  }
  dispose() {
    const e = this.axis;
    e && ye(e._bullets, (t, s) => {
      s.uid == this.uid && delete e._bullets[t];
    }), super.dispose();
  }
}
Object.defineProperty(Ja, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "AxisBullet"
});
Object.defineProperty(Ja, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Oe.classNames.concat([Ja.className])
});
class fn extends Je {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_tickPoints", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    });
  }
}
Object.defineProperty(fn, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "AxisLabel"
});
Object.defineProperty(fn, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Je.classNames.concat([fn.className])
});
class eo extends Is {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_tickPoints", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    });
  }
}
Object.defineProperty(eo, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "AxisLabelRadial"
});
Object.defineProperty(eo, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Is.classNames.concat([eo.className])
});
class pn extends Es {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_tickPoints", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    });
  }
}
Object.defineProperty(pn, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "AxisTick"
});
Object.defineProperty(pn, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Es.classNames.concat([pn.className])
});
class as extends ce {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_axisLength", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 100
    }), Object.defineProperty(this, "_start", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_end", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), Object.defineProperty(this, "_inversed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_minSize", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "chart", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_lc", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), Object.defineProperty(this, "_ls", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_thumbDownPoint", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_downStart", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_downEnd", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "ticks", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new $e(be.new({}), () => pn._new(this._root, {
        themeTags: se(this.ticks.template.get("themeTags", []), this.get("themeTags", []))
      }, [this.ticks.template]))
    }), Object.defineProperty(this, "grid", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new $e(be.new({}), () => $s._new(this._root, {
        themeTags: se(this.grid.template.get("themeTags", []), this.get("themeTags", []))
      }, [this.grid.template]))
    }), Object.defineProperty(this, "axisFills", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new $e(be.new({}), () => ce._new(this._root, {
        themeTags: se(this.axisFills.template.get("themeTags", ["axis", "fill"]), this.get("themeTags", []))
      }, [this.axisFills.template]))
    }), Object.defineProperty(this, "labels", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new $e(be.new({}), () => fn._new(this._root, {
        themeTags: se(this.labels.template.get("themeTags", []), this.get("themeTags", []))
      }, [this.labels.template]))
    }), Object.defineProperty(this, "axis", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "thumb", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  /**
   * @ignore
   */
  makeTick(e, t) {
    const s = this.ticks.make();
    return s._setDataItem(e), e.setRaw("tick", s), s.set("themeTags", se(s.get("themeTags"), t)), this.axis.labelsContainer.children.push(s), this.ticks.push(s), s;
  }
  /**
   * @ignore
   */
  makeGrid(e, t) {
    const s = this.grid.make();
    return s._setDataItem(e), e.setRaw("grid", s), s.set("themeTags", se(s.get("themeTags"), t)), this.axis.gridContainer.children.push(s), this.grid.push(s), s;
  }
  /**
   * @ignore
   */
  makeAxisFill(e, t) {
    const s = this.axisFills.make();
    return s._setDataItem(e), s.set("themeTags", se(s.get("themeTags"), t)), this.axis.gridContainer.children.push(s), e.setRaw("axisFill", s), this.axisFills.push(s), s;
  }
  /**
   * @ignore
   */
  makeLabel(e, t) {
    const s = this.labels.make();
    return s.set("themeTags", se(s.get("themeTags"), t)), this.axis.labelsContainer.children.moveValue(s, 0), s._setDataItem(e), e.setRaw("label", s), this.labels.push(s), s;
  }
  axisLength() {
    return 0;
  }
  /**
   * @ignore
   */
  gridCount() {
    return this.axisLength() / this.get("minGridDistance", 50);
  }
  _updatePositions() {
  }
  _afterNew() {
    super._afterNew(), this.set("isMeasured", !1);
    const e = this.thumb;
    e && (this._disposers.push(e.events.on("pointerdown", (t) => {
      this._handleThumbDown(t.originalEvent);
    })), this._disposers.push(e.events.on("globalpointerup", (t) => {
      this._handleThumbUp(t.originalEvent);
    })), this._disposers.push(e.events.on("globalpointermove", (t) => {
      this._handleThumbMove(t.originalEvent);
    })));
  }
  _changed() {
    if (super._changed(), this.isDirty("pan")) {
      const e = this.thumb;
      if (e) {
        const t = this.axis.labelsContainer, s = this.get("pan");
        s == "zoom" ? t.children.push(e) : s == "none" && t.children.removeValue(e);
      }
    }
  }
  _handleThumbDown(e) {
    this._thumbDownPoint = this.toLocal(this._root.documentPointToRoot({ x: e.clientX, y: e.clientY }));
    const t = this.axis;
    this._downStart = t.get("start"), this._downEnd = t.get("end");
  }
  _handleThumbUp(e) {
    this._thumbDownPoint = void 0;
  }
  _handleThumbMove(e) {
    const t = this._thumbDownPoint;
    if (t) {
      const s = this.toLocal(this._root.documentPointToRoot({ x: e.clientX, y: e.clientY })), r = this._downStart, n = this._downEnd, a = this._getPan(s, t) * Math.min(1, n - r) / 2;
      this.axis.setAll({ start: r - a, end: n + a });
    }
  }
  _getPan(e, t) {
    return 0;
  }
  /**
   * Converts relative position (0-1) on axis to a pixel coordinate.
   *
   * @param position  Position (0-1)
   * @return Coordinate (px)
   */
  positionToCoordinate(e) {
    return this._inversed ? (this._end - e) * this._axisLength : (e - this._start) * this._axisLength;
  }
  /**
   * @ignore
   */
  updateTooltipBounds(e) {
  }
  _updateSize() {
    this.markDirty(), this._clear = !0;
  }
  toAxisPosition(e) {
    const t = this._start || 0, s = this._end || 1;
    return e = e * (s - t), this.get("inversed") ? e = s - e : e = t + e, e;
  }
  /**
   * @ignore
   */
  fixPosition(e) {
    return this.get("inversed") ? 1 - e : e;
  }
  _updateLC() {
  }
  toggleVisibility(e, t, s, r) {
    let n = this.axis;
    const a = n.get("start", 0), o = n.get("end", 1);
    let l = a + (o - a) * (s - 1e-4), u = a + (o - a) * (r + 1e-4);
    t < l || t > u ? e.setPrivate("visible", !1) : e.setPrivate("visible", !0);
  }
  _positionTooltip(e, t) {
    const s = this.chart;
    s && (s.inPlot(t) ? e.set("pointTo", this._display.toGlobal(t)) : e.hide());
  }
  processAxis() {
  }
}
Object.defineProperty(as, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "AxisRenderer"
});
Object.defineProperty(as, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: ce.classNames.concat([as.className])
});
class mr extends as {
  constructor() {
    super(...arguments), Object.defineProperty(this, "thumb", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: gt.new(this._root, { width: R, isMeasured: !1, themeTags: ["axis", "x", "thumb"] })
    });
  }
  _afterNew() {
    this._settings.themeTags = se(this._settings.themeTags, ["renderer", "x"]), super._afterNew(), this.setPrivateRaw("letter", "X");
    const e = this.grid.template;
    e.set("height", R), e.set("width", 0), e.set("draw", (t, s) => {
      t.moveTo(0, 0), t.lineTo(0, s.height());
    }), this.set("draw", (t, s) => {
      t.moveTo(0, 0), t.lineTo(s.width(), 0);
    });
  }
  _changed() {
    super._changed();
    const e = this.axis;
    e.ghostLabel.setPrivate("visible", !this.get("inside")), e.ghostLabel.set("x", -1e3);
    const t = "opposite", s = "inside";
    if (this.isDirty(t) || this.isDirty(s)) {
      const r = this.chart, n = e.children;
      if (this.get(s) ? e.addTag(s) : e.removeTag(s), r) {
        if (this.get(t)) {
          const a = r.topAxesContainer.children;
          a.indexOf(e) == -1 && a.insertIndex(0, e), e.addTag(t), n.moveValue(this);
        } else {
          const a = r.bottomAxesContainer.children;
          a.indexOf(e) == -1 && a.moveValue(e), e.removeTag(t), n.moveValue(this, 0);
        }
        e.ghostLabel._applyThemes(), this.labels.each((a) => {
          a._applyThemes();
        }), this.root._markDirtyRedraw();
      }
      e.markDirtySize();
    }
    this.thumb.setPrivate("height", e.labelsContainer.height());
  }
  _getPan(e, t) {
    return (t.x - e.x) / this.width();
  }
  toAxisPosition(e) {
    const t = this._start || 0, s = this._end || 1;
    return e -= this._ls, e = e * (s - t) / this._lc, this.get("inversed") ? e = s - e : e = t + e, e;
  }
  _updateLC() {
    const e = this.axis, t = e.parent;
    if (t) {
      const s = t.innerWidth();
      this._lc = this.axisLength() / s, this._ls = (e.x() - t.get("paddingLeft", 0)) / s;
    }
  }
  _updatePositions() {
    const e = this.axis, t = e.x() - Te(e.get("centerX", 0), e.width()) - e.parent.get("paddingLeft", 0);
    e.gridContainer.set("x", t), e.topGridContainer.set("x", t), e.bulletsContainer.set("y", this.y());
    const s = e.chart;
    if (s) {
      const r = s.plotContainer, n = e.axisHeader;
      let a = e.get("marginLeft", 0), o = e.x() - a;
      const l = e.parent;
      l && (o -= l.get("paddingLeft", 0)), n.children.length > 0 ? (a = e.axisHeader.width(), e.set("marginLeft", a + 1)) : n.set("width", a), n.setAll({ x: o, y: -1, height: r.height() + 2 });
    }
  }
  /**
   * @ignore
   */
  processAxis() {
    super.processAxis();
    const e = this.axis;
    e.set("width", R);
    const t = this._root.verticalLayout;
    e.set("layout", t), e.labelsContainer.set("width", R), e.axisHeader.setAll({ layout: t });
  }
  /**
   * @ignore
   */
  axisLength() {
    return this.axis.width();
  }
  /**
   * Converts axis relative position to actual coordinate in pixels.
   *
   * @param   position  Position
   * @return            Point
   */
  positionToPoint(e) {
    return { x: this.positionToCoordinate(e), y: 0 };
  }
  /**
   * @ignore
   */
  updateTick(e, t, s, r) {
    if (e) {
      S(t) || (t = 0);
      let n = 0.5;
      S(r) && r > 1 ? n = e.get("multiLocation", n) : n = e.get("location", n), S(s) && s != t && (t = t + (s - t) * n), e.set("x", this.positionToCoordinate(t));
      let a = e.get("length", 0);
      const o = e.get("inside", this.get("inside", !1));
      this.get("opposite") ? (e.set("y", R), o || (a *= -1)) : (e.set("y", 0), o && (a *= -1)), e.set("draw", (l) => {
        l.moveTo(0, 0), l.lineTo(0, a);
      }), this.toggleVisibility(e, t, e.get("minPosition", 0), e.get("maxPosition", 1));
    }
  }
  /**
   * @ignore
   */
  updateLabel(e, t, s, r) {
    if (e) {
      let n = 0.5;
      S(r) && r > 1 ? n = e.get("multiLocation", n) : n = e.get("location", n), S(t) || (t = 0);
      const a = e.get("inside", this.get("inside", !1));
      this.get("opposite") ? a ? (e.set("position", "absolute"), e.set("y", 0)) : (e.set("position", "relative"), e.set("y", R)) : a ? (e.set("y", 0), e.set("position", "absolute")) : (e.set("y", void 0), e.set("position", "relative")), S(s) && s != t && (t = t + (s - t) * n), e.set("x", this.positionToCoordinate(t)), this.toggleVisibility(e, t, e.get("minPosition", 0), e.get("maxPosition", 1));
    }
  }
  /**
   * @ignore
   */
  updateGrid(e, t, s) {
    if (e) {
      S(t) || (t = 0);
      let r = e.get("location", 0.5);
      S(s) && s != t && (t = t + (s - t) * r), e.set("x", this.positionToCoordinate(t)), this.toggleVisibility(e, t, 0, 1);
    }
  }
  /**
   * @ignore
   */
  updateBullet(e, t, s) {
    if (e) {
      const r = e.get("sprite");
      if (r) {
        S(t) || (t = 0);
        let n = e.get("location", 0.5);
        S(s) && s != t && (t = t + (s - t) * n);
        let a = this.axis.roundAxisPosition(t, n), o = this.axis._bullets[a], l = -1;
        if (this.get("opposite") && (l = 1), e.get("stacked"))
          if (o) {
            let u = o.get("sprite");
            u && r.set("y", u.y() + u.height() * l);
          } else
            r.set("y", 0);
        this.axis._bullets[a] = e, r.set("x", this.positionToCoordinate(t)), this.toggleVisibility(r, t, 0, 1);
      }
    }
  }
  /**
   * @ignore
   */
  updateFill(e, t, s) {
    if (e) {
      S(t) || (t = 0), S(s) || (s = 1);
      let r = this.positionToCoordinate(t), n = this.positionToCoordinate(s);
      this.fillDrawMethod(e, r, n);
    }
  }
  fillDrawMethod(e, t, s) {
    e.set("draw", (r) => {
      const n = this.axis.gridContainer.height(), a = this.width();
      s < t && ([s, t] = [t, s]), !(t > a || s < 0) && (r.moveTo(t, 0), r.lineTo(s, 0), r.lineTo(s, n), r.lineTo(t, n), r.lineTo(t, 0));
    });
  }
  /**
   * @ignore
   */
  positionTooltip(e, t) {
    this._positionTooltip(e, { x: this.positionToCoordinate(t), y: 0 });
  }
  /**
   * @ignore
   */
  updateTooltipBounds(e) {
    const t = this.get("inside"), s = 1e5;
    let r = this._display.toGlobal({ x: 0, y: 0 }), n = r.x, a = 0, o = this.axisLength(), l = s, u = "up";
    this.get("opposite") ? t ? (u = "up", a = r.y, l = s) : (u = "down", a = r.y - s, l = s) : t ? (u = "down", a = r.y - s, l = s) : (u = "up", a = r.y, l = s);
    const h = { left: n, right: n + o, top: a, bottom: a + l }, c = e.get("bounds");
    pc(h, c) || (e.set("bounds", h), e.set("pointerOrientation", u));
  }
}
Object.defineProperty(mr, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "AxisRendererX"
});
Object.defineProperty(mr, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: as.classNames.concat([mr.className])
});
class br extends as {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_downY", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "thumb", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: gt.new(this._root, { height: R, isMeasured: !1, themeTags: ["axis", "y", "thumb"] })
    });
  }
  _afterNew() {
    this._settings.themeTags = se(this._settings.themeTags, ["renderer", "y"]), this._settings.opposite && this._settings.themeTags.push("opposite"), super._afterNew(), this.setPrivateRaw("letter", "Y");
    const e = this.grid.template;
    e.set("width", R), e.set("height", 0), e.set("draw", (t, s) => {
      t.moveTo(0, 0), t.lineTo(s.width(), 0);
    }), this.set("draw", (t, s) => {
      t.moveTo(0, 0), t.lineTo(0, s.height());
    });
  }
  _getPan(e, t) {
    return (e.y - t.y) / this.height();
  }
  _changed() {
    super._changed();
    const e = this.axis;
    e.ghostLabel.setPrivate("visible", !this.get("inside")), e.ghostLabel.set("y", -1e3);
    const t = this.thumb, s = "opposite", r = "inside", n = this.chart;
    if (this.isDirty(s) || this.isDirty(r)) {
      const o = e.children;
      if (this.get(r) ? e.addTag(r) : e.removeTag(r), n) {
        if (this.get(s)) {
          const l = n.rightAxesContainer.children;
          l.indexOf(e) == -1 && l.moveValue(e, 0), e.addTag(s), o.moveValue(this, 0);
        } else {
          const l = n.leftAxesContainer.children;
          l.indexOf(e) == -1 && l.moveValue(e), e.removeTag(s), o.moveValue(this);
        }
        e.ghostLabel._applyThemes(), this.labels.each((l) => {
          l._applyThemes();
        }), this.root._markDirtyRedraw();
      }
      e.markDirtySize();
    }
    const a = e.labelsContainer.width();
    n && (this.get(s) ? t.set("centerX", 0) : t.set("centerX", a)), t.setPrivate("width", a);
  }
  /**
   * @ignore
   */
  processAxis() {
    super.processAxis();
    const e = this.axis;
    e.get("height") == null && e.set("height", R);
    const t = this._root.horizontalLayout;
    e.set("layout", t), e.labelsContainer.set("height", R), e.axisHeader.set("layout", t);
  }
  _updatePositions() {
    const e = this.axis, t = e.y() - Te(e.get("centerY", 0), e.height());
    e.gridContainer.set("y", t), e.topGridContainer.set("y", t), e.bulletsContainer.set("x", this.x());
    const s = e.chart;
    if (s) {
      const r = s.plotContainer, n = e.axisHeader;
      let a = e.get("marginTop", 0);
      n.children.length > 0 ? (a = e.axisHeader.height(), e.set("marginTop", a + 1)) : n.set("height", a), n.setAll({ y: e.y() - a, x: -1, width: r.width() + 2 });
    }
  }
  /**
   * @ignore
   */
  axisLength() {
    return this.axis.innerHeight();
  }
  /**
   * Converts axis relative position to actual coordinate in pixels.
   *
   * @param   position  Position
   * @return            Point
   */
  positionToPoint(e) {
    return { x: 0, y: this.positionToCoordinate(e) };
  }
  /**
   * @ignore
   */
  updateLabel(e, t, s, r) {
    if (e) {
      S(t) || (t = 0);
      let n = 0.5;
      S(r) && r > 1 ? n = e.get("multiLocation", n) : n = e.get("location", n);
      const a = this.get("opposite"), o = e.get("inside", this.get("inside", !1));
      a ? (e.set("x", 0), o ? e.set("position", "absolute") : e.set("position", "relative")) : o ? (e.set("x", 0), e.set("position", "absolute")) : (e.set("x", void 0), e.set("position", "relative")), S(s) && s != t && (t = t + (s - t) * n), e.set("y", this.positionToCoordinate(t)), this.toggleVisibility(e, t, e.get("minPosition", 0), e.get("maxPosition", 1));
    }
  }
  /**
   * @ignore
   */
  updateGrid(e, t, s) {
    if (e) {
      S(t) || (t = 0);
      let r = e.get("location", 0.5);
      S(s) && s != t && (t = t + (s - t) * r), e.set("y", this.positionToCoordinate(t)), this.toggleVisibility(e, t, 0, 1);
    }
  }
  /**
   * @ignore
   */
  updateTick(e, t, s, r) {
    if (e) {
      S(t) || (t = 0);
      let n = 0.5;
      S(r) && r > 1 ? n = e.get("multiLocation", n) : n = e.get("location", n), S(s) && s != t && (t = t + (s - t) * n), e.set("y", this.positionToCoordinate(t));
      let a = e.get("length", 0);
      const o = e.get("inside", this.get("inside", !1));
      this.get("opposite") ? (e.set("x", 0), o && (a *= -1)) : o || (a *= -1), e.set("draw", (l) => {
        l.moveTo(0, 0), l.lineTo(a, 0);
      }), this.toggleVisibility(e, t, e.get("minPosition", 0), e.get("maxPosition", 1));
    }
  }
  /**
   * @ignore
   */
  updateBullet(e, t, s) {
    if (e) {
      const r = e.get("sprite");
      if (r) {
        S(t) || (t = 0);
        let n = e.get("location", 0.5);
        S(s) && s != t && (t = t + (s - t) * n);
        let a = this.axis.roundAxisPosition(t, n), o = this.axis._bullets[a], l = 1;
        if (this.get("opposite") && (l = -1), e.get("stacked"))
          if (o) {
            let u = o.get("sprite");
            u && r.set("x", u.x() + u.width() * l);
          } else
            r.set("x", 0);
        this.axis._bullets[a] = e, r.set("y", this.positionToCoordinate(t)), this.toggleVisibility(r, t, 0, 1);
      }
    }
  }
  /**
   * @ignore
   */
  updateFill(e, t, s) {
    if (e) {
      S(t) || (t = 0), S(s) || (s = 1);
      let r = this.positionToCoordinate(t), n = this.positionToCoordinate(s);
      this.fillDrawMethod(e, r, n);
    }
  }
  fillDrawMethod(e, t, s) {
    e.set("draw", (r) => {
      const n = this.axis.gridContainer.width(), a = this.height();
      s < t && ([s, t] = [t, s]), !(t > a || s < 0) && (r.moveTo(0, t), r.lineTo(n, t), r.lineTo(n, s), r.lineTo(0, s), r.lineTo(0, t));
    });
  }
  /**
   * Converts relative position (0-1) on axis to a pixel coordinate.
   *
   * @param position  Position (0-1)
   * @return Coordinate (px)
   */
  positionToCoordinate(e) {
    return this._inversed ? (e - this._start) * this._axisLength : (this._end - e) * this._axisLength;
  }
  /**
   * @ignore
   */
  positionTooltip(e, t) {
    this._positionTooltip(e, { x: 0, y: this.positionToCoordinate(t) });
  }
  /**
   * @ignore
   */
  updateTooltipBounds(e) {
    const t = this.get("inside"), s = 1e5;
    let r = this._display.toGlobal({ x: 0, y: 0 }), n = r.y, a = 0, o = this.axisLength(), l = s, u = "right";
    this.get("opposite") ? t ? (u = "right", a = r.x - s, l = s) : (u = "left", a = r.x, l = s) : t ? (u = "left", a = r.x, l = s) : (u = "right", a = r.x - s, l = s);
    const h = { left: a, right: a + l, top: n, bottom: n + o }, c = e.get("bounds");
    pc(h, c) || (e.set("bounds", h), e.set("pointerOrientation", u));
  }
  _updateLC() {
    const e = this.axis, t = e.parent;
    if (t) {
      const s = t.innerHeight();
      this._lc = this.axisLength() / s, this._ls = e.y() / s;
    }
  }
  /**
   * @ignore
   */
  toAxisPosition(e) {
    const t = this._start || 0, s = this._end || 1;
    return e -= this._ls, e = e * (s - t) / this._lc, this.get("inversed") ? e = t + e : e = s - e, e;
  }
  /**
   * @ignore
   */
  fixPosition(e) {
    return this.get("inversed") ? e : 1 - e;
  }
}
Object.defineProperty(br, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "AxisRendererY"
});
Object.defineProperty(br, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: as.classNames.concat([br.className])
});
class os extends Pe {
  _beforeChanged() {
    super._beforeChanged(), (this.isDirty("lowX0") || this.isDirty("lowY0") || this.isDirty("lowX1") || this.isDirty("lowY1") || this.isDirty("highX0") || this.isDirty("highX1") || this.isDirty("highY0") || this.isDirty("highY1")) && (this._clear = !0);
  }
  _draw() {
    super._draw();
    const e = this._display;
    e.moveTo(this.get("lowX0", 0), this.get("lowY0", 0)), e.lineTo(this.get("lowX1", 0), this.get("lowY1", 0)), e.moveTo(this.get("highX0", 0), this.get("highY0", 0)), e.lineTo(this.get("highX1", 0), this.get("highY1", 0));
  }
}
Object.defineProperty(os, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Candlestick"
});
Object.defineProperty(os, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Pe.classNames.concat([os.className])
});
class ls extends ss {
  constructor() {
    super(...arguments), Object.defineProperty(this, "columns", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new $e(be.new({}), () => Pe._new(this._root, {
        position: "absolute",
        themeTags: se(this.columns.template.get("themeTags", []), ["series", "column"])
      }, [this.columns.template]))
    });
  }
  /**
   * @ignore
   */
  makeColumn(e, t) {
    const s = this.mainContainer.children.push(t.make());
    return s._setDataItem(e), t.push(s), s;
  }
  _processAxisRange(e) {
    super._processAxisRange(e), e.columns = new $e(be.new({}), () => Pe._new(this._root, {
      position: "absolute",
      themeTags: se(e.columns.template.get("themeTags", []), ["series", "column"])
    }, [this.columns.template, e.columns.template]));
  }
}
Object.defineProperty(ls, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "ColumnSeries"
});
Object.defineProperty(ls, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: ss.classNames.concat([ls.className])
});
class us extends ls {
  constructor() {
    super(...arguments), Object.defineProperty(this, "columns", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new $e(be.new({
        themeTags: ["autocolor"]
      }), () => os._new(this._root, {
        themeTags: se(this.columns.template.get("themeTags", []), ["candlestick", "series", "column"])
      }, [this.columns.template]))
    });
  }
  /**
   * @ignore
   */
  makeColumn(e, t) {
    const s = this.mainContainer.children.push(t.make());
    return s._setDataItem(e), t.push(s), s;
  }
  _updateGraphics(e, t) {
    super._updateGraphics(e, t);
    const s = this.getRaw("xAxis"), r = this.getRaw("yAxis"), n = this.getRaw("baseAxis");
    let a = this.get("vcy", 1), o = this.get("vcx", 1), l, u, h, c, f, d, g, p, _ = this.get("locationX", e.get("locationX", 0.5)), m = this.get("locationY", e.get("locationY", 0.5)), v = this.get("openLocationX", e.get("openLocationX", _)), b = this.get("openLocationY", e.get("openLocationY", m)), y;
    if (r === n) {
      let x = s.getDataItemPositionX(e, this._xOpenField, 1, o), D = s.getDataItemPositionX(e, this._xField, 1, o);
      u = s.getDataItemPositionX(e, this._xLowField, 1, o), d = s.getDataItemPositionX(e, this._xHighField, 1, o), f = Math.max(x, D), l = Math.min(x, D);
      let A = this._aLocationY0 + b - 0.5, C = this._aLocationY1 + m - 0.5;
      h = r.getDataItemPositionY(e, this._yField, A + (C - A) / 2, a), c = h, g = h, p = h, y = "horizontal";
    } else {
      let x = r.getDataItemPositionY(e, this._yOpenField, 1, a), D = r.getDataItemPositionY(e, this._yField, 1, a);
      c = r.getDataItemPositionY(e, this._yLowField, 1, a), p = r.getDataItemPositionY(e, this._yHighField, 1, a), g = Math.max(x, D), h = Math.min(x, D);
      let A = this._aLocationX0 + v - 0.5, C = this._aLocationX1 + _ - 0.5;
      l = s.getDataItemPositionX(e, this._xField, A + (C - A) / 2, o), u = l, f = l, d = l, y = "vertical";
    }
    this._updateCandleGraphics(e, l, u, h, c, f, d, g, p, y);
  }
  _updateCandleGraphics(e, t, s, r, n, a, o, l, u, h) {
    let c = e.get("graphics");
    if (c) {
      let f = this.getPoint(t, r), d = this.getPoint(s, n), g = this.getPoint(a, l), p = this.getPoint(o, u), _ = c.x(), m = c.y();
      c.set("lowX0", f.x - _), c.set("lowY0", f.y - m), c.set("lowX1", d.x - _), c.set("lowY1", d.y - m), c.set("highX0", g.x - _), c.set("highY0", g.y - m), c.set("highX1", p.x - _), c.set("highY1", p.y - m), c.set("orientation", h);
      let v = e.get("rangeGraphics");
      v && w(v, (b) => {
        b.set("lowX0", f.x - _), b.set("lowY0", f.y - m), b.set("lowX1", d.x - _), b.set("lowY1", d.y - m), b.set("highX0", g.x - _), b.set("highY0", g.y - m), b.set("highX1", p.x - _), b.set("highY1", p.y - m), b.set("orientation", h);
      });
    }
  }
  _processAxisRange(e) {
    super._processAxisRange(e), e.columns = new $e(be.new({}), () => os._new(this._root, {
      themeTags: se(e.columns.template.get("themeTags", []), ["candlestick", "series", "column"])
    }, [this.columns.template, e.columns.template]));
  }
}
Object.defineProperty(us, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "CandlestickSeries"
});
Object.defineProperty(us, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: ls.classNames.concat([us.className])
});
class yr extends os {
  _draw() {
    const e = this._display;
    e.moveTo(this.get("lowX1", 0), this.get("lowY1", 0)), e.lineTo(this.get("highX1", 0), this.get("highY1", 0));
    let t = this.width(), s = this.height();
    if (this.get("orientation") == "vertical") {
      let r = s, n = 0;
      e.moveTo(0, r), e.lineTo(t / 2, r), e.moveTo(t / 2, n), e.lineTo(t, n);
    } else {
      let r = 0, n = t;
      e.moveTo(r, 0), e.lineTo(r, s / 2), e.moveTo(n, s / 2), e.lineTo(n, s);
    }
  }
}
Object.defineProperty(yr, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "OHLC"
});
Object.defineProperty(yr, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: os.classNames.concat([yr.className])
});
class to extends us {
  constructor() {
    super(...arguments), Object.defineProperty(this, "columns", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new $e(be.new({
        themeTags: ["autocolor"]
      }), () => yr._new(this._root, {
        themeTags: se(this.columns.template.get("themeTags", []), ["ohlc", "series", "column"])
      }, [this.columns.template]))
    });
  }
  /**
   * @ignore
   */
  makeColumn(e, t) {
    const s = this.mainContainer.children.push(t.make());
    return s._setDataItem(e), t.push(s), s;
  }
  _processAxisRange(e) {
    super._processAxisRange(e), e.columns = new $e(be.new({}), () => yr._new(this._root, {
      themeTags: se(e.columns.template.get("themeTags", []), ["ohlc", "series", "column"])
    }, [this.columns.template, e.columns.template]));
  }
}
Object.defineProperty(to, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "OHLCSeries"
});
Object.defineProperty(to, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: us.classNames.concat([to.className])
});
class dt extends is {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_endIndex", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_strokeGenerator", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Mp()
    }), Object.defineProperty(this, "_fillGenerator", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: TP()
    }), Object.defineProperty(this, "_legendStroke", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_legendFill", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "strokes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new $e(be.new({}), () => ce._new(this._root, {
        themeTags: se(this.strokes.template.get("themeTags", []), ["line", "series", "stroke"])
      }, [this.strokes.template]))
    }), Object.defineProperty(this, "fills", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new $e(be.new({}), () => ce._new(this._root, {
        themeTags: se(this.strokes.template.get("themeTags", []), ["line", "series", "fill"])
      }, [this.fills.template]))
    }), Object.defineProperty(this, "_fillTemplate", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_strokeTemplate", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_previousPoint", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: [0, 0, 0, 0]
    }), Object.defineProperty(this, "_dindex", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_sindex", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    });
  }
  _afterNew() {
    this._fillGenerator.y0(function(e) {
      return e[3];
    }), this._fillGenerator.x0(function(e) {
      return e[2];
    }), this._fillGenerator.y1(function(e) {
      return e[1];
    }), this._fillGenerator.x1(function(e) {
      return e[0];
    }), super._afterNew();
  }
  /**
   * @ignore
   */
  makeStroke(e) {
    const t = this.mainContainer.children.push(e.make());
    return e.push(t), t;
  }
  /**
   * @ignore
   */
  makeFill(e) {
    const t = this.mainContainer.children.push(e.make());
    return e.push(t), t;
  }
  _updateChildren() {
    this._strokeTemplate = void 0, this._fillTemplate = void 0;
    let e = this.get("xAxis"), t = this.get("yAxis");
    if (this.isDirty("stroke")) {
      const s = this.get("stroke");
      this.strokes.template.set("stroke", s);
      const r = this._legendStroke;
      r && r.states.lookup("default").set("stroke", s);
    }
    if (this.isDirty("fill")) {
      const s = this.get("fill");
      this.fills.template.set("fill", s);
      const r = this._legendFill;
      r && r.states.lookup("default").set("fill", s);
    }
    if (this.isDirty("curveFactory")) {
      const s = this.get("curveFactory");
      s && (this._strokeGenerator.curve(s), this._fillGenerator.curve(s));
    }
    if (e.inited && t.inited) {
      if (this._axesDirty || this._valuesDirty || this._stackDirty || this.isDirty("vcx") || this.isDirty("vcy") || this._sizeDirty || this.isDirty("connect") || this.isDirty("curveFactory")) {
        this.fills.each((h) => {
          h.setPrivate("visible", !1);
        }), this.strokes.each((h) => {
          h.setPrivate("visible", !1);
        }), this.axisRanges.each((h) => {
          let c = h.fills;
          c && c.each((d) => {
            d.setPrivate("visible", !1);
          });
          let f = h.strokes;
          f && f.each((d) => {
            d.setPrivate("visible", !1);
          });
        });
        let s = this.startIndex(), r = this.strokes.template.get("templateField"), n = this.fills.template.get("templateField"), a = !0, o = !0;
        r && (a = !1), n && (o = !1);
        for (let h = s - 1; h >= 0; h--) {
          let c = this.dataItems[h], f = !0, d = c.dataContext;
          if (r && d[r] && (a = !0), n && d[n] && (o = !0), w(this._valueFields, (g) => {
            S(c.get(g)) || (f = !1);
          }), f && a && o) {
            s = h;
            break;
          }
        }
        let l = this.dataItems.length, u = this.endIndex();
        if (u < l) {
          u++;
          for (let h = u; h < l; h++) {
            let c = this.dataItems[h], f = !0;
            if (w(this._valueFields, (d) => {
              S(c.get(d)) || (f = !1);
            }), f) {
              u = h + 1;
              break;
            }
          }
        }
        if (s > 0 && s--, this._endIndex = u, this._clearGraphics(), this._sindex = 0, this._dindex = s, this.dataItems.length == 1)
          this._startSegment(0);
        else
          for (; this._dindex < u - 1; )
            this._startSegment(this._dindex), this._sindex++;
      }
    } else
      this._skipped = !0;
    super._updateChildren();
  }
  _clearGraphics() {
    this.strokes.clear(), this.fills.clear();
  }
  _startSegment(e) {
    let t = this._endIndex, s = t;
    const r = this.get("autoGapCount"), n = this.get("connect"), a = this.makeFill(this.fills), o = this._fillTemplate, l = this.fills.template;
    o && o != l && (a.template = o), a.setPrivate("visible", !0);
    const u = this.makeStroke(this.strokes), h = this._strokeTemplate;
    h && h != this.strokes.template && (u.template = h), u.setPrivate("visible", !0);
    let c = this.get("xAxis"), f = this.get("yAxis"), d = this.get("baseAxis"), g = this.get("vcx", 1), p = this.get("vcy", 1), _ = this._xField, m = this._yField, v = this._xOpenField, b = this._yOpenField;
    const y = this.get("openValueXField"), x = this.get("openValueYField");
    y || (v = this._xField), x || (b = this._yField);
    const D = this.get("stacked"), A = c.basePosition(), C = f.basePosition();
    let O;
    d === f ? O = this._yField : O = this._xField;
    const T = [];
    let L = [];
    T.push(L);
    const j = this.strokes.template.get("templateField"), N = this.fills.template.get("templateField");
    let ee = this.get("locationX", 0.5), z = this.get("locationY", 0.5), H = this.get("openLocationX", ee), $ = this.get("openLocationY", z);
    const Z = this.get("minDistance", 0);
    let B, he = this.fills.template.get("visible");
    this.axisRanges.length > 0 && (he = !0);
    let M = !1;
    (D || y || x) && (M = !0);
    const k = {
      points: L,
      segments: T,
      stacked: D,
      getOpen: M,
      basePosX: A,
      basePosY: C,
      fillVisible: he,
      xField: _,
      yField: m,
      xOpenField: v,
      yOpenField: b,
      vcx: g,
      vcy: p,
      baseAxis: d,
      xAxis: c,
      yAxis: f,
      locationX: ee,
      locationY: z,
      openLocationX: H,
      openLocationY: $,
      minDistance: Z
    };
    for (B = e; B < s; B++) {
      this._dindex = B;
      const P = this._dataItems[B];
      let F = P.get(_), te = P.get(m);
      if (F == null || te == null ? n || (L = [], T.push(L), k.points = L) : this._getPoints(P, k), j) {
        let U = P.dataContext[j];
        if (U)
          if (U instanceof be || (U = be.new(U)), this._strokeTemplate = U, B > e) {
            s = B;
            break;
          } else
            u.template = U;
      }
      if (N) {
        let U = P.dataContext[N];
        if (U)
          if (U instanceof be || (U = be.new(U)), this._fillTemplate = U, B > e) {
            s = B;
            break;
          } else
            a.template = U;
      }
      if (!n) {
        let U = this.dataItems[B + 1];
        U && d.shouldGap(P, U, r, O) && (L = [], T.push(L), k.points = L);
      }
    }
    a.setRaw("userData", [e, B]), u.setRaw("userData", [e, B]), B === t && this._endLine(L, T[0][0]), u && this._drawStroke(u, T), a && this._drawFill(a, T), this.axisRanges.each((P) => {
      const F = P.container, te = P.fills, U = this.makeFill(te);
      F && F.children.push(U), U.setPrivate("visible", !0), this._drawFill(U, T);
      const _e = P.strokes, Se = this.makeStroke(_e);
      F && F.children.push(Se), Se.setPrivate("visible", !0), this._drawStroke(Se, T), U.setRaw("userData", [e, B]), Se.setRaw("userData", [e, B]);
    });
  }
  _getPoints(e, t) {
    let s = t.points, r = e.get("locationX", t.locationX), n = e.get("locationY", t.locationY), a = t.xAxis.getDataItemPositionX(e, t.xField, r, t.vcx), o = t.yAxis.getDataItemPositionY(e, t.yField, n, t.vcy);
    if (this._shouldInclude(a)) {
      const l = this.getPoint(a, o), u = [l.x, l.y];
      if (l.x += this._x, l.y += this._y, e.set("point", l), t.fillVisible) {
        let h = a, c = o;
        if (t.baseAxis === t.xAxis ? c = t.basePosY : t.baseAxis === t.yAxis && (h = t.basePosX), t.getOpen) {
          let d = e.get(t.xOpenField), g = e.get(t.yOpenField);
          if (d != null && g != null) {
            let p = e.get("openLocationX", t.openLocationX), _ = e.get("openLocationY", t.openLocationY);
            if (t.stacked) {
              let m = e.get("stackToItemX"), v = e.get("stackToItemY");
              m ? (h = t.xAxis.getDataItemPositionX(m, t.xField, p, m.component.get("vcx")), Wt(h) && (h = t.basePosX)) : t.yAxis === t.baseAxis ? h = t.basePosX : h = t.xAxis.getDataItemPositionX(e, t.xOpenField, p, t.vcx), v ? (c = t.yAxis.getDataItemPositionY(v, t.yField, _, v.component.get("vcy")), Wt(c) && (c = t.basePosY)) : t.xAxis === t.baseAxis ? c = t.basePosY : c = t.yAxis.getDataItemPositionY(e, t.yOpenField, _, t.vcy);
            } else
              h = t.xAxis.getDataItemPositionX(e, t.xOpenField, p, t.vcx), c = t.yAxis.getDataItemPositionY(e, t.yOpenField, _, t.vcy);
          }
        }
        let f = this.getPoint(h, c);
        u[2] = f.x, u[3] = f.y;
      }
      if (t.minDistance > 0) {
        const h = u[0], c = u[1], f = u[2], d = u[3], g = this._previousPoint, p = g[0], _ = g[1], m = g[2], v = g[3];
        (Math.hypot(h - p, c - _) > t.minDistance || f && d && Math.hypot(f - m, d - v) > t.minDistance) && (s.push(u), this._previousPoint = u);
      } else
        s.push(u);
    }
  }
  _endLine(e, t) {
  }
  _drawStroke(e, t) {
    e.get("visible") && !e.get("forceHidden") && e.set("draw", (s) => {
      w(t, (r) => {
        this._strokeGenerator.context(s), this._strokeGenerator(r);
      });
    });
  }
  _drawFill(e, t) {
    e.get("visible") && !e.get("forceHidden") && e.set("draw", (s) => {
      w(t, (r) => {
        this._fillGenerator.context(s), this._fillGenerator(r);
      });
    });
  }
  _processAxisRange(e) {
    super._processAxisRange(e), e.fills = new $e(be.new({}), () => ce._new(this._root, {
      themeTags: se(e.fills.template.get("themeTags", []), ["line", "series", "fill"])
    }, [this.fills.template, e.fills.template])), e.strokes = new $e(be.new({}), () => ce._new(this._root, {
      themeTags: se(e.strokes.template.get("themeTags", []), ["line", "series", "stroke"])
    }, [this.strokes.template, e.strokes.template]));
  }
  /**
   * @ignore
   */
  createLegendMarker(e) {
    const t = this.get("legendDataItem");
    if (t) {
      const s = t.get("marker"), r = t.get("markerRectangle");
      r && r.setPrivate("visible", !1), s.set("background", gt.new(s._root, { fillOpacity: 0, fill: K(0) }));
      const n = s.children.push(ce._new(s._root, {
        themeTags: ["line", "series", "legend", "marker", "stroke"],
        interactive: !1
      }, [this.strokes.template]));
      this._legendStroke = n;
      const a = s.children.push(ce._new(s._root, {
        themeTags: ["line", "series", "legend", "marker", "fill"]
      }, [this.fills.template]));
      this._legendFill = a;
      const o = this._root.interfaceColors.get("disabled");
      if (n.states.create("disabled", { fill: o, stroke: o }), a.states.create("disabled", { fill: o, stroke: o }), this.bullets.length > 0) {
        const l = this.bullets.getIndex(0);
        if (l) {
          const u = l(s._root, this, new ti(this, { legend: !0 }, {}));
          if (u) {
            const h = u.get("sprite");
            h instanceof ce && h.states.create("disabled", { fill: o, stroke: o }), h && (h.set("tooltipText", void 0), h.set("tooltipHTML", void 0), s.children.push(h), h.setAll({ x: s.width() / 2, y: s.height() / 2 }));
          }
        }
      }
    }
  }
}
Object.defineProperty(dt, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "LineSeries"
});
Object.defineProperty(dt, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: is.classNames.concat([dt.className])
});
class EP {
  constructor(e, t) {
    Object.defineProperty(this, "_line", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_point", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_context", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_x0", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_x1", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_y0", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_y1", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_t0", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_tension", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), this._context = e, this._tension = t;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN, this._point = 0;
  }
  lineEnd() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        ll(this, this._t0, Ch(this, this._t0));
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  }
  point(e, t) {
    [e, t] = [t, e];
    let s = NaN;
    if (e = +e, t = +t, !(e === this._x1 && t === this._y1)) {
      switch (this._point) {
        case 0:
          this._point = 1, this._line ? this._context.lineTo(t, e) : this._context.moveTo(t, e);
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3, ll(this, Ch(this, s = Dh(this, e, t)), s);
          break;
        default:
          ll(this, this._t0, s = Dh(this, e, t));
          break;
      }
      this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t, this._t0 = s;
    }
  }
}
function ru(i) {
  function e(t) {
    return new EP(t, i);
  }
  return e.tension = function(t) {
    return ru(+t);
  }, e;
}
function Sh(i) {
  return i < 0 ? -1 : 1;
}
function Dh(i, e, t) {
  let s = i._x1 - i._x0, r = e - i._x1, n = (i._y1 - i._y0) / (s || r < 0 && -0), a = (t - i._y1) / (r || s < 0 && -0), o = (n * r + a * s) / (s + r);
  return (Sh(n) + Sh(a)) * Math.min(Math.abs(n), Math.abs(a), 0.5 * Math.abs(o)) || 0;
}
function Ch(i, e) {
  let t = i._x1 - i._x0;
  return t ? (3 * (i._y1 - i._y0) / t - e) / 2 : e;
}
function ll(i, e, t) {
  let s = i._x0, r = i._y0, n = i._x1, a = i._y1, o = (n - s) / 1.5 * (1 - i._tension);
  i._context.bezierCurveTo(r + o * e, s + o, a - o * t, n - o, a, n);
}
class io extends dt {
  _afterNew() {
    this._setDefault("curveFactory", ru(this.get("tension", 0.5))), super._afterNew();
  }
  _updateChildren() {
    this.isDirty("tension") && (this.set("curveFactory", ru(this.get("tension", 0.5))), this._valuesDirty = !0), super._updateChildren();
  }
}
Object.defineProperty(io, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "SmoothedYLineSeries"
});
Object.defineProperty(io, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: dt.classNames.concat([io.className])
});
class RP {
  constructor(e, t) {
    Object.defineProperty(this, "_line", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_point", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_context", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_x0", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_x1", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_y0", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_y1", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_t0", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_tension", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), this._context = e, this._tension = t;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN, this._point = 0;
  }
  lineEnd() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        ul(this, this._t0, Oh(this, this._t0));
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  }
  point(e, t) {
    let s = NaN;
    if (e = +e, t = +t, !(e === this._x1 && t === this._y1)) {
      switch (this._point) {
        case 0:
          this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3, ul(this, Oh(this, s = Ph(this, e, t)), s);
          break;
        default:
          ul(this, this._t0, s = Ph(this, e, t));
          break;
      }
      this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t, this._t0 = s;
    }
  }
}
function Th(i) {
  function e(t) {
    return new RP(t, i);
  }
  return e;
}
function kh(i) {
  return i < 0 ? -1 : 1;
}
function Ph(i, e, t) {
  let s = i._x1 - i._x0, r = e - i._x1, n = (i._y1 - i._y0) / (s || r < 0 && -0), a = (t - i._y1) / (r || s < 0 && -0), o = (n * r + a * s) / (s + r);
  return (kh(n) + kh(a)) * Math.min(Math.abs(n), Math.abs(a), 0.5 * Math.abs(o)) || 0;
}
function Oh(i, e) {
  let t = i._x1 - i._x0;
  return t ? (3 * (i._y1 - i._y0) / t - e) / 2 : e;
}
function ul(i, e, t) {
  let s = i._x0, r = i._y0, n = i._x1, a = i._y1, o = (n - s) / 1.5 * (1 - i._tension);
  i._context.bezierCurveTo(s + o, r + o * e, n - o, a - o * t, n, a);
}
class so extends dt {
  _afterNew() {
    this._setDefault("curveFactory", Th(this.get("tension", 0.5))), super._afterNew();
  }
  _updateChildren() {
    this.isDirty("tension") && (this.set("curveFactory", Th(this.get("tension", 0.5))), this._valuesDirty = !0), super._updateChildren();
  }
}
Object.defineProperty(so, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "SmoothedXLineSeries"
});
Object.defineProperty(so, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: dt.classNames.concat([so.className])
});
class ro extends dt {
  _afterNew() {
    this._setDefault("curveFactory", wh.tension(this.get("tension", 0.5))), super._afterNew();
  }
  _updateChildren() {
    this.isDirty("tension") && (this.set("curveFactory", wh.tension(this.get("tension", 0.5))), this._valuesDirty = !0), super._updateChildren();
  }
}
Object.defineProperty(ro, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "SmoothedXYLineSeries"
});
Object.defineProperty(ro, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: dt.classNames.concat([ro.className])
});
class vr extends dt {
  _afterNew() {
    this._setDefault("curveFactory", kP), super._afterNew();
  }
  _getPoints(e, t) {
    let s = t.points, r = this.get("stepWidth", R).value / 2, n = e.get("locationX", t.locationX), a = e.get("locationY", t.locationY), o = n, l = a;
    t.baseAxis === t.xAxis ? (n -= r, o += r) : t.baseAxis === t.yAxis && (a -= r, l += r);
    let u = t.xAxis.getDataItemPositionX(e, t.xField, n, t.vcx), h = t.yAxis.getDataItemPositionY(e, t.yField, a, t.vcy), c = t.xAxis.getDataItemPositionX(e, t.xField, o, t.vcx), f = t.yAxis.getDataItemPositionY(e, t.yField, l, t.vcy);
    if (this._shouldInclude(u)) {
      const d = this.getPoint(u, h), g = [d.x, d.y], p = this.getPoint(c, f), _ = [p.x, p.y];
      if (t.fillVisible) {
        let m = u, v = h, b = c, y = f;
        if (t.baseAxis === t.xAxis ? (v = t.basePosY, y = t.basePosY) : t.baseAxis === t.yAxis && (m = t.basePosX, b = t.basePosX), t.getOpen) {
          let A = e.get(t.xOpenField), C = e.get(t.yOpenField);
          if (A != null && C != null)
            if (n = e.get("openLocationX", t.openLocationX), a = e.get("openLocationY", t.openLocationY), o = n, l = a, t.baseAxis === t.xAxis ? (n -= r, o += r) : t.baseAxis === t.yAxis && (a -= r, l += r), t.stacked) {
              let O = e.get("stackToItemX"), T = e.get("stackToItemY");
              O ? (m = t.xAxis.getDataItemPositionX(O, t.xField, n, O.component.get("vcx")), b = t.xAxis.getDataItemPositionX(O, t.xField, o, O.component.get("vcx"))) : t.yAxis === t.baseAxis ? (m = t.basePosX, b = t.basePosX) : t.baseAxis === t.yAxis && (m = t.xAxis.getDataItemPositionX(e, t.xOpenField, n, t.vcx), b = t.xAxis.getDataItemPositionX(e, t.xOpenField, o, t.vcx)), T ? (v = t.yAxis.getDataItemPositionY(T, t.yField, a, T.component.get("vcy")), y = t.yAxis.getDataItemPositionY(T, t.yField, l, T.component.get("vcy"))) : t.xAxis === t.baseAxis ? (v = t.basePosY, y = t.basePosY) : t.baseAxis === t.yAxis && (v = t.yAxis.getDataItemPositionY(e, t.yOpenField, a, t.vcy), y = t.yAxis.getDataItemPositionY(e, t.yOpenField, l, t.vcy));
            } else
              m = t.xAxis.getDataItemPositionX(e, t.xOpenField, n, t.vcx), v = t.yAxis.getDataItemPositionY(e, t.yOpenField, a, t.vcy), b = t.xAxis.getDataItemPositionX(e, t.xOpenField, o, t.vcx), y = t.yAxis.getDataItemPositionY(e, t.yOpenField, l, t.vcy);
        }
        let x = this.getPoint(m, v), D = this.getPoint(b, y);
        g[2] = x.x, g[3] = x.y, _[2] = D.x, _[3] = D.y;
      }
      s.push(g), s.push(_), e.set("point", { x: g[0] + (_[0] - g[0]) / 2, y: g[1] + (_[1] - g[1]) / 2 });
    }
    this.get("noRisers") && (t.points = [], t.segments.push(s));
  }
}
Object.defineProperty(vr, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "StepLineSeries"
});
Object.defineProperty(vr, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: dt.classNames.concat([vr.className])
});
const Xn = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Axis: rs,
  AxisBullet: Ja,
  AxisLabel: fn,
  AxisLabelRadial: eo,
  AxisRenderer: as,
  AxisRendererX: mr,
  AxisRendererY: br,
  AxisTick: pn,
  BaseColumnSeries: ss,
  Candlestick: os,
  CandlestickSeries: us,
  CategoryAxis: Mi,
  CategoryDateAxis: Ka,
  ColumnSeries: ls,
  DateAxis: _r,
  DefaultTheme: Ip,
  DurationAxis: Qa,
  GaplessDateAxis: qa,
  Grid: $s,
  LineSeries: dt,
  OHLC: yr,
  OHLCSeries: to,
  SmoothedXLineSeries: so,
  SmoothedXYLineSeries: ro,
  SmoothedYLineSeries: io,
  StepLineSeries: vr,
  ValueAxis: ns,
  XYChart: gr,
  XYChartScrollbar: hn,
  XYCursor: dn,
  XYSeries: is
}, Symbol.toStringTag, { value: "Module" }));
class gc extends Bs {
  setupDefaultRules() {
    super.setupDefaultRules(), this.rule("Component").setAll({
      interpolationDuration: 600
    }), this.rule("Hierarchy").set("animationDuration", 600), this.rule("Scrollbar").set("animationDuration", 600), this.rule("Tooltip").set("animationDuration", 300), this.rule("MapChart").set("animationDuration", 1e3), this.rule("MapChart").set("wheelDuration", 300), this.rule("Entity").setAll({
      stateAnimationDuration: 600
    }), this.rule("Sprite").states.create("default", { stateAnimationDuration: 600 }), this.rule("Tooltip", ["axis"]).setAll({
      animationDuration: 200
    }), this.rule("WordCloud").set("animationDuration", 500), this.rule("Polygon").set("animationDuration", 600), this.rule("ArcDiagram").set("animationDuration", 600);
  }
}
const $P = "_filter_1rgf4_44", NP = "_icon_size_1rgf4_47", FP = "_edit_1rgf4_58", YP = "_trash_1rgf4_64", BP = "_clone_1rgf4_70", HP = "_check_1rgf4_76", zP = "_previous_1rgf4_88", VP = "_add_1rgf4_116", XP = "_remove_1rgf4_119", WP = "_download_1rgf4_177", UP = "_next_1rgf4_135", GP = "_expand_1rgf4_247", cl = {
  default: "_default_1rgf4_7",
  "customizing-data-table": "_customizing-data-table_1rgf4_25",
  filter: $P,
  icon_size: NP,
  "custom-colum": "_custom-colum_1rgf4_51",
  "kebab-menu": "_kebab-menu_1rgf4_54",
  edit: FP,
  trash: YP,
  clone: BP,
  check: HP,
  previous: zP,
  "left-arrow": "_left-arrow_1rgf4_102",
  add: VP,
  remove: XP,
  "row-inline-action-buttons": "_row-inline-action-buttons_1rgf4_122",
  "next-previous-buttons": "_next-previous-buttons_1rgf4_135",
  "plus-button": "_plus-button_1rgf4_155",
  "minus-button": "_minus-button_1rgf4_169",
  download: WP,
  next: UP,
  "arrow-backward-skinny": "_arrow-backward-skinny_1rgf4_201",
  "arrow-forward-skinny": "_arrow-forward-skinny_1rgf4_211",
  "arrow-backward": "_arrow-backward_1rgf4_201",
  "arrow-forward": "_arrow-forward_1rgf4_211",
  "bar-filter": "_bar-filter_1rgf4_241",
  expand: GP
}, Mh = {
  filter: "customizing-data-table",
  download: "customizing-data-table",
  "custom-colum": "customizing-data-table",
  "kebab-menu": "customizing-data-table",
  edit: "row-inline-action-buttons",
  trash: "row-inline-action-buttons",
  check: "row-inline-action-buttons",
  clone: "row-inline-action-buttons",
  add: "plus-button",
  remove: "minus-button",
  default: ""
}, ZP = {
  name: "icon-button",
  props: {
    /**
     * set icon button style properties {ex {width: 100px; height 100px}}
     */
    styleProps: [String, Object],
    /**
     * return the icon button value on click
     */
    clickHandler: Function,
    /**
     * set active interaction on icon button
     */
    active: Boolean,
    /**
     * disable the icon button active interaction
     */
    disabled: Boolean,
    /**
     * change the icon button type
     */
    buttonType: {
      type: String,
      default: "filter"
    },
    /**
     * set the custom icon button icon URL
     */
    iconUrl: {
      type: String
    }
  },
  computed: {
    /**
     * Computes Button's class
     */
    buttonClassComputed() {
      return `${cl.default} ${cl[this.buttonType]} ${cl[this.classTypeForButton]} `;
    },
    /**
     * returns the type of button
     */
    classTypeForButton() {
      return Mh[this.buttonType] || Mh.default;
    }
  },
  methods: {
    /**
     *  executor method that handles click
     */
    executor() {
      var i;
      (i = this.clickHandler) == null || i.call(this);
    }
  }
};
var KP = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    class: i.buttonClassComputed,
    style: i.styleProps,
    attrs: {
      active: i.active,
      disabled: i.disabled
    },
    on: {
      click: i.executor
    }
  }, [t("div", {
    class: i.$style.icon_size
  }, [i.buttonType === "custom-button" ? t("img", {
    attrs: {
      src: i.iconUrl,
      alt: "icon"
    }
  }) : t("img", {
    attrs: {
      src: "#",
      alt: "icon"
    }
  })])]);
}, qP = [];
const QP = "_filter_1rgf4_44", JP = "_icon_size_1rgf4_47", eO = "_edit_1rgf4_58", tO = "_trash_1rgf4_64", iO = "_clone_1rgf4_70", sO = "_check_1rgf4_76", rO = "_previous_1rgf4_88", nO = "_add_1rgf4_116", aO = "_remove_1rgf4_119", oO = "_download_1rgf4_177", lO = "_next_1rgf4_135", uO = "_expand_1rgf4_247", cO = {
  default: "_default_1rgf4_7",
  "customizing-data-table": "_customizing-data-table_1rgf4_25",
  filter: QP,
  icon_size: JP,
  "custom-colum": "_custom-colum_1rgf4_51",
  "kebab-menu": "_kebab-menu_1rgf4_54",
  edit: eO,
  trash: tO,
  clone: iO,
  check: sO,
  previous: rO,
  "left-arrow": "_left-arrow_1rgf4_102",
  add: nO,
  remove: aO,
  "row-inline-action-buttons": "_row-inline-action-buttons_1rgf4_122",
  "next-previous-buttons": "_next-previous-buttons_1rgf4_135",
  "plus-button": "_plus-button_1rgf4_155",
  "minus-button": "_minus-button_1rgf4_169",
  download: oO,
  next: lO,
  "arrow-backward-skinny": "_arrow-backward-skinny_1rgf4_201",
  "arrow-forward-skinny": "_arrow-forward-skinny_1rgf4_211",
  "arrow-backward": "_arrow-backward_1rgf4_201",
  "arrow-forward": "_arrow-forward_1rgf4_211",
  "bar-filter": "_bar-filter_1rgf4_241",
  expand: uO
}, nu = {};
nu.$style = cO;
var hO = /* @__PURE__ */ X(
  ZP,
  KP,
  qP,
  !1,
  dO,
  "d2caa00e",
  null,
  null
);
function dO(i) {
  for (let e in nu)
    this[e] = nu[e];
}
const Ep = /* @__PURE__ */ function() {
  return hO.exports;
}();
var fO = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    staticClass: "no-data-chart",
    style: i.styleProps
  }, [i._v("No Data Available")]);
}, pO = [];
const gO = {
  props: {
    styleProps: String
  }
}, Ah = {};
var _O = /* @__PURE__ */ X(
  gO,
  fO,
  pO,
  !1,
  mO,
  "2a862353",
  null,
  null
);
function mO(i) {
  for (let e in Ah)
    this[e] = Ah[e];
}
const Rp = /* @__PURE__ */ function() {
  return _O.exports;
}();
var bO = function(e) {
  return yO(e) && !vO(e);
};
function yO(i) {
  return !!i && typeof i == "object";
}
function vO(i) {
  var e = Object.prototype.toString.call(i);
  return e === "[object RegExp]" || e === "[object Date]" || SO(i);
}
var xO = typeof Symbol == "function" && Symbol.for, wO = xO ? Symbol.for("react.element") : 60103;
function SO(i) {
  return i.$$typeof === wO;
}
function DO(i) {
  return Array.isArray(i) ? [] : {};
}
function gn(i, e) {
  return e.clone !== !1 && e.isMergeableObject(i) ? xr(DO(i), i, e) : i;
}
function CO(i, e, t) {
  return i.concat(e).map(function(s) {
    return gn(s, t);
  });
}
function TO(i, e) {
  if (!e.customMerge)
    return xr;
  var t = e.customMerge(i);
  return typeof t == "function" ? t : xr;
}
function kO(i) {
  return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(i).filter(function(e) {
    return Object.propertyIsEnumerable.call(i, e);
  }) : [];
}
function Lh(i) {
  return Object.keys(i).concat(kO(i));
}
function $p(i, e) {
  try {
    return e in i;
  } catch {
    return !1;
  }
}
function PO(i, e) {
  return $p(i, e) && !(Object.hasOwnProperty.call(i, e) && Object.propertyIsEnumerable.call(i, e));
}
function OO(i, e, t) {
  var s = {};
  return t.isMergeableObject(i) && Lh(i).forEach(function(r) {
    s[r] = gn(i[r], t);
  }), Lh(e).forEach(function(r) {
    PO(i, r) || ($p(i, r) && t.isMergeableObject(e[r]) ? s[r] = TO(r, t)(i[r], e[r], t) : s[r] = gn(e[r], t));
  }), s;
}
function xr(i, e, t) {
  t = t || {}, t.arrayMerge = t.arrayMerge || CO, t.isMergeableObject = t.isMergeableObject || bO, t.cloneUnlessOtherwiseSpecified = gn;
  var s = Array.isArray(e), r = Array.isArray(i), n = s === r;
  return n ? s ? t.arrayMerge(i, e, t) : OO(i, e, t) : gn(e, t);
}
xr.all = function(e, t) {
  if (!Array.isArray(e))
    throw new Error("first argument should be an array");
  return e.reduce(function(s, r) {
    return xr(s, r, t);
  }, {});
};
var MO = xr, AO = MO;
function at(i, e) {
  const t = [];
  return i && t.push(i), e && t.push(e), AO.all(t);
}
const LO = {
  focusable: !1,
  maxTooltipDistance: -1,
  maxTooltipDistanceBy: "xy",
  panX: !1,
  panY: !1,
  wheelX: "none",
  // 'zoomX' | 'zoomY' | 'zoomXY' | 'panX' | 'panY' | 'panXY' | 'none'
  wheelY: "none",
  // 'zoomX' | 'zoomY' | 'zoomXY' | 'panX' | 'panY' | 'panXY' | 'none'
  paddingTop: 0,
  paddingBottom: 0,
  paddingLeft: 0,
  paddingRight: 0
}, jO = {
  centerX: 0,
  centerY: 0,
  crisp: !1,
  // undefined | false | true
  cursorOverStyle: void 0,
  // undefined | string
  dateFormatter: void 0,
  // DateFormatter | undefined
  disabled: void 0,
  // undefined | false | true
  draggable: void 0,
  // undefined | false | true
  durationFormatter: void 0,
  // DurationFormatter | undefined
  dx: void 0,
  // undefined | number
  dy: void 0,
  // undefined | number
  exportable: void 0,
  // undefined | false | true
  forceHidden: !1,
  // undefined | false | true
  forceInactive: !1,
  // undefined | false | true
  height: de(100),
  // number | Percent | null
  html: void 0,
  // undefined | string
  id: void 0,
  // undefined | string
  interactive: !0,
  // undefined | false | true
  interactiveChildren: !0,
  // undefined | false | true
  isMeasured: !0,
  // undefined | false | true
  layer: void 0,
  // undefined | number
  marginBottom: 0,
  // undefined | number
  marginLeft: 0,
  // undefined | number
  marginRight: 0,
  // undefined | number
  marginTop: 0,
  // undefined | number
  mask: null,
  // Graphics | null
  maskContent: void 0,
  // undefined | false | true
  maxHeight: void 0,
  // number | null
  maxWidth: void 0,
  // number | null
  minHeight: void 0,
  // number | null
  minWidth: void 0,
  // number | null
  numberFormatter: void 0,
  // NumberFormatter | undefined
  opacity: 1,
  // undefined | number
  paddingBottom: 0,
  // undefined | number
  paddingLeft: 0,
  // undefined | number
  paddingRight: 0,
  // undefined | number
  paddingTop: 0,
  // undefined | number
  position: "relative",
  // "absolute" | "relative"
  reverseChildren: void 0,
  // undefined | false | true
  rotation: void 0,
  // undefined | number
  scale: 1,
  // undefined | number
  setStateOnChildren: void 0,
  // undefined | false | true
  showTooltipOn: "hover",
  // "hover" (default) | "always" | "click"
  toggleKey: void 0,
  // "disabled" | "active" | "none" | undefined
  tooltipHTML: void 0,
  // undefined | string
  tooltipPosition: "pointer",
  // "fixed" | "pointer"
  tooltipText: void 0,
  // undefined | string
  tooltipX: 0,
  // number | Percent
  tooltipY: 0,
  // number | Percent
  visible: !0,
  // undefined | false | true
  wheelable: void 0,
  // undefined | false | true
  width: de(100),
  // number | Percent | null
  x: 0,
  // number | Percent | null
  y: 0
  // number | Percent | null
}, _c = {
  /**
   * Important Settings: 관련 차트 항목을 전환하기 위해 클릭할 수 있는 범례 항목 요소는 무엇입니까?
   * "itemContainer" - 전체 범례 항목(기본값).
   * "marker"        - 범례 항목 마커.
   * "none"          - 범례 항목의 토글을 비활성화합니다.
   * x & y & centerX & centerY : root.container.layout 에 따라 조정되도록 처리
   */
  x: de(50),
  y: de(50),
  centerX: de(50),
  centerY: de(50),
  active: !1,
  calculateAggregates: !1,
  templateField: "legendSettings",
  fillField: "legendFill",
  strokeField: "legendStroke",
  clickTarget: "itemContainer",
  //"itemContainer" | "marker" | "none"
  crisp: !1,
  cursorOverStyle: void 0,
  dateFormatter: void 0,
  disabled: !1,
  draggable: !1,
  durationFormatter: !1,
  dx: 0,
  dy: 0,
  exportable: !0,
  forceHidden: !1,
  forceInactive: !1,
  height: null,
  html: void 0,
  id: void 0,
  idField: "legendId",
  interactive: void 0,
  interactiveChildren: !1,
  interpolationDuration: void 0,
  isMeasured: !0,
  layer: void 0,
  legendLabelText: void 0,
  legendValueText: void 0,
  marginBottom: 0,
  marginLeft: 0,
  marginRight: 0,
  marginTop: 0,
  mask: void 0,
  maskContent: void 0,
  maxHeight: null,
  maxWidth: null,
  minHeight: null,
  minWidth: null,
  name: void 0,
  nameField: "legendName",
  numberFormatter: void 0,
  opacity: 1,
  paddingBottom: 0,
  paddingLeft: 0,
  paddingRight: 0,
  paddingTop: 0,
  position: "relative",
  reverseChildren: !1,
  rotation: 0,
  scale: 1,
  sequencedDelay: void 0,
  sequencedInterpolation: void 0,
  setStateOnChildren: !1,
  showTooltipOn: "hover",
  stateAnimationDuration: 3,
  toggleKey: "none",
  tooltipHTML: void 0,
  tooltipPosition: "fixed",
  tooltipText: void 0,
  tooltipX: 0,
  tooltipY: 0,
  useDefaultMarker: !1,
  // Important Settings
  userData: void 0,
  valueField: "legendValue",
  visible: !0,
  wheelable: !1,
  width: null
}, mc = {
  fontSize: 11.25,
  fontWeight: "normal"
}, bc = {
  width: 12.46,
  height: 12.46
}, yc = {
  active: !0,
  centerX: 0,
  centerY: 0,
  cornerRadiusTL: 2,
  cornerRadiusTR: 2,
  cornerRadiusBL: 2,
  cornerRadiusBR: 2,
  crisp: !1,
  cursorOverStyle: void 0,
  dateFormatter: void 0,
  disabled: !1,
  draggable: !1,
  draw: void 0,
  durationFormatter: void 0,
  dx: void 0,
  dy: void 0,
  exportable: void 0,
  fillOpacity: 1,
  forceHidden: !1,
  forceInactive: !1,
  id: void 0,
  interactive: !0,
  isMeasured: !0,
  layer: void 0,
  lineJoin: "meter",
  marginBottom: void 0,
  marginLeft: void 0,
  marginRight: void 0,
  marginTop: void 0,
  maxHeight: null,
  maxWidth: null,
  minHeight: null,
  minWidth: null,
  nonScalingStroke: !1,
  numberFormatter: void 0,
  opacity: 1,
  position: "relative",
  rotation: 0,
  scale: 1,
  shadowBlur: void 0,
  shadowColor: null,
  shadowOffsetX: void 0,
  shadowOffsetY: void 0,
  shadowOpaicty: void 0,
  showTooltipOn: "hover",
  stateAnimationDuration: void 0,
  strokeDashoffset: void 0,
  strokeOpacity: 1,
  strokeWidth: 1,
  svgPath: void 0,
  templateField: "legendMarkerRectangles",
  // TODO: 적용안됨 (기술문의)
  toggleKey: void 0,
  tooltipHTML: void 0,
  tooltipPosition: "pointer",
  tooltipText: void 0,
  tooltipX: 0,
  tooltipY: 0,
  visible: !0,
  wheelable: void 0,
  x: 0,
  y: 0
}, Np = {
  paddingTop: 0,
  paddingLeft: 0,
  paddingRight: 0,
  paddingBottom: 0,
  getFillFromSprite: !1,
  // 채우기 색상을 상속 받음
  getStrokeFromSprite: !1,
  // out line 색상을 상속 받음
  autoTextColor: !1,
  // 글자색을 상속 받음.
  getLabelFillFromSprite: !1
  // 글자 배경색을 상속 받음
}, Fp = {
  fill: K("#fff"),
  fillOpacity: 1,
  shadowColor: K("#000000"),
  shadowBlur: 4,
  shadowOffsetX: 0,
  shadowOffsetY: 1,
  shadowOpacity: 0.25
}, IO = {
  fill: K("#4b4b4b"),
  fontSize: 11.25,
  textAlign: "center",
  oversizedBehavior: "none",
  // 'none'(default), 'hide', 'fit', 'wrap', 'wrap-no-break', 'truncate'
  maxWidth: 150,
  // with 'truncate'
  ellipsis: "..."
  // with 'truncate'
}, EO = {
  text: void 0,
  width: de(100),
  x: de(50),
  centerX: de(50),
  fontSize: 11.25,
  paddingTop: 10,
  paddingBottom: 0,
  fontWeight: "normal",
  textAlign: "center",
  html: void 0,
  fill: K("#4b4b4b")
}, RO = {
  strokeWidth: 1,
  strokeOpacity: 0.1,
  location: 0
}, $O = {
  minGridDistance: 15
}, NO = {
  marginTop: 15
}, FO = {
  fill: K("#4b4b4b"),
  fontSize: 12,
  textAlign: "center",
  visible: !0,
  minPosition: 0,
  maxPosition: 0.9
}, YO = {
  text: void 0,
  fill: K("#4b4b4b"),
  fontSize: 11.25,
  fontWeight: "normal",
  fontStyle: "normal",
  // 'normal', 'italic', 'oblique'
  rotation: -90,
  textAlign: "center",
  // 'start', 'end', 'left', 'right', 'center'
  paddingTop: 0,
  paddingBottom: 5,
  position: "relative",
  // 'relative', 'absolute'
  x: de(50),
  centerX: de(50),
  y: de(50),
  centerY: de(50)
}, BO = {
  strokeWidth: 1,
  strokeOpacity: 0.1,
  location: 0
}, HO = {
  minGridDistance: 30,
  inside: !1
}, zO = {
  fill: K("#fff"),
  fillOpacity: 1,
  stroke: K("#4b4b4b"),
  strokeWidth: 1,
  strokeOpacity: 0
}, VO = {
  fill: K("#4b4b4b"),
  fontSize: 11.25,
  fontWeight: "normal",
  fontStyle: "normal",
  // 'normal', 'italic', 'oblique'
  rotation: 0,
  textAlign: "left",
  // 'start', 'end', 'left', 'right', 'center'
  x: 0,
  centerX: 0,
  paddingTop: 20,
  paddingBottom: 20,
  position: "relative"
  // 'relative', 'absolute'
}, XO = {
  // isDown: false, // chartSet 으로 이동 (chartSet.scrollbar.isDown)
  forceHidden: !0,
  orientation: "horizontal",
  start: 0,
  end: 1,
  height: 50
  // mainValue: { key: "", displayName: "" }, // chartSet 으로 이동 or overall-xy-chart 에서만 처리하도록 변경
  // line: { color: "#fb9f57", strokeWidth: 2, fillOpacity: 0.2 },
}, WO = {
  fill: K("#000"),
  fillOpacity: 0.05,
  cornerRadiusTL: 10,
  cornerRadiusTR: 10,
  cornerRadiusBL: 10,
  cornerRadiusBR: 10
}, UO = {
  fill: K("#000"),
  fillOpacity: 0.05
}, GO = {
  visible: !1,
  scale: 0.9
}, ZO = {
  visible: !1,
  scale: 0.9
}, KO = {
  stacked: !1,
  clustered: !1
}, qO = {
  width: 15,
  height: 15,
  strokeWidth: 1,
  fillOpacity: 0.3,
  cornerRadiusTL: 0,
  cornerRadiusTR: 0,
  tooltipY: 0,
  templateField: "columnSettings"
}, QO = {
  numberFormat: "#,###.#",
  numericFields: ["valueY"]
};
var JO = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    staticClass: "xy-chart-container"
  }, [t("no-chart-data", {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: i.data.length === 0,
      expression: "data.length === 0"
    }],
    style: i.styleProps
  }), t("icon-button", {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: i.data.length > 0 && i.previousButton.visible,
      expression: "data.length > 0 && previousButton.visible"
    }],
    attrs: {
      "button-type": "arrow-backward-skinny",
      "click-handler": i.previousButton.handler,
      disabled: i.previousButton.disabled
    }
  }), t("div", {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: i.data.length > 0,
      expression: "data.length > 0"
    }],
    key: i.chartSetComputed.key,
    ref: i.chartSetComputed.refProps,
    style: i.styleProps,
    attrs: {
      id: i.chartSetComputed.id
    }
  }), t("icon-button", {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: i.data.length > 0 && i.nextButton.visible,
      expression: "data.length > 0 && nextButton.visible"
    }],
    attrs: {
      "button-type": "arrow-forward-skinny",
      "click-handler": i.nextButton.handler,
      disabled: i.nextButton.disabled
    }
  })], 1);
}, eM = [];
const tM = {
  components: {
    "icon-button": Ep,
    "no-chart-data": Rp
  },
  props: {
    // root
    rootNumberFormatterSet: Object,
    // column series
    columnSet: Object,
    columnTemplateSet: Object,
    // x scrollbar
    xScrollbarSet: Object,
    xScrollbarBackgroundSet: Object,
    xScrollbarThumbSet: Object,
    xScrollbarStartGripSet: Object,
    xScrollbarEndGripSet: Object,
    // xy chart
    xyChartSet: Object,
    xyChartContainerSet: Object,
    // yAxis
    yAxisSet: Object,
    yAxisRendererSet: Object,
    yAxisGridSet: Object,
    yAxisLabelSet: Object,
    yAxisExtraLabelSet: Object,
    yAxisHeaderBackgroundSet: Object,
    yAxisHeaderLabelSet: Object,
    // x axis
    xAxisRendererSet: Object,
    xAxisGridSet: Object,
    xAxisLabelSet: Object,
    xAxisExtraLabelSet: Object,
    // tooltip
    tooltipSet: Object,
    tooltipBackgroundSet: Object,
    // legend
    legendSet: Object,
    legendLabelSet: Object,
    legendMarkerSet: Object,
    legendMarkerRectangleSet: Object,
    legendData: Array,
    legendMarkerRectanglesStrokeDashArrayAdapter: Function,
    seriesTooltipHTMLAdapter: Function,
    columnHoverEvent: Function,
    // =============================== requirement props =========================
    data: {
      type: Array,
      default: () => []
    },
    category: String,
    // =============================== requirement props (one of these) =========================
    lineDataBinder: Array,
    stepLineDataBinder: Array,
    bubbleDataBinder: Array,
    barDataBinder: Array,
    candlestickDataBinder: Array,
    // =============================== optional props =========================
    chartSet: Object,
    candlestickSet: Object,
    lineSet: Object,
    stepLineSet: Object,
    bubbleSet: Object,
    yAxisRange: Array,
    logTest: {
      type: Boolean,
      default: !1
    },
    tooltipHTML: {
      type: String,
      default: "<div style='padding: 10px;'>{name} in {categoryX}: {valueY}</div>"
    },
    styleProps: {
      type: [String, Object],
      default: "height: 400px; width: 100%; min-width: 800px;"
    },
    previousButton: {
      type: Object,
      default: () => ({ visible: !1, disabled: !1 })
    },
    nextButton: {
      type: Object,
      default: () => ({ visible: !1, disabled: !1 })
    },
    // ============================== Functions =================================
    setCustom: Function,
    setCustomLegend: Function,
    setBubbleSeriesAdapter: Function,
    setXAxisFillRule: Function,
    xAxisGridStrokeOpacityAdapter: Function,
    // x축 grid 의 선을 custom
    xAxisLabelTextAdapter: Function,
    // x축 label을 custom
    xAxisTooltipLabelTextAdapter: Function,
    // x축 tooltip의 text를 custom
    seriesTooltipLabelHtmlAdapter: Function,
    // 시리즈 툴팁을 custom
    xScrollbarXAxisLabelTextAdapter: Function,
    // x스크롤바의 label을 custom
    seriesTooltipForceHiddenAdapter: Function,
    // 시리즈 툴팁의 숨김 여부를 custom
    getWheelCursorPositionX: Function,
    chartItemClickHandler: Function
    // ============= TODO: about overall-xy-chart (분리할 예정) ============================
    // zoomHandler: Function,
    // panHandler: Function,
    // setSelectionMin: Function,
    // setSelectionMax: Function,
    // timeScale: String,
    // selectionMin: String,
    // selectionMax: String,
    // setDataStartPoint: Function,
    // setDataEndPoint: Function,
    // dataStartPoint: {
    //   type: String,
    //   default: "",
    // },
    // dataEndPoint: {
    //   type: String,
    //   default: "",
    // },
  },
  data() {
    return {
      stepLineSeriesSettings: {},
      stepLineStrokeTemplateSettings: {},
      stepLineFillsTemplateSettings: {},
      bubbleSeriesSettings: {},
      bubbleBulletSettings: {},
      bubbleStrokeTemplateSettings: {},
      bubbleFillsTemplateSettings: {},
      candlestickSettings: {},
      lineSeriesSettings: {},
      lineBulletSettings: {},
      lineFillsTemplateSettings: {},
      lineStrokeTemplateSettings: {},
      categoryAxisSettings: {},
      valueAxisSettings: {},
      xySeries: "",
      xScrollbarOverallSeriesItem: "",
      chartTitle: "",
      xAxisExtraLabel: "",
      range: "",
      rangeDataItem: "",
      root: "",
      chart: "",
      xAxis: "",
      yAxisList: [],
      // about series
      lineSeriesList: [],
      lineSeries: "",
      stepLineSeriesList: [],
      stepLineSeries: "",
      columnSeriesList: [],
      columnSeries: "",
      bubbleSeriesList: [],
      bubbleSeries: "",
      candlestickSeriesList: [],
      candlestickSeries: "",
      xScrollbarSeriesList: [],
      xScrollbarSeries: "",
      // xScrollbarOverallSeries: "", // TODO: overall-xy-chart 관련 부분 제거
      xScrollbarColumnSeriesList: [],
      xScrollbarColumnSeries: "",
      xScrollbarLineSeriesList: [],
      xScrollbarLineSeries: "",
      xScrollbarStepLineSeriesList: [],
      xScrollbarStepLineSeries: "",
      xScrollbarBubbleSeriesList: [],
      xScrollbarBubbleSeries: "",
      xScrollbarCandlestickSeriesList: [],
      xScrollbarCandlestickSeries: "",
      legend: "",
      xScrollbar: "",
      xScrollbarXAxis: "",
      xScrollbarYAxis: "",
      /**
       * Breaking Change: since version 0.4.0
       * axisDataBinder.yAxis => chartSet.valueAxis
       * axisDataBinder.xAxis => chartSet.categoryAxis
       * 예전에는 x축은 categoryAxis, y축은 valueAxis 로 고정이었으나,
       * horizontal xy chart의 적용으로 인해, 두 가지의 축을 서로 바꿀 수 있도록 설정.
       */
      chartSetData: {
        refProps: "defaultXYChart",
        id: "defaultXYChart",
        key: "defaultXYChart",
        chartType: "default",
        isZoomOutButton: !1,
        isYAxesPlotContainerVisible: !0,
        isBottomAxesContainerVisible: !0,
        column: {
          colorList: [
            "#f08080",
            "#fa8072",
            "#e9967a",
            "#ff7f50",
            "#ff6347",
            "#f4a460",
            "#ffa07a"
          ]
        },
        root: {
          numberFormat: "#,###.#",
          container: {
            layout: "verticalLayout"
            // verticalLayout || horizontalLayout || gridLayout
          },
          tooltipContainerBounds: {
            top: 400,
            bottom: 400,
            left: 0,
            right: 0
          }
        },
        xAxis: {
          type: "CategoryAxis",
          grid: {
            strokeWidth: 1,
            strokeOpacity: 0.1,
            location: 0
          }
        },
        yAxis: {
          type: "ValueAxis",
          isStacked: !1,
          grid: {
            strokeWidth: 1,
            strokeOpacity: 0.1,
            location: 0
          },
          marginTop: 15,
          axisHeader: {
            minHeight: 0
          }
        },
        valueAxis: {
          isPercent: !1,
          strictMinMaxSelection: !1,
          min: null,
          extraMax: 0.1,
          baseValue: 0
        },
        cursor: {
          isAvailable: !1,
          xAxis: {
            isFocused: !1
          },
          yAxis: {
            isFocused: !1
          }
        }
      },
      candlestickSetData: {
        riseColor: "#f00",
        dropColor: "#00f"
      },
      lineSetData: {
        isConnected: !0,
        isLineVisible: !1,
        isFillVisible: !1,
        strokeWidth: 1,
        fillOpacity: 0.1,
        bullet: {
          strokeWidth: 2,
          radius: 3,
          isVisible: !0,
          isFilled: !1,
          forceHidden: !1
        },
        colorList: [
          "#f08080",
          "#fa8072",
          "#e9967a",
          "#ff7f50",
          "#ff6347",
          "#f4a460",
          "#ffa07a"
        ]
      },
      stepLineSetData: {
        isLineVisible: !1,
        strokeWidth: 1,
        colorList: [
          "#f08080",
          "#fa8072",
          "#e9967a",
          "#ff7f50",
          "#ff6347",
          "#f4a460",
          "#ffa07a"
        ],
        isFillVisible: !0,
        fillOpacity: 0.5,
        bullet: { strokeWidth: 2, radius: 3, forceHidden: !0 }
      },
      bubbleSetData: {
        strokeWidth: 2,
        bullet: { strokeWidth: 2, radius: 3, isVisible: !0, isFilled: !1 },
        colorList: [
          "#f08080",
          "#fa8072",
          "#e9967a",
          "#ff7f50",
          "#ff6347",
          "#f4a460",
          "#ffa07a"
        ]
      }
    };
  },
  updated() {
    this.logTest && console.log("xy updated");
  },
  mounted() {
    Mo("AM5C392708372"), this.createChart();
  },
  watch: {
    // series
    columnSet() {
      this.createChart();
    },
    columnTemplateSet() {
      this.createChart();
    },
    lineSet: {
      handler() {
        this.createChart();
      },
      deep: !0
    },
    // yAxis
    yAxisLabelSet() {
      this.createChart();
    },
    yAxisExtraLabelSet() {
      this.createChart();
    },
    yAxisHeaderBackgroundSet() {
      this.createChart();
    },
    yAxisHeaderLabelSet() {
      this.createChart();
    },
    yAxisRendererSet() {
      this.createChart();
    },
    yAxisGridSet() {
      this.createChart();
    },
    // xAxis
    xAxisLabelSet() {
      this.createChart();
    },
    xAxisExtraLabelSet() {
      this.createChart();
    },
    // tooltip
    tooltipSet() {
      this.createChart();
    },
    tooltipBackgroundSet() {
      this.createChart();
    },
    tooltipHTML() {
      this.createChart();
    },
    // legend
    legendSet() {
      this.createChart();
    },
    legendLabelSet() {
      this.createChart();
    },
    legendMarkerSet() {
      this.createChart();
    },
    legendMarkerRectangleSet() {
      this.createChart();
    },
    // xy chart
    xyChartContainerSetComputed() {
      this.createChart();
    },
    chartSetComputed() {
      this.createChart();
    },
    // scrolbar
    xScrollbarSet() {
      this.createChart();
    },
    // databinder
    lineDataBinder: {
      handler() {
        this.createChart();
      },
      deep: !0
    },
    stepLineDataBinder: {
      handler() {
        this.createChart();
      },
      deep: !0
    },
    barDataBinder: {
      handler() {
        this.createChart();
      },
      deep: !0
    },
    bubbleDataBinder: {
      handler() {
        this.createChart();
      },
      deep: !0
    },
    candlestickDataBinder: {
      handler() {
        this.createChart();
      },
      deep: !0
    },
    data() {
      this.createChart();
    }
    // TODO: overall-xy-chart 관련 부분 분리 =============================================================
    // dataStartPoint: {
    //   handler(newVal) {
    //     this.logTest && console.log("watch dataStartPoint: ", newVal);
    //   },
    // },
    // dataEndPoint: {
    //   handler(newVal) {
    //     this.logTest && console.log("watch dataEndPoint: ", newVal);
    //   },
    // },
    // selectionMin: {
    //   handler() {
    //     this.logTest && console.log("watch selectionMin: ");
    //     if (this.xAxis && this.data) {
    //       this.xAxis.data.setAll(this.data);
    //     }
    //   },
    //   immediate: true,
    // },
    // selectionMax: {
    //   handler() {
    //     this.logTest && console.log("watch selectionMin: ");
    //     if (this.xAxis && this.data) {
    //       this.xAxis.data.setAll(this.data);
    //     }
    //   },
    //   immediate: true,
    // },
    // "chartSetComputed.titleLabel.text": {
    //   handler() {
    //     this.logTest && console.log("watch chartSetComputed.titleLabel.text");
    //     this.setXAxisExtraLabel();
    //   },
    // },
    // "xScrollbarSetComputed.detail.mainValue.displayName": {
    //   handler() {
    //     this.logTest &&
    //       console.log(
    //         "watch xScrollbarSetComputed.detail.mainValue.displayName 11"
    //       );
    //     this.setChartTitle();
    //     this.setXScrollbar();
    //   },
    // },
  },
  computed: {
    chartSetComputed() {
      return Object.assign({}, at(this.chartSetData, this.chartSet));
    },
    // root
    rootNumberFormatterSetComputed() {
      return Object.assign(
        {},
        QO,
        this.rootNumberFormatterSet
      );
    },
    // xScrollbar
    xScrollbarSetComputed() {
      return Object.assign({}, XO, this.xScrollbarSet);
    },
    xScrollbarBackgroundSetComputed() {
      return Object.assign(
        {},
        WO,
        this.xScrollbarBackgroundSet
      );
    },
    xScrollbarThumbSetComputed() {
      return Object.assign(
        {},
        UO,
        this.xScrollbarThumbSet
      );
    },
    xScrollbarStartGripSetComputed() {
      return Object.assign(
        {},
        GO,
        this.xScrollbarStartGripSet
      );
    },
    xScrollbarEndGripSetComputed() {
      return Object.assign(
        {},
        ZO,
        this.xScrollbarEndGripSet
      );
    },
    // yAxis
    yAxisSetComputed() {
      return Object.assign({}, NO, this.yAxisSet);
    },
    yAxisHeaderBackgroundSetComputed() {
      return Object.assign(
        {},
        zO,
        this.yAxisHeaderBackgroundSet
      );
    },
    yAxisHeaderLabelSetComputed() {
      return Object.assign(
        {},
        VO,
        this.yAxisHeaderLabelSet
      );
    },
    yAxisRendererSetComputed() {
      return Object.assign({}, HO, this.yAxisRendererSet);
    },
    yAxisGridSetComputed() {
      return Object.assign({}, BO, this.yAxisGridSet);
    },
    yAxisLabelSetComputed() {
      return Object.assign({}, FO, this.yAxisLabelSet);
    },
    yAxisExtraLabelSetComputed() {
      return Object.assign(
        {},
        YO,
        this.yAxisExtraLabelSet
      );
    },
    // xAxis
    xAxisRendererSetComputed() {
      return Object.assign({}, $O, this.xAxisRendererSet);
    },
    xAxisGridSetComputed() {
      return Object.assign({}, RO, this.xAxisGridSet);
    },
    xAxisLabelSetComputed() {
      return Object.assign({}, IO, this.xAxisLabelSet);
    },
    xAxisExtraLabelSetComputed() {
      return Object.assign(
        {},
        EO,
        this.xAxisExtraLabelSet
      );
    },
    // tooltip
    tooltipSetComputed() {
      return Object.assign({}, Np, this.tooltipSet);
    },
    tooltipBackgroundSetComputed() {
      return Object.assign(
        {},
        Fp,
        this.tooltipBackgroundSet
      );
    },
    // legend
    legendSetComputed() {
      let i = { layout: this.root.gridLayout };
      return Object.assign({}, _c, this.legendSet, i);
    },
    legendLabelSetComputed() {
      return Object.assign({}, mc, this.legendLabelSet);
    },
    legendMarkerSetComputed() {
      return Object.assign({}, bc, this.legendMarkerSet);
    },
    legendMarkerRectangleSetComputed() {
      return Object.assign(
        {},
        yc,
        this.legendMarkerRectangleSet
      );
    },
    xyChartSetComputed() {
      return Object.assign({}, LO, this.xyChartSet);
    },
    xyChartContainerSetComputed() {
      return Object.assign(
        {},
        jO,
        this.xyChartContainerSet
      );
    },
    columnSetComputed() {
      return Object.assign({}, KO, this.columnSet);
    },
    columnTemplateSetComputed() {
      return Object.assign({}, qO, this.columnTemplateSet);
    },
    bubbleSetComputed() {
      return Object.assign({}, at(this.bubbleSetData, this.bubbleSet));
    },
    lineSetComputed() {
      return Object.assign({}, at(this.lineSetData, this.lineSet));
    },
    stepLineSetComputed() {
      return Object.assign({}, at(this.stepLineSetData, this.stepLineSet));
    },
    candlestickSetComputed() {
      return Object.assign(
        {},
        at(this.candlestickSetData, this.candlestickSet)
      );
    }
    // TODO: overall-xy-chart 관련 부분 제거 ==============================================================
    // closeDataStartPoint() {
    //   if (this.dataStartPoint && this.data.length > 0) {
    //     // selectionMin 의 Timestamp 반환
    //     let dataStartPointTs = moment(
    //       this.dataStartPoint,
    //       "YYYYMMDDmmss"
    //     ).unix();
    //     let dataStartPoint = NaN;
    //     let startDifference = dataStartPointTs;
    //     for (let i = 0; i < this.data.length; i++) {
    //       let targetTs = moment(
    //         this.data[i][this.category],
    //         "YYYYMMDDmmss"
    //       ).unix();
    //       if (startDifference > Math.abs(targetTs - dataStartPointTs)) {
    //         startDifference = Math.abs(targetTs - dataStartPointTs);
    //         dataStartPoint = this.data[i][this.category];
    //       }
    //     }
    //     if (!isNaN(dataStartPoint)) {
    //       return dataStartPoint;
    //     }
    //   }
    // },
    // closeDataEndPoint() {
    //   if (this.dataEndPoint && this.data.length > 0) {
    //     // selectionMin 의 Timestamp 반환
    //     let dataEndPointTs = moment(this.dataEndPoint, "YYYYMMDDmmss").unix();
    //     let dataEndPoint = NaN;
    //     let startDifference = dataEndPointTs;
    //     for (let i = 0; i < this.data.length; i++) {
    //       let targetTs = moment(
    //         this.data[i][this.category],
    //         "YYYYMMDDmmss"
    //       ).unix();
    //       if (startDifference > Math.abs(targetTs - dataEndPointTs)) {
    //         startDifference = Math.abs(targetTs - dataEndPointTs);
    //         dataEndPoint = this.data[i][this.category];
    //       }
    //     }
    //     if (!isNaN(dataEndPoint)) {
    //       return dataEndPoint;
    //     }
    //   }
    // },
    // default 의 selectionMin 과 가장 가까운 overall 의 selectionMin
    // closeSelectionMin() {
    //   this.logTest && console.log("closeSelectionMin");
    //   if (this.selectionMin && this.selectionMax && this.data.length > 0) {
    //     // selectionMin 의 Timestamp 반환
    //     let selectionMinTs = moment(this.selectionMin, "YYYYMMDDmmss").unix();
    //     let zoomStartPoint = NaN;
    //     let startDifference = selectionMinTs;
    //     for (let i = 0; i < this.data.length; i++) {
    //       let targetTs = moment(
    //         this.data[i][this.category],
    //         "YYYYMMDDmmss"
    //       ).unix();
    //       if (startDifference > Math.abs(targetTs - selectionMinTs)) {
    //         startDifference = Math.abs(targetTs - selectionMinTs);
    //         zoomStartPoint = this.data[i][this.category];
    //       }
    //     }
    //     if (!isNaN(zoomStartPoint)) {
    //       return zoomStartPoint;
    //     }
    //   }
    // },
    // default 의 selectionMax 과 가장 가까운 overall 의 selectionMax
    // closeSelectionMax() {
    //   if (this.selectionMin && this.selectionMax && this.data.length > 0) {
    //     let selectionMaxTs = moment(this.selectionMax, "YYYYMMDDmmss").unix();
    //     let zoomEndPoint = NaN;
    //     let endDifference = selectionMaxTs;
    //     for (let i = 0; i < this.data.length; i++) {
    //       let targetTs = moment(
    //         this.data[i][this.category],
    //         "YYYYMMDDmmss"
    //       ).unix();
    //       if (endDifference > Math.abs(targetTs - selectionMaxTs)) {
    //         endDifference = Math.abs(targetTs - selectionMaxTs);
    //         zoomEndPoint = this.data[i][this.category];
    //       }
    //     }
    //     if (!isNaN(zoomEndPoint)) {
    //       return zoomEndPoint;
    //     }
    //   }
    // },
  },
  methods: {
    setXAxisLabelHTML(i, e) {
      return '<div style="display: flex; flex-direction: column; align-items: center; font-size: 11.25px;">' + (i && `<div>${i}</div>`) + `<div>${e}</div></div>`;
    },
    // TODO: 외부 공통 js로 빼기
    getRanHex(i) {
      let e = [], t = [
        "0",
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        "a",
        "b",
        "c",
        "d",
        "e",
        "f"
      ];
      for (let s = 0; s < i; s++)
        e.push(t[Math.floor(Math.random() * 16)]);
      return e.join("");
    },
    // TODO: 외부 공통 js로 빼기
    getColor(i, e, t) {
      return this.logTest && console.log("getColor"), t || (i && e >= 0 && i[e] ? i[e] : "#" + this.getRanHex(6));
    },
    // TODO: overall-xy-chart 관련 부분 분리
    // setZoomHandler() {
    //   this.logTest && console.log("setZoomHandler");
    //   if (this.xAxis) {
    //     let startIndex = 0;
    //     let endIndex = 0;
    //     if (this.xAxis.getPrivate("startIndex")) {
    //       startIndex = this.xAxis.getPrivate("startIndex");
    //     }
    //     if (this.xAxis.getPrivate("endIndex")) {
    //       endIndex = this.xAxis.getPrivate("endIndex");
    //     }
    //     if (endIndex > 0) {
    //       let zoomSelectionMin =
    //         this.xAxis.dataItems[startIndex].dataContext[this.category];
    //       let zoomSelectoinMax =
    //         this.xAxis.dataItems[endIndex - 1].dataContext[this.category];
    //       this.zoomHandler(zoomSelectionMin, zoomSelectoinMax);
    //     }
    //   }
    // },
    // TODO: overall-xy-chart 관련 부분 분리
    // setPlotContainerPanHandler() {
    //   this.logTest && console.log("setPlotContainerPanHandler");
    //   if (this.xAxis) {
    //     let startIndex = 0;
    //     let endIndex = 0;
    //     // startIndex 설정
    //     if (this.xAxis.getPrivate("startIndex")) {
    //       startIndex = this.xAxis.getPrivate("startIndex");
    //     }
    //     // endIndex 설정
    //     if (this.xAxis.getPrivate("endIndex")) {
    //       endIndex = this.xAxis.getPrivate("endIndex");
    //     }
    //     if (endIndex > 0) {
    //       if (this.setSelectionMin) {
    //         this.setSelectionMin(
    //           this.xAxis.dataItems[startIndex].dataContext[this.category]
    //         );
    //       }
    //       if (this.setSelectionMax) {
    //         this.setSelectionMax(
    //           this.xAxis.dataItems[endIndex - 1].dataContext[this.category]
    //         );
    //       }
    //       // previous handler
    //       if (startIndex === 0) {
    //         setTimeout(() => {
    //           this.panHandler("previous");
    //         }, 500);
    //       }
    //       // next handler
    //       if (endIndex >= this.data.length - 1) {
    //         this.panHandler("next");
    //       }
    //     }
    //   }
    // },
    // TODO: overall-xy-chart 관련 부분 분리
    // setZoomPanEvents() {
    //   if (this.zoomHandler) {
    //     this.chart.events.on("wheelended", (ev) => {
    //       this.setZoomHandler(this.xScrollbar, ev);
    //     });
    //   }
    //   if (this.panHandler) {
    //     this.xScrollbar.events.on("rangechanged", (ev) => {
    //       if (ev.target.chart.xAxes._values[0]) {
    //         let startItem = ev.target.chart.xAxes._values[0].getSeriesItem(
    //           this.xySeries,
    //           ev.start
    //         );
    //         let endItem = ev.target.chart.xAxes._values[0].getSeriesItem(
    //           this.xySeries,
    //           ev.end
    //         );
    //         if (
    //           this.chartSetComputed.chartType === "overall" &&
    //           !(ev.start === 0 && ev.end === 1)
    //         ) {
    //           this.setDataStartPoint(startItem.dataContext[this.category]);
    //           this.setDataEndPoint(endItem.dataContext[this.category]);
    //         }
    //       }
    //     });
    //     // x scrollbar thumb panning handler
    //     this.xScrollbar.thumb.events.on("pointerup", (ev) => {
    //       this.logTest && console.log("x scrollbar thumb panning handler");
    //       // todo 다음 걸로 하도록 바꾸기
    //       let startDataIndex = 0;
    //       this.data.map((data, index) => {
    //         if (data[this.category] === this.dataStartPoint) {
    //           startDataIndex = index;
    //         }
    //       });
    //       // this.setSelectionMin(this.dataStartPoint);
    //       this.setSelectionMin(this.data[startDataIndex][this.category]);
    //       // let endDataIndex = 0;
    //       // this.data.map((data, index) => {
    //       //   if (data[this.category] === this.dataEndPoint) {
    //       //     endDataIndex = index;
    //       //   }
    //       // });
    //       // if (startIndex === endDataIndex) {
    //       //   this.setSelectionMax(this.data[startDataIndex + 1][this.category]);
    //       // } else {
    //       //   this.setSelectionMax(this.data[endDataIndex][this.category]);
    //       // }
    //       this.panHandler();
    //     });
    //     // x scrollbar background(overlay) click handler
    //     // 스크롤바 배경 클릭했을때 동작 추가작업 필요. (focus 시킨 후 기존 함수 실행.)
    //     // this.xScrollbar.overlay.events.on("pointerup", () => {
    //     //   this.logTest &&
    //     //     console.log("x scrollbar background(overlay) click handler");
    //     // });
    //     // plot container panning handler
    //     this.chart.plotContainer.events.on("pointerup", () => {
    //       this.logTest && console.log("plot container panning handler");
    //       this.setPlotContainerPanHandler();
    //     });
    //   }
    // },
    setSeries() {
      this.logTest && console.log("setSeries"), this.setStepLineSeries(), this.setColumnSeries(), this.setCandlestickSeries(), this.setBubbleSeries(), this.setLineSeries();
    },
    getAxisField(i, e) {
      let t = {}, s = this.chartSetComputed.valueAxis.isPercent ? "valueYTotalPercent" : "valueYWorking", r = this.chartSetComputed.valueAxis.isPercent ? "valueXTotalPercent" : "valueXWorking";
      return this.chartSetComputed.xAxis.type === "CategoryAxis" && this.chartSetComputed.yAxis.type === "ValueAxis" && (t = {
        categoryXField: this.category,
        valueYField: i,
        openValueYField: e,
        valueYShow: s
      }), this.chartSetComputed.xAxis.type === "ValueAxis" && this.chartSetComputed.yAxis.type === "CategoryAxis" && (t = {
        categoryYField: this.category,
        valueXField: i,
        openValueXField: e,
        valueXShow: r
      }), t;
    },
    setLineSeries() {
      this.logTest && console.log("setLineSeries"), this.lineSeriesList.map((i) => {
        i.dispose();
      }), this.lineSeriesList.splice(0), this.xScrollbarLineSeriesList.map((i) => {
        i.dispose();
      }), this.xScrollbarLineSeriesList.splice(0), this.lineDataBinder && this.lineDataBinder.length > 0 && this.lineDataBinder.map((i, e) => {
        let t = i == null ? void 0 : i.displayName, s = i == null ? void 0 : i.key, r = i == null ? void 0 : i.openKey, n = i == null ? void 0 : i.strokeWidth, a = i == null ? void 0 : i.isLineVisible;
        n === void 0 && (n = this.lineSetComputed.strokeWidth), this.lineStrokeTemplateSettings = {
          strokeWidth: Number(n),
          visible: a !== void 0 ? a : !0
        };
        let o = this.getColor(
          this.lineSetComputed.colorList,
          e,
          i == null ? void 0 : i.color
        );
        i.color = o;
        let l = this.getAxisField(s, r);
        i.yAxisListIndex === void 0 && (i.yAxisListIndex = 0), this.lineSeriesSettings = {
          connect: this.lineSetComputed.isConnected,
          stroke: K(i.color),
          fill: K(i.color),
          name: t,
          ...l,
          xAxis: this.xAxis,
          yAxis: this.yAxisList[i.yAxisListIndex]
        };
        let u = i.isFillVisible !== void 0 ? i.isFillVisible : this.lineSetComputed.isFillVisible;
        this.lineFillsTemplateSettings = {
          fillOpacity: Number(this.lineSetComputed.fillOpacity),
          visible: u
        }, this.lineSeries = dt.new(this.root, {
          ...this.lineSeriesSettings,
          categoryYField: "time"
        }), this.xySeries = this.chart.series.push(this.lineSeries), this.lineSeriesList.push(this.lineSeries), this.setLineSeriesChart(i, e), this.setLineSeriesXScrollbar();
      });
    },
    makeTooltip() {
      let i = pi.new(this.root, { ...this.tooltipSetComputed });
      return i.get("background").setAll({ ...this.tooltipBackgroundSetComputed }), i;
    },
    /**
     * @param {Object} dataBinder dataBinder
     * @param {number} index data index
     * tooltipHTML 우선순위
     * 1. adapter를 사용하여 설정된 tooltipHTML
     * 2. dataBinder를 통해 전달된 tooltipHTML
     * 3. tooltipHTML props를 통해 설정된 tooltipHTML
     */
    getTooltipHTML(i, e) {
      let t = i.tooltipHTML ? i.tooltipHTML : this.tooltipHTML;
      return this.seriesTooltipLabelHtmlAdapter && (t = this.seriesTooltipLabelHtmlAdapter(
        this.data[e],
        i
      )), t;
    },
    setLineSeriesChart(i, e) {
      let t = be.new(this.root, {});
      this.chartItemClickHandler && t.events.on("click", (n) => {
        n.target.dataItem.component.className === "LineSeries" && this.chartItemClickHandler(n);
      }), this.lineBulletSettings = {
        showTooltipOn: "hover",
        strokeWidth: this.lineSetComputed.bullet.strokeWidth,
        radius: Number(this.lineSetComputed.bullet.radius),
        fillOpacity: this.lineSetComputed.bullet.isVisible ? 1 : 0,
        strokeOpacity: this.lineSetComputed.bullet.isVisible ? 1 : 0,
        tooltip: this.makeTooltip()
      };
      let s = i.bullet && i.bullet.forceHidden !== void 0 ? i.bullet.forceHidden : this.lineSetComputed.bullet.forceHidden, r = this.lineSetComputed.bullet.isFilled ? K(i.color) : this.root.interfaceColors.get("background");
      this.lineSeries.bullets.push(() => oi.new(this.root, {
        sprite: li.new(
          this.root,
          {
            ...this.lineBulletSettings,
            forceHidden: s,
            fill: r,
            stroke: K(i.color),
            tooltipHTML: this.getTooltipHTML(i, e)
          },
          t
        )
      })), this.seriesTooltipHTMLAdapter && t.adapters.add(
        "tooltipHTML",
        (n, a) => this.seriesTooltipHTMLAdapter(n, a)
      ), this.lineSeries.strokes.template.setAll({
        ...this.lineStrokeTemplateSettings,
        strokeDasharray: i.strokeDasharray
      }), this.lineSeries.fills.template.setAll({
        ...this.lineFillsTemplateSettings
      }), this.lineSeries.data.setAll(this.data);
    },
    setLineSeriesXScrollbar() {
      this.logTest && console.log("setLineSeriesXScrollbar"), this.xScrollbar && (this.xScrollbarXAxis || this.setXScrollbarXAxis(), this.xScrollbarYAxis || this.setXScrollbarYAxis(), this.xScrollbarLineSeries = dt.new(this.root, {
        ...this.lineSeriesSettings,
        xAxis: this.xScrollbarXAxis,
        yAxis: this.xScrollbarYAxis
      }), this.xScrollbar.chart.series.push(this.xScrollbarLineSeries), this.xScrollbarLineSeriesList.push(this.xScrollbarLineSeries), this.xScrollbarLineSeries.bullets.push(() => oi.new(this.root, {
        sprite: li.new(this.root, { ...this.lineBulletSettings })
      })), this.xScrollbarLineSeries.strokes.template.setAll({
        ...this.lineStrokeTemplateSettings
      }), this.xScrollbarLineSeries.data.setAll(this.data));
    },
    // step line series
    setStepLineSeries() {
      this.logTest && console.log("setStepLineSeries"), this.stepLineSeriesList.map((i) => {
        i.dispose();
      }), this.stepLineSeriesList.splice(0), this.stepLineDataBinder && this.stepLineDataBinder.length > 0 && this.stepLineDataBinder.map((i, e) => {
        let t = i == null ? void 0 : i.displayName, s = i == null ? void 0 : i.key, r = i == null ? void 0 : i.openKey, n = i == null ? void 0 : i.strokeWidth, a = i == null ? void 0 : i.isLineVisible;
        n === void 0 && (n = this.stepLineSetComputed.strokeWidth), this.stepLineStrokeTemplateSettings = {
          strokeWidth: Number(n),
          visible: a !== void 0 ? a : !0
        };
        let o = this.getColor(
          this.lineSetComputed.colorList,
          e,
          i == null ? void 0 : i.color
        );
        i.color = o;
        let l = this.getAxisField(s, r);
        i.yAxisListIndex === void 0 && (i.yAxisListIndex = 0), this.stepLineSeriesSettings = {
          name: t,
          xAxis: this.xAxis,
          yAxis: this.yAxisList[i.yAxisListIndex],
          ...l
        };
        let u = i.isFillVisible !== void 0 ? i.isFillVisible : this.stepLineSetComputed.isFillVisible;
        this.stepLineFillsTemplateSettings = {
          fillOpacity: Number(this.stepLineSetComputed.fillOpacity),
          visible: u
        }, this.stepLineSeries = vr.new(this.root, {
          ...this.stepLineSeriesSettings,
          stroke: K(i.color),
          fill: K(i.color)
        }), this.xySeries = this.chart.series.push(this.stepLineSeries), this.stepLineSeriesList.push(this.stepLineSeries), this.setStepLineSeriesChart(i, e), this.setStepLineSeriesXScrollbar();
      });
    },
    setStepLineSeriesChart(i, e) {
      let t = be.new(this.root, {});
      this.chartItemClickHandler && t.events.on("click", (s) => {
        s.target.dataItem.component.className === "StepLineSeries" && this.chartItemClickHandler(s);
      }), this.stepLineSeries.bullets.push(() => oi.new(this.root, {
        sprite: li.new(
          this.root,
          {
            strokeWidth: this.stepLineSetComputed.bullet.strokeWidth,
            radius: Number(this.stepLineSetComputed.bullet.radius),
            forceHidden: this.stepLineSetComputed.bullet.forceHidden,
            fill: this.root.interfaceColors.get("background"),
            tooltip: this.makeTooltip(),
            tooltipHTML: this.getTooltipHTML(i, e),
            stroke: K(i.color)
          },
          t
        )
      })), this.seriesTooltipHTMLAdapter && t.adapters.add(
        "tooltipHTML",
        (s, r) => this.seriesTooltipHTMLAdapter(s, r)
      ), this.stepLineSeries.strokes.template.setAll({
        ...this.stepLineStrokeTemplateSettings
      }), this.stepLineSeries.fills.template.setAll({
        ...this.stepLineFillsTemplateSettings
      }), this.stepLineSeries.data.setAll(this.data);
    },
    setStepLineSeriesXScrollbar() {
      this.logTest && console.log("setStepLineSeriesXScrollbar"), this.xScrollbar && (this.xScrollbarStepLineSeries = vr.new(this.root, {
        ...this.stepLineSeriesSettings,
        xAxis: this.xScrollbarXAxis,
        yAxis: this.xScrollbarYAxis
      }), this.xScrollbar.chart.series.push(this.xScrollbarStepLineSeries), this.xScrollbarStepLineSeries.bullets.push(() => oi.new(this.root, {
        sprite: li.new(this.root, {})
      })), this.xScrollbarStepLineSeries.strokes.template.setAll({
        ...this.stepLineStrokeTemplateSettings
      }), this.xScrollbarStepLineSeries.data.setAll(this.data));
    },
    setBubbleSeries() {
      this.logTest && console.log("setBubbleSeries"), this.bubbleSeriesList.map((i) => {
        i.dispose();
      }), this.bubbleSeriesList.splice(0), this.xScrollbarBubbleSeriesList.map((i) => {
        i.dispose();
      }), this.xScrollbarBubbleSeriesList.splice(0), this.bubbleDataBinder && this.bubbleDataBinder.length > 0 && this.bubbleDataBinder.map((i, e) => {
        let t = i == null ? void 0 : i.displayName, s = i == null ? void 0 : i.key;
        this.bubbleStrokeTemplateSettings = {
          strokeWidth: Number(this.bubbleSetComputed.strokeWidth),
          visible: !1
        };
        let r = this.getColor(
          this.bubbleSetComputed.colorList,
          e,
          i == null ? void 0 : i.color
        );
        i.color = r;
        let n = this.getAxisField(s);
        i.yAxisListIndex === void 0 && (i.yAxisListIndex = 0), this.bubbleSeriesSettings = {
          name: t,
          xAxis: this.xAxis,
          yAxis: this.yAxisList[i.yAxisListIndex],
          ...n
        }, this.bubbleFillsTemplateSettings = {
          fillOpacity: Number(this.bubbleSetComputed.fillOpacity),
          visible: this.bubbleSetComputed.isFillVisible
        }, this.bubbleSeries = dt.new(this.root, {
          ...this.bubbleSeriesSettings,
          stroke: K(i.color),
          fill: K(i.color)
        }), this.xySeries = this.chart.series.push(this.bubbleSeries), this.bubbleSeriesList.push(this.bubbleSeries), this.setBubbleSeriesChart(i, e), this.setBubbleSeriesXScrollbar();
      });
    },
    setBubbleSeriesChart(i, e) {
      let t = be.new(this.root, {});
      this.chartItemClickHandler && t.events.on("click", (s) => {
        s.target.dataItem.component.className === "LineSeries" && this.chartItemClickHandler(s);
      }), this.setBubbleSeriesAdapter && this.setBubbleSeriesAdapter(
        t.adapters,
        ar,
        this,
        i
      ), this.bubbleBulletSettings = {
        showTooltipOn: "hover",
        strokeWidth: this.bubbleSetComputed.bullet.strokeWidth,
        radius: Number(this.bubbleSetComputed.bullet.radius),
        fillOpacity: this.bubbleSetComputed.bullet.isVisible ? 1 : 0,
        strokeOpacity: this.bubbleSetComputed.bullet.isVisible ? 1 : 0,
        tooltip: this.makeTooltip()
      }, this.bubbleSeries.bullets.push(() => oi.new(this.root, {
        sprite: li.new(
          this.root,
          {
            ...this.bubbleBulletSettings,
            tooltipHTML: this.getTooltipHTML(i, e),
            stroke: K(i.color),
            fill: this.bubbleSetComputed.bullet.isFilled ? K(i.color) : this.root.interfaceColors.get("background")
          },
          t
        )
      })), this.seriesTooltipHTMLAdapter && t.adapters.add(
        "tooltipHTML",
        (s, r) => this.seriesTooltipHTMLAdapter(s, r)
      ), this.bubbleSeries.strokes.template.setAll({
        ...this.bubbleStrokeTemplateSettings
      }), this.bubbleSeries.fills.template.setAll({
        ...this.bubbleFillsTemplateSettings
      }), this.bubbleSeries.data.setAll(this.data);
    },
    setBubbleSeriesXScrollbar() {
      this.logTest && console.log("setBubbleSeriesXScrollbar"), this.xScrollbar && (this.xScrollbarBubbleSeries = this.xScrollbar.chart.series.push(
        dt.new(this.root, {
          ...this.bubbleSeriesSettings,
          xAxis: this.xScrollbarXAxis,
          yAxis: this.xScrollbarYAxis
        })
      ), this.xScrollbarBubbleSeriesList.push(this.xScrollbarBubbleSeries), this.xScrollbarBubbleSeries.bullets.push(() => oi.new(this.root, {
        sprite: li.new(this.root, { ...this.bubbleBulletSettings })
      })), this.xScrollbarBubbleSeries.strokes.template.setAll({
        ...this.bubbleStrokeTemplateSettings
      }), this.xScrollbarBubbleSeries.fills.template.setAll({
        ...this.bubbleFillsTemplateSettings
      }), this.xScrollbarBubbleSeries.data.setAll(this.data));
    },
    hexToRgbA(i) {
      var e;
      if (/^#([A-Fa-f0-9]{3}){1,2}$/.test(i)) {
        e = i.substring(1).split(""), e.length == 3 && (e = [
          e[0],
          e[0],
          e[1],
          e[1],
          e[2],
          e[2]
        ]), e = "0x" + e.join("");
        let t = e >> 16 & 255, s = e >> 8 & 255, r = e & 255;
        return [t, r, s];
      }
      throw new Error("Bad Hex");
    },
    rgbaToHex(i) {
      this.logTest && console.log("rgbaStr: ", i);
      let e = i.replace(/\s/g, "").match(/^rgba?\((\d+),(\d+),(\d+),?([^,\s)]+)?/i);
      return e ? (e[1] | 256).toString(16).slice(1) + (e[2] | 256).toString(16).slice(1) + (e[3] | 256).toString(16).slice(1) : i;
    },
    setColumnSeries() {
      this.logTest && console.log("setColumnSeries"), this.columnSeriesList.map((i) => {
        i.dispose();
      }), this.columnSeriesList.splice(0), this.barDataBinder && this.barDataBinder.length > 0 && this.barDataBinder.map((i, e) => {
        let t = i == null ? void 0 : i.displayName, s = i == null ? void 0 : i.key;
        if (i == null ? void 0 : i.disabled) {
          let l = this.hexToRgbA(i == null ? void 0 : i.color), u = Math.floor((l[0] + l[1] + l[2]) / 3), h = this.rgbaToHex(
            `rgba(${u}, ${u}, ${u})`
          );
          i != null && i.color && (i.color = `#${h}`);
        }
        let n = this.getColor(
          this.chartSetComputed.column.colorList,
          e,
          i == null ? void 0 : i.color
        ), a = this.getAxisField(s);
        i.yAxisListIndex === void 0 && (i.yAxisListIndex = 0);
        let o = this.chart.series.push(
          ls.new(this.root, {
            ...this.columnSetComputed,
            name: t,
            ...a,
            xAxis: this.xAxis,
            yAxis: this.yAxisList[i != null && i.yAxisListIndex ? i.yAxisListIndex : 0]
          })
        );
        o.set("tooltip", this.makeTooltip()), o.columns.template.setAll({
          ...this.columnTemplateSetComputed,
          /**
           * y축이 카테고리고 x축이 value일 경우에는 width 는 am5.p100 이여야 함. (undefined 이면 100 percent 로 설정됨).
           * x축이 category일 경우에만 width 적용.
           */
          width: this.chartSetComputed.xAxis.type === "CategoryAxis" ? this.columnTemplateSetComputed.width : void 0,
          height: this.chartSetComputed.xAxis.type !== "CategoryAxis" ? this.columnTemplateSetComputed.height : void 0,
          tooltipHTML: this.getTooltipHTML(i, e),
          stroke: K(n),
          fill: K(n)
        }), this.xScrollbar && (this.xScrollbarColumnSeries = this.xScrollbar.chart.series.push(
          ls.new(this.root, {
            ...this.columnSetComputed,
            name: t,
            ...a,
            xAxis: this.xScrollbarXAxis,
            yAxis: this.xScrollbarYAxis
          })
        ), this.xScrollbarColumnSeries.columns.template.setAll({
          ...this.columnTemplateSetComputed,
          /**
           * y축이 카테고리고 x축이 value일 경우에는 width 는 am5.p100 이여야 함. (undefined 이면 100 percent 로 설정됨).
           * x축이 category일 경우에만 width 적용.
           */
          width: this.chartSetComputed.xAxis.type === "CategoryAxis" ? this.columnTemplateSetComputed.width : void 0,
          height: this.chartSetComputed.xAxis.type !== "CategoryAxis" ? Number(this.columnTemplateSetComputed.height) : void 0,
          tooltipHTML: this.getTooltipHTML(i, e),
          stroke: K(n),
          fill: K(n)
        }), this.xScrollbarColumnSeries.data.setAll(this.data)), this.chartItemClickHandler && o.columns.template.events.on(
          "click",
          this.chartItemClickHandler
        ), this.columnHoverEvent && o.columns.template.events.on(
          "pointerover",
          this.columnHoverEvent
        ), this.seriesTooltipHTMLAdapter && o.columns.template.adapters.add(
          "tooltipHTML",
          (l, u) => this.seriesTooltipHTMLAdapter(l, u)
        ), o.data.setAll(this.data), this.columnSeriesList.push(o);
      });
    },
    setYAxisHeader(i, e = 0) {
      this.yAxisList[e].axisHeader.children.clear(), (i != null && i.axisHeaderText || this.yAxisHeaderLabelSetComputed.text || this.yAxisHeaderLabelSetComputed.html) && (this.yAxisList[e].axisHeader.set(
        "minHeight",
        this.chartSetComputed.yAxis.axisHeader.minHeight
      ), this.yAxisList[e].axisHeader.get("background").setAll({
        ...this.yAxisHeaderBackgroundSetComputed
      }), this.yAxisList[e].axisHeader.children.push(
        Je.new(this.root, {
          ...this.yAxisHeaderLabelSetComputed,
          text: i != null && i.axisHeaderText ? i.axisHeaderText : this.yAxisHeaderLabelSetComputed.text
        })
      ));
    },
    setYAxisExtraLabel(i, e) {
      this.logTest && console.log("setYAxisExtraLabel"), w(this.yAxisList[e].children.values, (t) => {
        var s, r;
        ((r = (s = t == null ? void 0 : t.children) == null ? void 0 : s.values[0]) == null ? void 0 : r.className) === "Label" && t.dispose();
      }), (this.yAxisExtraLabelSetComputed.text || this.yAxisExtraLabelSetComputed.html || i != null && i.extraLabelText) && this.yAxisList[e].children[i != null && i.opposite ? "push" : "unshift"](
        G.new(this.root, {
          height: de(100),
          background: Pe.new(this.root, {
            // layout 확인용
            fill: K("#0f0"),
            fillOpacity: 0
          })
        })
      ).children.push(
        Je.new(this.root, {
          ...this.yAxisExtraLabelSetComputed,
          rotation: i != null && i.opposite ? 90 : -90,
          centerY: i != null && i.opposite ? de(100) : de(0),
          background: Pe.new(this.root, {
            // layout 확인용
            fill: K("#0f0"),
            fillOpacity: 0
          }),
          text: i != null && i.extraLabelText ? i.extraLabelText : this.yAxisExtraLabelSetComputed.text
        })
      );
    },
    setXAxisGridStrokeOpacityAdapter() {
      this.xAxisGridStrokeOpacityAdapter && this.xAxis.get("renderer").grid.template.adapters.add(
        "strokeOpacity",
        (i, e) => this.xAxisGridStrokeOpacityAdapter(e)
      );
    },
    createChart() {
      this.logTest && console.log("createChart"), this.$nextTick(() => {
        if (this.$refs[this.chartSetComputed.refProps]) {
          this.root || (this.root = Or.new(
            this.$refs[this.chartSetComputed.refProps],
            {
              tooltipContainerBounds: {
                top: this.chartSetComputed.root.tooltipContainerBounds.top,
                bottom: this.chartSetComputed.root.tooltipContainerBounds.bottom,
                left: this.chartSetComputed.root.tooltipContainerBounds.left,
                right: this.chartSetComputed.root.tooltipContainerBounds.right
              }
            }
          )), this.root.container.set(
            "background",
            Pe.new(this.root, {
              fill: K("#f00"),
              fillOpacity: 0
            })
          );
          const i = Bs.new(this.root);
          this.root.setThemes([gc.new(this.root), i]), this.setRootContainer(), this.setXyContainer(), this.setContainer(), this.setAxesSettings(), this.setAxes(), this.setXScrollbar(), this.setSeries(), this.setCursor(), this.setZoomOutButton(), this.setLegend(), this.setNumberFormatter();
          let e = this.chartSetComputed.yAxis.isStacked ? this.root.verticalLayout : this.root.horizontalLayout;
          this.chart.rightAxesContainer.setAll({
            layout: e,
            background: Pe.new(this.root, {
              // layout 확인용
              fill: K("#00f"),
              fillOpacity: 0
            })
          }), this.chart.leftAxesContainer.setAll({
            layout: e,
            background: Pe.new(this.root, {
              // layout 확인용
              fill: K("#00f"),
              fillOpacity: 0
            })
          }), this.setCustom && this.setCustom(ar, this), this.chart.appear(1e3, 100);
        }
      });
    },
    setRootContainer() {
      this.logTest && console.log("setRootContainer"), this.root.container.set(
        "layout",
        this.root[this.chartSetComputed.root.container.layout]
      );
    },
    setXyContainer() {
      this.xyContainer ? this.xyContainer.setAll({
        ...this.xyChartContainerSetComputed
      }) : this.xyContainer = this.root.container.children.push(
        G.new(this.root, {
          ...this.xyChartContainerSetComputed
        })
      ), this.xyContainer.set(
        "background",
        Pe.new(this.root, {
          fill: K("#00f"),
          fillOpacity: 0
        })
      );
    },
    setNumberFormatter() {
      this.root.numberFormatter.setAll({
        ...this.rootNumberFormatterSetComputed
      });
    },
    setCategoryAxis() {
      this.logTest && console.log("setCategoryAxis"), this.categoryAxisSettings = {
        categoryField: this.category,
        maxDeviation: 0,
        fillRule: (i) => {
          var e = i.get("axisFill");
          e.setPrivate("visible", !0), this.setXAxisFillRule && this.setXAxisFillRule(i, e);
        }
      };
    },
    setValueAxis() {
      this.logTest && console.log("setValueAxis");
      let i = {};
      this.chartSetComputed.valueAxis.isPercent && (i = {
        min: 0,
        max: 100,
        extraMax: 0,
        numberFormat: "#'%'",
        calculateTotals: !0
      }), this.valueAxisSettings = {
        // TODO: valueAxisSetComputed로 변경
        strictMinMaxSelection: this.chartSetComputed.valueAxis.strictMinMaxSelection,
        min: this.chartSetComputed.valueAxis.min,
        extraMax: this.chartSetComputed.valueAxis.extraMax,
        baseValue: this.chartSetComputed.valueAxis.baseValue,
        ...i
      };
    },
    setAxesSettings() {
      this.logTest && console.log("setAxesSettings"), this.setCategoryAxis(), this.setValueAxis();
    },
    // 스크롤바 설정 함수
    setXScrollbar() {
      this.logTest && console.log("setXScrollbar"), this.xScrollbar ? this.xScrollbar.setAll({ ...this.xScrollbarSetComputed }) : this.xScrollbar = this.chart.set(
        "scrollbarX",
        hn.new(this.root, {
          ...this.xScrollbarSetComputed
        })
      ), this.xScrollbarSetComputed.isDown && this.chart.bottomAxesContainer.children.push(this.xScrollbar), this.setXScrollbarAxis(), this.xScrollbar.thumb.setAll({ ...this.xScrollbarThumbSetComputed }), this.xScrollbar.startGrip.setAll(this.xScrollbarStartGripSetComputed), this.xScrollbar.endGrip.setAll(this.xScrollbarEndGripSetComputed), this.xScrollbar.get("background").setAll(this.xScrollbarBackgroundSetComputed);
    },
    setXScrollbarAxis() {
      this.logTest && console.log("setXScrollbarAxis"), this.setXScrollbarXAxis(), this.setXScrollbarYAxis();
    },
    setXScrollbarXAxis() {
      this.logTest && console.log("setXScrollbarXAxis"), this.xScrollbar && (this.xScrollbarXAxis ? (this.xScrollbarXAxis.setAll({ categoryField: this.category }), this.xScrollbarXAxis.get("renderer").setAll({ ...this.xAxisRendererSetComputed })) : this.xScrollbarXAxis = this.xScrollbar.chart.xAxes.push(
        Xn[this.chartSetComputed.xAxis.type].new(this.root, {
          // TODO: scrollbarXAxisSetComputed 로 변경
          categoryField: this.category,
          renderer: mr.new(this.root, {
            // TODO: scrollbarXAxisRendererSetComputed 로 변경
            ...this.xAxisRendererSetComputed
          })
        })
      ), this.xScrollbarXAxisLabelTextAdapter && this.xScrollbarXAxis.get("renderer").labels.template.adapters.add("text", (i, e) => this.xScrollbarXAxisLabelTextAdapter(
        i,
        e,
        this.data
      )), this.xScrollbarXAxis.get("renderer").labels.template.setAll({
        // TODO: scrolbarXAxisLabelSetComputed 로 변경
        fontSize: 10,
        textAlign: "center"
      }), this.xScrollbarXAxis.get("renderer").grid.template.setAll({
        // TODO: scrollbarXAxisGridSetComputed로 변경
        ...this.xAxisGridSetComputed
      }), this.xScrollbarXAxis.data.setAll(this.data));
    },
    setXScrollbarYAxis() {
      this.logTest && console.log("setXScrollbarYAxis");
      let i = this.chartSetComputed.yAxis.type, e = this.getAxisSettings(i);
      this.xScrollbar && (this.xScrollbarYAxis ? this.xScrollbarYAxis.setAll({ ...e }) : this.xScrollbarYAxis = this.xScrollbar.chart.yAxes.push(
        Xn[this.chartSetComputed.yAxis.type].new(this.root, {
          // TODO: scrollbar y axis settings 로 변경
          ...this.yAxisSettings,
          ...e,
          renderer: br.new(this.root, {})
        })
      ), this.xScrollbarYAxis.data.setAll(this.data));
    },
    setZoomOutButton() {
      this.chartSetComputed.isZoomOutButton || this.chart.zoomOutButton.set("forceHidden", !0);
    },
    // TODO: mainKey 를 설정하는 부분도 overall-xy-chart 관련 부분으로 봐야하나?
    // setXScrollbarMainLine() {
    //   this.logTest && console.log("setXScrollbarMainLine");
    //   if (
    //     this.xScrollbar &&
    //     this.xScrollbarXAxis &&
    //     this.xScrollbarYAxis &&
    //     this.xScrollbarSetComputed.detail.isVisible &&
    //     this.xScrollbarSetComputed.detail.mainValue.key
    //   ) {
    //     if (this.xScrollbar.chart.series.values.length === 0) {
    //       this.xScrollbarOverallSeries = am5xy.SmoothedXLineSeries.new(
    //         this.root,
    //         {
    //           fill: am5.color(this.xScrollbarSetComputed.detail.line.color),
    //           stroke: am5.color(this.xScrollbarSetComputed.detail.line.color),
    //           valueYField: this.xScrollbarSetComputed.detail.mainValue.key,
    //           categoryXField: this.category,
    //           xAxis: this.xScrollbarXAxis,
    //           yAxis: this.xScrollbarYAxis,
    //         }
    //       );
    //       this.xScrollbar.chart.series.push(this.xScrollbarOverallSeries);
    //     }
    //     this.xScrollbarOverallSeries.set(
    //       "valueYField",
    //       this.xScrollbarSetComputed.detail.mainValue.key
    //     );
    //     this.xScrollbarOverallSeries.strokes.template.setAll({
    //       strokeWidth: Number(
    //         this.xScrollbarSetComputed.detail.line.strokeWidth
    //       ),
    //     });
    //     this.xScrollbarOverallSeries.fills.template.setAll({
    //       fillOpacity: Number(
    //         this.xScrollbarSetComputed.detail.line.fillOpacity
    //       ),
    //       visible: true,
    //     });
    //     this.xScrollbarOverallSeries.data.setAll(this.data);
    //   }
    // },
    setXAxis() {
      this.logTest && console.log("setXAxis"), this.createXAxis(), this.setXAxisExtraLabel(), this.setXAxisLabel(), this.setXAxisGrid(), this.setXAxisLabelTextAdapter(), this.setXAxisTooltipLabelTextAdapter(), this.setXAxisGridStrokeOpacityAdapter(), this.xAxis.data.setAll(this.data);
    },
    createXAxis() {
      this.logTest && console.log("createXAxis");
      let i = this.chartSetComputed.xAxis.type, e = this.getAxisSettings(i);
      this.xAxis ? (this.xAxis.setAll({ ...e }), this.xAxis.get("renderer").setAll({ ...this.xAxisRendererSetComputed })) : this.xAxis = this.chart.xAxes.push(
        Xn[i].new(this.root, {
          ...e,
          renderer: mr.new(this.root, {
            ...this.xAxisRendererSetComputed
          })
        })
      );
      let t = this.chartSetComputed.xAxis.tooltipHTML;
      this.xAxis.set("tooltip", this.getAxisTooltip(t));
    },
    getAxisTooltip(i) {
      let e = i || "";
      return pi.new(this.root, { labelHTML: e });
    },
    setXAxisExtraLabel() {
      this.logTest && console.log("setXAxisExtraLabel"), // this.xAxis &&
      (this.xAxisExtraLabelSetComputed.html || this.xAxisExtraLabelSetComputed.text) && (this.xAxisExtraLabel ? this.xAxisExtraLabel.setAll({ ...this.xAxisExtraLabelSetComputed }) : this.xAxisExtraLabel = this.xAxis.children.push(
        Je.new(this.root, { ...this.xAxisExtraLabelSetComputed })
      ));
    },
    setXAxisLabel() {
      this.xAxis.get("renderer").labels.template.setAll({ ...this.xAxisLabelSetComputed });
    },
    setXAxisGrid() {
      this.xAxis.get("renderer").grid.template.setAll({
        ...this.xAxisGridSetComputed
      });
    },
    setXAxisLabelTextAdapter() {
      this.xAxisLabelTextAdapter && this.xAxis.get("renderer").labels.template.adapters.add("text", (i, e) => this.xAxisLabelTextAdapter(i, e, this.timeScale));
    },
    setXAxisTooltipLabelTextAdapter() {
      this.xAxisTooltipLabelTextAdapter && this.xAxis.get("tooltip").label.adapters.add("text", (i, e) => this.xAxisTooltipLabelTextAdapter(i, e));
    },
    // TODO: overall-xy-chart 관련 부분 분리
    // setXAxisZoomToCategories() {
    //   this.logTest && console.log("setXAxisZoomToCategories");
    //   if (this.closeSelectionMin && this.closeSelectionMax) {
    //     setTimeout(() => {
    //       if (this.chartSetComputed.chartType === "overall") {
    //         this.xAxis.zoomToCategories(
    //           this.closeDataStartPoint,
    //           this.closeDataEndPoint
    //         );
    //       }
    //       if (this.chartSetComputed.chartType === "default") {
    //         this.xAxis.zoomToCategories(
    //           this.closeSelectionMin,
    //           this.closeSelectionMax
    //         );
    //       }
    //     }, 1000);
    //   }
    // },
    setYAxis(i, e = 0) {
      this.logTest && console.log("setYAxis: ", e), this.createYAxis(i, e), this.setYAxisGrid(e), this.setYAxisHeader(i, e), this.setYAxisLabel(e), this.setYAxisExtraLabel(i, e), this.setYAxisCreateRange(e), this.yAxisList[e].set(
        "background",
        Pe.new(this.root, {
          fill: K("#f00"),
          fillOpacity: 0
        })
      ), this.yAxisList[e].data.setAll(this.data);
    },
    setYAxisGrid(i = 0) {
      this.yAxisList[i].get("renderer").grid.template.setAll({ ...this.yAxisGridSetComputed });
    },
    getAxisSettings(i) {
      if (this.logTest && console.log("getAxisSettings"), i === "ValueAxis")
        return this.valueAxisSettings;
      if (i === "CategoryAxis")
        return this.categoryAxisSettings;
    },
    createYAxis(i, e = 0) {
      this.logTest && console.log("createYAxis");
      let t = this.chartSetComputed.yAxis.type, s = this.getAxisSettings(t), r = (i == null ? void 0 : i.syncIndex) !== void 0 ? this.yAxisList[i.syncIndex] : void 0;
      this.yAxisList[e] ? (this.yAxisList[e].setAll({
        ...this.yAxisSetComputed,
        ...s,
        syncWithAxis: r
      }), this.yAxisList[e].get("renderer").setAll({
        ...this.yAxisRendererSetComputed
      })) : this.yAxisList[e] = this.chart.yAxes.unshift(
        Xn[t].new(this.root, {
          ...this.yAxisSetComputed,
          ...s,
          syncWithAxis: r,
          renderer: br.new(this.root, {
            ...this.yAxisRendererSetComputed
          })
        })
      ), this.yAxisList[e].get("renderer").set("opposite", i == null ? void 0 : i.opposite);
      let n = this.chartSetComputed.yAxis.tooltipHTML;
      this.yAxisList[e].set("tooltip", this.getAxisTooltip(n));
    },
    setYAxisLabel(i = 0) {
      this.logTest && console.log("setYAxisLabel"), this.yAxisList[i].get("renderer").labels.template.setAll({ ...this.yAxisLabelSetComputed }), this.yAxisList[i].get("renderer").labels.template.setup = (e) => {
        e.setAll({
          background: gt.new(this.root, {
            fill: K("#f00"),
            fillOpacity: 0
          })
        });
      };
    },
    setYAxisCreateRange(i = 0) {
      this.yAxisRange && this.yAxisRange.map((e) => {
        let t = this.yAxisList[i].makeDataItem({
          value: e.value,
          endValue: e.endValue,
          above: !0
        });
        this.range = this.yAxisList[i].createAxisRange(t);
        let s = typeof e.location == "number" ? { location: e.location } : { location: this.chartSetComputed.yAxis.grid.location }, r = e.color ? e.color : "#579ffb", n = e.strokeDasharray ? { strokeDasharray: e.strokeDasharray } : {};
        this.setRangeGrid(r, n, s), this.setRangeAxisFill(r), this.setRangeLabel(e.text, s, r);
      });
    },
    setRangeGrid(i, e, t) {
      this.range.get("grid").setAll({
        // TODO: axisRangeGridSetComputed 로 변경
        stroke: K(i),
        strokeOpacity: 1,
        ...e,
        ...t
      });
    },
    setRangeAxisFill(i) {
      this.range.get("axisFill").setAll({
        // TODO: axisRangeAxisFillSetComputed 로 변경
        fill: K(i),
        fillOpacity: 0.1,
        visible: !0
      });
    },
    setRangeLabel(i, e, t) {
      i && this.range.get("label").setAll({
        // TODO: axisRangeLabelSetComputed 로 변경
        fill: K(16777215),
        text: i,
        ...e,
        background: Pe.new(this.root, {
          fill: K(t)
        })
      });
    },
    setAxes() {
      this.logTest && console.log("setAxes"), this.setXAxis(), this.chartSetComputed.yAxisList ? this.chartSetComputed.yAxisList.map((i, e) => {
        this.setYAxis(i, e);
      }) : this.setYAxis();
    },
    setCursor() {
      if (this.logTest && console.log("setCursor"), this.chartSetComputed.cursor.isAvailable) {
        this.chart.set(
          "cursor",
          dn.new(this.root, {
            /**
             * behavior
             * 플롯 영역을 가로질러 끌 때 커서의 동작(?)
             * "none"(default), | "zoomX" | "zoomY" | "zoomXY" | "selectX" | "selectY"| "selectXY"
             */
            behavior: "none",
            xAxis: this.chartSetComputed.cursor.xAxis.isFocused ? this.xAxis : void 0,
            yAxis: this.chartSetComputed.cursor.yAxis.isFocused ? this.yAxisList[0] : void 0
          })
        );
        let i = this.chart.get("cursor");
        this.getWheelCursorPositionX && i.events.on("wheel", (e) => {
          e.target.getPrivate("positionX") && this.getWheelCursorPositionX(e.target.getPrivate("positionX"));
        });
      }
    },
    setChartTitle() {
      this.logTest && console.log("setChartTitle");
    },
    setChartContainer() {
      this.logTest && this.logTest && console.log("setChartContainer"), this.chart ? this.chart.setAll({ ...this.xyChartSetComputed }) : this.chart = this.xyContainer.children.push(
        gr.new(this.root, { ...this.xyChartSetComputed })
      ), this.chartSetComputed.isYAxesPlotContainerVisible || this.chart.yAxesAndPlotContainer.set("forceHidden", !0), this.chartSetComputed.isBottomAxesContainerVisible || this.chart.bottomAxesContainer.set("forceHidden", !0);
    },
    setContainer() {
      this.logTest && console.log("setContainer"), this.setChartContainer(), this.setChartTitle();
    },
    setCandlestickSeries() {
      var i, e, t, s, r, n, a, o, l;
      this.candlestickDataBinder && this.candlestickDataBinder.length > 0 && (this.candlestickSettings = {
        tooltip: this.makeTooltip(),
        name: (i = this.candlestickDataBinder) == null ? void 0 : i.displayName,
        openValueYField: (t = (e = this.candlestickDataBinder) == null ? void 0 : e.openValue) == null ? void 0 : t.key,
        highValueYField: (r = (s = this.candlestickDataBinder) == null ? void 0 : s.highValue) == null ? void 0 : r.key,
        lowValueYField: (a = (n = this.candlestickDataBinder) == null ? void 0 : n.lowValue) == null ? void 0 : a.key,
        valueYField: (l = (o = this.candlestickDataBinder) == null ? void 0 : o.defaultValue) == null ? void 0 : l.key,
        categoryXField: this.category
      }, this.setCandlestickSeriesChart(), this.setCandlestickSeriesXScrollbar());
    },
    setCandlestickSeriesChart(i = 0) {
      var e, t, s, r, n, a, o, l;
      this.candlestickSeries = us.new(this.root, {
        xAxis: this.xAxis,
        yAxis: this.yAxisList[i],
        ...this.candlestickSettings
      }), this.xySeries = this.chart.series.push(this.candlestickSeries), this.candlestickSeries.columns.template.setAll({
        width: 30
      }), this.candlestickSeries.columns.template.states.create("riseFromOpen", {
        fill: K(this.candlestickSetComputed.riseColor),
        stroke: K(this.candlestickSetComputed.riseColor)
      }), this.candlestickSeries.columns.template.states.create("dropFromOpen", {
        fill: K(this.candlestickSetComputed.dropColor),
        stroke: K(this.candlestickSetComputed.dropColor)
      }), this.candlestickSeries.get("tooltip").label.set(
        "text",
        `${(t = (e = this.candlestickDataBinder) == null ? void 0 : e.openValue) == null ? void 0 : t.displayName}: {openValueY}
${(r = (s = this.candlestickDataBinder) == null ? void 0 : s.highValue) == null ? void 0 : r.displayName}: {highValueY}
${(a = (n = this.candlestickDataBinder) == null ? void 0 : n.lowValue) == null ? void 0 : a.displayName}: {lowValueY}
${(l = (o = this.candlestickDataBinder) == null ? void 0 : o.defaultValue) == null ? void 0 : l.displayName}: {valueY}`
      ), this.candlestickSeries.columns.template.setAll({}), this.candlestickSeries.columns.template.events.on(
        "click",
        this.chartItemClickHandler
      ), this.candlestickSeries.data.setAll(this.data);
    },
    setCandlestickSeriesXScrollbar() {
      // this.xScrollbarSetComputed.detail.isVisible &&
      // !this.xScrollbarSetComputed.detail.mainValue.key
      this.xScrollbar && (this.xScrollbarCandlestickSeries = us.new(
        this.root,
        {
          xAxis: this.xScrollbarXAxis,
          yAxis: this.xScrollbarYAxis,
          ...this.candlestickSettings
        }
      ), this.xScrollbar.chart.series.push(this.xScrollbarCandlestickSeries), this.xScrollbarCandlestickSeries.columns.template.states.create(
        "riseFromOpen",
        {
          fill: K(this.candlestickSetComputed.riseColor),
          stroke: K(this.candlestickSetComputed.riseColor)
        }
      ), this.xScrollbarCandlestickSeries.columns.template.states.create(
        "dropFromOpen",
        {
          fill: K(this.candlestickSetComputed.dropColor),
          stroke: K(this.candlestickSetComputed.dropColor)
        }
      ), this.xScrollbarCandlestickSeries.data.setAll(this.data));
    },
    setLegend() {
      this.logTest && console.log("setLegend"), this.legendContainer || (this.legendContainer = this.root.container.children.push(
        G.new(this.root, {
          width: this.chartSetComputed.root.container.layout === "verticalLayout" ? de(100) : null,
          height: this.chartSetComputed.root.container.layout === "verticalLayout" ? null : de(100)
        })
      )), this.legendContainer.set(
        "background",
        Pe.new(this.root, {
          fill: K("#f00"),
          fillOpacity: 0
        })
      ), this.legend ? this.legend.setAll({ ...this.legendSetComputed }) : this.legend = this.legendContainer.children.push(
        js.new(this.root, { ...this.legendSetComputed })
      ), this.legend.labels.template.setAll({ ...this.legendLabelSetComputed }), this.legend.markers.template.setAll({ ...this.legendMarkerSetComputed }), this.legend.markerRectangles.template.setAll({
        ...this.legendMarkerRectangleSetComputed
      }), this.legend.valueLabels.template.set("forceHidden", !0), this.legendMarkerRectanglesStrokeDashArrayAdapter && this.legend.markerRectangles.template.adapters.add(
        "strokeDasharray",
        (i, e) => this.legendMarkerRectanglesStrokeDashArrayAdapter(
          i,
          e
        )
      ), this.setCustomLegend ? this.setCustomLegend(ar, this) : this.legend.data.setAll(
        this.legendData ? this.legendData : this.chart.series.values
      );
    }
  },
  beforeDestroy() {
    this.logTest && console.log("xy-chart beforeDestroy"), this.root && this.root.dispose();
  },
  unmounted() {
    this.logTest && console.log("xy-chart destroyed");
  }
}, jh = {};
var iM = /* @__PURE__ */ X(
  tM,
  JO,
  eM,
  !1,
  sM,
  "03a05552",
  null,
  null
);
function sM(i) {
  for (let e in jh)
    this[e] = jh[e];
}
const rM = /* @__PURE__ */ function() {
  return iM.exports;
}();
var nM = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div");
}, aM = [];
const oM = {
  name: "OverallXYChart",
  components: {
    "xy-chart": rM
  },
  watch: {
    dataStartPoint: {
      handler(i) {
        console.log("watch dataStartPoint 22: ", i);
      }
    },
    dataEndPoint: {
      handler(i) {
        console.log("watch dataEndPoint 22: ", i);
      }
    },
    xScrollbarSetComputed: {
      handler(i, e) {
        this.logTest && console.log("watch overall-xy-chart xScrollbarSetComputed"), this.logTest && console.log(i), this.logTest && console.log(e);
      },
      deep: !0
    },
    "xScrollbarSetComputed.detail.mainValue.displayName": {
      handler(i, e) {
        this.logTest && console.log(
          "watch overall-xy-chart xScrollbarSetComputed.detail.mainValue.displayName"
        ), this.logTest && console.log(i), this.logTest && console.log(e);
      }
    },
    defaultData: {
      handler() {
        this.logTest && console.log("watch defaultData: ", this.defaultData);
      },
      immediate: !0,
      deep: !0
    },
    overallData: {
      handler() {
        this.logTest && console.log("watch overallData: ", this.overallData);
      },
      immediate: !0,
      deep: !0
    }
  },
  computed: {
    defaultChartSetComputed() {
      return at(this.defaultChartSetData, this.defaultChartSet);
    },
    overallChartSetComputed() {
      return at(this.overallChartSetData, this.overallChartSet);
    },
    barSetComputed() {
      return at(this.barSetData, this.barSet);
    },
    bubbleSetComputed() {
      return at(this.bubbleSetData, this.bubbleSet);
    },
    lineSetComputed() {
      return at(this.lineSetData, this.lineSet);
    },
    candlestickSetComputed() {
      return at(this.candlestickSetData, this.candlestickSet);
    },
    legendSetComputed() {
      return at(this.defaultLegendSetData, this.defaultLegendSet);
    },
    overallLegendSetComputed() {
      return at(this.overallLegendSetData, this.overallLegendSet);
    },
    xScrollbarSetComputed() {
      return at(this.xScrollbarSetData, this.xScrollbarSet);
    }
  },
  data() {
    return {
      logTest: !1,
      candlestickSetData: {
        riseColor: "#ff0000",
        dropColor: "#0000ff"
      },
      lineSetData: {
        isLineVisible: !1,
        strokeWidth: 2,
        fillOpacity: 0.1,
        bullet: {
          strokeWidth: 2,
          radius: 3
        },
        colorList: [
          "#f08080",
          "#fa8072",
          "#e9967a",
          "#ff7f50",
          "#ff6347",
          "#f4a460",
          "#ffa07a"
        ]
      },
      bubbleSetData: {
        strokeWidth: 2,
        bullet: {
          strokeWidth: 2,
          radius: 3
        },
        colorList: [
          "#f08080",
          "#fa8072",
          "#e9967a",
          "#ff7f50",
          "#ff6347",
          "#f4a460",
          "#ffa07a"
        ]
      },
      barSetData: {
        isStacked: !1,
        isClustered: !1,
        width: 15,
        strokeWidth: 1.5,
        fillOpacity: 0.3,
        cornerRadius: {
          topLeft: 0,
          topRight: 0
        },
        colorList: [
          "#BCE2C7",
          "#4EBCD5",
          "#1A2281",
          "#4169e1",
          "#1e90ff",
          "#0000cd",
          "#000080"
        ]
      },
      overallLegendSetData: {
        isVisible: !1,
        layout: "GridLayout",
        x: 50,
        centerX: 50,
        y: 100,
        centerY: 100
      },
      overallChartSetData: {
        refProps: "overallXYChart",
        id: "overallXYChart",
        chartType: "overall",
        titleLabel: {
          text: "",
          fontSize: 12,
          fontWeight: "normal",
          textAlign: "center",
          x: 5,
          centerX: 0,
          paddingTop: 0,
          paddingBottom: 0,
          color: "#555"
        },
        isZoomOutButton: !1,
        isYAxesPlotContainerVisible: !1,
        isBottomAxesContainerVisible: !1,
        chartLayout: "verticalLayout",
        panX: !0,
        panY: !1,
        wheelX: "",
        wheelY: "zoomX"
      },
      xScrollbarSetData: {
        isVisible: !0,
        isDown: !1,
        gripScale: 0.9,
        isStartGrip: !1,
        isEndGrip: !1,
        // startPosition: 0.2,
        // endPosition: 0.8,
        startPosition: 0,
        endPosition: 1,
        thumb: { fill: "#550000", fillOpacity: 0.05 },
        isDetailed: !0,
        detail: {
          isVisible: !0,
          height: 50,
          mainValue: { key: "", displayName: "" },
          line: { color: "#fb9f57", strokeWidth: 2, fillOpacity: 0.2 },
          background: {
            fill: "#000000",
            fillOpacity: 0.05,
            cornerRadius: {
              topLeft: 0,
              topRight: 10,
              bottomLeft: 10,
              bottomRight: 10
            }
          }
        }
      },
      defaultLegendSetData: {
        isVisible: !0,
        layout: "GridLayout",
        x: 50,
        centerX: 50,
        y: 100,
        centerY: 100
      },
      defaultChartSetData: {
        refProps: "defaultXYChart",
        id: "defaultXYChart",
        chartType: "default",
        titleLabel: {
          text: "",
          fontSize: 12,
          fontWeight: "normal",
          textAlign: "center",
          x: 5,
          centerX: 0,
          paddingTop: 0,
          paddingBottom: 0,
          color: "#555"
        },
        isZoomOutButton: !1,
        isYAxesPlotContainerVisible: !0,
        isBottomAxesContainerVisible: !0,
        chartLayout: "verticalLayout",
        panX: !0,
        panY: !1,
        wheelX: "",
        wheelY: "zoomX"
      }
    };
  },
  props: {
    // new
    dataStartPoint: String,
    dataEndPoint: String,
    setDataStartPoint: Function,
    setDataEndPoint: Function,
    getWheelCursorPositionX: Function,
    xAxisGridStrokeOpacityAdapter: Function,
    xAxisLabelTextAdapter: Function,
    xAxisTooltipLabelTextAdapter: Function,
    seriesTooltipLabelHtmlAdapter: Function,
    xScrollbarXAxisLabelTextAdapter: Function,
    seriesTooltipForceHiddenAdapter: Function,
    // data binder
    axisDataBinder: Object,
    styleProps: {
      type: String,
      default: "height: 400px; width: 100%; min-width: 800px;"
    },
    // chart ui common settings
    candlestickSet: Object,
    lineSet: Object,
    bubbleSet: Object,
    barSet: Object,
    // common
    setSelectionMin: Function,
    setSelectionMax: Function,
    selectionMin: [String, Number],
    selectionMax: [String, Number],
    timeScale: String,
    xScrollbarSet: Object,
    // default
    defaultChartSet: Object,
    defaultLegendSet: Object,
    defaultZoomHandler: Function,
    defaultPanHandler: Function,
    // overall
    overallChartSet: Object,
    overallLegendSet: Object,
    overallZoomHandler: Function,
    overallPanHandler: Function,
    // data settings
    defaultData: Array,
    overallData: Array,
    category: String,
    bubbleDataBinder: Array,
    lineDataBinder: Array,
    barDataBinder: Array,
    candlestickDataBinder: Array,
    chartItemClickHandler: Function
  },
  // methods: {
  //   setDataStartPoint(result) {
  //     console.log("setDataStartPoint: ", result);
  //     this.dataStartPoint = result;
  //   },
  //   setDataEndPoint(result) {
  //     console.log("setDataEndPoint: ", result);
  //     this.dataEndPoint = result;
  //   },
  // },
  mounted() {
    this.logTest && console.log("overall-xy-chart mounted"), this.logTest && console.log("defaultData: ", this.defaultData), this.logTest && console.log("overallData: ", this.overallData);
  }
}, Ih = {};
var lM = /* @__PURE__ */ X(
  oM,
  nM,
  aM,
  !1,
  uM,
  null,
  null,
  null
);
function uM(i) {
  for (let e in Ih)
    this[e] = Ih[e];
}
const VN = /* @__PURE__ */ function() {
  return lM.exports;
}();
class cM extends Bs {
  setupDefaultRules() {
    super.setupDefaultRules();
    const e = this._root.interfaceColors, t = this.rule.bind(this);
    t("PercentSeries").setAll({
      legendLabelText: "{category}",
      legendValueText: "{valuePercentTotal.formatNumber('0.00p')}",
      colors: Rs.new(this._root, {}),
      width: R,
      height: R
    }), t("PieChart").setAll({
      radius: de(80),
      startAngle: -90,
      endAngle: 270
    }), t("PieSeries").setAll({
      alignLabels: !0,
      startAngle: -90,
      endAngle: 270
    }), t("PieSeries").states.create("hidden", { endAngle: -90, opacity: 0 }), t("Slice", ["pie"]).setAll({
      position: "absolute",
      isMeasured: !1,
      x: 0,
      y: 0,
      toggleKey: "active",
      tooltipText: "{category}: {valuePercentTotal.formatNumber('0.00p')}",
      strokeWidth: 1,
      strokeOpacity: 1,
      role: "figure",
      lineJoin: "round"
    }), t("Slice", ["pie"]).states.create("active", { shiftRadius: 20, scale: 1 }), t("Slice", ["pie"]).states.create("hoverActive", { scale: 1.04 }), t("Slice", ["pie"]).states.create("hover", { scale: 1.04 }), t("RadialLabel", ["pie"]).setAll({
      textType: "aligned",
      radius: 10,
      text: "{category}: {valuePercentTotal.formatNumber('0.00p')}",
      paddingTop: 5,
      paddingBottom: 5,
      populateText: !0
    }), t("Tick", ["pie"]).setAll({
      location: 1
    }), t("SlicedChart").setAll({
      paddingLeft: 10,
      paddingRight: 10,
      paddingTop: 10,
      paddingBottom: 10
    }), t("FunnelSeries").setAll({
      startLocation: 0,
      endLocation: 1,
      orientation: "vertical",
      alignLabels: !0,
      sequencedInterpolation: !0
    }), t("FunnelSlice").setAll({
      interactive: !0,
      expandDistance: 0
      //tooltipText: "{category}: {valuePercentTotal.formatNumber('0.00p')}"
    }), t("FunnelSlice").states.create("hover", { expandDistance: 0.15 }), t("Label", ["funnel"]).setAll({
      populateText: !0,
      text: "{category}: {valuePercentTotal.formatNumber('0.00p')}",
      centerY: le
    }), t("Label", ["funnel", "horizontal"]).setAll({
      centerX: 0,
      centerY: le,
      rotation: -90
    }), t("Label", ["funnel", "vertical"]).setAll({
      centerY: le,
      centerX: 0
    }), t("Tick", ["funnel"]).setAll({
      location: 1
    }), t("FunnelSlice", ["funnel", "link"]).setAll({
      fillOpacity: 0.5,
      strokeOpacity: 0,
      expandDistance: -0.1
    }), t("FunnelSlice", ["funnel", "link", "vertical"]).setAll({
      height: 10
    }), t("FunnelSlice", ["funnel", "link", "horizontal"]).setAll({
      width: 10
    }), t("PyramidSeries").setAll({
      valueIs: "area"
    }), t("FunnelSlice", ["pyramid", "link"]).setAll({
      fillOpacity: 0.5
    }), t("FunnelSlice", ["pyramid", "link", "vertical"]).setAll({
      height: 0
    }), t("FunnelSlice", ["pyramid", "link", "horizontal"]).setAll({
      width: 0
    }), t("FunnelSlice", ["pyramid"]).setAll({
      interactive: !0,
      expandDistance: 0
    }), t("FunnelSlice", ["pyramid"]).states.create("hover", { expandDistance: 0.15 }), t("Label", ["pyramid"]).setAll({
      populateText: !0,
      text: "{category}: {valuePercentTotal.formatNumber('0.00p')}",
      centerY: le
    }), t("Label", ["pyramid", "horizontal"]).setAll({
      centerX: 0,
      centerY: le,
      rotation: -90
    }), t("Label", ["pyramid", "vertical"]).setAll({
      centerY: le,
      centerX: 0
    }), t("Tick", ["pyramid"]).setAll({
      location: 1
    }), t("FunnelSlice", ["pictorial"]).setAll({
      interactive: !0,
      tooltipText: "{category}: {valuePercentTotal.formatNumber('0.00p')}"
    }), t("Label", ["pictorial"]).setAll({
      populateText: !0,
      text: "{category}: {valuePercentTotal.formatNumber('0.00p')}",
      centerY: le
    }), t("Label", ["pictorial", "horizontal"]).setAll({
      centerX: 0,
      centerY: le,
      rotation: -90
    }), t("Label", ["pictorial", "vertical"]).setAll({
      centerY: le,
      centerX: 0
    }), t("FunnelSlice", ["pictorial", "link"]).setAll({
      fillOpacity: 0.5,
      width: 0,
      height: 0
    }), t("Tick", ["pictorial"]).setAll({
      location: 0.5
    });
    {
      const s = t("Graphics", ["pictorial", "background"]);
      s.setAll({
        fillOpacity: 0.2
      }), Q(s, "fill", e, "alternativeBackground");
    }
  }
}
class _n extends ts {
  _afterNew() {
    this._defaultThemes.push(cM.new(this._root)), super._afterNew(), this.chartContainer.children.push(this.seriesContainer), this.seriesContainer.children.push(this.bulletsContainer);
  }
  _processSeries(e) {
    super._processSeries(e), this.seriesContainer.children.moveValue(this.bulletsContainer, this.seriesContainer.children.length - 1);
  }
}
Object.defineProperty(_n, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "PercentChart"
});
Object.defineProperty(_n, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: ts.classNames.concat([_n.className])
});
class mn extends gi {
  constructor() {
    super(...arguments), Object.defineProperty(this, "slicesContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.children.push(G.new(this._root, { position: "absolute", isMeasured: !1 }))
    }), Object.defineProperty(this, "labelsContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.children.push(G.new(this._root, { position: "absolute", isMeasured: !1 }))
    }), Object.defineProperty(this, "ticksContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.children.push(G.new(this._root, { position: "absolute", isMeasured: !1 }))
    }), Object.defineProperty(this, "_lLabels", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_rLabels", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_hLabels", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "slices", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._makeSlices()
    }), Object.defineProperty(this, "labels", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._makeLabels()
    }), Object.defineProperty(this, "ticks", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._makeTicks()
    });
  }
  /**
   * @ignore
   */
  makeSlice(e) {
    const t = this.slicesContainer.children.push(this.slices.make());
    return t.on("fill", () => {
      this.updateLegendMarker(e);
    }), t.on("stroke", () => {
      this.updateLegendMarker(e);
    }), t._setDataItem(e), e.set("slice", t), this.slices.push(t), t;
  }
  /**
   * @ignore
   */
  makeLabel(e) {
    const t = this.labelsContainer.children.push(this.labels.make());
    return t._setDataItem(e), e.set("label", t), this.labels.push(t), t;
  }
  _shouldMakeBullet(e) {
    return e.get("value") != null;
  }
  /**
   * @ignore
   */
  makeTick(e) {
    const t = this.ticksContainer.children.push(this.ticks.make());
    return t._setDataItem(e), e.set("tick", t), this.ticks.push(t), t;
  }
  _afterNew() {
    this.fields.push("category", "fill"), super._afterNew();
  }
  _onDataClear() {
    const e = this.get("colors");
    e && e.reset();
  }
  _prepareChildren() {
    if (super._prepareChildren(), this._lLabels = [], this._rLabels = [], this._hLabels = [], this._valuesDirty) {
      let e = 0, t = 0, s = 0, r = 1 / 0, n = 0;
      w(this._dataItems, (a) => {
        let o = a.get("valueWorking", 0);
        e += o, t += Math.abs(o);
      }), w(this._dataItems, (a) => {
        let o = a.get("valueWorking", 0);
        o > s && (s = o), o < r && (r = o), n++;
        let l = o / t;
        t == 0 && (l = 0), a.setRaw("valuePercentTotal", l * 100);
      }), this.setPrivateRaw("valueLow", r), this.setPrivateRaw("valueHigh", s), this.setPrivateRaw("valueSum", e), this.setPrivateRaw("valueAverage", e / n), this.setPrivateRaw("valueAbsoluteSum", t);
    }
  }
  /**
   * Shows hidden series.
   *
   * @param   duration  Animation duration in milliseconds
   * @return            Animation promise
   */
  show(e) {
    const t = Object.create(null, {
      show: { get: () => super.show }
    });
    return Ze(this, void 0, void 0, function* () {
      let s = [];
      s.push(t.show.call(this, e)), s.push(this._sequencedShowHide(!0, e)), yield Promise.all(s);
    });
  }
  /**
   * Hide whole series.
   *
   * @param   duration  Animation duration in milliseconds
   * @return            Animation promise
   */
  hide(e) {
    const t = Object.create(null, {
      hide: { get: () => super.hide }
    });
    return Ze(this, void 0, void 0, function* () {
      let s = [];
      s.push(t.hide.call(this, e)), s.push(this._sequencedShowHide(!1, e)), yield Promise.all(s);
    });
  }
  /**
   * @ignore
   */
  _updateChildren() {
    super._updateChildren(), this._valuesDirty && w(this._dataItems, (e) => {
      e.get("label").text.markDirtyText();
    }), (this.isDirty("legendLabelText") || this.isDirty("legendValueText")) && w(this._dataItems, (e) => {
      this.updateLegendValue(e);
    }), this._arrange();
  }
  _arrange() {
    this._arrangeDown(this._lLabels), this._arrangeUp(this._lLabels), this._arrangeDown(this._rLabels), this._arrangeUp(this._rLabels), this._arrangeLeft(this._hLabels), this._arrangeRight(this._hLabels), w(this.dataItems, (e) => {
      this._updateTick(e);
    });
  }
  _afterChanged() {
    super._afterChanged(), this._arrange();
  }
  processDataItem(e) {
    if (super.processDataItem(e), e.get("fill") == null) {
      let t = this.get("colors");
      t && e.setRaw("fill", t.next());
    }
  }
  /**
   * Shows series's data item.
   *
   * @param   dataItem  Data item
   * @param   duration  Animation duration in milliseconds
   * @return            Promise
   */
  showDataItem(e, t) {
    const s = Object.create(null, {
      showDataItem: { get: () => super.showDataItem }
    });
    return Ze(this, void 0, void 0, function* () {
      const r = [s.showDataItem.call(this, e, t)];
      S(t) || (t = this.get("stateAnimationDuration", 0));
      const n = this.get("stateAnimationEasing");
      let a = e.get("value");
      const o = e.animate({ key: "valueWorking", to: a, duration: t, easing: n });
      o && r.push(o.waitForStop());
      const l = e.get("tick");
      l && r.push(l.show(t));
      const u = e.get("label");
      u && r.push(u.show(t));
      const h = e.get("slice");
      h && r.push(h.show(t)), h.get("active") && h.states.applyAnimate("active"), yield Promise.all(r);
    });
  }
  /**
   * Hides series's data item.
   *
   * @param   dataItem  Data item
   * @param   duration  Animation duration in milliseconds
   * @return            Promise
   */
  hideDataItem(e, t) {
    const s = Object.create(null, {
      hideDataItem: { get: () => super.hideDataItem }
    });
    return Ze(this, void 0, void 0, function* () {
      const r = [s.hideDataItem.call(this, e, t)], n = this.states.create("hidden", {});
      S(t) || (t = n.get("stateAnimationDuration", this.get("stateAnimationDuration", 0)));
      const a = n.get("stateAnimationEasing", this.get("stateAnimationEasing")), o = e.animate({ key: "valueWorking", to: 0, duration: t, easing: a });
      o && r.push(o.waitForStop());
      const l = e.get("tick");
      l && r.push(l.hide(t));
      const u = e.get("label");
      u && r.push(u.hide(t));
      const h = e.get("slice");
      h.hideTooltip(), h && r.push(h.hide(t)), yield Promise.all(r);
    });
  }
  /**
   * @ignore
   */
  disposeDataItem(e) {
    super.disposeDataItem(e);
    let t = e.get("label");
    t && (this.labels.removeValue(t), t.dispose());
    let s = e.get("tick");
    s && (this.ticks.removeValue(s), s.dispose());
    let r = e.get("slice");
    r && (this.slices.removeValue(r), r.dispose());
  }
  /**
   * Triggers hover on a series data item.
   *
   * @since 5.0.7
   * @param  dataItem  Target data item
   */
  hoverDataItem(e) {
    const t = e.get("slice");
    t && !t.isHidden() && t.hover();
  }
  /**
   * Triggers un-hover on a series data item.
   *
   * @since 5.0.7
   * @param  dataItem  Target data item
   */
  unhoverDataItem(e) {
    const t = e.get("slice");
    t && t.unhover();
  }
  /**
   * @ignore
   */
  updateLegendMarker(e) {
    if (e) {
      const t = e.get("slice");
      if (t) {
        const s = e.get("legendDataItem");
        if (s) {
          const r = s.get("markerRectangle");
          w(fp, (n) => {
            t.get(n) != null && r.set(n, t.get(n));
          });
        }
      }
    }
  }
  _arrangeDown(e) {
    if (e) {
      let t = this._getNextDown();
      e.sort((s, r) => s.y > r.y ? 1 : s.y < r.y ? -1 : 0), w(e, (s) => {
        const r = s.label.adjustedLocalBounds();
        let n = r.top;
        s.y + n < t && (s.y = t - n), s.label.set("y", s.y), t = s.y + r.bottom;
      });
    }
  }
  _getNextUp() {
    return this.labelsContainer.maxHeight();
  }
  _getNextDown() {
    return 0;
  }
  _arrangeUp(e) {
    if (e) {
      let t = this._getNextUp();
      e.sort((s, r) => s.y < r.y ? 1 : s.y > r.y ? -1 : 0), w(e, (s) => {
        const r = s.label.adjustedLocalBounds();
        let n = r.bottom;
        s.y + n > t && (s.y = t - n), s.label.set("y", s.y), t = s.y + r.top;
      });
    }
  }
  _arrangeRight(e) {
    if (e) {
      let t = 0;
      e.sort((s, r) => s.y > r.y ? 1 : s.y < r.y ? -1 : 0), w(e, (s) => {
        const r = s.label.adjustedLocalBounds();
        let n = r.left;
        s.y + n < t && (s.y = t - n), s.label.set("x", s.y), t = s.y + r.right;
      });
    }
  }
  _arrangeLeft(e) {
    if (e) {
      let t = this.labelsContainer.maxWidth();
      e.sort((s, r) => s.y < r.y ? 1 : s.y > r.y ? -1 : 0), w(e, (s) => {
        const r = s.label.adjustedLocalBounds();
        let n = r.right;
        s.y + n > t && (s.y = t - n), s.label.set("x", s.y), t = s.y + r.left;
      });
    }
  }
  _updateSize() {
    super._updateSize(), this.markDirty();
  }
  _updateTick(e) {
  }
  _dispose() {
    super._dispose();
    const e = this.chart;
    e && e.series.removeValue(this);
  }
}
Object.defineProperty(mn, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "PercentSeries"
});
Object.defineProperty(mn, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: gi.classNames.concat([mn.className])
});
class no extends _n {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_maxRadius", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    });
  }
  _afterNew() {
    super._afterNew(), this.seriesContainer.setAll({ x: le, y: le });
  }
  _prepareChildren() {
    super._prepareChildren();
    const e = this.chartContainer, t = e.innerWidth(), s = e.innerHeight(), r = this.get("startAngle", 0), n = this.get("endAngle", 0), a = this.get("innerRadius");
    let o = ja(0, 0, r, n, 1);
    const l = t / (o.right - o.left), u = s / (o.bottom - o.top);
    let h = { left: 0, right: 0, top: 0, bottom: 0 };
    if (a instanceof ae) {
      let d = a.value, g = Math.min(l, u);
      d = Math.max(g * d, g - Math.min(s, t)) / g, h = ja(0, 0, r, n, d), this.setPrivateRaw("irModifyer", d / a.value);
    }
    o = ap([o, h]);
    const c = this._maxRadius;
    this._maxRadius = Math.min(l, u);
    const f = Te(this.get("radius", 0), this._maxRadius);
    this.seriesContainer.setAll({
      dy: -f * (o.bottom + o.top) / 2,
      dx: -f * (o.right + o.left) / 2
    }), (this.isDirty("startAngle") || this.isDirty("endAngle") || c != this._maxRadius) && this.series.each((d) => {
      d._markDirtyKey("startAngle");
    }), (this.isDirty("innerRadius") || this.isDirty("radius")) && this.series.each((d) => {
      d._markDirtyKey("innerRadius");
    });
  }
  /**
   * Returns outer radius in pixels.
   *
   * If optional series parameter is passed in, it will return outer radius
   * of that particular series.
   *
   * @param   series  Series
   * @return          Radius in pixels
   */
  radius(e) {
    let t = Te(this.get("radius", 0), this._maxRadius), s = Te(this.get("innerRadius", 0), t);
    if (e) {
      let r = this.series.indexOf(e), n = this.series.length, a = e.get("radius");
      return a != null ? s + Te(a, t - s) : s + (t - s) / n * (r + 1);
    }
    return t;
  }
  /**
   * Returns inner radius in pixels.
   *
   * If optional series parameter is passed in, it will return inner radius
   * of that particular series.
   *
   * @param   series  Series
   * @return          Radius in pixels
   */
  innerRadius(e) {
    const t = this.radius();
    let s = Te(this.get("innerRadius", 0), t);
    if (s < 0 && (s = t + s), e) {
      let r = this.series.indexOf(e), n = this.series.length, a = e.get("innerRadius");
      return a != null ? s + Te(a, t - s) : s + (t - s) / n * r;
    }
    return s;
  }
}
Object.defineProperty(no, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "PieChart"
});
Object.defineProperty(no, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: _n.classNames.concat([no.className])
});
class ao extends mn {
  _makeSlices() {
    return new $e(be.new({}), () => cn._new(this._root, {
      themeTags: se(this.slices.template.get("themeTags", []), ["pie", "series"])
    }, [this.slices.template]));
  }
  _makeLabels() {
    return new $e(be.new({}), () => Is._new(this._root, {
      themeTags: se(this.labels.template.get("themeTags", []), ["pie", "series"])
    }, [this.labels.template]));
  }
  _makeTicks() {
    return new $e(be.new({}), () => Es._new(this._root, {
      themeTags: se(this.ticks.template.get("themeTags", []), ["pie", "series"])
    }, [this.ticks.template]));
  }
  processDataItem(e) {
    super.processDataItem(e);
    const t = this.makeSlice(e);
    t.on("scale", () => {
      this._updateTick(e);
    }), t.on("shiftRadius", () => {
      this._updateTick(e);
    }), t.events.on("positionchanged", () => {
      this._updateTick(e);
    });
    const s = this.makeLabel(e);
    s.events.on("positionchanged", () => {
      this._updateTick(e);
    }), this.makeTick(e), t.events.on("positionchanged", () => {
      s.markDirty();
    });
  }
  _getNextUp() {
    const e = this.chart;
    return e ? e._maxRadius : this.labelsContainer.maxHeight() / 2;
  }
  _getNextDown() {
    const e = this.chart;
    return e ? -e._maxRadius : -this.labelsContainer.maxHeight() / 2;
  }
  _prepareChildren() {
    super._prepareChildren();
    const e = this.chart;
    if (e) {
      if (this.isDirty("alignLabels")) {
        let t = this.labels.template;
        if (this.get("alignLabels"))
          t.set("textType", "aligned");
        else {
          let s = t.get("textType");
          (s == null || s == "aligned") && t.set("textType", "adjusted");
        }
      }
      if (this._valuesDirty || this.isDirty("radius") || this.isDirty("innerRadius") || this.isDirty("startAngle") || this.isDirty("endAngle") || this.isDirty("alignLabels")) {
        this.markDirtyBounds();
        const t = this.get("startAngle", e.get("startAngle", -90)), r = this.get("endAngle", e.get("endAngle", 270)) - t;
        let n = t;
        const a = e.radius(this);
        this.setPrivateRaw("radius", a);
        let o = e.innerRadius(this) * e.getPrivate("irModifyer", 1);
        o < 0 && (o = a + o), w(this._dataItems, (l) => {
          this.updateLegendValue(l);
          let u = r * l.get("valuePercentTotal") / 100;
          const h = l.get("slice");
          if (h) {
            h.set("radius", a), h.set("innerRadius", o), h.set("startAngle", n), h.set("arc", u);
            const d = l.get("fill");
            h._setDefault("fill", d), h._setDefault("stroke", d);
          }
          let c = Ms(n + u / 2);
          const f = l.get("label");
          if (f && (f.setPrivate("radius", a), f.setPrivate("innerRadius", o), f.set("labelAngle", c), f.get("textType") == "aligned")) {
            let d = a + f.get("radius", 0), g = a * it(c);
            c > 90 && c <= 270 ? (!f.isHidden() && !f.isHiding() && this._lLabels.push({ label: f, y: g }), d *= -1, d -= this.labelsContainer.get("paddingLeft", 0), f.set("centerX", R), f.setPrivateRaw("left", !0)) : (!f.isHidden() && !f.isHiding() && this._rLabels.push({ label: f, y: g }), d += this.labelsContainer.get("paddingRight", 0), f.set("centerX", 0), f.setPrivateRaw("left", !1)), f.set("x", d), f.set("y", a * it(c));
          }
          n += u, this._updateTick(l);
        });
      }
    }
  }
  _updateTick(e) {
    const t = e.get("tick"), s = e.get("label"), r = e.get("slice"), n = t.get("location", 1);
    if (t && s && r) {
      const a = (r.get("shiftRadius", 0) + r.get("radius", 0)) * r.get("scale", 1) * n, o = s.get("labelAngle", 0), l = pt(o), u = it(o), h = this.labelsContainer, c = h.get("paddingLeft", 0), f = h.get("paddingRight", 0);
      let d = 0, g = 0;
      if (d = s.x(), g = s.y(), s.get("textType") == "circular") {
        const _ = s.radius() - s.get("paddingBottom", 0), m = s.get("labelAngle", 0);
        d = _ * pt(m), g = _ * it(m);
      }
      let p = -f;
      s.getPrivate("left") && (p = c), t.set("points", [{ x: r.x() + a * l, y: r.y() + a * u }, { x: d + p, y: g }, { x: d, y: g }]);
    }
  }
  _positionBullet(e) {
    const t = e.get("sprite");
    if (t) {
      const r = t.dataItem.get("slice");
      if (r) {
        const n = r.get("innerRadius", 0), a = r.get("radius", 0), o = r.get("startAngle", 0), l = r.get("arc", 0), u = e.get("locationX", 0.5), h = e.get("locationY", 0.5), c = o + l * u, f = n + (a - n) * h;
        t.setAll({ x: pt(c) * f, y: it(c) * f });
      }
    }
  }
}
Object.defineProperty(ao, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "PieSeries"
});
Object.defineProperty(ao, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: mn.classNames.concat([ao.className])
});
const hM = {
  active: !1,
  // undefined || false || true
  centerX: {
    value: 0,
    type: "number"
    // number || Percent
  },
  centerY: {
    value: 0,
    type: "number"
    // number || Percent
  },
  crisp: !1,
  // undefeind || false || true
  cursorOverStyle: void 0,
  // undefined || string
  dateFormatter: void 0,
  // DateFormatter || undefined
  disabled: !1,
  // undefined || false || true
  draggable: !1,
  // undefined || false || true
  draw: void 0,
  // undefined || (display: IGraphics, graphics: Graphics) => void
  durationFormatter: void 0,
  // DurationFormatter || undefined
  dx: 0,
  // undefined || number
  dy: 0,
  // undefined || number
  exportable: !0,
  // undefined || false || true
  fillOpacity: 0.5,
  // undefined || number
  forceHidden: !0,
  // undefined || false || true
  forceInactive: !1,
  // undefined || false || true
  height: null,
  // undefined || false || true
  id: void 0,
  // undefined || string
  interactive: void 0,
  // undefined || false || true
  isMeasured: !1,
  // undefined || false || true
  layer: void 0,
  // undefined || number
  length: void 0,
  // undefined || number
  /**
   * Important Settings: 다중점 선의 앵커 포인트(접합)에 사용되는 방법입니다.
   */
  lineJoin: "meter",
  // "meter"(default) || "round" || "bevel"
  /**
   * Important Settings
   */
  location: 0.5,
  // undefined || number
  marginBottom: 0,
  // undefined || number
  marginLeft: 0,
  // undefined || number
  marginRight: 0,
  // undefined || number
  marginTop: 0,
  // undefined || number
  maxHeight: null,
  // number || null
  maxWidth: null,
  // number || null
  minHeight: null,
  // number || null
  minWidth: null,
  // number || null
  nonScalingStroke: void 0,
  // undefined || false(default) || true
  numberFormatter: void 0,
  // NumberFormatter || undefined
  opacity: 0,
  // undefined || number
  position: "relative",
  // "absolute" || "relative"
  rotation: 0,
  // undefined || number
  scale: 1,
  // undefined || number
  shadowBlur: void 0,
  // undefined || number
  shadowOffsetX: 0,
  // undefined || number
  shadowOffsetY: 0,
  // undefined || number
  shadowOpacity: 1,
  // undefined || number
  showTooltipOn: "hover",
  // "hover"(default) || "always" || "click"
  stateAnimationDuration: 500,
  // undefined || number
  stroke: "#cbcbcb",
  // Color
  strokeDashArray: 0,
  // number[] || number
  strokeDashoffset: void 0,
  // undefined || number
  strokeOpacity: 0,
  // undefined || number
  strokeWidth: 1,
  // undefined || number
  svgPath: void 0,
  // undefined || string
  templateField: void 0,
  // undefined || number
  toggleKey: "none",
  // "disabled" || "active" || "none" || undefined
  tooltipHTML: void 0,
  // undefined || string
  tooltipPosition: "fixed",
  // "fixed" || "pointer"
  tooltipText: void 0,
  // undefined || string
  tooltipX: {
    value: 0,
    type: "number"
    // number || Percent
  },
  tooltipY: {
    value: 0,
    type: "number"
    // number || Percent
  },
  userData: void 0,
  // any
  visible: !0,
  // undefined || false || true
  wheelable: !1,
  // undefined || false || true
  width: {
    value: null,
    type: "number"
    // number || Percent || null
  },
  x: {
    value: 0,
    type: "number"
    // number || Percent || null
  },
  y: {
    value: 0,
    type: "number"
    // number || Percent || null
  }
}, dM = {
  active: !1,
  // undefined || false || true
  /**
   * Important Settings
   *
   * 레이블 위치의 반경입니다.
   * 절대 픽셀 값 또는 백분율로 설정할 수 있습니다.
   * 상대 값은 상황에 따라 슬라이스와 같은 특정 원형 개체 내의 위치를 의미하는 경우가 가장 많습니다.
   * 0%는 내부 가장자리를 의미하고 100%는 외부 가장자리를 의미합니다.
   */
  baseRadius: {
    value: 50,
    type: "Percent"
    // number || Percent (default: 100%)
  },
  /**
   * 기준선 아래로 내려가는 높이의 양을 고려해야 합니다.
   */
  baselineRatio: 0.19,
  // undefined || number (default: 0.19)
  /**
   * 텍스트를 자르거나 줄 바꿈할 때 단어가 끊어질 수 있는지 여부입니다.
   */
  breakWords: !0,
  // undefined || false(default) || true
  /**
   * 자체에 상대적인 요소 중심의 X 좌표입니다.
   * 중심 좌표는 배치 및 회전 피벗점에 영향을 미칩니다.
   */
  centerX: {
    value: 50,
    type: "Percent"
    // number || Percent
  },
  /**
   * 자체에 상대적인 요소 중심의 Y 좌표입니다.
   * 중심 좌표는 배치 및 회전 피벗점에 영향을 미칩니다.
   */
  centerY: {
    value: 50,
    type: "Percent"
    // number || Percent
  },
  /**
   * true로 설정하면 요소는 최소한의 앤티앨리어싱으로 화면에서 선명하게 보이도록 자체적으로 그리려고 시도합니다.
   * x/y 위치를 반올림하여 "픽셀에" 잘 배치됩니다.
   * 또한 장치 픽셀 비율 또는 확대/축소를 기반으로 strokeWidth를 조정하므로 선이 예상보다 가늘게 보일 수 있습니다.
   * 참고: 이것은 일반적으로 작동하지 않을 수 있습니다. 특히 서로 완벽하게 맞아야 하는 여러 개체에 설정할 때 그렇습니다.
   */
  crisp: !1,
  // undefiend, false, true
  /**
   * 이 요소를 가리킬 때 표시할 명명된 마우스 커서 스타일입니다.
   */
  cursorOverStyle: void 0,
  // undefined || string
  /**
   * 전역 포맷터 개체 대신 사용해야 하는 DateFormatter의 인스턴스입니다.
   */
  dateFormatter: void 0,
  // DateFormatter || undefined
  /**
   * 텍스트 방향.
   */
  direction: "ltr",
  // 'ltr'(default) || 'rtl'
  /**
   * 요소가 비활성화되었는지 여부를 나타냅니다.
   */
  disabled: !1,
  // undefined || false || true
  /**
   * true로 설정하면 사용자가 이 요소를 드래그할 수 있습니다.
   * 또한 이 요소 영역에 대한 기본 드래그 이벤트를 비활성화합니다.
   */
  draggable: !1,
  // undefined || false || true
  /**
   * 전역 포맷터 개체 대신 사용해야 하는 DurationFormatter의 인스턴스입니다.
   */
  durationFormatter: void 0,
  // DurationFomatter || undefined
  /**
   * 픽셀 단위의 수평 이동.
   * 왼쪽으로 이동하려면 음수가 될 수 있습니다.
   */
  dx: void 0,
  // undefined || number
  /**
   * 픽셀 단위의 수직 이동.
   * 위쪽으로 이동하려면 음수일 수 있습니다.
   */
  dy: void 0,
  // undefined || number
  /**
   * 텍스트를 자를 때 사용할 줄임표 문자입니다.
   * 기본적으로 유니코드 줄임표 기호("…")를 사용하며 일부 글꼴에서는 사용하지 못할 수 있습니다.
   * 줄임표가 깨져 보이면 다른 문자를 사용하십시오.
   */
  ellipsis: "...",
  // undefined || string (default: "...")
  /**
   * false로 설정하면 이 요소는 차트의 내보낸 스냅샷에 나타나지 않습니다.
   */
  exportable: !0,
  // undefined || false || true
  /**
   * 텍스트 색상.
   */
  fill: "#4b4b4b",
  // Color
  /**
   * 텍스트 불투명도.
   */
  fillOpacity: 1,
  // undefiend || number (default: 1)
  fontFamily: void 0,
  // undefined || string
  fontSize: "15px",
  // string || number
  fontStyle: "normal",
  // 'normal' || 'italic' || 'ablique'
  fontWeight: "normal",
  // 'normal' || 'bold' || 'bolder' || 'lighter' || '100' || '200' || '300' || '400' || '500' || '600' || '700' || '800' || '900'
  forceHidden: !1,
  // undefined || false || true
  /**
   * true로 설정하면 요소가 비활성화됩니다.
   * 관련 이벤트가 설정되어 있거나 Interactive: true가 설정되어 있어도 모든 상호 작용을 전혀 인식하지 못합니다.
   */
  forceInactive: !1,
  // undefined || false || true
  /**
   * 요소의 절대 높이(픽셀 단위) 또는 부모에 대한 상대 높이(백분율).
   */
  height: {
    value: null,
    type: "number"
    // number || Percent || null
  },
  /**
   * 컨테이너의 HTML 콘텐츠입니다.
   */
  html: void 0,
  // undefined || string
  /**
   * true로 설정하면 인라인 서식 블록을 무시하고 텍스트를 그대로 표시합니다.
   */
  ignoreFormatting: !1,
  // undefined || flase || true
  /**
   * 호의 내부(true) 또는 외부(false)에 레이블을 그려야 합니다.
   */
  inside: !0,
  // undefined || false || true
  /**
   * 이 요소가 사용자 상호 작용 이벤트를 수락해야 합니까?
   */
  interactive: !1,
  // undefined || false || true
  /**
   * true로 설정하면 직계 자식뿐만 아니라 모든 요소가 "대화형"이 됩니다.
   */
  interactiveChildren: !1,
  // undefined || false || true
  /**
   * false로 설정하면 요소가 측정되지 않고 레이아웃 체계에 참여할 수 없습니다.
   */
  isMeasured: !0,
  // undefiend || false || true
  /**
   * 문자 사이의 추가 간격(픽셀 단위)입니다.
   */
  kerning: 0,
  // undefined || number (default: 0)
  /**
   * 각도를 도 단위로 표시하십시오.
   * 대부분의 경우 차트/계열에 의해 설정되며 수동으로 설정할 필요가 없습니다.
   */
  labelAngle: 0,
  // undefiend || number
  /**
   * 요소를 넣을 숫자 레이어입니다.
   * 번호가 높은 요소가 번호가 낮은 요소 앞에 나타납니다.
   * 설정하지 않으면 상위 계층에서 계층을 상속합니다.
   */
  layer: void 0,
  // undefined || number
  /**
   * 레이아웃 방법
   */
  layout: null,
  // Layout || null
  /**
   * 퍼센트 또는 절대 픽셀의 라인 높이.
   */
  lineHeight: {
    value: 0,
    type: "number"
    // Percent || number
  },
  marginBottom: 0,
  // undefined || number
  marginLeft: 0,
  // undefined || number
  marginRight: 0,
  // undefined || number
  marginTop: 0,
  // undefined || number
  /**
   * 컨테이너의 마스크(클리핑 영역)로 사용할 요소입니다.
   */
  mask: null,
  // Graphics || null
  /**
   * true로 설정하면 컨테이너 경계를 벗어나는 모든 콘텐츠가 잘립니다.
   */
  maskContent: !1,
  // undefiend || false || true
  /**
   * 최대 허용 높이(픽셀)입니다.
   */
  maxHeight: null,
  // number || null
  /**
   * 허용되는 최대 너비(픽셀)입니다.
   */
  maxWidth: null,
  // number || null
  /**
   * 허용되는 최소 높이(픽셀)입니다.
   */
  minHeight: null,
  // number || null
  /**
   * Important Settings
   *
   * oversizedBehavior가 "fit"으로 설정된 경우 축소할 때 레이블에 허용되는 최소 상대 배율입니다.
   * 레이블을 맞추려면 minScale 이상으로 확장해야 하는 경우 대신 숨겨집니다.
   */
  minScale: null,
  // number || null
  /**
   * 허용되는 최소 너비(픽셀)입니다.
   */
  minWidth: null,
  // number || null
  /**
   * 전역 포매터 개체 대신 사용해야 하는 NumberFormatter의 인스턴스입니다.
   */
  numberFormatter: void 0,
  // NumberFormatter || undefined
  opacity: 1,
  // undefined || number
  /**
   * Important Settings
   *
   * 텍스트가 호의 안쪽 또는 바깥쪽을 향해야 텍스트가 따라옵니다.
   * "자동"은 가독성을 높이기 위해 각도에 따라 방향이 자동으로 선택됨을 의미합니다.
   * texttype 이 "circular"인 경우에만 적용됩니다.
   */
  orientation: "auto",
  // "inward" || "outward" || "auto"(default)
  /**
   * 지정된 공간에 맞지 않는 라벨 처리 방법.
   * 제한 사항: 원형 레이블에서 지원되는 유일한 값은 "hide" 및 "truncate"입니다.
   * 후자는 breakWords 설정을 무시합니다.
   */
  oversizedBehavior: "truncate",
  // "none" || "hide" || "fit" || "wrap" || "wrap-no-break" || "truncate"
  /**
   * 하단 패딩(픽셀 단위).
   */
  paddingBottom: 0,
  // undefined || number
  /**
   * 왼쪽 패딩(픽셀 단위).
   */
  paddingLeft: 0,
  // undefined || number
  /**
   * 오른쪽 패딩(픽셀 단위).
   */
  paddingRight: 0,
  // undefined || number
  /**
   * 상단 패딩(픽셀 단위).
   */
  paddingTop: 0,
  // undefined || number
  /**
   * Important Settings: true로 설정하면 레이블이 데이터 자리 표시자의 텍스트를 구문 분석하고 실제 데이터로 채우려고 시도합니다.
   */
  populateText: !0,
  // undefined || false || true
  /**
   * 요소의 위치 지정. "absolute"는 요소가 상위 레이아웃 구성표에 참여하지 않고 x 및 y 설정에 따라 단독으로 배치됨을 의미합니다.
   */
  position: "relative",
  // "absolute" || "relative"
  /**
   * 반경을 조정할 픽셀 값입니다.
   * baseRadius가 평가하는 모든 값에 더하거나 음수인 경우 뺍니다.
   */
  radius: 0,
  // undefined || number
  /**
   * true로 설정하면 자식이 반대 순서로 배치됩니다.
   */
  reverseChildren: !1,
  // undefined || false || true
  /**
   * 각도 회전.
   */
  rotation: 0,
  // undefiend || number
  /**
   * 규모: 1보다 작은 값으로 설정하면 개체가 축소됩니다.
   */
  scale: 1,
  // undefined || number
  /**
   * true로 설정하면 컨테이너에 상태를 적용하면 자식에도 동일한 상태가 적용됩니다.
   */
  setStateOnChildren: void 0,
  // undefined || false || true
  /**
   * 그림자의 흐릿함.
   * 숫자가 클수록 더 흐릿한 그림자가 됩니다.
   */
  shadowBlur: void 0,
  // undefined || number
  /**
   * 요소의 그림자 색상입니다.
   * 이것이 작동하려면 다음 중 적어도 하나를 설정해야 합니다.
   * shadowBlur, shadowOffsetX, shadowOffsetY.
   * Color || null
   */
  shadowColor: "#4b4b4b",
  /**
   * 수평 그림자 오프셋(픽셀 단위).
   */
  shadowOffsetX: void 0,
  // undefined || number
  /**
   * 수직 그림자 오프셋(픽셀 단위).
   */
  shadowOffsetY: void 0,
  // undefined || number
  /**
   * 그림자의 불투명도(0-1).
   * 설정하지 않으면 요소의 fillOpacity와 동일하게 사용됩니다.
   */
  shadowOpacity: 1,
  // undefined || number
  /**
   * 도구 설명이 요소 위에 표시되는 시기를 정의합니다.
   * 사용 가능한 옵션:
   * "hover" (default) - 요소를 포인터로 가리키거나 터치하면 도구 설명이 표시됩니다. 요소가 더 이상 가리키지 않거나 요소 외부에서 터치가 발생하면 즉시 숨겨집니다.
   * "always" - 도구 설명은 상호 작용 없이 항상 요소 위에 표시됩니다. 동시에 여러 요소에 대한 툴팁을 표시해야 하는 경우 명시적으로 Tooltip 인스턴스를 생성하고 요소의 툴팁 설정을 지정해야 합니다.
   * "click" - 도구 설명은 대상 요소를 클릭/탭할 때만 나타납니다. 페이지의 다른 곳을 클릭하면 도구 설명이 숨겨집니다.
   */
  showTooltipOn: "hover",
  // "hover" (default) || "always" || "click"
  /**
   * 한 상태에서 다른 상태로 전환되는 기간.
   */
  stateAnimationDuration: 500,
  // undefined || number
  /**
   * 바인딩 요소의 설정을 데이터에 허용합니다.
   */
  // templateField: undefined, // undefined || string
  templateField: "labelSettings",
  // undefined || string
  /**
   * 라벨의 텍스트.
   */
  text: "{value}",
  // undefined || string
  textAlign: "start",
  // "start" || "end" || "left" || "right" || "center"
  /**
   * 텍스트 청크를 세로로 정렬할 때 사용할 기준선입니다.
   */
  textBaseline: "alphabetic",
  // "top" || "hanging" || "middle" || "alphabetic" || "ideographic" || "bottom"
  textDecoration: void 0,
  // "underline" || "line-through"
  /**
   * Important Settings
   *
   * Label type.
   * "regular"  - 일반 수평 라벨.
   * "circular" - 아치형 라벨.
   * "radial"   - 호의 중심에서 발산하는 라벨.
   * "aligned"  - 수평 레이블은 다른 레이블과 수평으로 정렬됩니다.
   * "adjusted" - 위치 조정된 수평 레이블
   * "regular"(default) || "circular" || "radial" || "aligned" || "adjsted"
   */
  textType: "regular",
  /**
   * 설정하면 클릭/터치할 때 요소가 지정된 부울 설정을 true와 false 사이에서 토글합니다.
   */
  toggleKey: "none",
  // "disabled" || "active" || "none" || undefined
  /**
   * 마우스를 올렸을 때 도구 설명에 표시할 HTML 콘텐츠입니다.
   */
  tooltipHTML: void 0,
  // undefined || string
  /**
   * 툴팁 위치.
   */
  tooltipPosition: "fixed",
  // "fixed" || "pointer"
  /**
   * 가리키면 도구 설명에 표시할 텍스트입니다.
   */
  tooltipText: void 0,
  // undefined || string
  /**
   * 도구 설명 포인터 X 좌표는 요소 자체를 기준으로 합니다.
   */
  tooltipX: {
    value: 0,
    type: "number"
    // number || Percent
  },
  /**
   * 도구 설명 포인터 Y 좌표는 요소 자체를 기준으로 합니다.
   */
  tooltipY: {
    value: 0,
    type: "number"
    // number || Percent
  },
  /**
   * 요소와 연결해야 하는 사용자 지정 사용자 데이터를 위한 저장소입니다.
   */
  userData: void 0,
  // any
  visible: !0,
  // undefined || false || true
  /**
   * true로 설정하면 요소 위에서 마우스 휠 이벤트가 트리거됩니다.
   * 또한 포인터가 요소 위에 있을 때 마우스 휠을 사용하여 페이지 스크롤을 비활성화합니다.
   */
  wheelable: !1,
  // undefined || false || true
  /**
   * 요소의 절대 너비(픽셀 단위) 또는 부모에 대한 상대 너비(백분율).
   */
  width: {
    value: null,
    type: "number"
    // number || Percent || null
  },
  /**
   * 상위에 상대적인 X 위치.
   */
  x: {
    value: 0,
    type: "number"
    // number || Percent || null
  },
  /**
   * 상위에 상대적인 Y 위치입니다.
   */
  y: {
    value: 0,
    type: "number"
    // number || Percent || null
  }
}, fM = {
  active: !1,
  // undefined || false || true
  /**
   * Important Settings (idk)
   *
   * "너비"를 도 단위로 슬라이스합니다.
   * undefined || number
   */
  arc: void 0,
  centerX: {
    value: 50,
    type: "Percent"
    // number || Percent
  },
  centerY: {
    value: 50,
    type: "Percent"
    // number || Percent
  },
  /**
   * 모서리 반경을 픽셀 단위로 슬라이스합니다.
   * undefined || number
   */
  cornerRadius: 0,
  crisp: !1,
  // undefiend, false, true
  cursorOverStyle: "pointer",
  // undefined || string
  /**
   * Important Settings
   *
   * 슬라이스의 innerRadius 값에 추가할 픽셀 수입니다.
   * 음수도 사용할 수 있습니다.
   * undefined || number
   */
  dInnerRadius: void 0,
  /**
   * Important Settings
   *
   * 슬라이스의 반지름 값에 추가할 픽셀 수입니다.
   * 음수도 사용할 수 있습니다.
   * undefined || number
   */
  dRadius: void 0,
  dateFormatter: void 0,
  // DateFormatter || undefinend
  disabled: !1,
  // undefined || false || true
  draggable: !1,
  // undefined || false || true
  /**
   * 그리기 기능.
   * 그리기 위해 렌더러(표시 매개변수) 메서드를 사용해야 합니다.
   * undefined || (display: IGraphics, graphics: Graphics) => void
   */
  draw: void 0,
  durationFormatter: void 0,
  // DurationFormatter || undefined
  dx: void 0,
  // undefined || number
  dy: void 0,
  // undefined || number
  exportable: void 0,
  // undefined || false || true
  fillOpacity: 1,
  // undefined || number
  forceHidden: !1,
  // undefined || false || true
  forceInactive: !1,
  // undefined || false || true
  height: {
    value: null,
    type: "number"
    // number || Percent || null
  },
  /**
   * Important Settings (idk, Not Working)
   *
   * 슬라이스의 내부 반경(픽셀)입니다.
   * undefined || number
   */
  innerRadius: 0,
  interactive: void 0,
  // undefined || false || true
  isMeasured: !1,
  // undefined || false || true
  layer: void 0,
  // undefined || number
  /**
   * Important Settings (idk, Not Working)
   *
   * 다중점 선의 앵커 포인트(접합)에 사용되는 방법입니다.
   * "miter"(default) || "round" || "bevel"
   */
  lineJoin: "miter",
  marginBottom: 0,
  // undefined || number : 하단 여백(픽셀 단위).
  marginLeft: 0,
  // undefined || number : 왼쪽 여백(픽셀 단위).
  marginRight: 0,
  // undefined || number : 오른쪽 여백(픽셀 단위).
  marginTop: 0,
  // undefined || number : 상단 여백(픽셀 단위).
  maxHeight: null,
  // number || null : 최대 허용 높이(픽셀)입니다.
  maxWidth: null,
  // number || null : 허용되는 최대 너비(픽셀)입니다.
  minHeight: null,
  // number || null : 허용되는 최소 높이(픽셀)입니다.
  minWidth: null,
  // number || null : 허용되는 최소 너비(픽셀)입니다.
  /**
   * Graphics의 크기가 변경될 때 Graphics의 스트로크가 동일하게 유지되어야 하는지 여부를 나타냅니다.
   * 이것은 상위 컨테이너 규모 변경을 고려하지 않습니다.
   * undefined || false (default) || true
   */
  nonScalingStroke: !1,
  numberFormatter: void 0,
  // NumberFormatter || undefined
  opacity: 1,
  // undefined || number
  position: "relative",
  // "absolute" || "relative"
  /**
   * Important Settings (not working)
   *
   * 반경(픽셀).
   * undefined || number
   */
  radius: 100,
  rotation: 0,
  // undefined || number
  scale: 1,
  // undefined || number
  shadowBlur: void 0,
  // undefined || number
  shadowColor: "#4b4b4b",
  // Color || null
  shadowOffsetX: void 0,
  // undefined || number
  shadowOffsetY: void 0,
  // undefined || number
  shadowOpacity: 1,
  // undefined || number
  /**
   * 반경을 픽셀 단위로 슬라이스합니다.
   * undefined || number
   */
  shiftRadius: 0,
  showTooltipOn: "hover",
  // "hover" || "always" || "click"
  /**
   * 시작 각도(도).
   * undefined || number
   */
  startAngle: void 0,
  stateAnimationDuration: 500,
  // undefined || number
  /**
   * 획(테두리 또는 선) 색상.
   * Color
   * TODO: 투명으로 할 수 있나? am5.Color(투명)
   */
  stroke: "#4b4b4b",
  /**
   * 획(테두리 또는 선) 파선 설정.
   * number[] || number
   */
  strokeDashArray: [10, 5],
  /**
   * 획(테두리 또는 선) 대시 오프셋.
   * undefined || number
   */
  strokeDashoffset: void 0,
  /**
   * 획의 불투명도(테두리 또는 선). 0 - 완전 투명; 1 - 완전 불투명.
   * undefined || number
   */
  strokeOpacity: 0,
  /**
   * 획(테두리 또는 선)의 너비(픽셀)입니다.
   * undefined || number
   */
  strokeWidth: 0,
  /**
   * SVG 경로를 사용하여 도형을 그립니다.
   * undefined || string
   */
  svgPath: void 0,
  // templateField: undefined,
  templateField: "sliceSettings",
  toggleKey: "none",
  // "disabled" || "active" || "none" || undefined
  tooltipHTML: "<div style='padding: 10px'>{category}: {value}</div>",
  // undefined || string
  tooltipPosition: "fixed",
  // "fixed" || "pointer"
  tooltipText: void 0,
  // undefined || string
  tooltipX: {
    value: 50,
    type: "Percent"
    // number || Percent,
  },
  tooltipY: {
    value: 50,
    type: "Percent"
    // number || Percent,
  },
  userData: void 0,
  // any
  visible: !0,
  // undefined || false || true
  width: {
    value: null,
    type: "number"
    // number || Percent || null
  },
  x: {
    value: 0,
    type: "number"
    // number || Percent || null
  },
  y: {
    value: 0,
    type: "number"
    // number || Percent || null
  }
}, pM = {
  // colors: ["#095256", "#087f8c", "#5aaa95", "#86a873", "#bb9f06"],
  colors: ["#BCE2C7", "#4EBCD5", "#1A2281", "#86a873", "#bb9f06"],
  active: !1,
  // undefined || false | true
  /**
   * Important Settings: 슬라이스 레이블을 열/행에 정렬해야 합니까?
   */
  alignLabels: !1,
  // undefined || false || true
  /**
   * true로 설정하면 시리즈에서 집계 값을 계산합니다.
   * 퍼센트, 높음, 낮음 등을 변경합니다.
   * 도구 설명, 디스플레이 데이터 필드, 열 규칙 또는 이와 유사한 항목에서 이러한 집계 값을 사용하지 않는 한 활성화하지 마십시오.
   */
  calculateAggregates: !1,
  // undefined || false || true
  centerX: {
    value: 0,
    type: "number"
    // number || Percent
  },
  centerY: {
    value: 0,
    type: "number"
    // number || Percent
  },
  crisp: !1,
  // undefined || false || true
  cursorOverStyle: void 0,
  // undefined || string
  dateFormatter: void 0,
  // DateFormatter || undefined
  disabled: !1,
  // undefined || false || true
  draggable: !1,
  // undefined || false || true
  durationFormatter: void 0,
  // DurationFormatter || undefined
  dx: 0,
  // undefined || number
  dy: 0,
  // undefined || number
  /**
   * 계열의 끝 각도(도)입니다.
   */
  endAngle: 270,
  // undefined || number(default: 270)
  exportable: !0,
  // undefined || false || true
  /**
   * 슬라이스 채우기를 위한 색상을 보유하는 필드입니다.
   */
  fillField: void 0,
  // undefined || string
  forceHidden: void 0,
  // undefiend || false || true
  height: {
    value: 100,
    type: "Percent"
    // number || Percent || null
  },
  html: void 0,
  // undefiend || string
  /**
   * 시리즈의 반경(픽셀 또는 백분율)입니다.
   * 음수로 설정하면 외부 반경의 픽셀을 의미합니다.
   */
  innerRadius: {
    value: 0,
    type: "number"
    // Percent || number
  },
  interactive: void 0,
  // undefined || false || true
  interactiveChildren: void 0,
  // undefined || false || true
  /**
   * 한 설정 값에서 다른 설정 값까지의 애니메이션 기간(밀리초)입니다.
   */
  interpolationDuration: void 0,
  // undefined || number
  isMeasured: !0,
  // undefiend || false || true
  /**
   * 범례의 레이블에 사용할 텍스트 템플릿입니다.
   */
  legendLabelText: "{category}",
  // undefined || string
  /**
   * 범례의 값 레이블에 사용할 텍스트 템플릿입니다.
   */
  legendValueText: void 0,
  // undefined || string (ex: ": {value}")
  marginBottom: 0,
  // undefined || number: 하단 여백(픽셀 단위).
  marginLeft: 0,
  // undefined || number: 왼쪽 여백(픽셀 단위).
  marginRight: 0,
  // undefined || number: 오른쪽 여백(픽셀 단위).
  marginTop: 0,
  // undefined || number: 상단 여백(픽셀 단위).
  maskContent: !1,
  // undefined || false || true
  maxHeight: null,
  // number || null : 최대 허용 높이(픽셀)입니다.
  maxWidth: null,
  // number || null : 허용되는 최대 너비(픽셀)입니다.
  minHeight: null,
  // number || null : 허용되는 최소 높이(픽셀)입니다.
  minWidth: null,
  // number || null : 허용되는 최소 너비(픽셀)입니다.
  name: "abc",
  // 시리즈의 이름입니다.
  numberFormatter: void 0,
  // NumberFormatter || undefined
  opacity: 1,
  // undefined || number
  paddingBottom: 0,
  // 하단 패딩(픽셀 단위).
  paddingLeft: 0,
  // 왼쪽 패딩(픽셀 단위).
  paddingRight: 0,
  // 오른쪽 패딩(픽셀 단위).
  paddingTop: 0,
  // 상단 패딩(픽셀 단위).
  position: "relative",
  // 'absolute' || 'relative'
  /**
   * Important Settings: 시리즈의 반경(픽셀 또는 백분율)입니다.
   */
  radius: {
    value: 100,
    type: "Percent"
    // Percent || number
  },
  reverseChildren: void 0,
  // undefined || false || true
  rotation: void 0,
  // undefined || number
  scale: 1,
  // undefined || number
  /**
   * 다음 데이터 항목의 애니메이션을 시작하기 전에 대기하는 밀리초 단위의 지연입니다.
   */
  sequencedDelay: void 0,
  // undefined || number
  /**
   * true로 설정하면 시리즈 초기 애니메이션이 한 번에 모두 재생되지 않고 항목별로 재생됩니다.
   */
  sequencedInterpolation: void 0,
  // undefined || false || true
  setStateOnChildren: void 0,
  // undefined || false || true
  showTooltipOn: "hover",
  // "hover" || "always" || "click"
  /**
   * 시리즈의 시작 각도(도)입니다.
   */
  startAngle: -90,
  // undefined || number (default: -90)
  stateAnimationDuration: 500,
  // undefined || number
  templateField: void 0,
  // undefined || string
  toggleKey: "none",
  // "disabled" || "active" || "none" || "undefined"
  tooltipHTML: void 0,
  // undefined || string
  tooltipPosition: "fixed",
  // "fixed" || "pointer"
  tooltipText: void 0,
  // undefined || string
  tooltipX: {
    value: 0,
    type: "number"
    // number || Percent
  },
  tooltipY: {
    value: 0,
    type: "number"
    // number || Percent
  },
  userData: void 0,
  // any
  /**
   * 데이터 항목의 숫자 값을 데이터에서 조회하는 키입니다.
   * 일부 시리즈는 요소를 표시하는 데 사용합니다.
   * 열 규칙에도 사용할 수 있습니다.
   */
  valueField: "value",
  // undefined || string
  visible: !0,
  // undefined || false || true
  wheelable: !0,
  // undefined || false || true
  width: {
    value: 100,
    type: "Percent"
    // number || Percent || null
  },
  x: {
    value: 0,
    type: "number"
    // number || Percent || null
  },
  y: {
    value: 0,
    type: "number"
    // number || Percent || null
  }
}, gM = {
  tick: hM,
  labels: dM,
  slices: fM,
  series: pM,
  active: !1,
  // undefined || false | true
  centerX: {
    value: 0,
    type: "number"
    //  number || Percent,
  },
  centerY: {
    value: 0,
    type: "number"
    //  number || Percent,
  },
  crisp: !1,
  // undefined || false || true
  cursorOverStyle: void 0,
  // undefined || string
  dateFormatter: void 0,
  // DateFormatter || undefined
  disabled: !1,
  // undefined || false || true
  draggable: !1,
  // undefined || false || true
  durationFormatter: void 0,
  // DurationFormatter || undefined
  dx: 0,
  // undefined || number
  dy: 0,
  // undefined || number
  /**
   * 계열의 끝 각도(도)입니다.
   */
  endAngle: 270,
  // undefined || number(default: 270)
  exportable: !0,
  // undefined || false || true
  /**
   * 슬라이스 채우기를 위한 색상을 보유하는 필드입니다.
   */
  fillField: void 0,
  // undefined || string
  forceHidden: void 0,
  // undefiend || false || true
  height: {
    value: 100,
    type: "Percent"
    // number || Percent || null
  },
  html: void 0,
  // undefiend || string
  /**
   * 시리즈의 반경(픽셀 또는 백분율)입니다.
   * 음수로 설정하면 외부 반경의 픽셀을 의미합니다.
   */
  innerRadius: {
    value: 80,
    type: "Percent"
    // Percent || number
  },
  interactive: void 0,
  // undefined || false || true
  interactiveChildren: void 0,
  // undefined || false || true
  isMeasured: !0,
  // undefiend || false || true
  marginBottom: 0,
  // undefined || number: 하단 여백(픽셀 단위).
  marginLeft: 0,
  // undefined || number: 왼쪽 여백(픽셀 단위).
  marginRight: 0,
  // undefined || number: 오른쪽 여백(픽셀 단위).
  marginTop: 0,
  // undefined || number: 상단 여백(픽셀 단위).
  maskContent: !1,
  // undefined || false || true
  maxHeight: null,
  // number || null : 최대 허용 높이(픽셀)입니다.
  maxWidth: null,
  // number || null : 허용되는 최대 너비(픽셀)입니다.
  minHeight: null,
  // number || null : 허용되는 최소 높이(픽셀)입니다.
  minWidth: null,
  // number || null : 허용되는 최소 너비(픽셀)입니다.
  name: "abc",
  // 시리즈의 이름입니다.
  numberFormatter: void 0,
  // NumberFormatter || undefined
  opacity: 1,
  // undefined || number
  paddingBottom: 0,
  // 하단 패딩(픽셀 단위).
  paddingLeft: 0,
  // 왼쪽 패딩(픽셀 단위).
  paddingRight: 0,
  // 오른쪽 패딩(픽셀 단위).
  paddingTop: 0,
  // 상단 패딩(픽셀 단위).
  position: "relative",
  // 'absolute' || 'relative'
  /**
   * Important Settings: 시리즈의 반경(픽셀 또는 백분율)입니다.
   */
  radius: {
    value: 100,
    type: "Percent"
    // Percent || number
  },
  reverseChildren: void 0,
  // undefined || false || true
  rotation: void 0,
  // undefined || number
  scale: 1,
  // undefined || number
  setStateOnChildren: void 0,
  // undefined || false || true
  showTooltipOn: "hover",
  // "hover" || "always" || "click"
  /**
   * 시리즈의 시작 각도(도)입니다.
   */
  startAngle: -90,
  // undefined || number (default: -90)
  stateAnimationDuration: 500,
  // undefined || number
  templateField: void 0,
  // undefined || string
  toggleKey: "none",
  // "disabled" || "active" || "none" || "undefined"
  tooltipHTML: void 0,
  // undefined || string
  tooltipPosition: "fixed",
  // "fixed" || "pointer"
  tooltipText: void 0,
  // undefined || string
  tooltipX: {
    value: 0,
    type: "number"
    // number || Percent
  },
  tooltipY: {
    value: 0,
    type: "number"
    // number || Percent
  },
  userData: void 0,
  // any
  /**
   * 데이터 항목의 숫자 값을 데이터에서 조회하는 키입니다.
   * 일부 시리즈는 요소를 표시하는 데 사용합니다.
   * 열 규칙에도 사용할 수 있습니다.
   */
  valueField: "value",
  // undefined || string
  visible: !0,
  // undefined || false || true
  wheelable: !0,
  // undefined || false || true
  width: {
    value: 100,
    type: "Percent"
    // number || Percent || null
  },
  x: {
    value: 0,
    type: "number"
    // number || Percent || null
  },
  y: {
    value: 0,
    type: "number"
    // number || Percent || null
  }
}, re = (i) => i.type === "Percent" ? de(i.value) : i.value;
var _M = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", [t("no-chart-data", {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: i.data.length === 0 || i.allNoValue,
      expression: "data.length === 0 || allNoValue"
    }],
    style: i.styleProps
  }), t("div", {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: i.data.length > 0 && !i.allNoValue,
      expression: "data.length > 0 && !allNoValue"
    }],
    ref: "pieChartDiv",
    style: i.styleProps
  })], 1);
}, mM = [];
const bM = {
  name: "PieChart",
  components: {
    "no-chart-data": Rp
  },
  props: {
    tooltipSet: Object,
    tooltipBackgroundSet: Object,
    legendSet: Object,
    legendLabelSet: Object,
    legendMarkerSet: Object,
    legendMarkerRectangleSet: Object,
    legendData: Array,
    legendMarkerRectanglesStrokeDashArrayAdapter: Function,
    seriesTooltipHTMLAdapter: Function,
    logTest: Boolean,
    category: String,
    chartSet: Object,
    pieSet: Object,
    styleProps: {
      type: String,
      default: "width: 300px; height: 300px"
    },
    data: {
      type: Array,
      default: () => []
    },
    pieDataBinder: {
      type: Array,
      default: () => []
    }
  },
  data() {
    return {
      root: "",
      legend: "",
      legendContainer: "",
      chart: "",
      pieSeries: "",
      chartSetData: {
        root: {
          container: {
            layout: "verticalLayout"
            // 'verticalLayout', 'horizontalLayout'
          }
        },
        donutInnerLabel: {
          x: 50,
          y: 50,
          centerX: 50,
          centerY: 50,
          html: ""
        }
      }
    };
  },
  watch: {
    tooltipSet() {
      this.resetChart();
    },
    tooltipBackgroundSet() {
      this.resetChart();
    },
    legendSet() {
      this.resetChart();
    },
    legendLabelSet() {
      this.resetChart();
    },
    legendMarkerSet() {
      this.resetChart();
    },
    legendMarkerRectangleSet() {
      this.resetChart();
    },
    chartSet() {
      this.resetChart();
    },
    pieSet() {
      this.resetChart();
    },
    styleProps() {
      this.resetChart();
    },
    pieDataBinder() {
      this.resetChart();
    },
    data() {
      this.resetChart();
    }
  },
  mounted() {
    Mo("AM5C392708372"), this.createChart();
  },
  computed: {
    tooltipSetComputed() {
      return Object.assign({}, Np, this.tooltipSet);
    },
    tooltipBackgroundSetComputed() {
      return Object.assign(
        {},
        Fp,
        this.tooltipBackgroundSet
      );
    },
    legendSetComputed() {
      let i = { layout: this.root.gridLayout };
      return Object.assign({}, _c, this.legendSet, i);
    },
    legendLabelSetComputed() {
      return Object.assign({}, mc, this.legendLabelSet);
    },
    legendMarkerSetComputed() {
      return Object.assign({}, bc, this.legendMarkerSet);
    },
    legendMarkerRectangleSetComputed() {
      return Object.assign(
        {},
        yc,
        this.legendMarkerRectangleSet
      );
    },
    allNoValue() {
      const i = Object.values(this.data[0]), e = (t) => !t;
      return i.every(e);
    },
    chartSetComputed() {
      let i = at(this.chartSetData, this.chartSet);
      return Object.assign({}, i);
    },
    pieSetComputed() {
      let i = at(gM, this.pieSet);
      return Object.assign({}, i);
    },
    computedPieData() {
      let i = [];
      return this.pieDataBinder.map((e) => {
        i.push({ ...e, value: this.data[0][e.key] });
      }), i;
    }
  },
  methods: {
    createChart() {
      this.data.length > 0 && (this.root = Or.new(this.$refs.pieChartDiv, {}), this.root.setThemes([gc.new(this.root)]), this.setRootContainer(), this.setPieContainer(), this.setDonutInnerLabel(), this.setPieChart(), this.setPieSeries(), this.setLegend(), this.pieSeries.appear(1e3, 100));
    },
    setRootContainer() {
      this.root.container.set(
        "layout",
        this.root[this.chartSetComputed.root.container.layout]
      );
    },
    setPieContainer() {
      this.pieContainer = this.root.container.children.push(
        G.new(this.root, {
          width: de(100),
          height: de(100)
        })
      );
    },
    resetChart() {
      this.root && this.root.dispose(), this.createChart();
    },
    setDonutInnerLabel() {
      this.pieContainer.children.unshift(
        Je.new(this.root, {})
      ).setAll({
        x: de(this.chartSetComputed.donutInnerLabel.x),
        y: de(this.chartSetComputed.donutInnerLabel.y),
        centerX: de(this.chartSetComputed.donutInnerLabel.centerX),
        centerY: de(this.chartSetComputed.donutInnerLabel.centerY),
        html: this.chartSetComputed.donutInnerLabel.html
        // text: this.chartSetComputed.donutInnerLabel.html,
      });
    },
    setPieChart() {
      let i = pi.new(this.root, { ...this.tooltipSetComputed });
      i.get("background").setAll({ ...this.tooltipBackgroundSetComputed }), this.chart = this.pieContainer.children.push(
        no.new(this.root, {
          /**
           * 적용하지 않은 settings 들
           *
           * background, colors, layerMargin, layout, mask, stateAnimationEasing
           * themeTagsSelf, themes, tooltip, verticalScrollbar
           */
          active: this.pieSetComputed.active,
          categoryField: this.category,
          centerX: re(this.pieSetComputed.centerX),
          centerY: re(this.pieSetComputed.centerY),
          crisp: this.pieSetComputed.crisp,
          cursorOverStyle: this.pieSetComputed.cursorOverStyle,
          dateFormatter: this.pieSetComputed.dateFormatter,
          disabled: this.pieSetComputed.disabled,
          draggable: this.pieSetComputed.draggable,
          durationFormatter: this.pieSetComputed.durationFormatter,
          dx: this.pieSetComputed.dx,
          dy: this.pieSetComputed.dy,
          endAngle: this.pieSetComputed.endAngle,
          exportable: this.pieSetComputed.exportable,
          forceHidden: this.pieSetComputed.forceHidden,
          height: re(this.pieSetComputed.height),
          html: this.pieSetComputed.html,
          innerRadius: re(this.pieSetComputed.innerRadius),
          interactive: this.pieSetComputed.interactive,
          interactiveChildren: this.pieSetComputed.interactiveChildren,
          isMeasured: this.pieSetComputed.isMeasured,
          layout: this.root.gridLayout,
          marginBottom: this.pieSetComputed.marginBottom,
          marginLeft: this.pieSetComputed.marginLeft,
          marginRight: this.pieSetComputed.marginRight,
          marginTop: this.pieSetComputed.marginTop,
          maskContent: this.pieSetComputed.maskContent,
          maxHeight: this.pieSetComputed.maxHeight,
          maxWidth: this.pieSetComputed.maxWidth,
          minHeight: this.pieSetComputed.minHeight,
          minWidth: this.pieSetComputed.minWidth,
          numberFormatter: this.pieSetComputed.numberFormatter,
          opacity: this.pieSetComputed.opacity,
          paddingBottom: this.pieSetComputed.paddingBottom,
          paddingLeft: this.pieSetComputed.paddingLeft,
          paddingRight: this.pieSetComputed.paddingRight,
          paddingTop: this.pieSetComputed.paddingTop,
          position: this.pieSetComputed.position,
          radius: re(this.pieSetComputed.radius),
          reverseChildren: this.pieSetComputed.reverseChildren,
          rotation: this.pieSetComputed.rotation,
          scale: this.pieSetComputed.scale,
          setStateOnChildren: this.pieSetComputed.setStateOnChildren,
          showTooltipOn: this.pieSetComputed.showTooltipOn,
          startAngle: this.pieSetComputed.startAngle,
          stateAnimationDuration: this.pieSetComputed.stateAnimationDuration,
          templateField: this.pieSetComputed.templateField,
          toggleKey: this.pieSetComputed.toggleKey,
          tooltip: i,
          tooltipHTML: this.pieSetComputed.tooltipHTML,
          tooltipPosition: this.pieSetComputed.tooltipPosition,
          tooltipText: this.pieSetComputed.tooltipText,
          tooltipX: re(this.pieSetComputed.tooltipX),
          tooltipY: re(this.pieSetComputed.tooltipY),
          userData: this.pieSetComputed.userData,
          valueField: this.pieSetComputed.valueField,
          visible: this.pieSetComputed.visible,
          wheelable: this.pieSetComputed.wheelable,
          width: re(this.pieSetComputed.width),
          x: re(this.pieSetComputed.x),
          y: re(this.pieSetComputed.y)
        })
      );
    },
    setPieSeries() {
      this.setSeries(), this.setSeriesColors(), this.setSeriesSlices(), this.setSeriesLabels(), this.setSeriesTicks(), this.pieSeries.data.setAll(this.computedPieData);
    },
    setSeries() {
      this.pieDataBinder.map((i) => {
        this.pieSeries = this.chart.series.push(
          ao.new(this.root, {
            // name: this.pieSetComputed.series.name,
            name: i.displayName,
            /**
             * 적용하지 않은 settings 들
             *
             * background, colors, fill, heatRules, id, idField, interpolationEasing
             * layerMargin, layout, LegendDataItem, mask, stateAnimationEasing, stroke
             * themeTagsSelf, themes, tooltip, verticalScrollbar
             */
            active: this.pieSetComputed.series.active,
            alignLabels: this.pieSetComputed.series.alignLabels,
            calculateAggregates: this.pieSetComputed.series.calculateAggregates,
            categoryField: this.category,
            centerX: re(this.pieSetComputed.series.centerX),
            centerY: re(this.pieSetComputed.series.centerY),
            crisp: this.pieSetComputed.series.crisp,
            cursorOverStyle: this.pieSetComputed.series.cursorOverStyle,
            dateFormatter: this.pieSetComputed.series.dateFormatter,
            disabled: this.pieSetComputed.series.disabled,
            draggable: this.pieSetComputed.series.draggable,
            durationFormatter: this.pieSetComputed.series.durationFormatter,
            dx: this.pieSetComputed.series.dx,
            dy: this.pieSetComputed.series.dy,
            endAngle: this.pieSetComputed.series.endAngle,
            exportable: this.pieSetComputed.series.exportable,
            fillField: this.pieSetComputed.series.fillField,
            forceHidden: this.pieSetComputed.series.forceHidden,
            height: re(this.pieSetComputed.series.height),
            html: this.pieSetComputed.series.html,
            innerRadius: re(this.pieSetComputed.series.innerRadius),
            interactive: this.pieSetComputed.series.interactive,
            interactiveChildren: this.pieSetComputed.series.interactiveChildren,
            interpolationDuration: this.pieSetComputed.series.interpolationDuration,
            isMeasured: this.pieSetComputed.series.isMeasured,
            legendLabelText: this.pieSetComputed.series.legendLabelText,
            legendValueText: this.pieSetComputed.series.legendValueText,
            marginBottom: this.pieSetComputed.series.marginBottom,
            marginLeft: this.pieSetComputed.series.marginLeft,
            marginRight: this.pieSetComputed.series.marginRight,
            marginTop: this.pieSetComputed.series.marginTop,
            maskContent: this.pieSetComputed.series.maskContent,
            maxHeight: this.pieSetComputed.series.maxHeight,
            maxWidth: this.pieSetComputed.series.maxWidth,
            minHeight: this.pieSetComputed.series.minHeight,
            minWidth: this.pieSetComputed.series.minWidth,
            numberFormatter: this.pieSetComputed.series.numberFormatter,
            opacity: this.pieSetComputed.series.opacity,
            paddingBottom: this.pieSetComputed.series.paddingBottom,
            paddingLeft: this.pieSetComputed.series.paddingLeft,
            paddingRight: this.pieSetComputed.series.paddingRight,
            paddingTop: this.pieSetComputed.series.paddingTop,
            position: this.pieSetComputed.series.position,
            radius: re(this.pieSetComputed.series.radius),
            reverseChildren: this.pieSetComputed.series.reverseChildren,
            rotation: this.pieSetComputed.series.rotation,
            scale: this.pieSetComputed.series.scale,
            sequencedDelay: this.pieSetComputed.series.sequencedDelay,
            sequencedInterpolation: this.pieSetComputed.series.sequencedInterpolation,
            setStateOnChildren: this.pieSetComputed.series.setStateOnChildren,
            showTooltipOn: this.pieSetComputed.series.showTooltipOn,
            startAngle: this.pieSetComputed.series.startAngle,
            stateAnimationDuration: this.pieSetComputed.series.stateAnimationDuration,
            templateField: this.pieSetComputed.series.templateField,
            toggleKey: this.pieSetComputed.series.toggleKey,
            tooltipHTML: this.pieSetComputed.series.tooltipHTML,
            tooltipPosition: this.pieSetComputed.series.tooltipPosition,
            tooltipText: this.pieSetComputed.series.tooltipText,
            tooltipX: re(this.pieSetComputed.series.tooltipX),
            tooltipY: re(this.pieSetComputed.series.tooltipY),
            userData: this.pieSetComputed.series.userData,
            valueField: this.pieSetComputed.series.valueField,
            visible: this.pieSetComputed.series.visible,
            wheelable: this.pieSetComputed.series.wheelable,
            width: re(this.pieSetComputed.series.width),
            x: re(this.pieSetComputed.series.x),
            y: re(this.pieSetComputed.series.y)
          })
        );
      });
    },
    setSeriesColors() {
      typeof this.pieSetComputed.series.colors == "string" && (this.pieSetComputed.series.colors = this.pieSetComputed.series.colors.split(","));
      let i = [];
      this.pieSetComputed.series.colors.map((e) => {
        i.push(K(e));
      }), this.pieSeries.get("colors").set("colors", [...i]);
    },
    setSeriesSlices() {
      this.pieSeries.slices.template.setAll({
        /**
         * 적용하지 않은 settings 들
         *
         * fillGradient, fillPattern, id, layerMargin, stateAnimationEasing, strokeGradient
         * strokePattern, themeTags, themeTagsSelf, themes, tooltip
         */
        active: this.pieSetComputed.slices.active,
        arc: this.pieSetComputed.slices.arc,
        centerX: re(this.pieSetComputed.slices.centerX),
        centerY: re(this.pieSetComputed.slices.centerY),
        cornerRadius: this.pieSetComputed.slices.cornerRadius,
        crisp: this.pieSetComputed.slices.crisp,
        cursorOverStyle: this.pieSetComputed.slices.cursorOverStyle,
        dInnerRadius: this.pieSetComputed.slices.dInnerRadius,
        dRadius: this.pieSetComputed.slices.dRadius,
        dateFormatter: this.pieSetComputed.slices.dateFormatter,
        disabled: this.pieSetComputed.slices.disabled,
        draggable: this.pieSetComputed.slices.draggable,
        draw: this.pieSetComputed.slices.draw,
        durationFormatter: this.pieSetComputed.slices.durationFormatter,
        dx: this.pieSetComputed.slices.dx,
        dy: this.pieSetComputed.slices.dy,
        exportable: this.pieSetComputed.slices.exportable,
        // fillOpacity: this.pieSetComputed.slices.fillOpacity,
        fillOpacity: 1,
        forceHidden: this.pieSetComputed.slices.forceHidden,
        forceInactive: this.pieSetComputed.slices.forceInactive,
        height: re(this.pieSetComputed.slices.height),
        innerRadius: re(this.pieSetComputed.slices.innerRadius),
        interactive: this.pieSetComputed.slices.interactive,
        isMeasured: this.pieSetComputed.slices.isMeasured,
        layer: this.pieSetComputed.slices.layer,
        lineJoin: this.pieSetComputed.slices.lineJoin,
        marginBottom: this.pieSetComputed.slices.marginBottom,
        marginLeft: this.pieSetComputed.slices.marginLeft,
        marginRight: this.pieSetComputed.slices.marginRight,
        marginTop: this.pieSetComputed.slices.marginTop,
        maxHeight: this.pieSetComputed.slices.maxHeight,
        maxWidth: this.pieSetComputed.slices.maxWidth,
        minHeight: this.pieSetComputed.slices.minHeight,
        minWidth: this.pieSetComputed.slices.minWidth,
        nonScalingStroke: this.pieSetComputed.slices.nonScalingStroke,
        numberFormatter: this.pieSetComputed.slices.numberFormatter,
        opacity: this.pieSetComputed.slices.opacity,
        // position: this.pieSetComputed.slices.position,
        position: "absolute",
        radius: re(this.pieSetComputed.slices.radius),
        rotation: this.pieSetComputed.slices.rotation,
        scale: this.pieSetComputed.slices.scale,
        shadowBlur: this.pieSetComputed.slices.shadowBlur,
        shadowColor: K(this.pieSetComputed.slices.shadowColor),
        shadowOffsetX: this.pieSetComputed.slices.shadowOffsetX,
        shadowOffsetY: this.pieSetComputed.slices.shadowOffsetY,
        shadowOpacity: this.pieSetComputed.slices.shadowOpacity,
        shiftRadius: this.pieSetComputed.slices.shiftRadius,
        showTooltipOn: this.pieSetComputed.slices.showTooltipOn,
        startAngle: this.pieSetComputed.slices.startAngle,
        stateAnimationDuration: this.pieSetComputed.slices.stateAnimationDuration,
        stroke: K(this.pieSetComputed.slices.stroke),
        strokeDashArray: this.pieSetComputed.slices.strokeDashArray,
        strokeDashoffset: this.pieSetComputed.slices.strokeDashoffset,
        strokeOpacity: this.pieSetComputed.slices.strokeOpacity,
        strokeWidth: this.pieSetComputed.slices.strokeWidth,
        svgPath: this.pieSetComputed.slices.svgPath,
        templateField: this.pieSetComputed.slices.templateField,
        toggleKey: this.pieSetComputed.slices.toggleKey,
        tooltipHTML: this.pieSetComputed.slices.tooltipHTML,
        tooltipPosition: this.pieSetComputed.slices.tooltipPosition,
        tooltipText: this.pieSetComputed.slices.tooltipText,
        tooltipX: re(this.pieSetComputed.slices.tooltipX),
        tooltipY: re(this.pieSetComputed.slices.tooltipY),
        userData: this.pieSetComputed.slices.userData,
        visible: this.pieSetComputed.slices.visible,
        width: re(this.pieSetComputed.slices.width),
        x: re(this.pieSetComputed.slices.x),
        y: re(this.pieSetComputed.slices.y)
      }), this.pieSeries.slices.template.states.create("hover", {
        scale: 1
      }), this.seriesTooltipHTMLAdapter && this.pieSeries.slices.template.adapters.add(
        "tooltipHTML",
        (i, e) => this.seriesTooltipHTMLAdapter(i, e)
      ), this.pieSeries.toFront(), console.log("this.pieSeries: ", this.pieSeries);
    },
    setSeriesLabels() {
      this.pieSeries.labels.template.setAll({
        /**
         * 적용하지 않은 settings 들
         *
         * background, layerMargin, stateAnimationEasing, themeTags, themeTagsSelf, themes
         * tooltip, verticalScrollbar
         */
        fill: K(this.pieSetComputed.labels.fill),
        active: this.pieSetComputed.labels.active,
        baseRadius: re(this.pieSetComputed.labels.baseRadius),
        baselineRatio: this.pieSetComputed.labels.baselineRatio,
        breakWords: this.pieSetComputed.labels.breakWords,
        centerX: re(this.pieSetComputed.labels.centerX),
        centerY: re(this.pieSetComputed.labels.centerY),
        crisp: this.pieSetComputed.labels.crisp,
        cursorOverStyle: this.pieSetComputed.labels.cursorOverStyle,
        dateFormatter: this.pieSetComputed.labels.dateFormatter,
        direction: this.pieSetComputed.labels.direction,
        disabled: this.pieSetComputed.labels.disabled,
        draggable: this.pieSetComputed.labels.draggable,
        durationFormatter: this.pieSetComputed.labels.durationFormatter,
        dx: this.pieSetComputed.labels.dx,
        dy: this.pieSetComputed.labels.dy,
        ellipsis: this.pieSetComputed.labels.ellipsis,
        exportable: this.pieSetComputed.labels.exportable,
        fillOpacity: this.pieSetComputed.labels.fillOpacity,
        fontFamily: this.pieSetComputed.labels.fontFamily,
        fontSize: this.pieSetComputed.labels.fontSize,
        fontStyle: this.pieSetComputed.labels.fontStyle,
        fontWeight: this.pieSetComputed.labels.fontWeight,
        forceHidden: this.pieSetComputed.labels.forceHidden,
        forceInactive: this.pieSetComputed.labels.forceInactive,
        height: re(this.pieSetComputed.labels.height),
        html: this.pieSetComputed.labels.html,
        id: this.pieSetComputed.labels.id,
        ignoreFormatting: this.pieSetComputed.labels.ignoreFormatting,
        inside: this.pieSetComputed.labels.inside,
        interactive: this.pieSetComputed.labels.interactive,
        interactiveChildren: this.pieSetComputed.labels.interactiveChildren,
        isMeasured: this.pieSetComputed.labels.isMeasured,
        kerning: this.pieSetComputed.labels.kerning,
        labelAngle: this.pieSetComputed.labels.labelAngle,
        layer: this.pieSetComputed.labels.layer,
        layout: this.pieSetComputed.labels.layout,
        lineHeight: re(this.pieSetComputed.labels.lineHeight),
        marginBottom: this.pieSetComputed.labels.marginBottom,
        marginLeft: this.pieSetComputed.labels.marginLeft,
        marginRight: this.pieSetComputed.labels.marginRight,
        marginTop: this.pieSetComputed.labels.marginTop,
        mask: this.pieSetComputed.labels.mask,
        maskContent: this.pieSetComputed.labels.maskContent,
        maxHeight: this.pieSetComputed.labels.maxHeight,
        maxWidth: this.pieSetComputed.labels.maxWidth,
        minHeight: this.pieSetComputed.labels.minHeight,
        minScale: this.pieSetComputed.labels.minScale,
        minWidth: this.pieSetComputed.labels.minWidth,
        numberFormatter: this.pieSetComputed.labels.numberFormatter,
        opacity: this.pieSetComputed.labels.opacity,
        orientation: this.pieSetComputed.labels.orientation,
        oversizedBehavior: this.pieSetComputed.labels.oversizedBehavior,
        paddingBottom: this.pieSetComputed.labels.paddingBottom,
        paddingLeft: this.pieSetComputed.labels.paddingLeft,
        paddingRight: this.pieSetComputed.labels.paddingRight,
        paddingTop: this.pieSetComputed.labels.paddingTop,
        populateText: this.pieSetComputed.labels.populateText,
        position: this.pieSetComputed.labels.position,
        radius: this.pieSetComputed.labels.radius,
        reverseChildren: this.pieSetComputed.labels.reverseChildren,
        rotation: this.pieSetComputed.labels.rotation,
        scale: this.pieSetComputed.labels.scale,
        setStateOnChildren: this.pieSetComputed.labels.setStateOnChildren,
        shadowBlur: this.pieSetComputed.labels.shadowBlur,
        shadowColor: K(this.pieSetComputed.labels.shadowColor),
        shadowOffsetX: this.pieSetComputed.labels.shadowOffsetX,
        shadowOffsetY: this.pieSetComputed.labels.shadowOffsetY,
        shadowOpacity: this.pieSetComputed.labels.shadowOpacity,
        showTooltipOn: this.pieSetComputed.labels.showTooltipOn,
        stateAnimationDuration: this.pieSetComputed.labels.stateAnimationDuration,
        templateField: this.pieSetComputed.labels.templateField,
        text: this.pieSetComputed.labels.text,
        textAlign: this.pieSetComputed.labels.textAlign,
        textBaseline: this.pieSetComputed.labels.textBaseline,
        textDecoration: this.pieSetComputed.labels.textDecoration,
        textType: this.pieSetComputed.labels.textType,
        toggleKey: this.pieSetComputed.labels.toggleKey,
        tooltipHTML: this.pieSetComputed.labels.tooltipHTML,
        tooltipPosition: this.pieSetComputed.labels.tooltipPosition,
        tooltipText: this.pieSetComputed.labels.tooltipText,
        tooltipX: re(this.pieSetComputed.labels.tooltipX),
        tooltipY: re(this.pieSetComputed.labels.tooltipY),
        userData: this.pieSetComputed.labels.userData,
        visible: this.pieSetComputed.labels.visible,
        wheelable: this.pieSetComputed.labels.wheelable,
        width: re(this.pieSetComputed.labels.width),
        x: re(this.pieSetComputed.labels.x),
        y: re(this.pieSetComputed.labels.y)
      });
    },
    setSeriesTicks() {
      this.pieSeries.ticks.template.setAll({
        /**
         * 적용하지 않은 settings 들
         *
         * fill, fillGradient, fillPattern, layerMargin
         * points, segments, shadowColor, stateAnimationEasing
         * stroke, strokeGradient, strokePattern, themeTags, themeTagsSelf, themes, tooltip
         */
        active: this.pieSetComputed.tick.active,
        centerX: re(this.pieSetComputed.tick.centerX),
        centerY: re(this.pieSetComputed.tick.centerY),
        crisp: this.pieSetComputed.tick.crisp,
        cursorOverStyle: this.pieSetComputed.tick.cursorOverStyle,
        dateFormatter: this.pieSetComputed.tick.dateFormatter,
        disabled: this.pieSetComputed.tick.disabled,
        draggable: this.pieSetComputed.tick.draggable,
        draw: this.pieSetComputed.tick.draw,
        durationFormatter: this.pieSetComputed.tick.durationFormatter,
        dx: this.pieSetComputed.tick.dx,
        dy: this.pieSetComputed.tick.dy,
        exportable: this.pieSetComputed.tick.exportable,
        fillOpacity: this.pieSetComputed.tick.fillOpacity,
        forceHidden: this.pieSetComputed.tick.forceHidden,
        forceInactive: this.pieSetComputed.tick.forceInactive,
        height: this.pieSetComputed.tick.height,
        id: this.pieSetComputed.tick.id,
        interactive: this.pieSetComputed.tick.interactive,
        isMeasured: this.pieSetComputed.tick.isMeasured,
        layer: this.pieSetComputed.tick.layer,
        length: this.pieSetComputed.tick.length,
        lineJoin: this.pieSetComputed.tick.lineJoin,
        location: this.pieSetComputed.tick.location,
        marginBottom: this.pieSetComputed.tick.marginBottom,
        marginLeft: this.pieSetComputed.tick.marginLeft,
        marginRight: this.pieSetComputed.tick.marginRight,
        marginTop: this.pieSetComputed.tick.marginTop,
        maxHeight: this.pieSetComputed.tick.maxHeight,
        maxWidth: this.pieSetComputed.tick.maxWidth,
        minHeight: this.pieSetComputed.tick.minHeight,
        minWidth: this.pieSetComputed.tick.minWidth,
        nonScalingStroke: this.pieSetComputed.tick.nonScalingStroke,
        numberFormatter: this.pieSetComputed.tick.numberFormatter,
        opacity: this.pieSetComputed.tick.opacity,
        position: this.pieSetComputed.tick.position,
        rotation: this.pieSetComputed.tick.rotation,
        scale: this.pieSetComputed.tick.scale,
        shadowBlur: this.pieSetComputed.tick.shadowBlur,
        shadowOffsetX: this.pieSetComputed.tick.shadowOffsetX,
        shadowOffsetY: this.pieSetComputed.tick.shadowOffsetY,
        shadowOpacity: this.pieSetComputed.tick.shadowOpacity,
        showTooltipOn: this.pieSetComputed.tick.showTooltipOn,
        stateAnimationDuration: this.pieSetComputed.tick.stateAnimationDuration,
        stroke: this.pieSetComputed.tick.stroke,
        strokeDashArray: this.pieSetComputed.tick.strokeDashArray,
        strokeDashoffset: this.pieSetComputed.tick.strokeDashoffset,
        strokeOpacity: this.pieSetComputed.tick.strokeOpacity,
        strokeWidth: this.pieSetComputed.tick.strokeWidth,
        svgPath: this.pieSetComputed.tick.svgPath,
        templateField: this.pieSetComputed.tick.templateField,
        toggleKey: this.pieSetComputed.tick.toggleKey,
        tooltipHTML: this.pieSetComputed.tick.tooltipHTML,
        tooltipPosition: this.pieSetComputed.tick.tooltipPosition,
        tooltipText: this.pieSetComputed.tick.tooltipText,
        tooltipX: re(this.pieSetComputed.tick.tooltipX),
        tooltipY: re(this.pieSetComputed.tick.tooltipY),
        userData: this.pieSetComputed.tick.userData,
        visible: this.pieSetComputed.tick.visible,
        wheelable: this.pieSetComputed.tick.wheelable,
        width: re(this.pieSetComputed.tick.width),
        x: re(this.pieSetComputed.tick.x),
        y: re(this.pieSetComputed.tick.y)
      });
    },
    setLegend() {
      var i;
      this.logTest && console.log("setLegend"), (!this.legendContainer || this.legendContainer && ((i = this.legendContainer) != null && i.isDisposed())) && (this.legendContainer = this.root.container.children.push(
        G.new(this.root, {})
      )), this.legendContainer.set(
        "width",
        this.chartSetComputed.root.container.layout === "verticalLayout" ? de(100) : null
      ), this.legendContainer.set(
        "height",
        this.chartSetComputed.root.container.layout === "verticalLayout" ? null : de(100)
      ), this.legendContainer.set(
        "background",
        Pe.new(this.root, {
          fill: K("#f00"),
          fillOpacity: 0
        })
      ), !this.legend || this.legend && this.legend.isDisposed() ? this.legend = this.legendContainer.children.push(
        js.new(this.root, { ...this.legendSetComputed })
      ) : this.legend.setAll({ ...this.legendSetComputed }), this.legend.labels.template.setAll({ ...this.legendLabelSetComputed }), this.legend.markers.template.setAll({ ...this.legendMarkerSetComputed }), this.legend.markerRectangles.template.setAll({
        ...this.legendMarkerRectangleSetComputed
      }), this.legend.valueLabels.template.set("forceHidden", !0), this.setCustomLegend && this.setCustomLegend(ar, this), this.legend.itemContainers.template.setup = (e) => {
        e.events.disableType("pointerover");
      }, this.legendMarkerRectanglesStrokeDashArrayAdapter && this.legend.markerRectangles.template.adapters.add(
        "strokeDasharray",
        (e, t) => this.legendMarkerRectanglesStrokeDashArrayAdapter(
          e,
          t
        )
      ), this.legend.data.setAll(
        this.legendData ? this.legendData : this.pieSeries.dataItems
      );
    }
  }
}, Eh = {};
var yM = /* @__PURE__ */ X(
  bM,
  _M,
  mM,
  !1,
  vM,
  null,
  null,
  null
);
function vM(i) {
  for (let e in Eh)
    this[e] = Eh[e];
}
const XN = /* @__PURE__ */ function() {
  return yM.exports;
}();
var xM = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    key: "legenddiv",
    ref: "legenddiv",
    style: i.styleProps,
    attrs: {
      id: "legenddiv"
    }
  });
}, wM = [];
const SM = {
  components: {},
  props: {
    legendSet: Object,
    legendLabelSet: Object,
    legendMarkerSet: Object,
    legendMarkerRectangleSet: Object,
    logTest: {
      type: Boolean,
      default: !1
    },
    legendMarkerRectanglesStrokeDashArrayAdapter: Function,
    chartSet: Object,
    setCustom: Function,
    setCustomLegend: Function,
    styleProps: {
      type: String,
      default: "width: 500px; height: 100px;"
    },
    data: {
      type: Array,
      default: () => []
    }
  },
  data() {
    return {
      root: "",
      legend: "",
      chartSetData: {
        refProps: "legendContainer",
        id: "legendContainer",
        key: "legendContainer",
        root: {
          container: {
            layout: "verticalLayout"
            // verticalLayout || horizontalLayout || gridLayout
          }
        }
      }
    };
  },
  mounted() {
    Mo("AM5C392708372"), this.createChart();
  },
  watch: {
    data: {
      handler(i) {
        console.log("watch legend: ", i), this.createChart();
      },
      deep: !0
    }
  },
  computed: {
    legendSetComputed() {
      let i = { layout: this.root.gridLayout };
      return Object.assign({}, _c, this.legendSet, i);
    },
    legendLabelSetComputed() {
      return Object.assign({}, mc, this.legendLabelSet);
    },
    legendMarkerSetComputed() {
      return Object.assign({}, bc, this.legendMarkerSet);
    },
    legendMarkerRectangleSetComputed() {
      return Object.assign(
        {},
        yc,
        this.legendMarkerRectangleSet
      );
    },
    chartSetComputed() {
      let i = at(this.chartSetData, this.chartSet);
      return Object.assign({}, i);
    }
  },
  methods: {
    createChart() {
      this.logTest && console.log("createChart"), this.$nextTick(() => {
        if (this.$refs.legenddiv) {
          this.root || (this.root = Or.new(this.$refs.legenddiv));
          const i = Bs.new(this.root);
          this.root.setThemes([gc.new(this.root), i]), this.setLegend(), this.root.numberFormatter.setAll({
            numberFormat: "#.#",
            numericFields: ["valueY"]
          }), this.setCustom && this.setCustom(ar, this);
        }
      });
    },
    setLegend() {
      this.logTest && console.log("setLegend"), this.legend ? this.legend.setAll({ ...this.legendSetComputed }) : this.legend = this.root.container.children.push(
        js.new(this.root, { ...this.legendSetComputed })
      ), this.legend.labels.template.setAll({ ...this.legendLabelSetComputed }), this.legend.markers.template.setAll({ ...this.legendMarkerSetComputed }), this.legend.markerRectangles.template.setAll({
        ...this.legendMarkerRectangleSetComputed
      }), this.legend.valueLabels.template.set("forceHidden", !0), this.legendMarkerRectanglesStrokeDashArrayAdapter && this.legend.markerRectangles.template.adapters.add(
        "strokeDasharray",
        (i, e) => this.legendMarkerRectanglesStrokeDashArrayAdapter(
          i,
          e
        )
      ), this.setCustomLegend && this.setCustomLegend(ar, this), this.legend.data.setAll(this.data);
    }
  },
  beforeDestroy() {
    this.logTest && console.log("xy-chart beforeDestroy"), this.root && (this.logTest && console.log("root dispose"), this.root.dispose());
  }
}, Rh = {};
var DM = /* @__PURE__ */ X(
  SM,
  xM,
  wM,
  !1,
  CM,
  null,
  null,
  null
);
function CM(i) {
  for (let e in Rh)
    this[e] = Rh[e];
}
const WN = /* @__PURE__ */ function() {
  return DM.exports;
}(), TM = "_container_18krm_7", kM = "_inputs_18krm_35", Wn = {
  container: TM,
  "input-wrapper": "_input-wrapper_18krm_14",
  "-focus": "_-focus_18krm_27",
  "-disabled": "_-disabled_18krm_31",
  inputs: kM,
  "-error": "_-error_18krm_39",
  "error-message": "_error-message_18krm_73"
}, PM = {
  props: {
    /* declares custom style props for component */
    styleProps: [String, Object],
    /* declares error message to show */
    errorMessage: {
      type: String,
      default: "Enter a valid IP Address (ex. 0.0.0.0)"
    },
    /* declares id for input element */
    id: {
      type: String,
      default: "input-id"
    },
    /* declares disable as true or false */
    disabled: {
      type: Boolean,
      default: !1
    },
    /* declares initial value */
    initialValue: String,
    /**
     * declares function that sets a result
     * and includes a description of its parameters
     * and return type
     */
    setResult: Function
  },
  data() {
    return {
      octets: [{ value: "" }, { value: "" }, { value: "" }, { value: "" }],
      isFocused: !1,
      ipAddress: "",
      error: !1
    };
  },
  /**
   * Watch the octets for changes and update ipAddress and
   * perform validation, then run setIpAddress function to update
   * the parent component with the new IP address.
   */
  watch: {
    octets: {
      handler(i) {
        this.ipAddress = i.map((e) => e.value).join("."), this.validateIpAddress(), this.setIpAddress();
      },
      deep: !0,
      immediate: !0
    }
  },
  methods: {
    /* validate ip address */
    validateIpAddress() {
      const i = /^(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;
      this.ipAddress.length < 4 || (this.error = this.octets.some((e) => !i.test(e.value)));
    },
    /**
     * ensures that the length of the input octets
     * in the IP address field does not exceed 3
     */
    inputHandler(i) {
      for (let e = i; e < this.octets.length; e++) {
        const t = this.octets[e];
        if (t.value && t.value.toString().length >= 3)
          t.value = t.value.toString().substring(0, 3), this.$refs[`octet-${i + 2}`] && this.$refs[`octet-${i + 2}`][0].focus();
        else
          return;
      }
    },
    /* set ip address */
    setIpAddress() {
      var i;
      (i = this.setResult) == null || i.call(this, this.id, this.ipAddress, this.error);
    }
  },
  computed: {
    /**
     * Compute property to return input wrapper class
     * based on focus, disable, and error states.
     */
    inputWrapperClass() {
      return `${Wn["input-wrapper"]} ${this.isFocused ? Wn["-focus"] : ""} ${this.disabled ? Wn["-disabled"] : ""} ${this.error ? Wn["-error"] : ""}`;
    }
  },
  /* sets the octets of the IP address to the initial value provided */
  mounted() {
    this.initialValue && (this.octets = this.initialValue.split(".").map((i) => ({
      value: i
    })));
  }
};
var OM = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    class: i.$style.container,
    attrs: {
      id: i.id
    }
  }, [t("div", {
    class: i.inputWrapperClass,
    style: i.styleProps
  }, i._l(i.octets, function(s, r) {
    return t("div", {
      class: i.$style.inputs
    }, [t("input", {
      directives: [{
        name: "model",
        rawName: "v-model.number",
        value: s.value,
        expression: "octet.value",
        modifiers: {
          number: !0
        }
      }],
      key: r,
      ref: `octet-${r + 1}`,
      refInFor: !0,
      style: s.value.length === 0 ? "border-bottom: 1px solid #c9c9c9" : "",
      attrs: {
        autocomplete: "off",
        type: "number",
        id: `octet-${r + 1}`,
        disabled: i.disabled
      },
      domProps: {
        value: s.value
      },
      on: {
        input: [function(n) {
          n.target.composing || i.$set(s, "value", i._n(n.target.value));
        }, function(n) {
          return i.inputHandler(r);
        }],
        focusin: function(n) {
          i.isFocused = !0;
        },
        focusout: function(n) {
          i.isFocused = !1;
        },
        blur: function(n) {
          return i.$forceUpdate();
        }
      }
    }), r < 3 ? t("span", [i._v(".")]) : i._e()]);
  }), 0), i.error ? t("p", {
    class: i.$style["error-message"]
  }, [i._v(" " + i._s(i.errorMessage) + " ")]) : i._e()]);
}, MM = [];
const AM = "_container_18krm_7", LM = "_inputs_18krm_35", jM = {
  container: AM,
  "input-wrapper": "_input-wrapper_18krm_14",
  "-focus": "_-focus_18krm_27",
  "-disabled": "_-disabled_18krm_31",
  inputs: LM,
  "-error": "_-error_18krm_39",
  "error-message": "_error-message_18krm_73"
}, au = {};
au.$style = jM;
var IM = /* @__PURE__ */ X(
  PM,
  OM,
  MM,
  !1,
  EM,
  "b393c6fa",
  null,
  null
);
function EM(i) {
  for (let e in au)
    this[e] = au[e];
}
const UN = /* @__PURE__ */ function() {
  return IM.exports;
}(), RM = "_container_tgidv_1", $M = "_caret_color_tgidv_1", NM = "_container_input_tgidv_4", FM = "_base_input__icon_tgidv_40", YM = "_base_input__icon_img_tgidv_48", BM = "_checkmark_disabled_tgidv_57", HM = "_checkmark_green_tgidv_62", zM = "_base_input_tgidv_40", VM = "_base_input_error_tgidv_88", XM = "_validity_tgidv_94", WM = "_outside_checkmark_green_tgidv_97", UM = "_outside_checkmark_disabled_tgidv_102", GM = "_error_tgidv_107", ZM = "_disable_tgidv_114", KM = "_right_tgidv_119", qM = "_left_tgidv_122", QM = "_error_message_tgidv_125", Un = {
  container: RM,
  caret_color: $M,
  container_input: NM,
  base_input__icon: FM,
  base_input__icon_img: YM,
  checkmark_disabled: BM,
  checkmark_green: HM,
  base_input: zM,
  base_input_error: VM,
  validity: XM,
  outside_checkmark_green: WM,
  outside_checkmark_disabled: UM,
  error: GM,
  disable: ZM,
  right: KM,
  left: qM,
  error_message: QM
}, JM = {
  name: "InputNumber",
  props: {
    /**
     * The id of the input.
     */
    id: String,
    /**
     * The style properties for the input.
     */
    styleProps: {
      type: [String, Object],
      default: ""
    },
    /**
     * The placeholder text for the input.
     */
    placeholderText: {
      type: String,
      default: "Enter number"
    },
    /**
     * The position of the checkmark (inside or outside).
     */
    checkmark: {
      type: String,
      default: "outside"
    },
    /**
     * Whether the input is active or not.
     */
    active: Boolean,
    /**
     * Whether the input is disabled or not.
     */
    disabled: Boolean,
    /**
     * Whether there is an error on the input or not.
     */
    error: Boolean,
    /**
     * The URL and position of the icon for the input.
     */
    iconUrl: {
      type: Object,
      default: null
    },
    /**
     * The minimum value for the input.
     */
    min: Number,
    /**
     * The maximum value for the input.
     */
    max: Number,
    /**
     * The step value for the input.
     */
    step: Number,
    /**
     * The change handler function for the input.
     */
    changeHandler: Function,
    /**
     * The error message for the input.
     */
    errorMessage: String,
    /**
     * Whether the input is required or not.
     */
    required: Boolean,
    /**
     * Whether the input is read-only or not.
     */
    readonly: Boolean
  },
  data() {
    return {
      /**
       * The text value of the input.
       */
      text: "",
      /**
       * Whether the input data is valid or not.
       */
      isDataValid: !1,
      /**
       * Whether a key is pressed in the input or not.
       */
      isKeyPressed: !1
    };
  },
  watch: {
    text() {
      this.changeHandler && this.changeHandler({ value: this.text, id: this.id }), this.validateText();
    }
  },
  methods: {
    /**
     * Event handler for the key pressed event in the input.
     */
    keyPressedEvent() {
      this.isKeyPressed || (this.isKeyPressed = !0);
    },
    /**
     * Validates the input text and sets the data validity.
     */
    validateText() {
      const i = parseInt(this.text);
      this.isDataValid = (this.min === void 0 || i >= this.min) && (this.max === void 0 || i <= this.max);
    }
  },
  computed: {
    /**
     * Computes the position class for the container based on various conditions.
     */
    positionComputed() {
      const i = [];
      return this.iconUrl && i.push(Un[this.iconUrl.position]), this.disabled && i.push(Un.disable), this.error && i.push(Un.error), i.join(" ");
    },
    /**
     * Computes the class for the text box element based on whether there is an error or not.
     */
    textBoxClassComputed() {
      const i = [];
      return this.error && i.push(Un.base_input_error), i.join(" ");
    }
  }
};
var eA = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    class: i.$style.container
  }, [t("div", [t("div", {
    class: [i.$style.container_input, i.positionComputed]
  }, [i.iconUrl ? t("span", {
    class: [i.$style.base_input__icon]
  }, [t("span", {
    class: i.$style.base_input_icon_img
  }, [t("img", {
    attrs: {
      src: i.iconUrl.url,
      alt: "input number"
    }
  })])]) : i._e(), t("input", {
    directives: [{
      name: "model",
      rawName: "v-model.trim",
      value: i.text,
      expression: "text",
      modifiers: {
        trim: !0
      }
    }],
    class: [i.textBoxClassComputed, i.$style.base_input, i.isKeyPressed ? i.$style.caret_color : ""],
    style: i.styleProps,
    attrs: {
      id: i.id,
      placeholder: i.placeholderText,
      type: "number",
      active: i.active,
      disabled: i.disabled,
      error: i.error,
      min: i.min,
      max: i.max,
      step: i.step,
      required: i.required,
      readonly: i.readonly,
      "error-message": i.errorMessage
    },
    domProps: {
      value: i.text
    },
    on: {
      keyup: function(s) {
        return i.keyPressedEvent();
      },
      input: function(s) {
        s.target.composing || (i.text = s.target.value.trim());
      },
      blur: function(s) {
        return i.$forceUpdate();
      }
    }
  }), i.checkmark === "inside" ? t("span", {
    class: [i.isDataValid ? i.$style.checkmark_green : i.$style.checkmark_disabled, i.$style.validity]
  }) : i._e()]), i.checkmark === "outside" ? t("span", {
    class: [i.isDataValid ? i.$style.outside_checkmark_green : i.$style.outside_checkmark_disabled, i.$style.validity]
  }) : i._e()]), i.error ? t("div", [t("span", {
    class: i.$style.error_message
  }, [i._v(i._s(i.errorMessage))])]) : i._e()]);
}, tA = [];
const iA = "_container_tgidv_1", sA = "_caret_color_tgidv_1", rA = "_container_input_tgidv_4", nA = "_base_input__icon_tgidv_40", aA = "_base_input__icon_img_tgidv_48", oA = "_checkmark_disabled_tgidv_57", lA = "_checkmark_green_tgidv_62", uA = "_base_input_tgidv_40", cA = "_base_input_error_tgidv_88", hA = "_validity_tgidv_94", dA = "_outside_checkmark_green_tgidv_97", fA = "_outside_checkmark_disabled_tgidv_102", pA = "_error_tgidv_107", gA = "_disable_tgidv_114", _A = "_right_tgidv_119", mA = "_left_tgidv_122", bA = "_error_message_tgidv_125", yA = {
  container: iA,
  caret_color: sA,
  container_input: rA,
  base_input__icon: nA,
  base_input__icon_img: aA,
  checkmark_disabled: oA,
  checkmark_green: lA,
  base_input: uA,
  base_input_error: cA,
  validity: hA,
  outside_checkmark_green: dA,
  outside_checkmark_disabled: fA,
  error: pA,
  disable: gA,
  right: _A,
  left: mA,
  error_message: bA
}, ou = {};
ou.$style = yA;
var vA = /* @__PURE__ */ X(
  JM,
  eA,
  tA,
  !1,
  xA,
  "6777dd27",
  null,
  null
);
function xA(i) {
  for (let e in ou)
    this[e] = ou[e];
}
const GN = /* @__PURE__ */ function() {
  return vA.exports;
}(), wA = "_container_1yqik_1", SA = "_container_input_1yqik_1", DA = "_base_input__icon_1yqik_37", CA = "_base_input_icon_img_1yqik_45", TA = "_base_input__icon_error_left_1yqik_54", kA = "_base_input__icon_error_right_1yqik_57", PA = "_validity_1yqik_60", OA = "_inside_1yqik_63", MA = "_inside1_1yqik_68", AA = "_base_input_1yqik_37", LA = "_caret_color_1yqik_87", jA = "_base_input_error_1yqik_96", IA = "_outside1_1yqik_105", EA = "_outside_1yqik_105", RA = "_error_1yqik_115", $A = "_disable_1yqik_122", NA = "_right_1yqik_127", FA = "_left_1yqik_130", YA = "_error_message_1yqik_133", _s = {
  container: wA,
  container_input: SA,
  base_input__icon: DA,
  base_input_icon_img: CA,
  base_input__icon_error_left: TA,
  base_input__icon_error_right: kA,
  validity: PA,
  inside: OA,
  inside1: MA,
  base_input: AA,
  caret_color: LA,
  base_input_error: jA,
  outside1: IA,
  outside: EA,
  error: RA,
  disable: $A,
  right: NA,
  left: FA,
  error_message: YA
}, BA = {
  props: {
    /* declares id to assign elements */
    id: String,
    /* declares custom styles props */
    styleProps: {
      type: [String, Object],
      default: ""
    },
    /* declares placeholder text for input field */
    placeholderText: {
      type: String,
      default: "Enter Text Here"
    },
    /* declares checkmark to display check */
    checkmark: String,
    /* declares active as true or false */
    active: Boolean,
    /* declares disabled as true or false */
    disabled: Boolean,
    /* declares error as false */
    error: {
      type: Boolean,
      default: !1
    },
    /* declares required as true or false */
    required: Boolean,
    /* declares icon url as object of url and position */
    iconUrl: {
      type: Object
    },
    /* declares min characters, default as 1 */
    minlength: {
      type: Number,
      default: 1
    },
    /* declares max characters */
    maxlength: Number,
    /* declares error message to show */
    errorMessage: String,
    /* declares readonly as true or false */
    readonly: Boolean
  },
  data() {
    return {
      validData: !1,
      text: "",
      keyPressed: !1
    };
  },
  methods: {
    /**
     * validates if the provided value is valid or not,
     * based on minlength and maxlength props
     */
    isValid(i) {
      const e = i.length;
      return !(e < this.minlength || this.maxlength && e > this.maxlength);
    },
    /* updates the component's state when a key is pressed */
    onKeyPressed() {
      this.keyPressed || (this.keyPressed = !0), this.validData = this.isValid(this.text);
    }
  },
  computed: {
    /* compute the position based on icon url position */
    positionComputed() {
      var t;
      let i = "";
      const e = (t = this.iconUrl) == null ? void 0 : t.position;
      return e && (i += `${_s[e]} `), this.error && (i += `${_s.error} `), this.disabled && (i += `${_s.disable} `), i;
    },
    /**
     * generates the class name for the input text box
     * based on whether an error has occurred or not
     */
    textBoxClassComputed() {
      let i = `${_s.base_input} `;
      return this.error && (i += `${_s.base_input_error} `), i;
    },
    /**
     * Returns the CSS class for the input icon border
     * based on the error status and position of the icon.
     */
    iconBorderComputed() {
      var e;
      return !this.error || !((e = this.iconUrl) != null && e.position) ? "" : this.iconUrl.position === "left" ? `${_s.base_input__icon_error_left} ` : `${_s.base_input__icon_error_right} `;
    }
  }
};
var HA = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    class: i.$style.container
  }, [t("div", {
    staticStyle: {
      display: "flex"
    }
  }, [t("div", {
    class: [i.$style.container_input, i.$style.search_bar__input, i.positionComputed],
    style: i.styleProps,
    attrs: {
      tabindex: "0"
    }
  }, [i.iconUrl ? t("span", {
    class: [i.iconBorderComputed, i.$style.base_input__icon]
  }, [t("span", {
    class: i.$style.base_input_icon_img
  }, [t("img", {
    attrs: {
      src: i.iconUrl.url
    }
  })])]) : i._e(), t("input", {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: i.text,
      expression: "text"
    }],
    class: [i.textBoxClassComputed, i.$style.base_input, i.keyPressed ? i.$style.caret_color : ""],
    attrs: {
      id: i.id,
      placeholder: i.placeholderText,
      type: "text",
      active: i.active,
      disabled: i.disabled,
      error: i.error,
      minlength: i.minlength,
      maxlength: i.maxlength,
      checkmark: i.checkmark,
      readonly: i.readonly,
      required: i.required
    },
    domProps: {
      value: i.text
    },
    on: {
      keyup: function(s) {
        return i.onKeyPressed();
      },
      input: function(s) {
        s.target.composing || (i.text = s.target.value);
      }
    }
  }), i.checkmark === "inside" ? t("span", {
    class: [i.validData ? i.$style.inside1 : i.$style.inside, i.$style.validity]
  }) : i._e()]), i.checkmark == "outside" ? t("span", {
    class: [i.validData ? i.$style.outside1 : i.$style.outside, i.$style.validity]
  }) : i._e()]), i.error ? t("div", [t("span", {
    class: i.$style.error_message
  }, [i._v(i._s(i.errorMessage))])]) : i._e()]);
}, zA = [];
const VA = "_container_1yqik_1", XA = "_container_input_1yqik_1", WA = "_base_input__icon_1yqik_37", UA = "_base_input_icon_img_1yqik_45", GA = "_base_input__icon_error_left_1yqik_54", ZA = "_base_input__icon_error_right_1yqik_57", KA = "_validity_1yqik_60", qA = "_inside_1yqik_63", QA = "_inside1_1yqik_68", JA = "_base_input_1yqik_37", eL = "_caret_color_1yqik_87", tL = "_base_input_error_1yqik_96", iL = "_outside1_1yqik_105", sL = "_outside_1yqik_105", rL = "_error_1yqik_115", nL = "_disable_1yqik_122", aL = "_right_1yqik_127", oL = "_left_1yqik_130", lL = "_error_message_1yqik_133", uL = {
  container: VA,
  container_input: XA,
  base_input__icon: WA,
  base_input_icon_img: UA,
  base_input__icon_error_left: GA,
  base_input__icon_error_right: ZA,
  validity: KA,
  inside: qA,
  inside1: QA,
  base_input: JA,
  caret_color: eL,
  base_input_error: tL,
  outside1: iL,
  outside: sL,
  error: rL,
  disable: nL,
  right: aL,
  left: oL,
  error_message: lL
}, lu = {};
lu.$style = uL;
var cL = /* @__PURE__ */ X(
  BA,
  HA,
  zA,
  !1,
  hL,
  "47d3f7b6",
  null,
  null
);
function hL(i) {
  for (let e in lu)
    this[e] = lu[e];
}
const ZN = /* @__PURE__ */ function() {
  return cL.exports;
}(), dL = {
  name: "table-input",
  props: {
    id: {
      type: String,
      default: "table-input"
    },
    styleProps: {
      type: [String, Object]
    },
    textPosition: {
      type: String,
      default: "left"
    },
    value: {
      type: [String, Number]
    },
    numberFormatting: {
      type: Boolean,
      default: !1
    },
    changeHandler: {
      type: Function
    }
  },
  data() {
    return {
      newValue: "",
      isChanged: !1
    };
  },
  methods: {
    removeCommas(i) {
      return Number(i.replace(/,/g, ""));
    },
    handleInput(i) {
      const e = i.target, t = e.value.replace(/[^0-9]/g, "");
      this.numberFormatting ? this.newValue = Number(t).toLocaleString() : this.newValue = e.value;
    }
  },
  watch: {
    value: {
      handler(i) {
        this.newValue = this.numberFormatting ? Number(i).toLocaleString() : i;
      },
      immediate: !0,
      deep: !0
    },
    newValue: {
      handler(i, e) {
        var t;
        e && (this.isChanged = !0), (t = this.changeHandler) == null || t.call(
          this,
          this.numberFormatting ? this.removeCommas(i) : i,
          this.id,
          this.isChanged
        );
      },
      immediate: !0,
      deep: !0
    }
  }
};
var fL = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    class: i.$style.table_input_main,
    style: i.styleProps,
    attrs: {
      id: i.id
    }
  }, [t("input", {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: i.newValue,
      expression: "newValue"
    }],
    style: {
      textAlign: i.textPosition
    },
    domProps: {
      value: i.newValue
    },
    on: {
      input: [function(s) {
        s.target.composing || (i.newValue = s.target.value);
      }, i.handleInput]
    }
  })]);
}, pL = [];
const gL = "_table_input_main_1cgke_7", _L = {
  table_input_main: gL
}, uu = {};
uu.$style = _L;
var mL = /* @__PURE__ */ X(
  dL,
  fL,
  pL,
  !1,
  bL,
  null,
  null,
  null
);
function bL(i) {
  for (let e in uu)
    this[e] = uu[e];
}
const KN = /* @__PURE__ */ function() {
  return mL.exports;
}(), yL = {
  props: {
    /* declares id to assign element */
    id: String,
    /* declares custom style prop for component */
    styleProps: {
      type: [String, Object],
      default: ""
    },
    /* set placeholder text to render */
    placeholderText: {
      type: String,
      default: "Memo"
    },
    /* declares active as true or false */
    active: Boolean,
    /* declares disabled as true or false */
    disabled: Boolean,
    /* declares error as true of false */
    error: Boolean,
    /* set error message */
    errorMessage: {
      type: String,
      default: "Error Message Here"
    },
    /* declares minimum characters length */
    minlength: Number,
    /* declares maximum characters length  */
    maxlength: Number,
    /* declares cols for hight */
    cols: Number,
    /* declares readonly as true or false */
    readonly: Boolean,
    /* set change handler */
    changeHandler: Function,
    /* declares required as true or false */
    required: Boolean
  },
  data() {
    return {
      text: "",
      inputHeight: "0",
      keypressed: !1
    };
  },
  watch: {
    /* watch for changes in text input and emit input event with the new value */
    text() {
      this.changeHandler && this.changeHandler({ value: this.value, id: this.id }), this.resize(), this.$emit("input", this.text);
    }
  },
  computed: {
    /* compute class name based on the error value for the text area box. */
    textBoxClassComputed() {
      return this.error == !0 ? `${this.$style.textarea_box_error}` : `${this.$style.textarea_box}`;
    }
  },
  methods: {
    keyPressed() {
      this.keypressed || (this.keypressed = !0);
    },
    resize() {
      this.inputHeight = `${this.$refs.input.scrollHeight}px`;
    }
  },
  mounted() {
    this.resize();
  }
};
var vL = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", [t("div", {
    class: i.$style.container
  }, [t("div", {
    class: i.$style.textarea_box_container
  }, [t("textarea", {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: i.text,
      expression: "text"
    }],
    ref: "input",
    class: [i.textBoxClassComputed, i.keypressed ? i.$style.caret_color : ""],
    style: i.styleProps,
    attrs: {
      id: i.id,
      placeholder: i.placeholderText,
      type: "text",
      active: i.active,
      disabled: i.disabled,
      minlength: i.minlength,
      maxlength: i.maxlength,
      readonly: i.readonly,
      cols: i.cols,
      error: i.error,
      required: i.required,
      "error-message": i.errorMessage
    },
    domProps: {
      value: i.text
    },
    on: {
      keyup: function(s) {
        return i.keyPressed();
      },
      input: function(s) {
        s.target.composing || (i.text = s.target.value);
      }
    }
  })]), i.error ? t("div", {
    class: i.$style.error_message
  }, [t("span", [i._v(i._s(i.errorMessage))])]) : i._e()])]);
}, xL = [];
const wL = "_container_iwgo8_1", SL = "_caret_color_iwgo8_1", DL = "_textarea_box_container_iwgo8_4", CL = "_textarea_box_iwgo8_4", TL = "_textarea_box_error_iwgo8_63", kL = "_error_message_iwgo8_80", PL = {
  container: wL,
  caret_color: SL,
  textarea_box_container: DL,
  textarea_box: CL,
  textarea_box_error: TL,
  error_message: kL
}, cu = {};
cu.$style = PL;
var OL = /* @__PURE__ */ X(
  yL,
  vL,
  xL,
  !1,
  ML,
  "53416bd2",
  null,
  null
);
function ML(i) {
  for (let e in cu)
    this[e] = cu[e];
}
const qN = /* @__PURE__ */ function() {
  return OL.exports;
}(), AL = "_selected_item_11ukj_17", LL = "_drag_icon_11ukj_34", jL = "_available_list_item_11ukj_38", IL = "_assigned_list_item_11ukj_38", EL = "_minus_item_11ukj_64", RL = "_plus_item_icon_11ukj_82", $L = "_minus_item_icon_11ukj_86", NL = "_primary_active_switch_11ukj_1", FL = {
  selected_item: AL,
  drag_icon: LL,
  "list-item": "_list-item_11ukj_38",
  available_list_item: jL,
  assigned_list_item: IL,
  minus_item: EL,
  plus_item_icon: RL,
  minus_item_icon: $L,
  primary_active_switch: NL
}, YL = "assigned_list_item", BL = "available_list_item", HL = {
  name: "listGroup",
  props: {
    /** set the list items */
    list: {
      type: Array
    },
    setResult: Function,
    /** set the style properties of the list {e.g {width : 200px}} */
    styleProps: {
      type: String
    },
    /** to show and hide each item's id */
    itemId: {
      type: Boolean,
      default: !1
    },
    /** to add and remove an option of list items */
    isSelected: {
      type: Boolean,
      default: !1
    }
  },
  computed: {
    /**
     * calculate style for a selected list
     */
    selectedStyle() {
      return this.isSelected ? YL : BL;
    },
    /**
     * returns the style for list-group either availableList or assigned list
     */
    listGroupClassComputed() {
      return `${FL[this.selectedStyle]}`;
    }
  },
  methods: {
    /**
     * Updates the availability of an item and invokes the setResult callback.
     * @param item - The item to be updated.
     */
    availableItem(i) {
      i.enable = !0, this.$nextTick(() => {
        this.setResult && this.setResult(i);
      });
    },
    /**
     * Performs operations on the selected item in the list.
     * @param  index - The index of the selected item.
     */
    selectedItem(i) {
      var t, s;
      const e = (t = this.list) == null ? void 0 : t[i];
      e && (this.$nextTick(() => {
        this.setResult && this.setResult(e);
      }), (s = this.list) == null || s.splice(i, 1));
    }
  }
};
var zL = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    style: i.styleProps
  }, i._l(i.list, function(s, r) {
    return t("div", {
      key: r,
      class: i.$style.selected_item
    }, [i.itemId ? t("div", {
      class: i.listGroupClassComputed,
      attrs: {
        disabled: s.enable
      }
    }, [i._v(" " + i._s(s.id) + " ")]) : i._e(), t("div", {
      class: i.listGroupClassComputed,
      attrs: {
        disabled: s.enable
      }
    }, [i._v(" " + i._s(s.name) + " ")]), i.isSelected ? t("div", {
      class: i.$style.minus_item,
      on: {
        click: function(n) {
          return i.selectedItem(r);
        }
      }
    }, [t("img", {
      class: i.$style.minus_item_icon,
      attrs: {
        src: "#",
        alt: "icon"
      }
    })]) : t("div", {
      class: i.$style.minus_item,
      attrs: {
        disabled: s.enable
      },
      on: {
        click: function(n) {
          return i.availableItem(s);
        }
      }
    }, [t("img", {
      class: i.$style.plus_item_icon,
      attrs: {
        src: "#",
        alt: "icon"
      }
    })])]);
  }), 0);
}, VL = [];
const XL = "_selected_item_11ukj_17", WL = "_drag_icon_11ukj_34", UL = "_available_list_item_11ukj_38", GL = "_assigned_list_item_11ukj_38", ZL = "_minus_item_11ukj_64", KL = "_plus_item_icon_11ukj_82", qL = "_minus_item_icon_11ukj_86", QL = "_primary_active_switch_11ukj_1", JL = {
  selected_item: XL,
  drag_icon: WL,
  "list-item": "_list-item_11ukj_38",
  available_list_item: UL,
  assigned_list_item: GL,
  minus_item: ZL,
  plus_item_icon: KL,
  minus_item_icon: qL,
  primary_active_switch: QL
}, hu = {};
hu.$style = JL;
var ej = /* @__PURE__ */ X(
  HL,
  zL,
  VL,
  !1,
  tj,
  null,
  null,
  null
);
function tj(i) {
  for (let e in hu)
    this[e] = hu[e];
}
const QN = /* @__PURE__ */ function() {
  return ej.exports;
}(), ij = {
  name: "listItem",
  props: {
    /** set list to handle add/remove item records */
    list: {
      type: Array,
      required: !0
    },
    /** responsible for remove one item */
    removeListItem: {
      type: Function,
      required: !0
    },
    /** responsible for add item */
    addListItem: {
      type: Function,
      required: !0
    }
  }
}, sj = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjUiIGhlaWdodD0iMjUiIHZpZXdCb3g9IjAgMCAyNSAyNSIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICAgIDxyZWN0IHdpZHRoPSIyNSIgaGVpZ2h0PSIyNSIgcng9IjMiIGZpbGw9IiNEOUQ5RDkiLz4KICAgIDxwYXRoIGQ9Ik0xNy41NTYgNy43MDhIMTQuOUwxNC42OTQgNy4yOTRDMTQuNjQ5OSA3LjIwNTU1IDE0LjU4MiA3LjEzMTE3IDE0LjQ5NzkgNy4wNzkyM0MxNC40MTM4IDcuMDI3MjkgMTQuMzE2OCA2Ljk5OTg1IDE0LjIxOCA3SDExLjY5QzExLjU5MTUgNi45OTk3MSAxMS40OTQ5IDcuMDI3MTMgMTEuNDExMyA3LjA3OTExQzExLjMyNzcgNy4xMzExIDExLjI2MDMgNy4yMDU1NyAxMS4yMTcgNy4yOTRMMTEuMDA4IDcuNzA4SDguMzU0QzguMjYwMTEgNy43MDggOC4xNzAwNyA3Ljc0NTMgOC4xMDM2OCA3LjgxMTY5QzguMDM3MyA3Ljg3ODA3IDggNy45NjgxMiA4IDguMDYyVjguNzdDOCA4Ljg2Mzg5IDguMDM3MyA4Ljk1MzkzIDguMTAzNjggOS4wMjAzMkM4LjE3MDA3IDkuMDg2NzEgOC4yNjAxMSA5LjEyNCA4LjM1NCA5LjEyNEgxNy41NTRDMTcuNjAwNyA5LjEyNDI3IDE3LjY0NjkgOS4xMTUzIDE3LjY5MDEgOS4wOTc2M0MxNy43MzMzIDkuMDc5OTYgMTcuNzcyNSA5LjA1MzkzIDE3LjgwNTYgOS4wMjEwM0MxNy44Mzg3IDguOTg4MTMgMTcuODY0OSA4Ljk0OTAyIDE3Ljg4MjkgOC45MDU5NEMxNy45MDA4IDguODYyODYgMTcuOTEgOC44MTY2NiAxNy45MSA4Ljc3VjguMDYyQzE3LjkxIDguMDE1NTEgMTcuOTAwOCA3Ljk2OTQ4IDE3Ljg4MzEgNy45MjY1M0MxNy44NjUzIDcuODgzNTggMTcuODM5MiA3Ljg0NDU2IDE3LjgwNjMgNy44MTE2OUMxNy43NzM0IDcuNzc4ODEgMTcuNzM0NCA3Ljc1Mjc0IDE3LjY5MTUgNy43MzQ5NUMxNy42NDg1IDcuNzE3MTYgMTcuNjAyNSA3LjcwOCAxNy41NTYgNy43MDhWNy43MDhaTTkuMTc3IDE3LjMzQzkuMTkyODEgMTcuNjAwNCA5LjMxMTM4IDE3Ljg1NDYgOS41MDg0MiAxOC4wNDA1QzkuNzA1NDcgMTguMjI2NCA5Ljk2NjExIDE4LjMzIDEwLjIzNyAxOC4zM0gxNS42NzRDMTUuOTQ0OSAxOC4zMyAxNi4yMDU1IDE4LjIyNjQgMTYuNDAyNiAxOC4wNDA1QzE2LjU5OTYgMTcuODU0NiAxNi43MTgyIDE3LjYwMDQgMTYuNzM0IDE3LjMzTDE3LjIwMyA5LjgzSDguNzA4TDkuMTc3IDE3LjMzWiIgZmlsbD0iIzU5NTk1OSIvPgo8L3N2Zz4K";
var rj = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    class: i.$style.main
  }, [i._l(i.list, function(s, r) {
    return t("div", {
      key: `detailInput-${r}`,
      class: i.$style["form-inline"]
    }, [t("input", {
      directives: [{
        name: "model",
        rawName: "v-model",
        value: s.description,
        expression: "input.description"
      }],
      class: i.$style["custom-input"],
      attrs: {
        type: "text",
        id: `item-${r}`
      },
      domProps: {
        value: s.description
      },
      on: {
        input: function(n) {
          n.target.composing || i.$set(s, "description", n.target.value);
        }
      }
    }), i.list.length > 1 ? t("span", {
      class: i.$style["remove-item"],
      on: {
        click: function(n) {
          return i.removeListItem(r, i.list);
        }
      }
    }, [t("img", {
      class: i.$style["trash-custom-icon"],
      attrs: {
        src: sj,
        alt: "closeIcon"
      }
    })]) : i._e()]);
  }), t("div", {
    class: i.$style["add-items"]
  }, [t("span", {
    class: i.$style["add-more-item"],
    on: {
      click: function(s) {
        return i.addListItem(i.list);
      }
    }
  }, [i._v(" + Add more ")])])], 2);
}, nj = [];
const aj = "_main_ts50g_1", oj = {
  main: aj,
  "form-inline": "_form-inline_ts50g_4",
  "remove-item": "_remove-item_ts50g_10",
  "trash-custom-icon": "_trash-custom-icon_ts50g_13",
  "custom-input": "_custom-input_ts50g_25",
  "add-items": "_add-items_ts50g_40",
  "add-more-item": "_add-more-item_ts50g_40"
}, du = {};
du.$style = oj;
var lj = /* @__PURE__ */ X(
  ij,
  rj,
  nj,
  !1,
  uj,
  "488eae47",
  null,
  null
);
function uj(i) {
  for (let e in du)
    this[e] = du[e];
}
const JN = /* @__PURE__ */ function() {
  return lj.exports;
}(), cj = {
  props: {
    /** set Modal container style properties like width, hight etc} */
    styleProps: [String, Object],
    /** set the type of modal component */
    modalType: {
      type: String,
      default: "popup"
    },
    /** set modal header like title */
    headingText: {
      type: String,
      default: "Header"
    },
    /** set modal sub heading */
    subHeadingText: String,
    /** set modal click handler */
    modalHandler: Function,
    /** set modal isOpened */
    isOpened: Boolean
  },
  data() {
    return {
      hide: !this.isOpened
    };
  },
  methods: {
    /** set handle modal to open and close the modal */
    handleModal() {
      var i;
      this.hide = !this.hide, (i = this.modalHandler) == null || i.call(this);
    }
  },
  /**
   * set document body height and overflow style
   * will be mounted when component is added to the DOM
   */
  mounted() {
    document.body.style.cssText = "height: 100vh; overflow: hidden;";
  },
  /**
   * remove document body styles
   * will be unmounted when component is removed from DOM
   */
  unmounted() {
    document.body.style.cssText = "";
  },
  computed: {
    /** set position of Modal */
    modalPositionComputed() {
      return this.modalType === "slide-in" ? "right" : "center";
    },
    /** compute subheadings */
    modalSubHeaderComputed() {
      return this.subHeadingText ?? "";
    },
    /** computing base modal class  */
    modalClassComputed() {
      let i = `modal-default ${this.modalSubHeaderComputed} `;
      return this.modalType === "slide-in" && (i += this.modalType), i;
    },
    /** set transition of modal */
    modalTransitionComputed() {
      return this.modalType === "slide-in" ? "slide-fade" : "fade";
    }
  }
}, hj = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTQiIGhlaWdodD0iMTQiIHZpZXdCb3g9IjAgMCAxNCAxNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICAgIDxwYXRoIGQ9Ik0xNCAxLjQxTDEyLjU5IDBMNyA1LjU5TDEuNDEgMEwwIDEuNDFMNS41OSA3TDAgMTIuNTlMMS40MSAxNEw3IDguNDFMMTIuNTkgMTRMMTQgMTIuNTlMOC40MSA3TDE0IDEuNDFaIiBmaWxsPSIjNEI0QjRCIi8+CiAgICA8L3N2Zz4KICAgIA==";
var dj = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("transition", {
    attrs: {
      name: "bg"
    }
  }, [i.isOpened ? t("div", {
    staticClass: "emdn-modal-wrapper"
  }, [t("div", {
    staticClass: "modal-background",
    class: i.modalPositionComputed,
    on: {
      click: i.handleModal
    }
  }, [t("transition", {
    attrs: {
      name: i.modalTransitionComputed
    }
  }, [i.isOpened ? t("div", {
    class: i.modalClassComputed,
    style: i.styleProps,
    on: {
      click: function(s) {
        s.stopPropagation();
      }
    }
  }, [t("section", [t("div", {
    staticClass: "modal-header-line"
  }), t("div", {
    staticClass: "modal-header-contents"
  }, [t("div", {
    staticClass: "modal-header-contents-left"
  }, [t("h1", [i._v(i._s(i.headingText))]), i._t("switch-tab")], 2), t("button", {
    attrs: {
      type: "button"
    },
    on: {
      click: i.handleModal
    }
  }, [t("img", {
    attrs: {
      src: hj
    }
  })])]), i.subHeadingText ? t("div", {
    staticClass: "modal-sub-header"
  }, [t("h2", [i._v(i._s(i.subHeadingText))])]) : i._e()]), t("section", {
    staticClass: "modal-body-area"
  }, [t("div", [i._t("body")], 2)]), t("section", {
    staticClass: "modal-footer-area"
  }, [i._t("footer")], 2)]) : i._e()])], 1)]) : i._e()]);
}, fj = [];
const $h = {};
var pj = /* @__PURE__ */ X(
  cj,
  dj,
  fj,
  !1,
  gj,
  "c2e49d7e",
  null,
  null
);
function gj(i) {
  for (let e in $h)
    this[e] = $h[e];
}
const eF = /* @__PURE__ */ function() {
  return pj.exports;
}(), _j = {
  name: "onBoarding",
  props: {
    /** set styles of component */
    styleProps: [String, Object],
    /** Set heading text */
    head: String,
    /** set body data message */
    body: String,
    /** set range to more than one onboarding */
    range: {
      type: Number,
      default: 1
    },
    /** step is starting and range defines how many times display component */
    step: {
      type: Number,
      default: 1
    },
    /** set multi steps  */
    multipleSteps: Boolean,
    /** set click handler */
    clickHandler: Function,
    /** set close handler to close component */
    handleClose: Function,
    /** set active to show and hide component */
    active: Boolean
  },
  components: {
    /** CTA button used inside onboarding component */
    CtaButton: Fs
  },
  methods: {
    /**
     * apply handler method that trigger callback function clickHandler
     * if step is equal to the range then trigger callback function close
     */
    applyHandlerMethod() {
      this.$nextTick(() => {
        var i;
        (i = this.clickHandler) == null || i.call(this);
      }), this.step == this.range && this.close();
    },
    /** close that will trigger callback closeHandler */
    close() {
      var i;
      (i = this.handleClose) == null || i.call(this);
    }
  }
};
var mj = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return i.active ? t("div", {
    class: i.$style.tooltipMain
  }, [t("div", {
    class: i.$style.tooltip
  }, [i.multipleSteps ? t("span", {
    class: [i.step <= 1 ? i.$style.stepOne : "", i.step == 2 ? i.$style.stepTwo : "", i.step == 3 ? i.$style.stepThree : "", i.step == 4 ? i.$style.stepFour : "", i.step > 4 ? i.$style.stepOne : ""],
    style: i.styleProps
  }, [t("div", {
    class: i.$style.main
  }, [t("div", {
    class: i.$style.customTitle
  }, [t("div", {
    class: i.$style.head
  }, [i._v(i._s(i.head))]), t("div", {
    class: i.$style.crossImage,
    on: {
      click: i.close
    }
  }, [t("img", {
    class: i.$style.crossIcon,
    attrs: {
      src: "#",
      alt: "icon"
    }
  })])]), t("div", {
    class: i.$style.body
  }, [i._t("body")], 2), i.range >= 2 && i.range >= i.step && i.step >= 1 ? t("div", {
    class: i.$style.footer
  }, [t("div", {
    class: i.$style.step
  }, [i._v("Step " + i._s(i.step) + " of " + i._s(i.range))]), t("div", {
    class: i.$style.button
  }, [t("CtaButton", {
    staticClass: "btn-custom btn-custom-primary animationPrimary",
    attrs: {
      "style-props": "background: #ffffff",
      variant: "text",
      "color-type": "blue",
      "click-handler": i.applyHandlerMethod
    }
  }, [i.step != i.range ? t("span", [i._v("Next")]) : t("span", [i._v("Done")])])], 1)]) : i._e()])]) : i._e(), i.multipleSteps == !1 ? t("span", {
    class: i.$style.stepOne,
    style: i.styleProps
  }, [t("div", {
    class: i.$style.main
  }, [t("div", {
    class: i.$style.customTitle
  }, [t("div", {
    class: i.$style.head
  }, [i._v(i._s(i.head))]), t("div", {
    class: i.$style.crossImage,
    on: {
      click: i.close
    }
  }, [t("img", {
    class: i.$style.crossIcon,
    attrs: {
      src: "#",
      alt: "icon"
    }
  })])]), t("div", {
    class: i.$style.body
  }, [i._t("body")], 2)])]) : i._e()])]) : i._e();
}, bj = [];
const yj = "_tooltipMain_sis1v_1", vj = "_tooltip_sis1v_1", xj = "_main_sis1v_18", wj = "_footer_sis1v_21", Sj = "_customTitle_sis1v_24", Dj = "_head_sis1v_27", Cj = "_crossImage_sis1v_34", Tj = "_crossIcon_sis1v_39", kj = "_body_sis1v_42", Pj = "_step_sis1v_50", Oj = "_button_sis1v_56", Mj = "_stepOne_sis1v_61", Aj = "_stepTwo_sis1v_62", Lj = "_stepThree_sis1v_63", jj = "_stepFour_sis1v_64", Ij = {
  tooltipMain: yj,
  tooltip: vj,
  main: xj,
  footer: wj,
  customTitle: Sj,
  head: Dj,
  crossImage: Cj,
  crossIcon: Tj,
  body: kj,
  step: Pj,
  button: Oj,
  stepOne: Mj,
  stepTwo: Aj,
  stepThree: Lj,
  stepFour: jj
}, fu = {};
fu.$style = Ij;
var Ej = /* @__PURE__ */ X(
  _j,
  mj,
  bj,
  !1,
  Rj,
  "27c21b37",
  null,
  null
);
function Rj(i) {
  for (let e in fu)
    this[e] = fu[e];
}
const tF = /* @__PURE__ */ function() {
  return Ej.exports;
}(), $j = {
  name: "imageViewer",
  props: {
    src: {
      type: String,
      default: ""
    },
    styleData: {
      type: String,
      default: ""
    },
    preview: Boolean
  }
}, Nj = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTQ2IiBoZWlnaHQ9IjExMiIgdmlld0JveD0iMCAwIDE0NiAxMTIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSIxNDYiIGhlaWdodD0iMTEyIiByeD0iMTAiIGZpbGw9IiNDNEM0QzQiLz4KPHBhdGggZD0iTTEzNiA5SDlWNzUuNUw0Mi4zNzk4IDM1LjM1OTdDNDUuNTY4MiAzMS41MjU1IDUxLjQ0OTIgMzEuNTExIDU0LjY1NjYgMzUuMzI5Mkw5MC41IDc4TDEwNy41OTcgNjAuMTQzMkMxMTAuNjAxIDU3LjAwNTEgMTE1LjU2MSA1Ni44Mzg1IDExOC43NyA1OS43Njc5TDEzNiA3NS41VjlaIiBmaWxsPSIjRjBGMUYzIi8+CjxjaXJjbGUgY3g9IjExMCIgY3k9IjMxIiByPSIxMyIgZmlsbD0iI0M0QzRDNCIvPgo8L3N2Zz4K";
var Fj = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    style: i.styleData
  }, [t("div", {
    class: i.preview ? i.$style.main_image : i.$style.slider_image,
    style: {
      "background-image": `url(${i.src})`
    },
    attrs: {
      tabindex: "0"
    }
  }, [i.src ? i._e() : t("span", {
    class: i.$style.placeholder
  }, [t("div", {
    class: i.$style.imagesSpacing
  }, [t("img", {
    attrs: {
      src: Nj,
      alt: ""
    }
  })])])])]);
}, Yj = [];
const Bj = "_main_image_d1u1d_1", Hj = "_slider_image_d1u1d_9", zj = "_placeholder_d1u1d_24", Vj = "_imagesSpacing_d1u1d_35", Xj = {
  main_image: Bj,
  slider_image: Hj,
  placeholder: zj,
  imagesSpacing: Vj
}, pu = {};
pu.$style = Xj;
var Wj = /* @__PURE__ */ X(
  $j,
  Fj,
  Yj,
  !1,
  Uj,
  null,
  null,
  null
);
function Uj(i) {
  for (let e in pu)
    this[e] = pu[e];
}
const Yp = /* @__PURE__ */ function() {
  return Wj.exports;
}(), Gj = "slide_next", Zj = "slide_prev", Kj = {
  name: "slider",
  components: {
    ImageViewer: Yp
  },
  props: {
    slides: Array,
    SelectedImage: Function,
    preview: Boolean,
    numberOfSlides: Number
  },
  data() {
    return {
      current: 0,
      direction: 1,
      transitionName: "fade",
      show: !1,
      chunkSize: this.numberOfSlides,
      data: this.slides
    };
  },
  methods: {
    slide(i) {
      this.direction = i, i === 1 ? this.transitionName = Gj : this.transitionName = Zj;
      const e = this.data.length;
      this.current = (this.current + i % e + e) % e;
    },
    handleChunk() {
      let i = [];
      for (let e = 0; e < this.data.length; e += this.chunkSize) {
        const t = this.data.slice(e, e + this.chunkSize);
        i = [...i, t];
      }
      this.data = i;
    }
  },
  watch: {
    slides(i) {
      let e = [];
      for (let t = 0; t < i.length; t += this.chunkSize) {
        const s = i.slice(t, t + this.chunkSize);
        e = [...e, s];
      }
      this.data = e;
    }
  },
  beforeMount() {
    this.handleChunk();
  },
  mounted() {
    this.show = !0;
  }
};
var qj = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", [t("div", {
    attrs: {
      id: i.$style.slider
    }
  }, [t("transition-group", {
    class: i.$style.slides_group,
    attrs: {
      tag: "div",
      name: i.transitionName,
      "enter-class": i.$style[`${i.transitionName}_enter`],
      "enter-active-class": i.$style[`${i.transitionName}_enter_active`],
      "leave-active-class": i.$style[`${i.transitionName}_leave_active`],
      "leave-to-class": i.$style[`${i.transitionName}_leave_to`]
    }
  }, [i.show ? t("div", {
    key: i.current,
    class: i.$style.slide
  }, i._l(i.data[i.current], function(s, r) {
    return t("div", {
      key: r,
      class: i.$style.slider_body,
      attrs: {
        id: "slide1"
      }
    }, [t("div", {
      on: {
        click: function() {
          return i.SelectedImage(s);
        }
      }
    }, [t("ImageViewer", {
      class: i.$style.slider_content,
      attrs: {
        preview: i.preview,
        src: s
      }
    })], 1)]);
  }), 0) : i._e()]), t("div", {
    class: [i.$style.btn, i.$style.btn_prev],
    attrs: {
      "aria-label": "Previous slide"
    },
    on: {
      click: function(s) {
        return i.slide(-1);
      }
    }
  }, [t("div", {
    class: i.$style.button_left
  })]), t("div", {
    class: [i.$style.btn, i.$style.btn_next],
    attrs: {
      "aria-label": "Next slide"
    },
    on: {
      click: function(s) {
        return i.slide(1);
      }
    }
  }, [t("div", {
    class: i.$style.button_right
  })])], 1)]);
}, Qj = [];
const Jj = "_slider_k3kgu_52", eI = "_slides_group_k3kgu_10", tI = "_fade_enter_active_k3kgu_17", iI = "_fade_enter_k3kgu_17", sI = "_slide_next_enter_active_k3kgu_23", rI = "_slide_next_leave_active_k3kgu_24", nI = "_slide_next_enter_k3kgu_23", aI = "_slide_next_leave_to_k3kgu_30", oI = "_slide_prev_enter_active_k3kgu_33", lI = "_slide_prev_leave_active_k3kgu_34", uI = "_slide_prev_enter_k3kgu_33", cI = "_slide_prev_leave_to_k3kgu_40", hI = "_slide_k3kgu_10", dI = "_slider_body_k3kgu_52", fI = "_slider_content_k3kgu_60", pI = "_btn_k3kgu_70", gI = "_btn_next_k3kgu_86", _I = "_button_right_k3kgu_90", mI = "_button_left_k3kgu_95", bI = {
  slider: Jj,
  slides_group: eI,
  fade_enter_active: tI,
  fade_enter: iI,
  slide_next_enter_active: sI,
  slide_next_leave_active: rI,
  slide_next_enter: nI,
  slide_next_leave_to: aI,
  slide_prev_enter_active: oI,
  slide_prev_leave_active: lI,
  slide_prev_enter: uI,
  slide_prev_leave_to: cI,
  slide: hI,
  slider_body: dI,
  slider_content: fI,
  btn: pI,
  btn_next: gI,
  button_right: _I,
  button_left: mI
}, gu = {};
gu.$style = bI;
var yI = /* @__PURE__ */ X(
  Kj,
  qj,
  Qj,
  !1,
  vI,
  null,
  null,
  null
);
function vI(i) {
  for (let e in gu)
    this[e] = gu[e];
}
const xI = /* @__PURE__ */ function() {
  return yI.exports;
}(), wI = {
  name: "main",
  components: {
    ImageViewer: Yp,
    Slider: xI
  },
  props: {
    /**
     * set the image components src
     */
    src: {
      type: String,
      default: ""
    },
    /**
     * contain the list of slides
     */
    allSlides: {
      type: Array
    },
    /**
     * to show and hide an image viewing component
     */
    showImageViewer: {
      type: Boolean
    },
    /**
     * to show and hide a slider component
     */
    showSlider: {
      type: Boolean
    },
    /**
     * to set the number of slides in a slider component
     */
    numberOfSlides: {
      type: Number,
      default: 4
    },
    /**
     * to set styles in image viewing component {e.g {width: 100px; height 100px}}
     */
    styleProps: {
      styleProps: [String, Object],
      default: "width: 331px; height: 230px"
    }
  },
  computed: {},
  data() {
    return {
      selectedImage: ""
    };
  },
  methods: {
    handleImage(i) {
      this.selectedImage = i;
    }
  }
};
var SI = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", [i.showImageViewer ? t("ImageViewer", {
    attrs: {
      preview: !0,
      styleData: i.styleProps,
      src: i.src ? i.src : i.selectedImage
    }
  }) : i._e(), i.showSlider ? t("Slider", {
    style: {
      width: i.showImageViewer ? "" : "331px"
    },
    attrs: {
      numberOfSlides: i.numberOfSlides,
      preview: !1,
      slides: i.allSlides,
      "selected-image": i.handleImage
    }
  }) : i._e()], 1);
}, DI = [];
const Nh = {};
var CI = /* @__PURE__ */ X(
  wI,
  SI,
  DI,
  !1,
  TI,
  null,
  null,
  null
);
function TI(i) {
  for (let e in Nh)
    this[e] = Nh[e];
}
const iF = /* @__PURE__ */ function() {
  return CI.exports;
}(), kI = {
  name: "SnackBar",
  props: {
    /** set snackbar title */
    snackBarTitle: {
      type: String,
      default: "Success!"
    },
    /** set a snackbar body message */
    snackBarMessage: {
      type: String,
      default: "Your data has been saved successfully."
    }
  },
  data() {
    return {
      active: !1
    };
  },
  mounted() {
    this.active = !0, setTimeout(() => {
      this.active = !1;
    }, 6e3);
  },
  watch: {
    /** on active change, it will trigger to onClose() */
    active(i) {
      i && window.addEventListener("click", this.onClose);
    }
  },
  methods: {
    /** hide the snackbar */
    onClose() {
      this.active = !1;
    }
  }
}, PI = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI4IiBoZWlnaHQ9IjgiIHZpZXdCb3g9IjAgMCA4IDgiPgogIDxwYXRoIGlkPSJQYXRoXzE5NTUiIGRhdGEtbmFtZT0iUGF0aCAxOTU1IiBkPSJNNC43MDgsNCw3Ljg1My44NTVBLjUuNSwwLDAsMCw3LjE0Ni4xNDhMNCwzLjI5My44NTQuMTQ4QS41LjUsMCwwLDAsLjE0Ny44NTVMMy4yOTMsNCwuMTQ3LDcuMTQ3YS41LjUsMCwxLDAsLjcwNy43MDdMNCw0LjcwOCw3LjE0Niw3Ljg1NGEuNS41LDAsMSwwLC43MDctLjcwN1oiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAgLTAuMDAxKSIvPgo8L3N2Zz4K";
var OI = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return i.active ? t("div", {
    class: i.$style.dialogbox
  }, [t("div", {
    class: i.$style.heading
  }, [i._v(i._s(i.snackBarTitle))]), t("p", [i._v(i._s(i.snackBarMessage))]), t("div", {
    class: i.$style.close,
    on: {
      click: i.onClose
    }
  }, [t("img", {
    staticClass: "cross_icon",
    attrs: {
      src: PI,
      alt: "cross icon"
    }
  })])]) : i._e();
}, MI = [];
const AI = "_dialogbox_2rlt0_1", LI = "_fadein_2rlt0_1", jI = "_fadeout_2rlt0_1", II = "_close_2rlt0_35", EI = "_heading_2rlt0_40", RI = "_cross_icon_2rlt0_57", $I = {
  dialogbox: AI,
  fadein: LI,
  fadeout: jI,
  close: II,
  heading: EI,
  cross_icon: RI
}, _u = {};
_u.$style = $I;
var NI = /* @__PURE__ */ X(
  kI,
  OI,
  MI,
  !1,
  FI,
  "684aa832",
  null,
  null
);
function FI(i) {
  for (let e in _u)
    this[e] = _u[e];
}
const sF = /* @__PURE__ */ function() {
  return NI.exports;
}(), YI = "_center_align_ikhq4_4", BI = "_red_ikhq4_16", HI = "_blue_ikhq4_19", zI = "_purple_ikhq4_22", VI = "_gray_ikhq4_25", XI = "_light_gray_ikhq4_28", WI = "_dark_gray_ikhq4_31", UI = "_purple_gray_ikhq4_34", GI = "_yellow_ikhq4_37", ZI = "_black_ikhq4_40", KI = "_green_ikhq4_43", qI = "_orange_ikhq4_46", QI = "_brown_ikhq4_49", JI = "_light_orange_ikhq4_52", eE = "_black_bordered_gray_ikhq4_55", tE = "_red_bordered_gray_ikhq4_59", iE = "_black_bordered_white_ikhq4_63", sE = "_red_dashed_white_ikhq4_67", rE = "_label_styles_ikhq4_70", Fh = {
  center_align: YI,
  default: "_default_ikhq4_8",
  red: BI,
  blue: HI,
  purple: zI,
  gray: VI,
  light_gray: XI,
  dark_gray: WI,
  purple_gray: UI,
  yellow: GI,
  black: ZI,
  green: KI,
  orange: qI,
  brown: QI,
  light_orange: JI,
  black_bordered_gray: eE,
  red_bordered_gray: tE,
  black_bordered_white: iE,
  red_dashed_white: sE,
  label_styles: rE
}, nE = {
  OVERDUE: "red",
  HIGH_RISK: "red",
  DOWNTIME: "red",
  CHANGED: "red",
  SENSOR_OFFLINE: "red",
  UPCOMING: "yellow",
  IN_PROGRESS: "yellow",
  MEDIUM_RISK: "yellow",
  IDLE: "yellow",
  CONFIRMED: "green",
  LOW_RISK: "green",
  COMPLETED: "green",
  IN_PRODUCTION: "green",
  CANCELLED: "dark_gray",
  INACTIVE: "purple_gray",
  DECLINED: "gray",
  NO_SENSOR: "black_bordered_white",
  REQUESTED: "purple",
  REGISTERED: "purple",
  PENDING_APPROVAL: "blue",
  UNCONFIRMED: "orange",
  ON_STANDBY: "black_bordered_gray",
  SENSOR_DETACHED: "red_dashed_white",
  DISPOSED: "black",
  DISABLED: "dark_gray",
  IN_USE: "green",
  NOT_IN_USE: "light_orange",
  FAILURE: "light_gray",
  DISCARDED: "black",
  HIGH: "red",
  MEDIUM: "yellow",
  LOW: "green",
  PROLONGED: "brown"
}, aE = {
  name: "table-status",
  props: {
    /**
     * Category type (i.e. OVERDUE, ON_STANDBY etc...)
     */
    category: {
      type: String,
      required: !0
    }
  },
  computed: {
    /**
     *  color style computed according to category
     */
    colorComputed() {
      return `${Fh.default} ${Fh[nE[this.category]]} `;
    },
    /**
     *  converting label from camel case to Snake case
     */
    labelText() {
      return this.snakeToTitle(this.category);
    }
  },
  methods: {
    /**
     * converting snake case to title case
     */
    snakeToTitle(i) {
      return i ? i.split("_").map((t) => {
        const s = t.toLowerCase();
        return s.charAt(0).toUpperCase() + s.slice(1);
      }).join(" ") : "";
    }
  }
};
var oE = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return i.category ? t("div", {
    class: i.$style.center_align
  }, [t("div", {
    class: i.colorComputed
  }), t("span", {
    class: i.$style.label_styles
  }, [i._v(" " + i._s(i.labelText) + " ")])]) : i._e();
}, lE = [];
const uE = "_center_align_ikhq4_4", cE = "_red_ikhq4_16", hE = "_blue_ikhq4_19", dE = "_purple_ikhq4_22", fE = "_gray_ikhq4_25", pE = "_light_gray_ikhq4_28", gE = "_dark_gray_ikhq4_31", _E = "_purple_gray_ikhq4_34", mE = "_yellow_ikhq4_37", bE = "_black_ikhq4_40", yE = "_green_ikhq4_43", vE = "_orange_ikhq4_46", xE = "_brown_ikhq4_49", wE = "_light_orange_ikhq4_52", SE = "_black_bordered_gray_ikhq4_55", DE = "_red_bordered_gray_ikhq4_59", CE = "_black_bordered_white_ikhq4_63", TE = "_red_dashed_white_ikhq4_67", kE = "_label_styles_ikhq4_70", PE = {
  center_align: uE,
  default: "_default_ikhq4_8",
  red: cE,
  blue: hE,
  purple: dE,
  gray: fE,
  light_gray: pE,
  dark_gray: gE,
  purple_gray: _E,
  yellow: mE,
  black: bE,
  green: yE,
  orange: vE,
  brown: xE,
  light_orange: wE,
  black_bordered_gray: SE,
  red_bordered_gray: DE,
  black_bordered_white: CE,
  red_dashed_white: TE,
  label_styles: kE
}, mu = {};
mu.$style = PE;
var OE = /* @__PURE__ */ X(
  aE,
  oE,
  lE,
  !1,
  ME,
  null,
  null,
  null
);
function ME(i) {
  for (let e in mu)
    this[e] = mu[e];
}
const rF = /* @__PURE__ */ function() {
  return OE.exports;
}(), AE = {
  inactive: "#FF8489",
  pending: "#CCACFF",
  disapproved: "#D6DADE",
  active: "#D2F8E2",
  approved: "#D2F8E2"
}, LE = {
  name: "table-status-chip",
  props: {
    /**
     * set table status chip tooltip container style properties {ex {width: 100rem;}}
     */
    tooltipStyleProps: {
      type: [String, Object],
      default: "width : 18.75rem"
    },
    /**
     * set tooltip text
     */
    tooltipText: {
      type: String
    },
    /**
     * set the table status chip color and change text
     */
    statusType: {
      type: String,
      default: "Active"
    }
  },
  /**
   * import the tooltip to show on hover
   */
  components: {
    Tooltip: ec
  },
  /** to change the color of table status chip */
  computed: {
    /**
     * Retrieves the background color based on the current status type.
     * @returns The background color associated with the current status.
     */
    backgroundColor() {
      let i = this.statusType.toLocaleLowerCase();
      return AE[i];
    }
  }
};
var jE = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", [t("Tooltip", {
    attrs: {
      position: "bottom",
      "style-props": i.tooltipStyleProps
    },
    scopedSlots: i._u([{
      key: "context",
      fn: function() {
        return [t("div", {
          class: i.$style["chips-container"],
          style: {
            background: i.backgroundColor
          }
        }, [t("span", [i._v(i._s(i.statusType))])])];
      },
      proxy: !0
    }, {
      key: "body",
      fn: function() {
        return [i._v(" " + i._s(i.tooltipText) + " ")];
      },
      proxy: !0
    }])
  })], 1);
}, IE = [];
const EE = {
  "chips-container": "_chips-container_1emh2_1"
}, bu = {};
bu.$style = EE;
var RE = /* @__PURE__ */ X(
  LE,
  jE,
  IE,
  !1,
  $E,
  null,
  null,
  null
);
function $E(i) {
  for (let e in bu)
    this[e] = bu[e];
}
const nF = /* @__PURE__ */ function() {
  return RE.exports;
}(), NE = {
  name: "listSearchBar",
  props: {
    /**
     * search handler function
     */
    searchHandler: Function,
    /**
     * title name {title/name/...}
     */
    titleName: {
      type: String,
      default: "title"
    },
    /**
     * list of items
     */
    items: Array,
    /**
     * Click handler (click on tab)
     */
    clickHandler: Function,
    /**
     * style props
     */
    styleProps: {
      type: [String, Object]
    },
    /**
     * search bar placeholder
     */
    placeholder: String,
    id: String
  },
  /**
   * components imported
   */
  components: {
    SearchBar: Do,
    ToolTip: ec
  },
  data() {
    return {};
  },
  methods: {
    /**
     * search bar handler
     * @param value
     */
    search(i) {
      var e;
      (e = this.searchHandler) == null || e.call(this, i);
    },
    /**
     * truncate text method accepts a string and length. return a string
     * @param text
     * @param length
     * @return string
     */
    truncateText(i, e) {
      return i.length <= e ? i : i.substring(0, e) + "...";
    },
    /**
     * Click on option. If there is a click handler,
     * the click handler is executed, and if there is no click handler, it will  just select tab.
     * @param item
     */
    optionClick(i) {
      var e;
      (e = this.items) == null || e.forEach((t) => {
        t.active = !1;
      }), this.$nextTick(() => {
        var t;
        i.active = !0, (t = this.clickHandler) == null || t.call(this, i);
      });
    }
  }
};
var FE = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    class: i.$style.list_wrap,
    style: i.styleProps
  }, [t("search-bar", {
    attrs: {
      "placeholder-text": i.placeholder || "Search",
      "set-search-complete-keyword": i.search,
      "style-props": "width:100%; margin-bottom: 16px;"
    }
  }), t("div", {
    class: i.$style.list_item_wrapper
  }, i._l(i.items, function(s, r) {
    return t("div", {
      key: r,
      class: i.$style.list_item_style
    }, [t("div", {
      class: i.$style.list_item,
      attrs: {
        active: s.active
      },
      on: {
        click: function(n) {
          return i.optionClick(s);
        }
      }
    }, [(s.isLow ? s.title.length > 12 : s.title.length > 20) ? t("tool-tip", {
      attrs: {
        position: "bottom",
        "style-props": "width: fit-content; max-width:160px; "
      },
      scopedSlots: i._u([{
        key: "context",
        fn: function() {
          return [t("div", {
            class: i.$style.list_item_title
          }, [i._v(" " + i._s(s.isLow ? i.truncateText(s.title, 12) : i.truncateText(s.title, 20)) + " ")])];
        },
        proxy: !0
      }, {
        key: "body",
        fn: function() {
          return [t("span", [i._v(i._s(s.title))])];
        },
        proxy: !0
      }], null, !0)
    }) : t("div", {
      class: i.$style.list_item_title
    }, [i._v(" " + i._s(s.title) + " ")]), s.isLow ? t("div", {
      class: i.$style.low_flag
    }, [t("span", [i._v("Low Comp.")])]) : i._e()], 1)]);
  }), 0)], 1);
}, YE = [];
const BE = "_list_wrap_qxoy1_1", HE = "_list_item_wrapper_qxoy1_9", zE = "_list_item_style_qxoy1_17", VE = "_list_item_qxoy1_9", XE = "_list_item_title_qxoy1_30", WE = "_low_flag_qxoy1_50", UE = {
  list_wrap: BE,
  list_item_wrapper: HE,
  list_item_style: zE,
  list_item: VE,
  list_item_title: XE,
  low_flag: WE
}, yu = {};
yu.$style = UE;
var GE = /* @__PURE__ */ X(
  NE,
  FE,
  YE,
  !1,
  ZE,
  "797b3672",
  null,
  null
);
function ZE(i) {
  for (let e in yu)
    this[e] = yu[e];
}
const aF = /* @__PURE__ */ function() {
  return GE.exports;
}(), KE = {
  /**
   * alias for icon-button
   */
  components: {
    IconButton: Ep
  },
  props: {
    styleProps: [String, Object],
    /**
     * Current Page
     */
    currentPage: {
      type: Number,
      default: 1
    },
    /**
     * Total Pages
     */
    totalPage: {
      type: Number,
      default: 1
    },
    /**
     * Disable complete pagination component
     */
    disabled: {
      type: Boolean,
      default: !1
    },
    /**
     * Handler for changing page to Previous Page will return object  currentPage: number; totalPage: number
     */
    previousClickHandler: Function,
    /**
     * Handler for changing page to Next Page will return object  currentPage: number; totalPage: number
     */
    nextClickHandler: Function
  },
  data() {
    return {
      disableNext: !1,
      disablePrevious: !1
    };
  },
  computed: {
    /**
     * disable Next button if there is no next page available
     */
    computeNextDisabled() {
      return this.currentPage == this.totalPage || this.disabled;
    },
    /**
     * disable previous button if there is no previous page available
     */
    computePreviousDisabled() {
      return this.currentPage == 1 || this.disabled;
    }
  },
  methods: {
    /**
     * Handler for changing page to Next Page
     * create object  currentPage: number; totalPage: number and send in argument of call back function
     */
    nextHandler() {
      var i;
      this.currentPage >= this.totalPage || (i = this.nextClickHandler) == null || i.call(this, {
        currentPage: this.currentPage + 1,
        totalPage: this.totalPage
      });
    },
    /**
     * Handler for changing page to Previous Page
     * create object currentPage: number; totalPage: number and send in argument of call back function
     */
    previousHandler() {
      var i;
      this.currentPage <= 1 || (i = this.previousClickHandler) == null || i.call(this, {
        currentPage: this.currentPage - 1,
        totalPage: this.totalPage
      });
    }
  }
};
var qE = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    class: i.$style.pagination_container,
    style: i.styleProps
  }, [t("span", {
    class: i.$style.pagination_label
  }, [i._v(i._s(i.currentPage) + " of " + i._s(i.totalPage))]), t("icon-button", {
    attrs: {
      "button-type": "previous",
      "click-handler": i.previousHandler,
      disabled: i.computePreviousDisabled
    }
  }), t("icon-button", {
    attrs: {
      "button-type": "next",
      "click-handler": i.nextHandler,
      disabled: i.computeNextDisabled
    }
  })], 1);
}, QE = [];
const JE = "_pagination_container_1hck9_7", eR = "_pagination_label_1hck9_15", tR = {
  pagination_container: JE,
  pagination_label: eR
}, vu = {};
vu.$style = tR;
var iR = /* @__PURE__ */ X(
  KE,
  qE,
  QE,
  !1,
  sR,
  "6f1eee53",
  null,
  null
);
function sR(i) {
  for (let e in vu)
    this[e] = vu[e];
}
const oF = /* @__PURE__ */ function() {
  return iR.exports;
}(), rR = {
  name: "tabButton",
  props: {
    /** list of objects to create tabs */
    tabButtons: {
      type: Array,
      default: []
    },
    /** Click handler for tab */
    clickHandler: Function,
    /** type of tab (primary-tab,secondary-tab) */
    tabType: {
      type: String,
      default: "primary-tab"
    },
    /** style  of tab (horizontal, vertical) */
    tabStyle: {
      type: String,
      default: "horizontal"
    }
  },
  methods: {
    /**
     * click handler make active to clicked tab
     * @param button
     */
    onClick(i) {
      var e;
      this.tabButtons.forEach((t) => {
        t.active = t === i;
      }), this.$forceUpdate(), (e = this.clickHandler) == null || e.call(this, i), this.$emit("tab-buttons-emit", this.tabButtons);
    }
  }
};
var nR = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    class: i.$style[i.tabStyle]
  }, i._l(i.tabButtons, function(s, r) {
    return t("button", {
      key: r,
      class: i.$style[i.tabType],
      attrs: {
        active: s.active
      },
      on: {
        click: function() {
          return i.onClick(s);
        }
      }
    }, [i._v(" " + i._s(s.title) + " ")]);
  }), 0);
}, aR = [];
const oR = "_horizontal_1h317_20", lR = "_vertical_1h317_39", uR = {
  horizontal: oR,
  "primary-tab": "_primary-tab_1h317_23",
  "secondary-tab": "_secondary-tab_1h317_29",
  vertical: lR
}, xu = {};
xu.$style = uR;
var cR = /* @__PURE__ */ X(
  rR,
  nR,
  aR,
  !1,
  hR,
  "70791194",
  null,
  null
);
function hR(i) {
  for (let e in xu)
    this[e] = xu[e];
}
const lF = /* @__PURE__ */ function() {
  return cR.exports;
}(), dR = "_chart_wrapper_f490r_7", fR = "_img_zone_f490r_26", pR = "_active_f490r_38", gR = "_hover_icon_f490r_41", _R = "_img_zone_hover_background_f490r_45", mR = "_small_f490r_51", bR = "_chart_title_f490r_62", yR = "_default_style_f490r_96", vR = {
  chart_wrapper: dR,
  "horizontal-style-icon-tab": "_horizontal-style-icon-tab_f490r_7",
  "vertical-style-icon-tab": "_vertical-style-icon-tab_f490r_7",
  img_zone: fR,
  active: pR,
  hover_icon: gR,
  img_zone_hover_background: _R,
  small: mR,
  chart_title: bR,
  default_style: yR
}, xR = {
  name: "tabIcon",
  props: {
    /** A list of tab buttons */
    tabButtons: {
      type: Array,
      default: []
    },
    /** A function to call when a tab button is clicked */
    clickHandler: Function,
    /** The tab direction (either "horizontal" or "vertical") */
    tabStyle: {
      type: String,
      default: "horizontal"
    },
    /** set the tab size {e.g small, large} */
    size: {
      type: String,
      default: "large"
    }
  },
  computed: {
    /**
     * Compute tab icon style
     */
    tabIconClassComputed() {
      return `${vR[this.computedTabStyle]}`;
    },
    /**
     * Compute tab style
     */
    computedTabStyle() {
      return `${this.tabStyle}-style-icon-tab`;
    }
  },
  data() {
    return {
      hover: !1
    };
  },
  methods: {
    /**
     * click handler make active to clicked tab
     * @param button
     */
    executor(i) {
      var e, t;
      (e = this.tabButtons) == null || e.forEach((s) => {
        s.active = s === i;
      }), (t = this.clickHandler) == null || t.call(this, i);
    }
  }
};
var wR = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", [t("div", {
    class: i.tabIconClassComputed
  }, i._l(i.tabButtons, function(s, r) {
    return t("div", {
      key: r,
      class: [i.size === "small" ? i.$style.small : "", i.$style.chart_wrapper],
      attrs: {
        active: s.active,
        id: s.title
      },
      on: {
        mouseover: function(n) {
          i.hover = !0;
        },
        mouseleave: function(n) {
          i.hover = !1;
        }
      }
    }, [t("div", {
      on: {
        click: function(n) {
          return i.executor(s);
        }
      }
    }, [t("div", {
      class: [s.active || i.hover ? i.$style.img_zone_hover_background : "", i.$style.img_zone],
      attrs: {
        active: s.active
      }
    }, [t("img", {
      class: [s.active ? i.$style.hover_icon : ""],
      attrs: {
        src: s.icon,
        alt: ""
      }
    })]), t("div", {
      class: i.$style.chart_title
    }, [t("b", [i._v(i._s(s.title))])])])]);
  }), 0)]);
}, SR = [];
const DR = "_chart_wrapper_f490r_7", CR = "_img_zone_f490r_26", TR = "_active_f490r_38", kR = "_hover_icon_f490r_41", PR = "_img_zone_hover_background_f490r_45", OR = "_small_f490r_51", MR = "_chart_title_f490r_62", AR = "_default_style_f490r_96", LR = {
  chart_wrapper: DR,
  "horizontal-style-icon-tab": "_horizontal-style-icon-tab_f490r_7",
  "vertical-style-icon-tab": "_vertical-style-icon-tab_f490r_7",
  img_zone: CR,
  active: TR,
  hover_icon: kR,
  img_zone_hover_background: PR,
  small: OR,
  chart_title: MR,
  default_style: AR
}, wu = {};
wu.$style = LR;
var jR = /* @__PURE__ */ X(
  xR,
  wR,
  SR,
  !1,
  IR,
  "08835825",
  null,
  null
);
function IR(i) {
  for (let e in wu)
    this[e] = wu[e];
}
const uF = /* @__PURE__ */ function() {
  return jR.exports;
}(), ER = "_img_zone_zej1h_28", RR = "_img_zone_hover_background_zej1h_43", $R = "_chart_title_zej1h_50", NR = "_hover_icon_zej1h_126", FR = "_default_style_zej1h_165", Yh = {
  "primary-tab": "_primary-tab_zej1h_9",
  "horizontal-style-icon-tab": "_horizontal-style-icon-tab_zej1h_9",
  "vertical-style-icon-tab": "_vertical-style-icon-tab_zej1h_9",
  img_zone: ER,
  img_zone_hover_background: RR,
  "hover-icon": "_hover-icon_zej1h_46",
  chart_title: $R,
  "secondary-tab": "_secondary-tab_zej1h_86",
  hover_icon: NR,
  default_style: FR
}, YR = {
  name: "tabModule",
  props: {
    /** array of buttons */
    tabButtons: {
      type: Array,
      default: []
    },
    /** style props */
    styleProps: {
      type: [String, Object]
    },
    /** tab click handler */
    clickHandler: Function,
    /* tab style Horizontal | vertical */
    tabStyle: {
      type: String,
      default: "horizontal"
    },
    /** tab type primary-tab | secondary-tab */
    tabType: {
      type: String,
      default: "primary-tab"
    }
  },
  computed: {
    /** computed style for button*/
    buttonClassComputed() {
      return `${Yh[this.tabType]}`;
    },
    /**  computed style for tab style*/
    computedClassTabStyle() {
      return `${Yh[this.computedTabStyle]}`;
    },
    /** icon style computed*/
    computedTabStyle() {
      return `${this.tabStyle}-style-icon-tab`;
    }
  },
  data() {
    return {
      hover: !1
    };
  },
  methods: {
    /**
     * click handler make active to clicked tab
     * @param button
     */
    executor(i) {
      var e;
      this.tabButtons.forEach((t) => {
        t.active = i === t;
      }), (e = this.clickHandler) == null || e.call(this, i);
    }
  }
};
var BR = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", [t("div", {
    class: i.computedClassTabStyle
  }, i._l(i.tabButtons, function(s, r) {
    return t("div", {
      key: r,
      class: i.buttonClassComputed,
      attrs: {
        active: s.active,
        id: s.title
      },
      on: {
        mouseover: function(n) {
          i.hover = !0;
        },
        mouseleave: function(n) {
          i.hover = !1;
        }
      }
    }, [t("div", {
      on: {
        click: function(n) {
          return i.executor(s);
        }
      }
    }, [t("div", {
      class: [s.active || i.hover ? i.$style.img_zone_hover_background : "", i.$style.img_zone],
      attrs: {
        active: s.active
      }
    }, [t("img", {
      class: [s.active ? i.$style.hover_icon : ""],
      attrs: {
        src: s.icon,
        alt: ""
      }
    })]), t("div", {
      class: i.$style.chart_title
    }, [i._v(" " + i._s(s.title) + " ")])])]);
  }), 0)]);
}, HR = [];
const zR = "_img_zone_zej1h_28", VR = "_img_zone_hover_background_zej1h_43", XR = "_chart_title_zej1h_50", WR = "_hover_icon_zej1h_126", UR = "_default_style_zej1h_165", GR = {
  "primary-tab": "_primary-tab_zej1h_9",
  "horizontal-style-icon-tab": "_horizontal-style-icon-tab_zej1h_9",
  "vertical-style-icon-tab": "_vertical-style-icon-tab_zej1h_9",
  img_zone: zR,
  img_zone_hover_background: VR,
  "hover-icon": "_hover-icon_zej1h_46",
  chart_title: XR,
  "secondary-tab": "_secondary-tab_zej1h_86",
  hover_icon: WR,
  default_style: UR
}, Su = {};
Su.$style = GR;
var ZR = /* @__PURE__ */ X(
  YR,
  BR,
  HR,
  !1,
  KR,
  "eab13392",
  null,
  null
);
function KR(i) {
  for (let e in Su)
    this[e] = Su[e];
}
const cF = /* @__PURE__ */ function() {
  return ZR.exports;
}(), qR = "_chart_wrapper_iramq_7", QR = "_img_zone_iramq_26", JR = "_active_iramq_38", e$ = "_hover_icon_iramq_41", t$ = "_img_zone_hover_background_iramq_45", i$ = "_small_iramq_51", s$ = "_chart_title_iramq_62", r$ = "_default_style_iramq_96", n$ = {
  chart_wrapper: qR,
  "horizontal-style-icon-tab": "_horizontal-style-icon-tab_iramq_7",
  "vertical-style-icon-tab": "_vertical-style-icon-tab_iramq_7",
  img_zone: QR,
  active: JR,
  hover_icon: e$,
  img_zone_hover_background: t$,
  small: i$,
  chart_title: s$,
  default_style: r$
}, a$ = {
  name: "tabNumber",
  props: {
    /** array of buttons */
    tabButtons: {
      type: Array,
      default: []
    },
    styleProps: {
      type: [String, Object]
    },
    clickHandler: Function,
    /** tab style  horizontal or vertical */
    tabStyle: {
      type: String,
      default: ""
    },
    /** 'large', 'small'  */
    size: {
      type: String,
      default: "large"
    }
  },
  computed: {
    /** Compute tab number style */
    TabNumberClassComputed() {
      return `${n$[this.computedTabStyle]}`;
    },
    /** computed tab style */
    computedTabStyle() {
      return `${this.tabStyle}-style-icon-tab`;
    }
  },
  data() {
    return {
      hover: !1
    };
  },
  methods: {
    /**
     * set clicked button as active and invoke callback function
     * @param button
     */
    executor(i) {
      var e;
      this.tabButtons.forEach((t) => {
        t.active = i === t;
      }), (e = this.clickHandler) == null || e.call(this, i);
    }
  }
};
var o$ = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", [t("div", {
    class: i.TabNumberClassComputed
  }, i._l(i.tabButtons, function(s, r) {
    return t("div", {
      key: r,
      class: [i.size === "small" ? i.$style.small : "", i.$style.chart_wrapper],
      attrs: {
        active: s.active,
        id: s.title
      },
      on: {
        mouseover: function(n) {
          i.hover = !0;
        },
        mouseleave: function(n) {
          i.hover = !1;
        }
      }
    }, [t("div", {
      on: {
        click: function(n) {
          return i.executor(s);
        }
      }
    }, [t("div", {
      class: [s.active || i.hover ? i.$style.img_zone_hover_background : "", i.$style.img_zone],
      attrs: {
        active: s.active
      }
    }, [t("img", {
      class: [s.active ? i.$style.hover_icon : ""],
      attrs: {
        src: s.icon,
        alt: ""
      }
    })]), t("div", {
      class: i.$style.chart_title
    }, [t("b", [i._v(i._s(s.itemRate) + "%")]), t("span", [i._v(i._s(s.title))])])])]);
  }), 0)]);
}, l$ = [];
const u$ = "_chart_wrapper_iramq_7", c$ = "_img_zone_iramq_26", h$ = "_active_iramq_38", d$ = "_hover_icon_iramq_41", f$ = "_img_zone_hover_background_iramq_45", p$ = "_small_iramq_51", g$ = "_chart_title_iramq_62", _$ = "_default_style_iramq_96", m$ = {
  chart_wrapper: u$,
  "horizontal-style-icon-tab": "_horizontal-style-icon-tab_iramq_7",
  "vertical-style-icon-tab": "_vertical-style-icon-tab_iramq_7",
  img_zone: c$,
  active: h$,
  hover_icon: d$,
  img_zone_hover_background: f$,
  small: p$,
  chart_title: g$,
  default_style: _$
}, Du = {};
Du.$style = m$;
var b$ = /* @__PURE__ */ X(
  a$,
  o$,
  l$,
  !1,
  y$,
  "675937e4",
  null,
  null
);
function y$(i) {
  for (let e in Du)
    this[e] = Du[e];
}
const hF = /* @__PURE__ */ function() {
  return b$.exports;
}(), v$ = {
  name: "tab-overview",
  props: {
    /**  Position of the tab (top or bottom) */
    position: {
      type: String,
      default: "top",
      validator(i) {
        return ["top", "bottom"].includes(i);
      }
    },
    /** Label Align of the tab (top or bottom) */
    labelAlign: {
      type: String,
      default: "top",
      validator(i) {
        return ["top", "bottom"].includes(i);
      }
    },
    /** is Active prop */
    isActive: Boolean,
    /** label of tab */
    label: String,
    field: String,
    trend: [String, Number, Object],
    value: [String, Number, Object],
    /** Function to format the value */
    valueFormatter: Function,
    /** Function to format the trend */
    trendFormatter: Function,
    clickHandler: Function
  },
  methods: {
    /**  Execute Click Handler */
    handleClick() {
      this.clickHandler && this.clickHandler();
    }
  },
  computed: {
    hasTrend() {
      return this.trend !== null;
    },
    isTrendPositive() {
      const i = De(this.trend) ? er(this.trend) : this.trend;
      return this.hasTrend ? Number(i) >= 0 : !1;
    },
    /** Function to format the value */
    formattedValue() {
      const i = De(this == null ? void 0 : this.value) ? er(this == null ? void 0 : this.value) : this == null ? void 0 : this.value;
      return this.valueFormatter ? this.valueFormatter(i) : "";
    },
    /** Function to format the trend */
    formattedTrend() {
      const i = De(this.trend) ? er(this.trend) : this.trend;
      return this.hasTrend && (this != null && this.trendFormatter) ? Number(i) >= 0 ? `+${this.trendFormatter(i)}` : `${this.trendFormatter(i)}` : "";
    }
  }
};
var x$ = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    class: [i.$style.tab_overview, i.$style[i.position]],
    attrs: {
      active: i.isActive
    },
    on: {
      click: i.handleClick
    }
  }, [t("div", {
    class: i.$style.tab_lead
  }, [t("div", {
    class: i.$style.lead_label
  }, [i._v(" " + i._s(i.label) + " ")]), i.hasTrend ? t("div", {
    class: [i.$style.lead_trail, i.isTrendPositive ? i.$style.positive : ""]
  }, [i._v(" " + i._s(i.formattedTrend) + " ")]) : i._e()]), t("div", {
    class: i.$style.tab_divider
  }), t("div", {
    class: i.$style.tab_content
  }, [i._v(" " + i._s(i.formattedValue) + " ")])]);
}, w$ = [];
const S$ = "_tab_overview_divzu_7", D$ = "_top_divzu_44", C$ = "_tab_lead_divzu_55", T$ = "_bottom_divzu_59", k$ = "_lead_label_divzu_80", P$ = "_lead_trail_divzu_88", O$ = "_positive_divzu_96", M$ = "_tab_divider_divzu_104", A$ = "_tab_content_divzu_108", L$ = {
  tab_overview: S$,
  top: D$,
  tab_lead: C$,
  bottom: T$,
  lead_label: k$,
  lead_trail: P$,
  positive: O$,
  tab_divider: M$,
  tab_content: A$
}, Cu = {};
Cu.$style = L$;
var j$ = /* @__PURE__ */ X(
  v$,
  x$,
  w$,
  !1,
  I$,
  "2e410dd7",
  null,
  null
);
function I$(i) {
  for (let e in Cu)
    this[e] = Cu[e];
}
const dF = /* @__PURE__ */ function() {
  return j$.exports;
}(), Bh = 24, E$ = {
  name: "time-picker",
  props: {
    /**
     * Function to handle time change
     */
    changeTime: Function,
    /**
     * ID of the time picker component
     */
    id: {
      type: String,
      default: ""
    },
    /**
     * Minimum selectable time
     */
    minTime: {
      type: String,
      default: "00"
    },
    /**
     * Maximum selectable time
     */
    maxTime: {
      type: String,
      default: "24"
    },
    /**
     * Selected time object
     */
    selectedTime: {
      type: Object,
      default: () => ({
        hour: 0,
        minute: 0,
        isAddDay: !1
      })
    },
    /**
     * Flag indicating if the time picker is disabled
     */
    disabled: Boolean,
    /**
     * Flag indicating if minute selection is enabled
     */
    enableMinute: {
      type: Boolean,
      default: !1
    },
    /**
     * Flag indicating if the time picker is used for range selection
     */
    isRange: {
      type: Boolean,
      default: !1
    }
  },
  data() {
    return {
      visible: !1,
      dayStart: ""
    };
  },
  watch: {
    visible(i) {
      i ? window.addEventListener("click", this.handleClickOutside) : window.removeEventListener("click", this.handleClickOutside);
    },
    disabled() {
      this.disabled && (this.visible = !1);
    }
  },
  computed: {
    /**
     * Get the title of the selected time
     */
    getTitle() {
      var t, s, r, n;
      const i = (s = (t = this.selectedTime) == null ? void 0 : t.hour) == null ? void 0 : s.toString().padStart(2, "0"), e = (n = (r = this.selectedTime) == null ? void 0 : r.minute) == null ? void 0 : n.toString().padStart(2, "0");
      return `${i}:${e}`;
    },
    /**
     * Get the time range object
     */
    getTimeRange() {
      return {
        min: this.extractTime(this.minTime),
        max: this.extractTime(this.maxTime)
      };
    },
    /**
     * Get the range of selectable hours
     */
    getHourRange() {
      const i = parseInt(this.getTimeRange.min.hour), e = parseInt(this.getTimeRange.max.hour), t = e - i, s = i > e ? Bh + t : t;
      return i === e ? Bh : s;
    },
    getMinuteRange() {
      return this.enableMinute && !this.isRange ? 60 : 1;
    }
  },
  methods: {
    /**
     * Extract hour and minute from a time string
     * @param time - The time string
     * @returns Object containing hour and minute
     */
    extractTime(i) {
      return {
        hour: i.slice(0, 2),
        minute: i.slice(2, 4)
      };
    },
    /**
     * Check if a day needs to be added based on the hour index and type
     * @param index - The hour index
     * @param type - The type of time (hour/minute)
     * @returns rue if a day needs to be added, false otherwise
     */
    addDay(i, e) {
      const { hour: t } = this.getTimeRange.min, s = this.getTimeTitle(i, e);
      return parseInt(s) < parseInt(t);
    },
    /**
     * Handle click outside the time picker component
     * @param event - The click event
     */
    handleClickOutside(i) {
      const e = this.$refs.timePicker;
      e != null && e.contains(i.target) || (this.visible = !1);
    },
    /**
     * Check if an hour is selected
     * @param index - The hour index
     * @returns True if the hour is selected, false otherwise
     */
    checkSelectedHour(i) {
      const { hour: e, isAddDay: t } = this.selectedTime, { min: s } = this.getTimeRange;
      return t ? i === +e + 1 - +s.hour + 24 : i === +e + 1 - +s.hour;
    },
    /**
     * Get the time title based on the index and type
     * @param index - The index of the time
     * @param type - The type of time (hour/minute)
     * @returns The formatted time title
     */
    getTimeTitle(i, e) {
      const { min: t } = this.getTimeRange;
      return e === "hour" ? ((parseInt(t.hour) + i) % 24).toString().padStart(2, "0") : (i - 1).toString().padStart(2, "0");
    },
    /**
     * Check if a minute is enabled for selection
     * @param index - The minute index
     * @returns True if the minute is enabled, false otherwise
     */
    checkEnableMinute(i) {
      const { max: e } = this.getTimeRange, { isAddDay: t, hour: s } = this.selectedTime;
      return !(t && s === parseInt(e.hour) && i > parseInt(e.minute));
    },
    /**
     * Handle the change of selected time
     * @param time - The selected time value
     * @param type - The type of time (hour/minute)
     */
    handleChangeTime(i, e) {
      if (e === "hour") {
        const { min: t } = this.getTimeRange;
        this.selectedTime.hour = i + parseInt(t.hour), this.selectedTime.isAddDay = this.selectedTime.hour >= 24, this.selectedTime.hour = (i + parseInt(t.hour)) % 24;
      } else
        this.selectedTime.minute = i;
      this.changeTime && this.changeTime(this.selectedTime, e);
    }
  },
  mounted() {
    window.addEventListener("click", this.handleClickOutside);
  },
  beforeUnmount() {
    window.removeEventListener("click", this.handleClickOutside);
  }
};
var R$ = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    class: i.$style.dropdown_container,
    attrs: {
      id: i.id
    }
  }, [t("a", {
    class: [i.$style.time_dropdown, i.$style.time_dropdown_btn, i.disabled ? i.$style.time_dropdown_disabled : ""],
    style: {
      pointerEvents: i.disabled ? "none" : "auto"
    },
    attrs: {
      href: "javascript:void(0)",
      active: i.visible
    },
    on: {
      click: function(s) {
        s.stopPropagation(), i.visible = !0;
      }
    }
  }, [t("span", {
    class: i.$style.span_height
  }, [i._v(i._s(i.getTitle))]), t("span", {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: i.selectedTime.isAddDay,
      expression: "selectedTime.isAddDay"
    }],
    class: i.$style.bonus_time
  }, [i._v(i._s("+1"))])]), t("div", {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: i.visible,
      expression: "visible"
    }],
    class: [i.visible ? i.$style.show : "", i.$style.dropdown_menu]
  }, [t("div", [t("div", {
    class: i.$style.hour_dropdown_col
  }, [t("ul", {
    class: i.$style.hour_dropdown
  }, i._l(i.getHourRange, function(s) {
    return t("li", {
      key: s,
      class: [i.checkSelectedHour(s) ? i.$style.selected_item : ""]
    }, [t("span", {
      class: i.$style.dropdown_item,
      on: {
        click: function(r) {
          return i.handleChangeTime(s - 1, "hour");
        }
      }
    }, [i._v(" " + i._s(i.getTimeTitle(s - 1, "hour")) + " "), t("span", {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: i.isRange && i.addDay(s - 1, "hour"),
        expression: "isRange && addDay(index - 1, 'hour')"
      }],
      class: i.$style.day_plus
    }, [i._v(" " + i._s("+1") + " ")])])]);
  }), 0)]), t("div", {
    class: i.$style.hour_dropdown_col
  }, [t("ul", {
    class: i.$style.hour_dropdown
  }, i._l(i.getMinuteRange, function(s) {
    return t("li", {
      key: s,
      class: [s === +i.selectedTime.minute + 1 ? i.$style.selected_item : ""]
    }, [t("span", {
      class: [i.checkEnableMinute(s - 1) ? "" : i.$style.disable_item, i.$style.dropdown_item],
      on: {
        click: function(r) {
          return i.handleChangeTime(s - 1, "minute");
        }
      }
    }, [i._v(" " + i._s(i.getTimeTitle(s, "minute")) + " ")])]);
  }), 0)])])])]);
}, $$ = [];
const N$ = "_dropdown_container_gp95v_1", F$ = "_time_dropdown_gp95v_4", Y$ = "_time_dropdown_disabled_gp95v_20", B$ = "_span_height_gp95v_23", H$ = "_bonus_time_gp95v_28", z$ = "_time_dropdown_btn_gp95v_38", V$ = "_dropdown_menu_gp95v_66", X$ = "_hour_dropdown_col_gp95v_84", W$ = "_hour_dropdown_gp95v_84", U$ = "_selected_item_gp95v_106", G$ = "_dropdown_item_gp95v_109", Z$ = "_day_plus_gp95v_119", K$ = {
  dropdown_container: N$,
  time_dropdown: F$,
  time_dropdown_disabled: Y$,
  span_height: B$,
  bonus_time: H$,
  time_dropdown_btn: z$,
  dropdown_menu: V$,
  hour_dropdown_col: X$,
  hour_dropdown: W$,
  selected_item: U$,
  dropdown_item: G$,
  day_plus: Z$
}, Tu = {};
Tu.$style = K$;
var q$ = /* @__PURE__ */ X(
  E$,
  R$,
  $$,
  !1,
  Q$,
  "6517f251",
  null,
  null
);
function Q$(i) {
  for (let e in Tu)
    this[e] = Tu[e];
}
const fF = /* @__PURE__ */ function() {
  return q$.exports;
}(), J$ = {
  name: "ToggleButton",
  props: {
    /**
     * set the toggle button value on and off {e.g true, false}
     * @deprecated Use `value` instead.
     */
    toggle: Boolean,
    value: Boolean,
    /** set the toggle button state to disable {e.g true, false} */
    disabled: Boolean,
    /** change the size of toggle button {e.g default, large}  */
    size: {
      type: String,
      default: "default"
    },
    /**
     *  return the toggle button value on click {e.g true, false}
     * @deprecated Use `onChanged` instead.
     */
    clickHandler: Function,
    onChanged: Function
  },
  data() {
    return {
      checked: this.value ?? this.toggle
    };
  },
  watch: {
    /** change button state on click */
    toggle(i) {
      this.checked = i;
    },
    value(i) {
      this.checked = i;
    }
  },
  methods: {
    /** Event trigger on click to change state of toggle button */
    toggleValue() {
      return this.onChanged ? this.onChanged(!this.value) : this.handleToggle();
    },
    /**
     * @deprecated This will be removed in the next major version.
     */
    handleToggle() {
      if (this.clickHandler && !this.disabled)
        return this.clickHandler(), this.checked = !this.checked, this.checked;
    }
  }
};
var eN = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    class: i.$style.d_flex
  }, [t("p", {
    class: [i.checked ? i.$style.btn_off : i.$style.btn_on, i.disabled && i.$style.default_off]
  }, [i._v(" Off ")]), t("div", {
    on: {
      click: i.toggleValue
    }
  }, [t("input", {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: i.checked,
      expression: "checked"
    }],
    attrs: {
      type: "checkbox",
      disabled: i.disabled
    },
    domProps: {
      checked: Array.isArray(i.checked) ? i._i(i.checked, null) > -1 : i.checked
    },
    on: {
      change: function(s) {
        var r = i.checked, n = s.target, a = !!n.checked;
        if (Array.isArray(r)) {
          var o = null, l = i._i(r, o);
          n.checked ? l < 0 && (i.checked = r.concat([o])) : l > -1 && (i.checked = r.slice(0, l).concat(r.slice(l + 1)));
        } else
          i.checked = a;
      }
    }
  }), t("label", {
    class: [i.disabled ? i.$style.disable_label : "", i.size === "default" ? i.$style.default_size_label : i.$style.large_size_label]
  }, [i._v(" Toggle ")])]), t("p", {
    class: [i.checked ? i.$style.btn_on : i.$style.btn_off, i.disabled && i.$style.default_off]
  }, [i._v(" On ")])]);
}, tN = [];
const iN = "_d_flex_lw4w6_1", sN = "_btn_off_lw4w6_46", rN = "_btn_on_lw4w6_52", nN = "_default_off_lw4w6_58", aN = "_disable_label_lw4w6_61", oN = "_default_size_label_lw4w6_69", lN = "_large_size_label_lw4w6_81", uN = {
  d_flex: iN,
  btn_off: sN,
  btn_on: rN,
  default_off: nN,
  disable_label: aN,
  default_size_label: oN,
  large_size_label: lN
}, ku = {};
ku.$style = uN;
var cN = /* @__PURE__ */ X(
  J$,
  eN,
  tN,
  !1,
  hN,
  "71371179",
  null,
  null
);
function hN(i) {
  for (let e in ku)
    this[e] = ku[e];
}
const pF = /* @__PURE__ */ function() {
  return cN.exports;
}(), dN = {
  props: {
    id: {
      type: String,
      default: "tooltip-id"
    },
    position: {
      type: String,
      default: "top"
    },
    colorType: {
      type: String,
      default: "black"
    }
  },
  data() {
    return {
      showTooltip: !1,
      tooltipPositionStyles: {}
    };
  },
  watch: {
    showTooltip() {
      this.showTooltip && this.calculateTooltipPosition();
    }
  },
  methods: {
    calculateTooltipPosition() {
      this.$nextTick(() => {
        const i = this.$refs.targetRef, e = this.$refs.tooltipRef;
        if (!i || !e)
          return;
        const t = i.getBoundingClientRect(), s = e.getBoundingClientRect();
        let r, n;
        switch (this.position) {
          case "top":
            r = t.left + t.width / 2 - s.width / 2, n = t.top - s.height - 12;
            break;
          case "bottom":
            r = t.left + t.width / 2 - s.width / 2, n = t.top + t.height + 12;
            break;
          case "left":
            r = t.left - s.width - 16, n = t.top + t.height / 2 - s.height / 2;
            break;
          case "left-top":
            r = t.left - t.width - 20, n = t.top - s.height - 12;
            break;
          case "left-bottom":
            r = t.left - t.width - 20, n = t.top + t.height + 12;
            break;
          case "right":
            r = t.left + t.width + 16, n = t.top + t.height / 2 - s.height / 2;
            break;
          case "right-top":
            r = t.left + t.width - 20, n = t.top - s.height - 12;
            break;
          case "right-bottom":
            r = t.left + t.width - 20, n = t.top + t.height + 12;
            break;
        }
        this.tooltipPositionStyles = {
          left: `${r}px`,
          top: `${n}px`
        };
      });
    }
  }
};
var fN = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", [t("div", {
    attrs: {
      id: i.id
    }
  }, [t("div", {
    ref: "targetRef",
    class: i.$style["target-container"],
    on: {
      mouseenter: function(s) {
        s.stopPropagation(), s.preventDefault(), i.showTooltip = !0;
      },
      mouseleave: function(s) {
        s.stopPropagation(), s.preventDefault(), i.showTooltip = !1;
      }
    }
  }, [i._t("target")], 2)]), i.showTooltip ? t("div", {
    ref: "tooltipRef",
    class: [i.$style["tooltip-container"], i.$style[i.position], i.$style[i.colorType]],
    style: i.tooltipPositionStyles
  }, [i._t("tooltip")], 2) : i._e()]);
}, pN = [];
const gN = "_white_c1xiz_25", _N = "_top_c1xiz_31", mN = "_bottom_c1xiz_49", bN = "_right_c1xiz_67", yN = "_left_c1xiz_121", vN = {
  "target-container": "_target-container_c1xiz_7",
  "tooltip-container": "_tooltip-container_c1xiz_12",
  white: gN,
  top: _N,
  bottom: mN,
  right: bN,
  "right-top": "_right-top_c1xiz_85",
  "right-bottom": "_right-bottom_c1xiz_103",
  left: yN,
  "left-top": "_left-top_c1xiz_139",
  "left-bottom": "_left-bottom_c1xiz_157"
}, Pu = {};
Pu.$style = vN;
var xN = /* @__PURE__ */ X(
  dN,
  fN,
  pN,
  !1,
  wN,
  null,
  null,
  null
);
function wN(i) {
  for (let e in Pu)
    this[e] = Pu[e];
}
const gF = /* @__PURE__ */ function() {
  return xN.exports;
}();
export {
  CN as Accordion,
  TN as AlertBox,
  kN as Calendar,
  WN as ChartLegend,
  EN as CheckList,
  bd as CheckboxButton,
  RN as Chips,
  PN as ContentModal,
  Fs as CtaButton,
  $N as CustomList,
  NN as DataTable,
  YN as DataTableV3,
  FN as DataTablev2,
  gw as DotSpinner,
  BN as DoubleDropdown,
  LS as Dropdown,
  hf as Icon,
  Ep as IconButton,
  UN as InputIpAddress,
  GN as InputNumber,
  ZN as InputText,
  ON as LineSpinner,
  QN as ListGroup,
  JN as ListItem,
  aF as ListSearchBar,
  MN as MasterFilter,
  eF as Modal,
  tF as Onboarding,
  VN as OverallXYChart,
  oF as Pagination,
  XN as PieChart,
  tc as Popover,
  AN as ProgressBar,
  Do as SearchBar,
  DN as SearchJS,
  iF as Slider,
  sF as Snackbar,
  lF as TabButton,
  uF as TabIcon,
  cF as TabModule,
  hF as TabNumber,
  dF as TabOverview,
  LN as TableActionbarButton,
  KN as TableInput,
  rF as TableStatus,
  nF as TableStatusChip,
  qN as Textarea,
  fF as TimePicker,
  jN as TimelineStepper,
  pF as ToggleButton,
  ec as Tooltip,
  gF as TooltipV2,
  SN as VueCompositionAPI,
  IN as Widget,
  rM as XYChart
};
