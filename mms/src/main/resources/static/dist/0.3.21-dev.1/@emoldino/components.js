const rf = {
  data: {
    description: `
    - type: object[]
    - chart에 들어갈 데이터
    - 이 데이터중 하나의 데이터의 중심이 될 항목을 category로 설정합니다.
    `
  },
  category: {
    description: `
    - type: string
    - x축의 기준이 될 데이터
    `
  },
  axisDataBinder: {
    description: `
    - type: object
    - 축의 형식을 정의합니다.

    key
     - xAxis:
       - name: x axis name
       - type: ('CategoryAxis' || )
     - yAxis:
       - name: y axis name
       - type: ('ValueAxis' || )
       - isLeft: 왼쪽에 전시할 것인지 여부
     - ySecondAxis:
       - name: second y axis name
       - type: ('ValueAxis' || )
       - isLeft: 왼쪽에 전시할 것인지 여부
    `
  },
  lineDataBinder: {
    description: `
    - type: object[]
    라인 차트를 보여줄 항목

    key
     - key: data로 넘겨준 항목의 key
     - displayName: 이 데이터가 차트에 표시될 때 나타낼 이름
     - color(optional): 이 데이터를 차트에 표시될 때 나타낼 색상
     - isYSecondAxis(optional): 이 데이터를 두 번째 y 축으로 설정할 것인지를 정의합니다.
     - tooltipHTML(optional): tooltip 을 설정합니다.
    `
  },
  bubbleDataBinder: {
    description: `
    - type: object[]
    - 버블 차트를 보여줄 항목
    - lineDataBinder와 같은 형식입니다.
    `
  },
  barDataBinder: {
    description: `
    - type: object[]
    - 막대 차트를 보여줄 항목
    - lineDataBinder와 같은 형식입니다.
    `
  },
  candlestickDataBinder: {
    description: `
    - type: object[]
    - 캔들스틱 차트를 보여줄 항목
    - lineDataBinder와 같은 형식입니다.
    `
  },
  timsScale: {
    description: `
    - type: string
    - 시간 단위
    - 사용 가능한 값: 'MINUTELY', 'HOURLY', 'DAILY', 'WEEKLY', 'MONTHLY', 'YEARLY'
    `
  },
  selectionMin: {
    description: "선택된 최소 값."
  },
  selectionMax: {
    description: "선택된 최대 값."
  },
  tooltipHTML: {
    description: "기본으로 보여줄 tooltip html"
  },
  xAxisGridStrokeOpacityAdapter: {
    description: `
     @description x축 grid의 선 투명도를 개별로 조정하는 어댑터

     @param {object} target - xAxis 개별 항목
     @returns {number} grid stroke opacity
    `
  },
  xAxisLabelTextAdapter: {
    description: `
    * @description x축 label을 개별로 조정하는 어댑터
   *
   * @param {string} text - 현재 저장되어 있는 개별 xAxis label text
   * @param {object} target - xAxis 개별 항목
   * @returns {string} xAxis label text
    ,`
  },
  xAxisTooltipLabelTextAdapter: {
    description: `
    * @description x축 끝에 나오는 tooltip 을 조정하는 어댑터
    *
    * @param {string} text - 현재 저장되어 있는 개별 xAxis tooltip text
    * @param {object} target - xAxis 개별 항목
    * @returns {string} xAxis tooltip label text
    `
  },
  seriesTooltipLabelHtmlAdapter: {
    description: `
    * @description 전체적인 시리즈의 tooltip 을 조정하는 어댑터
    *
    * @param {string} html - 현재 저장되어 있는 개별 xAxis tooltip HTML
    * @param {object} target - series 개별 항목
    * @param {object} item - chart data binder item (displayName || key || color)
    `
  },
  xScrollbarXAxisLabelTextAdapter: {
    description: `
    * @description 스크롤바의 x축 label을 개별로 조정하는 어댑터
    *
    * @param {string} text - 현재 저장되어 있는 개별 dettail scrollbar xAxis label text
    * @param {object} target - detailScrollbar xAxis 개별 항목
    `
  },
  seriesTooltipForceHiddenAdapter: {
    description: `
    * @description 시리즈의 툴팁을 숨길지 여부를 정의하는 어댑터
    *
    * @param {object} forceHidden - 현재 forceHidden 여부
    * @param {object} target - series 개별 항목
    * @param {object} item - chart data binder item (displayName || key || color)
    `
  },
  getWheelCursorPositionX: {
    description: `

    `
  },
  chartItemClickHandler: {
    description: `
    * @description chart의 항목을 클릭할 때 동작하는 함수
    *
    * @param {string} event - click event
    `
  },
  setSelectionMin: {
    description: `
    * @description 현재 선택된 가장 작은 value를 저장하는 함수
    * @param {string} selectionMin - 선택된 최소값 (카테고리)
    `
  },
  setSelectionMax: {
    description: `
    * @description 현재 선택된 가장 큰 value를 저장하는 함수
    * @param {string} selectionMax - 선택된 최대값 (카테고리)
    `
  },
  zoomHandler: {
    description: `
    /**
     * @description zoom 동작 시 동작하는 함수
     * @param {string} zoomSelectionMin - zoom을 동작시킬 때 선택된 최소 값
     * @param {string} zoomSelectionMax - zoom을 동작시킬 때 선택된 최대 값
    `
  },
  panHandler: {
    description: `
    * @description drag 동작 시 동작하는 함수
    * @param {string} param - ('next' || 'previous')
    `
  },
  styleProps: {
    description: `
    * @description  차트 컨테이너를 구성하는 style
    `
  },
  chartSet: {
    description: `
    * @description - 기본 차트 설정
    *
    * key
    *
    *  - refProps(string):
    *    > 차트의 ref 를 설정합니다
    *    > default: "defaultXYChart"
    *
    *  - id(string):
    *    > 차트의 id 를 설정합니다
    *    > default: "defaultXYChart"
    *
    *  - chartType:
    *    > 현재 차트가 상세 스크롤바 차트인지 기본 차트인지를 구분합니다.
    *    > 선택 가능한 값: ('default' || 'overall' || none)
    *    > default: 'default'
    *
    *  - titleLabel(object):
    *    - text (string):
    *      > default: "0000-00-00 ~ 0000-00-00"
    *    - fontSize (number):
    *      > title label 의 글자 크기를 설정합니다.(px)
    *      > default: 12
    *    - fontWeight (string):
    *      > title label 의 글자 두께를 설정합니다.
    *      > default: "normal"
    *    - textAlign (string):
    *      > title label의 글자 정렬을 설정합니다.
    *      > default: "center"
    *    - x (number):
    *      > x 축의 위치를 설정합니다.
    *      > default: 5
    *    - centerX (number):
    *      > x 축 중심의 위치를 설정합니다.
    *      > default: 0
    *    - paddingTop (number):
    *      > 상단 padding 을 설정합니다.
    *      > default: 0
    *    - paddingBottom (number):
    *      > 하단 padding 을 설정합니다.
    *      > default: 0
    *    - color (string):
    *      > title label의 글자 색을 설정합니다.
    *      > default: "#555"
    *
    *  - isZoomOutButton:
    *    > zoom out 버튼을 사용할 것인지 여부를 정의합니다.
    *    > default: false
    *
    *  - isYAxesPlotContainerVisible:
    *    > yAxisPlotContainer를 보여줄 것인지 여부를 정의합니다.
    *    > yAxisPlotContainer 가 뭔데요? 링크로 알려주기
    *    > default: true
    *
    *  - isBottomAxesContainerVisible:
    *    > bottomAxesContainer를 보여줄 것인지 여부를 정의합니다.
    *    > bottomAxesContainer 가 뭔데요?  링크로 알려주기
    *    > default: true
    *
    *  - chartLayout:
    *    > default: "verticalLayout"
    *
    *  - panX:
    *    > x 축을 드래그 할 수 있도록 할 것인지 여부를 정의합니다.
    *    > default: true
    *
    *  - panY:
    *    > y 축을 드래그 할 수 있도록 할 것인지 여부를 정의합니다.
    *    > default: false
    *
    *  - wheelX:
    *    > 사용 가능한 값:
    *    > default: ""
    *
    *  - wheelY:
    *    > 사용 가능한 값:
    *    > default: "zoomX"
    `
  },
  legendSet: {
    description: `
    * @description - 기본 범례 설정
    *
    * key
    *  - isVisible (boolean): (default: true)
    *  - layout ('gridLayout' || ): (default: "gridLayout")
    *  - x (number): (default: 50)
    *  - centerX (number): (default: 50)
    *  - y (number): (default: 100)
    *  - centerY (number): (default: 100)
    `
  },
  candlestickSet: {
    description: `
    * @description 기본 candlestick chart 설정
    * 
    * key
    *  - riseColor(string): (default: "#ff0000")
    *  - dropColor(string): (default: "#0000ff")
    `
  },
  lineSet: {
    description: `
    * @description 기본 line chart 설정
    *
    * key
    *  - isLineVisible(boolean): (default: false)
    *  - strokeWidth(number): (default: 2)
    *  - fillOpacity(number): (default: 0.1)
    *  - bullet(object): (default: { strokeWidth: 2, radius: 3 })
    *  - colorList(array): (default: ["#f08080", "#fa8072", "#e9967a", "#ff7f50", "#ff6347", "#f4a460", "#ffa07a"])
    `
  },
  bubbleSet: {
    description: `
    * @description 기본 bubble chart 설정
    * 
    * key
    *  - strokeWidth(number): (default: 2)
    *  - bullet(object): (default: { strokeWidth: 2, radius: 3 })
    *  - colorList(array): (default: [ "#f08080", "#fa8072", "#e9967a", "#ff7f50", "#ff6347", "#f4a460", "#ffa07a" ])
    `
  },
  barSet: {
    description: `
    * @description 기본 bar chart 설정
    * 
    * key
    *  - isStacked(boolean): (default: false)
    *  - isClustered(boolean): (default: false)
    *  - width(number): (default: 15)
    *  - strokeWidth(number): (default: 1.5)
    *  - fillOpacity(number): (default: 0.3)
    *  - cornerRadius(object): (default: { topLeft: 0, topRight: 0 })
    *  - colorList(array): (default: [ "#BCE2C7", "#4EBCD5", "#1A2281", "#4169e1", "#1e90ff", "#0000cd", "#000080" ])
    `
  },
  defaultScrollbarSet: {
    description: `
    * @description 기본 scrollbar 설정
    * 
    * key
    *  - isVisible(boolean): (default: true)
    *  - isX(boolean): (default: false)
    *  - isY(boolean): (default: false)
    *  - isStartGrip (boolean): (default: false)
    *  - isEndGrip (boolean): (default: false)
    *  - isXDown (boolean): (default: false)
    *  - thumb (object): (default: { fill: "#550000", fillOpacity: 0.05 })
    *  - gripScale (number): (default: 0.9)
    *  - startPosition (number): (default: 0.2)
    *  - endPosition (number): (default: 0.8)
    `
  },
  detailScrollSet: {
    description: `
    * @description 상세 scrollbar 설정
    * 
    * key
    *  - isVisible (boolean): (default: true)
    *  - mainValue (object):
    *    - key: "",
    *    - displayName: ""
    *  - height (number): (default: 50)
    *  - line (object): (default: { color: "#fb9f57", strokeWidth: 2, fillOpacity: 0.2 })
    *  - background (object): {
    *    - fill (string): (default: "#000000")
    *    - fillOpacity (number): (default: 0.05)
    *    - cornerRadius(object): {
    *      - topLeft(number): (default: 0)
    *      - topRight(number): (default: 10)
    *      - bottomLeft(number): (default: 10)
    *      - bottomRight(number): (default: 10)
    `
  }
}, zO = {
  storybookChartargTypes: rf
};
function nf(i, e, t, s, r) {
  return t.trim().length > 0 && i.toLowerCase().includes(t) && !s.includes(e) ? (s.push(e), r(s), !0) : !1;
}
function af(i, e, t, s, r) {
  let n = !1;
  s.length > 0 && s.indexOf(e) >= 0 && s.indexOf(e) === r - 1 && (n = !0);
  const a = new RegExp(t, "gi");
  return i.replace(
    a,
    (l, u) => String.raw`
      <span
        id="${e}-${u}"
        class="highlight ${n ? "focus" : ""}"
        tabindex="0"
      >
        ${l}
      </span>
    `
  );
}
const XO = {
  setHighlightJS: af,
  getHasKeywordJS: nf
};
var Ao = function(i, e) {
  return Ao = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, s) {
    t.__proto__ = s;
  } || function(t, s) {
    for (var r in s)
      Object.prototype.hasOwnProperty.call(s, r) && (t[r] = s[r]);
  }, Ao(i, e);
};
function of(i, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
  Ao(i, e);
  function t() {
    this.constructor = i;
  }
  i.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
}
function Th(i) {
  var e = typeof Symbol == "function" && Symbol.iterator, t = e && i[e], s = 0;
  if (t)
    return t.call(i);
  if (i && typeof i.length == "number")
    return {
      next: function() {
        return i && s >= i.length && (i = void 0), { value: i && i[s++], done: !i };
      }
    };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function lf(i) {
  var e;
  At(i, (e = Fl()) === null || e === void 0 ? void 0 : e.proxy);
}
var Lo, un = [], kh = (
  /** @class */
  function() {
    function i(e) {
      this.active = !0, this.effects = [], this.cleanups = [], this.vm = e;
    }
    return i.prototype.run = function(e) {
      if (this.active)
        try {
          return this.on(), e();
        } finally {
          this.off();
        }
      else
        ({}).NODE_ENV !== "production" && lf("cannot run an inactive effect scope.");
    }, i.prototype.on = function() {
      this.active && (un.push(this), Lo = this);
    }, i.prototype.off = function() {
      this.active && (un.pop(), Lo = un[un.length - 1]);
    }, i.prototype.stop = function() {
      this.active && (this.vm.$destroy(), this.effects.forEach(function(e) {
        return e.stop();
      }), this.cleanups.forEach(function(e) {
        return e();
      }), this.active = !1);
    }, i;
  }()
);
(function(i) {
  of(e, i);
  function e(t) {
    t === void 0 && (t = !1);
    var s = this, r = void 0;
    return ff(function() {
      r = Ah(Aa());
    }), s = i.call(this, r) || this, t || uf(s), s;
  }
  return e;
})(kh);
function uf(i, e) {
  var t;
  if (e = e || Lo, e && e.active) {
    e.effects.push(i);
    return;
  }
  var s = (t = Fl()) === null || t === void 0 ? void 0 : t.proxy;
  s && s.$on("hook:destroyed", function() {
    return i.stop();
  });
}
function hf(i) {
  if (!i.scope) {
    var e = new kh(i.proxy);
    i.scope = e, i.proxy.$on("hook:destroyed", function() {
      return e.stop();
    });
  }
  return i.scope;
}
var jo = void 0;
try {
  var Qi = require("vue");
  Qi && wu(Qi) ? jo = Qi : Qi && "default" in Qi && wu(Qi.default) && (jo = Qi.default);
} catch {
}
var us = null, Ds = null, Dn = !0, Ch = "__composition_api_installed__";
function wu(i) {
  return i && as(i) && i.name === "Vue";
}
function cf(i) {
  return us && ti(i, Ch);
}
function Aa() {
  return {}.NODE_ENV !== "production" && Bl(us, "must call Vue.use(VueCompositionAPI) before using any function."), us;
}
function Mh() {
  var i = us || jo;
  return {}.NODE_ENV !== "production" && Bl(i, "No vue dependency found."), i;
}
function df(i) {
  ({}).NODE_ENV !== "production" && us && i.__proto__ !== us.__proto__ && At("[vue-composition-api] another instance of Vue installed"), us = i, Object.defineProperty(i, Ch, {
    configurable: !0,
    writable: !0,
    value: !0
  });
}
function ff(i) {
  var e = Dn;
  Dn = !1;
  try {
    i();
  } finally {
    Dn = e;
  }
}
function Su(i) {
  if (Dn) {
    var e = Ds;
    e == null || e.scope.off(), Ds = i, Ds == null || Ds.scope.on();
  }
}
function Fl() {
  return Ds;
}
var so = /* @__PURE__ */ new WeakMap();
function Rn(i) {
  if (so.has(i))
    return so.get(i);
  var e = {
    proxy: i,
    update: i.$forceUpdate,
    type: i.$options,
    uid: i._uid,
    // $emit is defined on prototype and it expected to be bound
    emit: i.$emit.bind(i),
    parent: null,
    root: null
    // to be immediately set
  };
  hf(e);
  var t = [
    "data",
    "props",
    "attrs",
    "refs",
    "vnode",
    "slots"
  ];
  return t.forEach(function(s) {
    ft(e, s, {
      get: function() {
        return i["$".concat(s)];
      }
    });
  }), ft(e, "isMounted", {
    get: function() {
      return i._isMounted;
    }
  }), ft(e, "isUnmounted", {
    get: function() {
      return i._isDestroyed;
    }
  }), ft(e, "isDeactivated", {
    get: function() {
      return i._inactive;
    }
  }), ft(e, "emitted", {
    get: function() {
      return i._events;
    }
  }), so.set(i, e), i.$parent && (e.parent = Rn(i.$parent)), i.$root && (e.root = Rn(i.$root)), e;
}
var pf = function(i) {
  return Object.prototype.toString.call(i);
};
function Du(i) {
  return typeof i == "function" && /native code/.test(i.toString());
}
var gf = typeof Symbol < "u" && Du(Symbol) && typeof Reflect < "u" && Du(Reflect.ownKeys), ks = function(i) {
  return i;
};
function ft(i, e, t) {
  var s = t.get, r = t.set;
  Object.defineProperty(i, e, {
    enumerable: !0,
    configurable: !0,
    get: s || ks,
    set: r || ks
  });
}
function Oh(i, e, t, s) {
  Object.defineProperty(i, e, {
    value: t,
    enumerable: !!s,
    writable: !0,
    configurable: !0
  });
}
function ti(i, e) {
  return Object.hasOwnProperty.call(i, e);
}
function Bl(i, e) {
  if (!i)
    throw new Error("[vue-composition-api] ".concat(e));
}
function _f(i) {
  return typeof i == "string" || typeof i == "number" || // $flow-disable-line
  typeof i == "symbol" || typeof i == "boolean";
}
function $s(i) {
  return Array.isArray(i);
}
var mf = 4294967295;
function bf(i) {
  var e = parseFloat(String(i));
  return e >= 0 && Math.floor(e) === e && isFinite(i) && e <= mf;
}
function Nn(i) {
  return i !== null && typeof i == "object";
}
function Ei(i) {
  return pf(i) === "[object Object]";
}
function as(i) {
  return typeof i == "function";
}
function yf(i) {
  return i == null;
}
function At(i, e) {
  var t = Mh();
  !t || !t.util ? console.warn("[vue-composition-api] ".concat(i)) : t.util.warn(i, e);
}
function Ah(i, e) {
  e === void 0 && (e = {});
  var t = i.config.silent;
  i.config.silent = !0;
  var s = new i(e);
  return i.config.silent = t, s;
}
function vf(i) {
  var e = Aa();
  return e && i instanceof e;
}
function xf(i, e) {
  return function() {
    for (var t = [], s = 0; s < arguments.length; s++)
      t[s] = arguments[s];
    return i.$scopedSlots[e] ? i.$scopedSlots[e].apply(i, t) : {}.NODE_ENV !== "production" ? At("slots.".concat(e, '() got called outside of the "render()" scope'), i) : void 0;
  };
}
function wf(i, e) {
  var t;
  if (!i)
    t = {};
  else {
    if (i._normalized)
      return i._normalized;
    t = {};
    for (var s in i)
      i[s] && s[0] !== "$" && (t[s] = !0);
  }
  for (var s in e)
    s in t || (t[s] = !0);
  return t;
}
var Tr = "composition-api.refKey", Pu = /* @__PURE__ */ new WeakMap(), Sf = /* @__PURE__ */ new WeakMap();
function Df(i, e, t) {
  var s = Aa(), r = s.util, n = r.warn, a = r.defineReactive;
  ({}).NODE_ENV !== "production" && (yf(i) || _f(i)) && n("Cannot set reactive property on undefined, null, or primitive value: ".concat(i));
  var o = i.__ob__;
  function l() {
    o && Nn(t) && !ti(t, "__ob__") && Hl(t);
  }
  if ($s(i)) {
    if (bf(e))
      return i.length = Math.max(i.length, e), i.splice(e, 1, t), l(), t;
    if (e === "length" && t !== i.length)
      return i.length = t, o == null || o.dep.notify(), t;
  }
  return e in i && !(e in Object.prototype) ? (i[e] = t, l(), t) : i._isVue || o && o.vmCount ? ({}.NODE_ENV !== "production" && n("Avoid adding reactive properties to a Vue instance or its root $data at runtime - declare it upfront in the data option."), t) : o ? (a(o.value, e, t), Ih(i, e, t), l(), o.dep.notify(), t) : (i[e] = t, t);
}
var Lh = (
  /** @class */
  function() {
    function i(e) {
      var t = e.get, s = e.set;
      ft(this, "value", {
        get: t,
        set: s
      });
    }
    return i;
  }()
);
function jh(i, e, t) {
  e === void 0 && (e = !1), t === void 0 && (t = !1);
  var s = new Lh(i);
  t && (s.effect = !0);
  var r = Object.seal(s);
  return e && Sf.set(r, !0), r;
}
function Tu(i) {
  var e;
  if (We(i))
    return i;
  var t = Rh((e = {}, e[Tr] = i, e));
  return jh({
    get: function() {
      return t[Tr];
    },
    set: function(s) {
      return t[Tr] = s;
    }
  });
}
function We(i) {
  return i instanceof Lh;
}
function ro(i) {
  return We(i) ? i.value : i;
}
function Pf(i) {
  if ({}.NODE_ENV !== "production" && !Cs(i) && At("toRefs() expects a reactive object but received a plain one."), !Ei(i))
    return i;
  var e = {};
  for (var t in i)
    e[t] = Tf(i, t);
  return e;
}
function Tf(i, e) {
  e in i || Df(i, e, void 0);
  var t = i[e];
  return We(t) ? t : jh({
    get: function() {
      return i[e];
    },
    set: function(s) {
      return i[e] = s;
    }
  });
}
var Eh = "__v_skip";
function Fs(i) {
  var e;
  return Boolean(i && ti(i, "__ob__") && typeof i.__ob__ == "object" && ((e = i.__ob__) === null || e === void 0 ? void 0 : e[Eh]));
}
function Cs(i) {
  var e;
  return Boolean(i && ti(i, "__ob__") && typeof i.__ob__ == "object" && !(!((e = i.__ob__) === null || e === void 0) && e[Eh]));
}
function Eo(i) {
  if (!(!Ei(i) || Fs(i) || $s(i) || We(i) || vf(i) || Pu.has(i))) {
    Pu.set(i, !0);
    for (var e = Object.keys(i), t = 0; t < e.length; t++)
      Ih(i, e[t]);
  }
}
function Ih(i, e, t) {
  if (e !== "__ob__" && !Fs(i[e])) {
    var s, r, n = Object.getOwnPropertyDescriptor(i, e);
    if (n) {
      if (n.configurable === !1)
        return;
      s = n.get, r = n.set, (!s || r) && arguments.length === 2 && (t = i[e]);
    }
    Eo(t), ft(i, e, {
      get: function() {
        var o = s ? s.call(i) : t;
        return e !== Tr && We(o) ? o.value : o;
      },
      set: function(o) {
        s && !r || (e !== Tr && We(t) && !We(o) ? t.value = o : (r && r.call(i, o), t = o), Eo(o));
      }
    });
  }
}
function Yh(i) {
  var e = Mh(), t;
  if (e.observable)
    t = e.observable(i);
  else {
    var s = Ah(e, {
      data: {
        $$state: i
      }
    });
    t = s._data.$$state;
  }
  return ti(t, "__ob__") || Hl(t), t;
}
function Hl(i, e) {
  var t, s;
  if (e === void 0 && (e = /* @__PURE__ */ new Set()), !(e.has(i) || ti(i, "__ob__") || !Object.isExtensible(i))) {
    Oh(i, "__ob__", kf(i)), e.add(i);
    try {
      for (var r = Th(Object.keys(i)), n = r.next(); !n.done; n = r.next()) {
        var a = n.value, o = i[a];
        !(Ei(o) || $s(o)) || Fs(o) || !Object.isExtensible(o) || Hl(o, e);
      }
    } catch (l) {
      t = { error: l };
    } finally {
      try {
        n && !n.done && (s = r.return) && s.call(r);
      } finally {
        if (t)
          throw t.error;
      }
    }
  }
}
function kf(i) {
  return i === void 0 && (i = {}), {
    value: i,
    dep: {
      notify: ks,
      depend: ks,
      addSub: ks,
      removeSub: ks
    }
  };
}
function Cf() {
  return Yh({}).__ob__;
}
function Rh(i) {
  if (!Nn(i))
    return {}.NODE_ENV !== "production" && At('"reactive()" must be called on an object.'), i;
  if (!(Ei(i) || $s(i)) || Fs(i) || !Object.isExtensible(i))
    return i;
  var e = Yh(i);
  return Eo(e), e;
}
function Mf(i, e, t) {
  var s = i.__composition_api_state__ = i.__composition_api_state__ || {};
  s[e] = t;
}
function Of(i, e) {
  return (i.__composition_api_state__ || {})[e];
}
var Ai = {
  set: Mf,
  get: Of
};
function Af(i, e, t) {
  var s = i.$options.props;
  !(e in i) && !(s && ti(s, e)) ? (We(t) ? ft(i, e, {
    get: function() {
      return t.value;
    },
    set: function(r) {
      t.value = r;
    }
  }) : ft(i, e, {
    get: function() {
      return Cs(t) && t.__ob__.dep.depend(), t;
    },
    set: function(r) {
      t = r;
    }
  }), {}.NODE_ENV !== "production" && i.$nextTick(function() {
    Object.keys(i._data).indexOf(e) === -1 && (We(t) ? ft(i._data, e, {
      get: function() {
        return t.value;
      },
      set: function(r) {
        t.value = r;
      }
    }) : ft(i._data, e, {
      get: function() {
        return t;
      },
      set: function(r) {
        t = r;
      }
    }));
  })) : {}.NODE_ENV !== "production" && (s && ti(s, e) ? At('The setup binding property "'.concat(e, '" is already declared as a prop.'), i) : At('The setup binding property "'.concat(e, '" is already declared.'), i));
}
function Lf(i) {
  var e = Ai.get(i, "rawBindings") || {};
  if (!(!e || !Object.keys(e).length)) {
    for (var t = i.$refs, s = Ai.get(i, "refs") || [], r = 0; r < s.length; r++) {
      var n = s[r], a = e[n];
      !t[n] && a && We(a) && (a.value = null);
    }
    for (var o = Object.keys(t), l = [], r = 0; r < o.length; r++) {
      var n = o[r], a = e[n];
      t[n] && a && We(a) && (a.value = t[n], l.push(n));
    }
    Ai.set(i, "refs", l);
  }
}
function ku(i) {
  for (var e = [i._vnode]; e.length; ) {
    var t = e.pop();
    if (t && (t.context && Lf(t.context), t.children))
      for (var s = 0; s < t.children.length; ++s)
        e.push(t.children[s]);
  }
}
function Cu(i, e) {
  var t, s;
  if (i) {
    var r = Ai.get(i, "attrBindings");
    if (!(!r && !e)) {
      if (!r) {
        var n = Rh({});
        r = { ctx: e, data: n }, Ai.set(i, "attrBindings", r), ft(e, "attrs", {
          get: function() {
            return r == null ? void 0 : r.data;
          },
          set: function() {
            ({}).NODE_ENV !== "production" && At("Cannot assign to '$attrs' because it is a read-only property", i);
          }
        });
      }
      var a = i.$attrs, o = function(h) {
        ti(r.data, h) || ft(r.data, h, {
          get: function() {
            return i.$attrs[h];
          }
        });
      };
      try {
        for (var l = Th(Object.keys(a)), u = l.next(); !u.done; u = l.next()) {
          var c = u.value;
          o(c);
        }
      } catch (h) {
        t = { error: h };
      } finally {
        try {
          u && !u.done && (s = l.return) && s.call(l);
        } finally {
          if (t)
            throw t.error;
        }
      }
    }
  }
}
function Mu(i, e) {
  var t = i.$options._parentVnode;
  if (t) {
    for (var s = Ai.get(i, "slots") || [], r = wf(t.data.scopedSlots, i.$slots), n = 0; n < s.length; n++) {
      var a = s[n];
      r[a] || delete e[a];
    }
    for (var o = Object.keys(r), n = 0; n < o.length; n++) {
      var a = o[n];
      e[a] || (e[a] = xf(i, a));
    }
    Ai.set(i, "slots", o);
  }
}
function no(i, e, t) {
  var s = Fl();
  Su(i);
  try {
    return e(i);
  } catch (r) {
    if (t)
      t(r);
    else
      throw r;
  } finally {
    Su(s);
  }
}
function jf(i) {
  i.mixin({
    beforeCreate: e,
    mounted: function() {
      ku(this);
    },
    beforeUpdate: function() {
      Cu(this);
    },
    updated: function() {
      ku(this);
    }
  });
  function e() {
    var a = this, o = a.$options, l = o.setup, u = o.render;
    if (u && (o.render = function() {
      for (var h = this, d = [], f = 0; f < arguments.length; f++)
        d[f] = arguments[f];
      return no(Rn(a), function() {
        return u.apply(h, d);
      });
    }), !!l) {
      if (!as(l)) {
        ({}).NODE_ENV !== "production" && At('The "setup" option should be a function that returns a object in component definitions.', a);
        return;
      }
      var c = o.data;
      o.data = function() {
        return t(a, a.$props), as(c) ? c.call(a, a) : c || {};
      };
    }
  }
  function t(a, o) {
    o === void 0 && (o = {});
    var l = a.$options.setup, u = n(a), c = Rn(a);
    c.setupContext = u, Oh(o, "__ob__", Cf()), Mu(a, u.slots);
    var h;
    if (no(c, function() {
      h = l(o, u);
    }), !!h) {
      if (as(h)) {
        var d = h;
        a.$options.render = function() {
          return Mu(a, u.slots), no(c, function() {
            return d();
          });
        };
        return;
      } else if (Nn(h)) {
        Cs(h) && (h = Pf(h)), Ai.set(a, "rawBindings", h);
        var f = h;
        Object.keys(f).forEach(function(g) {
          var p = f[g];
          if (!We(p))
            if (Cs(p))
              $s(p) && (p = Tu(p));
            else if (as(p)) {
              var _ = p;
              p = p.bind(a), Object.keys(_).forEach(function(m) {
                p[m] = _[m];
              });
            } else
              Nn(p) ? r(p) && s(p) : p = Tu(p);
          Af(a, g, p);
        });
        return;
      }
      ({}).NODE_ENV !== "production" && Bl(!1, '"setup" must return a "Object" or a "Function", got "'.concat(Object.prototype.toString.call(h).slice(8, -1), '"'));
    }
  }
  function s(a, o) {
    if (o === void 0 && (o = /* @__PURE__ */ new Set()), !o.has(a) && !(!Ei(a) || We(a) || Cs(a) || Fs(a))) {
      var l = Aa(), u = l.util.defineReactive;
      Object.keys(a).forEach(function(c) {
        var h = a[c];
        u(a, c, h), h && (o.add(h), s(h, o));
      });
    }
  }
  function r(a, o) {
    return o === void 0 && (o = /* @__PURE__ */ new Map()), o.has(a) ? o.get(a) : (o.set(a, !1), $s(a) && Cs(a) ? (o.set(a, !0), !0) : !Ei(a) || Fs(a) || We(a) ? !1 : Object.keys(a).some(function(l) {
      return r(a[l], o);
    }));
  }
  function n(a) {
    var o = { slots: {} }, l = [
      "root",
      "parent",
      "refs",
      "listeners",
      "isServer",
      "ssrContext"
    ], u = ["emit"];
    return l.forEach(function(c) {
      var h = "$".concat(c);
      ft(o, c, {
        get: function() {
          return a[h];
        },
        set: function() {
          ({}).NODE_ENV !== "production" && At("Cannot assign to '".concat(c, "' because it is a read-only property"), a);
        }
      });
    }), Cu(a, o), u.forEach(function(c) {
      var h = "$".concat(c);
      ft(o, c, {
        get: function() {
          return function() {
            for (var d = [], f = 0; f < arguments.length; f++)
              d[f] = arguments[f];
            var g = a[h];
            g.apply(a, d);
          };
        }
      });
    }), {}.NODE_ENV === "test" && (o._vm = a), o;
  }
}
function Nh(i, e) {
  if (!i)
    return e;
  if (!e)
    return i;
  for (var t, s, r, n = gf ? Reflect.ownKeys(i) : Object.keys(i), a = 0; a < n.length; a++)
    t = n[a], t !== "__ob__" && (s = e[t], r = i[t], ti(e, t) ? s !== r && Ei(s) && !We(s) && Ei(r) && !We(r) && Nh(r, s) : e[t] = r);
  return e;
}
function Ef(i) {
  if (cf(i)) {
    ({}).NODE_ENV !== "production" && At("[vue-composition-api] already installed. Vue.use(VueCompositionAPI) should be called only once.");
    return;
  }
  ({}).NODE_ENV !== "production" && (i.version ? (i.version[0] !== "2" || i.version[1] !== ".") && At("[vue-composition-api] only works with Vue 2, v".concat(i.version, " found.")) : At("[vue-composition-api] no Vue version found")), i.config.optionMergeStrategies.setup = function(e, t) {
    return function(r, n) {
      return Nh(as(e) ? e(r, n) || {} : void 0, as(t) ? t(r, n) || {} : void 0);
    };
  }, df(i), jf(i);
}
var If = {
  install: function(i) {
    return Ef(i);
  }
};
typeof window < "u" && window.Vue && window.Vue.use(If);
const Yf = {
  props: {
    styleProps: {
      type: String,
      default: ""
    }
  },
  data() {
    return {
      active: !1
    };
  },
  methods: {
    /**
     * Gets called when the user clicks on the accordion
     */
    OpenPannel() {
      this.active = !this.active;
      let i = this.$refs.panel;
      i.style.maxHeight ? i.style.maxHeight = null : i.style.maxHeight = i.scrollHeight + "px";
    }
  }
}, Rf = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iOSIgaGVpZ2h0PSI1IiB2aWV3Qm94PSIwIDAgOSA1IiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPg0KICAgIDxwYXRoIGQ9Ik00LjQyODgzIDMuNTQ2MzVMMS4wODAwOCAwLjM1NDU2OUMwLjk2MTE4MiAwLjI0MTY2MyAwLjgwMDA1OCAwLjE3ODM2NCAwLjYzMjE1NCAwLjE3ODU5OUMwLjQ2NDI1IDAuMTc4ODMzIDAuMzAzMzIxIDAuMjQyNTgxIDAuMTg0NzY5IDAuMzU1ODE5QzAuMDY2MjE3NyAwLjQ2OTA1NyAtMC4wMDAyNDU2NTIgMC42MjI1MDkgNC45Njg4NmUtMDcgMC43ODI0MTdDMC4wMDAyNDY2NDUgMC45NDIzMjYgMC4wNjcxODIxIDEuMDk1NTkgMC4xODYwODIgMS4yMDg1TDMuOTc4ODMgNC44MjQ1N0M0LjA5NCA0LjkzMzgyIDQuMjQ4OTUgNC45OTY2MSA0LjQxMTQ2IDQuOTk5ODdDNC41NzM5OCA1LjAwMzEzIDQuNzMxNTYgNC45NDY2MSA0Ljg1MTQ2IDQuODQyMDdMOC42NzM4MyAxLjIxMUM4Ljc5MjczIDEuMDk4MDkgOC44NTk2NyAwLjk0NDgyNSA4Ljg1OTkxIDAuNzg0OTE3QzguODYwMTYgMC42MjUwMDkgOC43OTM3IDAuNDcxNTU3IDguNjc1MTQgMC4zNTgzMTlDOC41NTY1OSAwLjI0NTA4MSA4LjM5NTY2IDAuMTgxMzMzIDguMjI3NzYgMC4xODEwOThDOC4wNTk4NiAwLjE4MDg2NCA3Ljg5ODczIDAuMjQ0MTYzIDcuNzc5ODMgMC4zNTcwNjlMNC40Mjg4MyAzLjU0NjM1WiIgZmlsbD0iIzM0OTFGRiIvPg0KICAgIDwvc3ZnPg0KICAgIA==";
var Nf = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    class: i.$style.accordion_main,
    style: i.styleProps
  }, [t("button", {
    class: i.$style.heading,
    on: {
      click: function() {
        return i.OpenPannel();
      }
    }
  }, [t("span", [i._t("header")], 2), t("span", {
    class: [i.active ? i.$style.icon_rotate : i.$style.icon, i.$style.accordion_icon]
  }, [t("img", {
    attrs: {
      src: Rf,
      alt: "embd-accordian-icon"
    }
  })])]), t("div", {
    ref: "panel",
    class: i.$style.panel
  }, [i._t("body")], 2)]);
}, $f = [];
const Ff = "_accordion_main_1kuar_1", Bf = "_heading_1kuar_6", Hf = "_accordion_icon_1kuar_28", zf = "_icon_rotate_1kuar_31", Xf = "_icon_1kuar_31", Vf = "_panel_1kuar_37", Uf = {
  accordion_main: Ff,
  heading: Bf,
  accordion_icon: Hf,
  icon_rotate: zf,
  icon: Xf,
  panel: Vf
};
function te(i, e, t, s, r, n, a, o) {
  var l = typeof i == "function" ? i.options : i;
  e && (l.render = e, l.staticRenderFns = t, l._compiled = !0), s && (l.functional = !0), n && (l._scopeId = "data-v-" + n);
  var u;
  if (a ? (u = function(d) {
    d = d || // cached call
    this.$vnode && this.$vnode.ssrContext || // stateful
    this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext, !d && typeof __VUE_SSR_CONTEXT__ < "u" && (d = __VUE_SSR_CONTEXT__), r && r.call(this, d), d && d._registeredComponents && d._registeredComponents.add(a);
  }, l._ssrRegister = u) : r && (u = o ? function() {
    r.call(
      this,
      (l.functional ? this.parent : this).$root.$options.shadowRoot
    );
  } : r), u)
    if (l.functional) {
      l._injectStyles = u;
      var c = l.render;
      l.render = function(f, g) {
        return u.call(g), c(f, g);
      };
    } else {
      var h = l.beforeCreate;
      l.beforeCreate = h ? [].concat(h, u) : [u];
    }
  return {
    exports: i,
    options: l
  };
}
const Io = {};
Io.$style = Uf;
var Wf = /* @__PURE__ */ te(
  Yf,
  Nf,
  $f,
  !1,
  Gf,
  null,
  null,
  null
);
function Gf(i) {
  for (let e in Io)
    this[e] = Io[e];
}
const VO = /* @__PURE__ */ function() {
  return Wf.exports;
}(), Zf = {
  props: {
    emit: Function,
    active: Boolean,
    disabled: Boolean,
    iconType: {
      type: String,
      default: ""
    },
    size: {
      type: String,
      default: ""
    },
    imgSrc: {
      type: String
    },
    label: {
      type: String
    }
  },
  computed: {
    intputTextChange() {
      return this.iconType === "change-state" ? "Change State" : this.iconType === "disable" ? "Disable" : this.iconType === "note" ? "Note" : this.iconType === "edit" ? "Edit" : this.iconType === "enable" ? "Enable" : this.iconType === "export" ? "Export" : this.iconType === "view" ? "View" : this.iconType === "reset" ? "Reset" : this.iconType === "register" ? "Register" : this.iconType === "view-edit-history" ? "View Edit History" : this.iconType === "shift-config" ? "Shift Config" : this.iconType === "role-user-config" ? "Role-User Config" : this.iconType === "remove-from-product" ? "Remove from Product" : this.iconType === "role-permission-config" ? "Set Permission" : this.label;
    },
    buttonClassComputed() {
      return `default default-color ${this.iconType} ${this.size}`;
    }
  },
  methods: {
    /**
     * Handle the emit
     * @return void
     */
    executor() {
      this.emit && this.emit();
    }
  }
};
var Kf = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    class: i.buttonClassComputed,
    attrs: {
      active: i.active,
      disabled: i.disabled
    },
    on: {
      click: i.executor
    }
  }, [i.iconType === "custom" ? t("span", [i._v(i._s(i.label))]) : t("span", [i._v(i._s(i.intputTextChange))]), i.iconType === "custom" ? t("img", {
    staticClass: "right-side-image",
    attrs: {
      src: i.imgSrc,
      alt: "embd-actionbar-custom-icon"
    }
  }) : t("img", {
    class: i.iconType,
    attrs: {
      src: "#",
      alt: "embd-button-actionbar-icon"
    }
  })]);
}, Qf = [];
const Ou = {};
var qf = /* @__PURE__ */ te(
  Zf,
  Kf,
  Qf,
  !1,
  Jf,
  "3fd69a20",
  null,
  null
);
function Jf(i) {
  for (let e in Ou)
    this[e] = Ou[e];
}
const UO = /* @__PURE__ */ function() {
  return qf.exports;
}(), ep = "_center_align_1pk4p_4", tp = "_default_btn_1pk4p_8", ip = "_radio_button_1pk4p_23", sp = "_radio_button_inner_1pk4p_23", rp = "_small_1pk4p_69", np = "_check_list_1pk4p_81", ap = "_check_list_inner_1pk4p_84", op = "_checkbox_1pk4p_119", lp = "_icon_size_1pk4p_139", up = "_label_styles_1pk4p_151", hp = "_large_1pk4p_157", hn = {
  center_align: ep,
  default_btn: tp,
  radio_button: ip,
  radio_button_inner: sp,
  default: "_default_1pk4p_8",
  small: rp,
  check_list: np,
  check_list_inner: ap,
  checkbox: op,
  icon_size: lp,
  label_styles: up,
  large: hp
}, cp = {
  name: "checkbox-button",
  props: {
    clickHandler: Function,
    labelText: {
      type: String,
      default: ""
    },
    size: {
      type: String
    },
    active: {
      type: Boolean,
      defualt: !0
    },
    disabled: Boolean,
    buttonType: {
      type: String,
      default: "check_list"
    }
  },
  watch: {
    active(i) {
      this.check = i;
    }
  },
  data() {
    return {
      hover: !1,
      check: !0
    };
  },
  computed: {
    buttonClassComputed() {
      let i = `${hn.default_btn} ${hn[this.buttonType]} `;
      return this.size && (i += `${hn[this.size]} `), i;
    },
    innerShapeStyleComputed() {
      return hn[this.buttonType + "_inner"];
    }
  },
  methods: {
    truncateText(i, e) {
      return i.length > e ? i.substring(0, e) + "..." : i;
    },
    executor() {
      this.clickHandler && (this.check = !this.check, this.clickHandler(this.check));
    }
  },
  mounted() {
    this.check = this.active;
  }
};
var dp = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    class: i.$style.center_align
  }, [t("div", {
    class: i.buttonClassComputed,
    attrs: {
      active: i.check,
      disabled: i.disabled
    },
    on: {
      click: i.executor
    }
  }, [i.buttonType === "checkbox" && (i.hover || i.active) ? t("img", {
    class: i.$style.icon_size,
    attrs: {
      src: "#",
      alt: ""
    }
  }) : t("div", {
    class: i.innerShapeStyleComputed
  })]), i.labelText != "" ? t("label", [t("span", {
    class: [i.size ? i.$style[i.size] : "", i.$style.label_styles]
  }, [i._v(" " + i._s(i.truncateText(i.labelText, 40)) + " ")])]) : i._e()]);
}, fp = [];
const pp = "_center_align_1pk4p_4", gp = "_default_btn_1pk4p_8", _p = "_radio_button_1pk4p_23", mp = "_radio_button_inner_1pk4p_23", bp = "_small_1pk4p_69", yp = "_check_list_1pk4p_81", vp = "_check_list_inner_1pk4p_84", xp = "_checkbox_1pk4p_119", wp = "_icon_size_1pk4p_139", Sp = "_label_styles_1pk4p_151", Dp = "_large_1pk4p_157", Pp = {
  center_align: pp,
  default_btn: gp,
  radio_button: _p,
  radio_button_inner: mp,
  default: "_default_1pk4p_8",
  small: bp,
  check_list: yp,
  check_list_inner: vp,
  checkbox: xp,
  icon_size: wp,
  label_styles: Sp,
  large: Dp
}, Yo = {};
Yo.$style = Pp;
var Tp = /* @__PURE__ */ te(
  cp,
  dp,
  fp,
  !1,
  kp,
  null,
  null,
  null
);
function kp(i) {
  for (let e in Yo)
    this[e] = Yo[e];
}
const $h = /* @__PURE__ */ function() {
  return Tp.exports;
}(), Cp = {
  name: "alert-box",
  props: {
    checkBoxHandler: Function,
    showAlertBox: {
      type: Boolean,
      default: !0
    },
    title: String,
    checkbox: {
      type: Boolean,
      default: !1
    },
    checkboxLabel: {
      type: String,
      default: "Don't show this warning again."
    },
    showCloseButton: {
      type: Boolean,
      default: !1
    },
    styleProp: String,
    titleIconUrl: {
      type: String,
      default: "warning"
    },
    onClose: Function
  },
  components: {
    CheckboxButton: $h
  },
  computed: {
    computeTitleIcon() {
      return `title-icon title-icon-${this.titleIconUrl}`;
    }
  },
  data() {
    return {
      visibleSuccess: !1,
      active: !1
    };
  },
  methods: {
    handleClose() {
      this.$nextTick(() => {
        var i;
        (i = this.onClose) == null || i.call(this);
      });
    },
    handleCheckboxClick() {
      this.$nextTick(() => {
        var i;
        this.active = !this.active, (i = this.checkBoxHandler) == null || i.call(this, this.active);
      });
    }
  }
};
var Mp = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    class: i.$style["emdn-alert-box-modal-root"],
    style: i.showAlertBox ? "" : {
      display: "none"
    },
    attrs: {
      bodystyle: "[object Object]"
    }
  }, [t("div", {
    class: i.$style["alert-box-modal-mask"],
    style: i.showAlertBox ? "" : {
      display: "none"
    },
    on: {
      click: function(s) {
        return s.target !== s.currentTarget ? null : i.handleClose.apply(null, arguments);
      }
    }
  }, [t("div", {
    class: [i.$style["alert-box-modal-wrap"], i.$style["alert-box-modal-centered"]],
    style: i.showAlertBox ? "" : {
      display: "none"
    },
    attrs: {
      tabindex: "-1",
      role: "dialog"
    }
  }, [t("div", {
    class: i.$style["alert-box-modal"],
    style: i.styleProp,
    attrs: {
      role: "document"
    }
  }, [t("div", {
    staticStyle: {
      width: "0px",
      height: "0px",
      overflow: "hidden"
    },
    attrs: {
      tabindex: "0",
      "aria-hidden": "true"
    }
  }), t("div", {
    class: i.$style["custom-modal-body-user"]
  }, [t("div", {
    class: i.$style["close-btn"],
    style: i.showCloseButton ? "" : {
      visibility: "hidden"
    }
  }, [t("div", {
    class: [i.$style["t-close-button"], i.$style["close-button"]],
    attrs: {
      "aria-hidden": "true"
    },
    on: {
      click: function(s) {
        return s.stopPropagation(), i.handleClose.apply(null, arguments);
      }
    }
  }, [t("span", {
    class: i.$style["t-icon-close"]
  })])]), t("div", {
    class: i.$style["modal-body"]
  }, [t("div", {
    class: i.$style["content-div"]
  }, [t("div", {
    class: i.$style["main-title"]
  }, [t("img", {
    class: [i.$style["title-icon"], i.$style[`title-icon-${i.titleIconUrl}`]],
    attrs: {
      src: i.titleIconUrl
    }
  }), t("span", {
    class: i.$style.title
  }, [i._v(i._s(i.title))])]), t("div", {
    class: i.$style["message-and-btn"]
  }, [t("div", [t("span", {
    class: i.$style["message-style"]
  }, [i._t("messagebody")], 2), i.checkbox ? t("div", {
    class: i.$style["check-box-styles"]
  }, [t("checkbox-button", {
    attrs: {
      "button-type": "check_list",
      "label-text": i.checkboxLabel,
      size: "small",
      "click-handler": i.handleCheckboxClick,
      active: i.active
    }
  })], 1) : i._e()])])]), t("div", {
    class: i.$style.footer
  }, [t("div", {
    class: i.$style["btn-styles"]
  }, [t("div", {
    class: i.$style["btn-ind-style"]
  }, [i._t("successbutton")], 2), t("div", {
    class: i.$style["btn-ind-style"]
  }, [i._t("rejectbutton")], 2)])])])])])])])]);
}, Op = [];
const Ap = "_title_141ac_69", Lp = "_footer_141ac_107", jp = {
  "emdn-alert-box-modal-root": "_emdn-alert-box-modal-root_141ac_1",
  "alert-box-modal-mask": "_alert-box-modal-mask_141ac_4",
  "alert-box-modal-wrap": "_alert-box-modal-wrap_141ac_17",
  "alert-box-modal-centered": "_alert-box-modal-centered_141ac_20",
  "alert-box-modal": "_alert-box-modal_141ac_4",
  "custom-modal-body-user": "_custom-modal-body-user_141ac_26",
  "close-btn": "_close-btn_141ac_33",
  "t-close-button": "_t-close-button_141ac_39",
  "t-icon-close": "_t-icon-close_141ac_46",
  "modal-body": "_modal-body_141ac_53",
  "content-div": "_content-div_141ac_61",
  "main-title": "_main-title_141ac_64",
  "title-icon": "_title-icon_141ac_69",
  "title-icon-warning": "_title-icon-warning_141ac_69",
  "title-icon-info": "_title-icon-info_141ac_75",
  title: Ap,
  "message-and-btn": "_message-and-btn_141ac_90",
  "message-style": "_message-style_141ac_96",
  "check-box-styles": "_check-box-styles_141ac_104",
  footer: Lp,
  "btn-styles": "_btn-styles_141ac_110",
  "btn-ind-style": "_btn-ind-style_141ac_114"
}, Ro = {};
Ro.$style = jp;
var Ep = /* @__PURE__ */ te(
  Cp,
  Mp,
  Op,
  !1,
  Ip,
  null,
  null,
  null
);
function Ip(i) {
  for (let e in Ro)
    this[e] = Ro[e];
}
const WO = /* @__PURE__ */ function() {
  return Ep.exports;
}(), Yp = "_center_59o0q_78", Rp = "_small_59o0q_100", Np = "_text_59o0q_104", $p = "_blue_59o0q_115", Fp = "_green_59o0q_146", Bp = "_red_59o0q_177", Hp = "_white_59o0q_207", zp = "_dropdown_59o0q_225", Xp = "_right_side_image_59o0q_225", Vp = "_upload_59o0q_277", Up = "_hyperlink_59o0q_287", Wp = "_top_right_side_image_59o0q_294", ur = {
  default: "_default_59o0q_62",
  center: Yp,
  small: Rp,
  text: Np,
  blue: $p,
  "blue-border-show": "_blue-border-show_59o0q_1",
  "blue-fill": "_blue-fill_59o0q_132",
  "blue-fill-border-show": "_blue-fill-border-show_59o0q_1",
  green: Fp,
  "green-border-show": "_green-border-show_59o0q_1",
  "green-fill": "_green-fill_59o0q_162",
  "green-fill-border-show": "_green-fill-border-show_59o0q_1",
  red: Bp,
  "red-border-show": "_red-border-show_59o0q_1",
  "red-fill": "_red-fill_59o0q_192",
  "red-fill-border-show": "_red-fill-border-show_59o0q_1",
  white: Hp,
  "white-border-show": "_white-border-show_59o0q_1",
  dropdown: zp,
  right_side_image: Xp,
  "date-picker": "_date-picker_59o0q_256",
  export: "_export_59o0q_270",
  upload: Vp,
  hyperlink: Up,
  top_right_side_image: Wp
}, Gp = {
  props: {
    styleProps: {
      type: String,
      default: ""
    },
    clickHandler: Function,
    active: Boolean,
    disabled: Boolean,
    colorType: String,
    buttonType: {
      type: String
    },
    size: {
      type: String
    }
  },
  computed: {
    colorTypeComputed() {
      return this.buttonType === "text" || this.buttonType === "text dropdown" || this.buttonType === "text hyperlink" ? null : this.buttonType === "export" ? "blue-fill" : this.colorType ? this.colorType : "blue";
    },
    textPositionComputed() {
      return this.imagePosition ? null : "center";
    },
    // TODO; has bugs to append undefined class name
    buttonClassComputed() {
      var e;
      let i = `${ur.default} `;
      return this.size && (i += `${ur[this.size]} `), this.colorTypeComputed && (i += `${ur[this.colorTypeComputed]} `), this.textPositionComputed && (i += `${ur[this.textPositionComputed]} `), (e = this.buttonType) == null || e.split(" ").forEach((t) => {
        i += `${ur[t]} `;
      }), i;
    },
    imagePosition() {
      return this.buttonType === "text" || !this.buttonType ? null : this.buttonType === "text hyperlink" ? "top-right" : "right";
    },
    showIcon() {
      return this.buttonType == "dropdown" && this.colorType != "red" && this.colorType != "green" || this.buttonType == "date-picker" && this.colorType != "red" && this.colorType != "green" && this.colorType != "white" ? !0 : this.buttonType != "dropdown" && this.buttonType != "date-picker";
    }
  },
  methods: {
    executor() {
      this.clickHandler && this.clickHandler();
    }
  }
};
var Zp = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    class: i.buttonClassComputed,
    style: i.styleProps,
    attrs: {
      active: i.active,
      disabled: i.disabled
    },
    on: {
      click: function(s) {
        return s.stopPropagation(), i.executor.apply(null, arguments);
      }
    }
  }, [i.imagePosition === "left" ? t("img", {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: i.showIcon,
      expression: "showIcon"
    }],
    class: i.$style.left_side_image,
    attrs: {
      alt: "button-left-side-image"
    }
  }) : i._e(), i._t("default"), i.imagePosition === "right" ? t("img", {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: i.showIcon,
      expression: "showIcon"
    }],
    class: i.$style.right_side_image,
    attrs: {
      alt: "button-right-side-image"
    }
  }) : i._e(), i.imagePosition === "top-right" ? t("div", [t("img", {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: i.showIcon,
      expression: "showIcon"
    }],
    class: i.$style.top_right_side_image,
    attrs: {
      alt: "button-top-right-side-image"
    }
  })]) : i._e()], 2);
}, Kp = [];
const Qp = "_center_59o0q_78", qp = "_small_59o0q_100", Jp = "_text_59o0q_104", eg = "_blue_59o0q_115", tg = "_green_59o0q_146", ig = "_red_59o0q_177", sg = "_white_59o0q_207", rg = "_dropdown_59o0q_225", ng = "_right_side_image_59o0q_225", ag = "_upload_59o0q_277", og = "_hyperlink_59o0q_287", lg = "_top_right_side_image_59o0q_294", ug = {
  default: "_default_59o0q_62",
  center: Qp,
  small: qp,
  text: Jp,
  blue: eg,
  "blue-border-show": "_blue-border-show_59o0q_1",
  "blue-fill": "_blue-fill_59o0q_132",
  "blue-fill-border-show": "_blue-fill-border-show_59o0q_1",
  green: tg,
  "green-border-show": "_green-border-show_59o0q_1",
  "green-fill": "_green-fill_59o0q_162",
  "green-fill-border-show": "_green-fill-border-show_59o0q_1",
  red: ig,
  "red-border-show": "_red-border-show_59o0q_1",
  "red-fill": "_red-fill_59o0q_192",
  "red-fill-border-show": "_red-fill-border-show_59o0q_1",
  white: sg,
  "white-border-show": "_white-border-show_59o0q_1",
  dropdown: rg,
  right_side_image: ng,
  "date-picker": "_date-picker_59o0q_256",
  export: "_export_59o0q_270",
  upload: ag,
  hyperlink: og,
  top_right_side_image: lg
}, No = {};
No.$style = ug;
var hg = /* @__PURE__ */ te(
  Gp,
  Zp,
  Kp,
  !1,
  cg,
  "50e0bc44",
  null,
  null
);
function cg(i) {
  for (let e in No)
    this[e] = No[e];
}
const Qr = /* @__PURE__ */ function() {
  return hg.exports;
}();
//! moment.js
//! version : 2.29.4
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com
var Fh;
function P() {
  return Fh.apply(null, arguments);
}
function dg(i) {
  Fh = i;
}
function Zt(i) {
  return i instanceof Array || Object.prototype.toString.call(i) === "[object Array]";
}
function hs(i) {
  return i != null && Object.prototype.toString.call(i) === "[object Object]";
}
function be(i, e) {
  return Object.prototype.hasOwnProperty.call(i, e);
}
function zl(i) {
  if (Object.getOwnPropertyNames)
    return Object.getOwnPropertyNames(i).length === 0;
  var e;
  for (e in i)
    if (be(i, e))
      return !1;
  return !0;
}
function mt(i) {
  return i === void 0;
}
function fi(i) {
  return typeof i == "number" || Object.prototype.toString.call(i) === "[object Number]";
}
function qr(i) {
  return i instanceof Date || Object.prototype.toString.call(i) === "[object Date]";
}
function Bh(i, e) {
  var t = [], s, r = i.length;
  for (s = 0; s < r; ++s)
    t.push(e(i[s], s));
  return t;
}
function Di(i, e) {
  for (var t in e)
    be(e, t) && (i[t] = e[t]);
  return be(e, "toString") && (i.toString = e.toString), be(e, "valueOf") && (i.valueOf = e.valueOf), i;
}
function ri(i, e, t, s) {
  return cc(i, e, t, s, !0).utc();
}
function fg() {
  return {
    empty: !1,
    unusedTokens: [],
    unusedInput: [],
    overflow: -2,
    charsLeftOver: 0,
    nullInput: !1,
    invalidEra: null,
    invalidMonth: null,
    invalidFormat: !1,
    userInvalidated: !1,
    iso: !1,
    parsedDateParts: [],
    era: null,
    meridiem: null,
    rfc2822: !1,
    weekdayMismatch: !1
  };
}
function ae(i) {
  return i._pf == null && (i._pf = fg()), i._pf;
}
var $o;
Array.prototype.some ? $o = Array.prototype.some : $o = function(i) {
  var e = Object(this), t = e.length >>> 0, s;
  for (s = 0; s < t; s++)
    if (s in e && i.call(this, e[s], s, e))
      return !0;
  return !1;
};
function Xl(i) {
  if (i._isValid == null) {
    var e = ae(i), t = $o.call(e.parsedDateParts, function(r) {
      return r != null;
    }), s = !isNaN(i._d.getTime()) && e.overflow < 0 && !e.empty && !e.invalidEra && !e.invalidMonth && !e.invalidWeekday && !e.weekdayMismatch && !e.nullInput && !e.invalidFormat && !e.userInvalidated && (!e.meridiem || e.meridiem && t);
    if (i._strict && (s = s && e.charsLeftOver === 0 && e.unusedTokens.length === 0 && e.bigHour === void 0), Object.isFrozen == null || !Object.isFrozen(i))
      i._isValid = s;
    else
      return s;
  }
  return i._isValid;
}
function La(i) {
  var e = ri(NaN);
  return i != null ? Di(ae(e), i) : ae(e).userInvalidated = !0, e;
}
var Au = P.momentProperties = [], ao = !1;
function Vl(i, e) {
  var t, s, r, n = Au.length;
  if (mt(e._isAMomentObject) || (i._isAMomentObject = e._isAMomentObject), mt(e._i) || (i._i = e._i), mt(e._f) || (i._f = e._f), mt(e._l) || (i._l = e._l), mt(e._strict) || (i._strict = e._strict), mt(e._tzm) || (i._tzm = e._tzm), mt(e._isUTC) || (i._isUTC = e._isUTC), mt(e._offset) || (i._offset = e._offset), mt(e._pf) || (i._pf = ae(e)), mt(e._locale) || (i._locale = e._locale), n > 0)
    for (t = 0; t < n; t++)
      s = Au[t], r = e[s], mt(r) || (i[s] = r);
  return i;
}
function Jr(i) {
  Vl(this, i), this._d = new Date(i._d != null ? i._d.getTime() : NaN), this.isValid() || (this._d = new Date(NaN)), ao === !1 && (ao = !0, P.updateOffset(this), ao = !1);
}
function Kt(i) {
  return i instanceof Jr || i != null && i._isAMomentObject != null;
}
function Hh(i) {
  P.suppressDeprecationWarnings === !1 && typeof console < "u" && console.warn && console.warn("Deprecation warning: " + i);
}
function Bt(i, e) {
  var t = !0;
  return Di(function() {
    if (P.deprecationHandler != null && P.deprecationHandler(null, i), t) {
      var s = [], r, n, a, o = arguments.length;
      for (n = 0; n < o; n++) {
        if (r = "", typeof arguments[n] == "object") {
          r += `
[` + n + "] ";
          for (a in arguments[0])
            be(arguments[0], a) && (r += a + ": " + arguments[0][a] + ", ");
          r = r.slice(0, -2);
        } else
          r = arguments[n];
        s.push(r);
      }
      Hh(
        i + `
Arguments: ` + Array.prototype.slice.call(s).join("") + `
` + new Error().stack
      ), t = !1;
    }
    return e.apply(this, arguments);
  }, e);
}
var Lu = {};
function zh(i, e) {
  P.deprecationHandler != null && P.deprecationHandler(i, e), Lu[i] || (Hh(e), Lu[i] = !0);
}
P.suppressDeprecationWarnings = !1;
P.deprecationHandler = null;
function ni(i) {
  return typeof Function < "u" && i instanceof Function || Object.prototype.toString.call(i) === "[object Function]";
}
function pg(i) {
  var e, t;
  for (t in i)
    be(i, t) && (e = i[t], ni(e) ? this[t] = e : this["_" + t] = e);
  this._config = i, this._dayOfMonthOrdinalParseLenient = new RegExp(
    (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source
  );
}
function Fo(i, e) {
  var t = Di({}, i), s;
  for (s in e)
    be(e, s) && (hs(i[s]) && hs(e[s]) ? (t[s] = {}, Di(t[s], i[s]), Di(t[s], e[s])) : e[s] != null ? t[s] = e[s] : delete t[s]);
  for (s in i)
    be(i, s) && !be(e, s) && hs(i[s]) && (t[s] = Di({}, t[s]));
  return t;
}
function Ul(i) {
  i != null && this.set(i);
}
var Bo;
Object.keys ? Bo = Object.keys : Bo = function(i) {
  var e, t = [];
  for (e in i)
    be(i, e) && t.push(e);
  return t;
};
var gg = {
  sameDay: "[Today at] LT",
  nextDay: "[Tomorrow at] LT",
  nextWeek: "dddd [at] LT",
  lastDay: "[Yesterday at] LT",
  lastWeek: "[Last] dddd [at] LT",
  sameElse: "L"
};
function _g(i, e, t) {
  var s = this._calendar[i] || this._calendar.sameElse;
  return ni(s) ? s.call(e, t) : s;
}
function ii(i, e, t) {
  var s = "" + Math.abs(i), r = e - s.length, n = i >= 0;
  return (n ? t ? "+" : "" : "-") + Math.pow(10, Math.max(0, r)).toString().substr(1) + s;
}
var Wl = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, cn = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, oo = {}, Es = {};
function Q(i, e, t, s) {
  var r = s;
  typeof s == "string" && (r = function() {
    return this[s]();
  }), i && (Es[i] = r), e && (Es[e[0]] = function() {
    return ii(r.apply(this, arguments), e[1], e[2]);
  }), t && (Es[t] = function() {
    return this.localeData().ordinal(
      r.apply(this, arguments),
      i
    );
  });
}
function mg(i) {
  return i.match(/\[[\s\S]/) ? i.replace(/^\[|\]$/g, "") : i.replace(/\\/g, "");
}
function bg(i) {
  var e = i.match(Wl), t, s;
  for (t = 0, s = e.length; t < s; t++)
    Es[e[t]] ? e[t] = Es[e[t]] : e[t] = mg(e[t]);
  return function(r) {
    var n = "", a;
    for (a = 0; a < s; a++)
      n += ni(e[a]) ? e[a].call(r, i) : e[a];
    return n;
  };
}
function Pn(i, e) {
  return i.isValid() ? (e = Xh(e, i.localeData()), oo[e] = oo[e] || bg(e), oo[e](i)) : i.localeData().invalidDate();
}
function Xh(i, e) {
  var t = 5;
  function s(r) {
    return e.longDateFormat(r) || r;
  }
  for (cn.lastIndex = 0; t >= 0 && cn.test(i); )
    i = i.replace(
      cn,
      s
    ), cn.lastIndex = 0, t -= 1;
  return i;
}
var yg = {
  LTS: "h:mm:ss A",
  LT: "h:mm A",
  L: "MM/DD/YYYY",
  LL: "MMMM D, YYYY",
  LLL: "MMMM D, YYYY h:mm A",
  LLLL: "dddd, MMMM D, YYYY h:mm A"
};
function vg(i) {
  var e = this._longDateFormat[i], t = this._longDateFormat[i.toUpperCase()];
  return e || !t ? e : (this._longDateFormat[i] = t.match(Wl).map(function(s) {
    return s === "MMMM" || s === "MM" || s === "DD" || s === "dddd" ? s.slice(1) : s;
  }).join(""), this._longDateFormat[i]);
}
var xg = "Invalid date";
function wg() {
  return this._invalidDate;
}
var Sg = "%d", Dg = /\d{1,2}/;
function Pg(i) {
  return this._ordinal.replace("%d", i);
}
var Tg = {
  future: "in %s",
  past: "%s ago",
  s: "a few seconds",
  ss: "%d seconds",
  m: "a minute",
  mm: "%d minutes",
  h: "an hour",
  hh: "%d hours",
  d: "a day",
  dd: "%d days",
  w: "a week",
  ww: "%d weeks",
  M: "a month",
  MM: "%d months",
  y: "a year",
  yy: "%d years"
};
function kg(i, e, t, s) {
  var r = this._relativeTime[t];
  return ni(r) ? r(i, e, t, s) : r.replace(/%d/i, i);
}
function Cg(i, e) {
  var t = this._relativeTime[i > 0 ? "future" : "past"];
  return ni(t) ? t(e) : t.replace(/%s/i, e);
}
var kr = {};
function ut(i, e) {
  var t = i.toLowerCase();
  kr[t] = kr[t + "s"] = kr[e] = i;
}
function Ht(i) {
  return typeof i == "string" ? kr[i] || kr[i.toLowerCase()] : void 0;
}
function Gl(i) {
  var e = {}, t, s;
  for (s in i)
    be(i, s) && (t = Ht(s), t && (e[t] = i[s]));
  return e;
}
var Vh = {};
function ht(i, e) {
  Vh[i] = e;
}
function Mg(i) {
  var e = [], t;
  for (t in i)
    be(i, t) && e.push({ unit: t, priority: Vh[t] });
  return e.sort(function(s, r) {
    return s.priority - r.priority;
  }), e;
}
function ja(i) {
  return i % 4 === 0 && i % 100 !== 0 || i % 400 === 0;
}
function Rt(i) {
  return i < 0 ? Math.ceil(i) || 0 : Math.floor(i);
}
function he(i) {
  var e = +i, t = 0;
  return e !== 0 && isFinite(e) && (t = Rt(e)), t;
}
function rr(i, e) {
  return function(t) {
    return t != null ? (Uh(this, i, t), P.updateOffset(this, e), this) : $n(this, i);
  };
}
function $n(i, e) {
  return i.isValid() ? i._d["get" + (i._isUTC ? "UTC" : "") + e]() : NaN;
}
function Uh(i, e, t) {
  i.isValid() && !isNaN(t) && (e === "FullYear" && ja(i.year()) && i.month() === 1 && i.date() === 29 ? (t = he(t), i._d["set" + (i._isUTC ? "UTC" : "") + e](
    t,
    i.month(),
    $a(t, i.month())
  )) : i._d["set" + (i._isUTC ? "UTC" : "") + e](t));
}
function Og(i) {
  return i = Ht(i), ni(this[i]) ? this[i]() : this;
}
function Ag(i, e) {
  if (typeof i == "object") {
    i = Gl(i);
    var t = Mg(i), s, r = t.length;
    for (s = 0; s < r; s++)
      this[t[s].unit](i[t[s].unit]);
  } else if (i = Ht(i), ni(this[i]))
    return this[i](e);
  return this;
}
var Wh = /\d/, It = /\d\d/, Gh = /\d{3}/, Zl = /\d{4}/, Ea = /[+-]?\d{6}/, Pe = /\d\d?/, Zh = /\d\d\d\d?/, Kh = /\d\d\d\d\d\d?/, Ia = /\d{1,3}/, Kl = /\d{1,4}/, Ya = /[+-]?\d{1,6}/, nr = /\d+/, Ra = /[+-]?\d+/, Lg = /Z|[+-]\d\d:?\d\d/gi, Na = /Z|[+-]\d\d(?::?\d\d)?/gi, jg = /[+-]?\d+(\.\d{1,3})?/, en = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, Fn;
Fn = {};
function V(i, e, t) {
  Fn[i] = ni(e) ? e : function(s, r) {
    return s && t ? t : e;
  };
}
function Eg(i, e) {
  return be(Fn, i) ? Fn[i](e._strict, e._locale) : new RegExp(Ig(i));
}
function Ig(i) {
  return Ct(
    i.replace("\\", "").replace(
      /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
      function(e, t, s, r, n) {
        return t || s || r || n;
      }
    )
  );
}
function Ct(i) {
  return i.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
}
var Ho = {};
function xe(i, e) {
  var t, s = e, r;
  for (typeof i == "string" && (i = [i]), fi(e) && (s = function(n, a) {
    a[e] = he(n);
  }), r = i.length, t = 0; t < r; t++)
    Ho[i[t]] = s;
}
function tn(i, e) {
  xe(i, function(t, s, r, n) {
    r._w = r._w || {}, e(t, r._w, r, n);
  });
}
function Yg(i, e, t) {
  e != null && be(Ho, i) && Ho[i](e, t._a, t, i);
}
var lt = 0, li = 1, Jt = 2, Ue = 3, Ut = 4, ui = 5, os = 6, Rg = 7, Ng = 8;
function $g(i, e) {
  return (i % e + e) % e;
}
var Ee;
Array.prototype.indexOf ? Ee = Array.prototype.indexOf : Ee = function(i) {
  var e;
  for (e = 0; e < this.length; ++e)
    if (this[e] === i)
      return e;
  return -1;
};
function $a(i, e) {
  if (isNaN(i) || isNaN(e))
    return NaN;
  var t = $g(e, 12);
  return i += (e - t) / 12, t === 1 ? ja(i) ? 29 : 28 : 31 - t % 7 % 2;
}
Q("M", ["MM", 2], "Mo", function() {
  return this.month() + 1;
});
Q("MMM", 0, 0, function(i) {
  return this.localeData().monthsShort(this, i);
});
Q("MMMM", 0, 0, function(i) {
  return this.localeData().months(this, i);
});
ut("month", "M");
ht("month", 8);
V("M", Pe);
V("MM", Pe, It);
V("MMM", function(i, e) {
  return e.monthsShortRegex(i);
});
V("MMMM", function(i, e) {
  return e.monthsRegex(i);
});
xe(["M", "MM"], function(i, e) {
  e[li] = he(i) - 1;
});
xe(["MMM", "MMMM"], function(i, e, t, s) {
  var r = t._locale.monthsParse(i, s, t._strict);
  r != null ? e[li] = r : ae(t).invalidMonth = i;
});
var Fg = "January_February_March_April_May_June_July_August_September_October_November_December".split(
  "_"
), Qh = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), qh = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, Bg = en, Hg = en;
function zg(i, e) {
  return i ? Zt(this._months) ? this._months[i.month()] : this._months[(this._months.isFormat || qh).test(e) ? "format" : "standalone"][i.month()] : Zt(this._months) ? this._months : this._months.standalone;
}
function Xg(i, e) {
  return i ? Zt(this._monthsShort) ? this._monthsShort[i.month()] : this._monthsShort[qh.test(e) ? "format" : "standalone"][i.month()] : Zt(this._monthsShort) ? this._monthsShort : this._monthsShort.standalone;
}
function Vg(i, e, t) {
  var s, r, n, a = i.toLocaleLowerCase();
  if (!this._monthsParse)
    for (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = [], s = 0; s < 12; ++s)
      n = ri([2e3, s]), this._shortMonthsParse[s] = this.monthsShort(
        n,
        ""
      ).toLocaleLowerCase(), this._longMonthsParse[s] = this.months(n, "").toLocaleLowerCase();
  return t ? e === "MMM" ? (r = Ee.call(this._shortMonthsParse, a), r !== -1 ? r : null) : (r = Ee.call(this._longMonthsParse, a), r !== -1 ? r : null) : e === "MMM" ? (r = Ee.call(this._shortMonthsParse, a), r !== -1 ? r : (r = Ee.call(this._longMonthsParse, a), r !== -1 ? r : null)) : (r = Ee.call(this._longMonthsParse, a), r !== -1 ? r : (r = Ee.call(this._shortMonthsParse, a), r !== -1 ? r : null));
}
function Ug(i, e, t) {
  var s, r, n;
  if (this._monthsParseExact)
    return Vg.call(this, i, e, t);
  for (this._monthsParse || (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = []), s = 0; s < 12; s++) {
    if (r = ri([2e3, s]), t && !this._longMonthsParse[s] && (this._longMonthsParse[s] = new RegExp(
      "^" + this.months(r, "").replace(".", "") + "$",
      "i"
    ), this._shortMonthsParse[s] = new RegExp(
      "^" + this.monthsShort(r, "").replace(".", "") + "$",
      "i"
    )), !t && !this._monthsParse[s] && (n = "^" + this.months(r, "") + "|^" + this.monthsShort(r, ""), this._monthsParse[s] = new RegExp(n.replace(".", ""), "i")), t && e === "MMMM" && this._longMonthsParse[s].test(i))
      return s;
    if (t && e === "MMM" && this._shortMonthsParse[s].test(i))
      return s;
    if (!t && this._monthsParse[s].test(i))
      return s;
  }
}
function Jh(i, e) {
  var t;
  if (!i.isValid())
    return i;
  if (typeof e == "string") {
    if (/^\d+$/.test(e))
      e = he(e);
    else if (e = i.localeData().monthsParse(e), !fi(e))
      return i;
  }
  return t = Math.min(i.date(), $a(i.year(), e)), i._d["set" + (i._isUTC ? "UTC" : "") + "Month"](e, t), i;
}
function ec(i) {
  return i != null ? (Jh(this, i), P.updateOffset(this, !0), this) : $n(this, "Month");
}
function Wg() {
  return $a(this.year(), this.month());
}
function Gg(i) {
  return this._monthsParseExact ? (be(this, "_monthsRegex") || tc.call(this), i ? this._monthsShortStrictRegex : this._monthsShortRegex) : (be(this, "_monthsShortRegex") || (this._monthsShortRegex = Bg), this._monthsShortStrictRegex && i ? this._monthsShortStrictRegex : this._monthsShortRegex);
}
function Zg(i) {
  return this._monthsParseExact ? (be(this, "_monthsRegex") || tc.call(this), i ? this._monthsStrictRegex : this._monthsRegex) : (be(this, "_monthsRegex") || (this._monthsRegex = Hg), this._monthsStrictRegex && i ? this._monthsStrictRegex : this._monthsRegex);
}
function tc() {
  function i(a, o) {
    return o.length - a.length;
  }
  var e = [], t = [], s = [], r, n;
  for (r = 0; r < 12; r++)
    n = ri([2e3, r]), e.push(this.monthsShort(n, "")), t.push(this.months(n, "")), s.push(this.months(n, "")), s.push(this.monthsShort(n, ""));
  for (e.sort(i), t.sort(i), s.sort(i), r = 0; r < 12; r++)
    e[r] = Ct(e[r]), t[r] = Ct(t[r]);
  for (r = 0; r < 24; r++)
    s[r] = Ct(s[r]);
  this._monthsRegex = new RegExp("^(" + s.join("|") + ")", "i"), this._monthsShortRegex = this._monthsRegex, this._monthsStrictRegex = new RegExp(
    "^(" + t.join("|") + ")",
    "i"
  ), this._monthsShortStrictRegex = new RegExp(
    "^(" + e.join("|") + ")",
    "i"
  );
}
Q("Y", 0, 0, function() {
  var i = this.year();
  return i <= 9999 ? ii(i, 4) : "+" + i;
});
Q(0, ["YY", 2], 0, function() {
  return this.year() % 100;
});
Q(0, ["YYYY", 4], 0, "year");
Q(0, ["YYYYY", 5], 0, "year");
Q(0, ["YYYYYY", 6, !0], 0, "year");
ut("year", "y");
ht("year", 1);
V("Y", Ra);
V("YY", Pe, It);
V("YYYY", Kl, Zl);
V("YYYYY", Ya, Ea);
V("YYYYYY", Ya, Ea);
xe(["YYYYY", "YYYYYY"], lt);
xe("YYYY", function(i, e) {
  e[lt] = i.length === 2 ? P.parseTwoDigitYear(i) : he(i);
});
xe("YY", function(i, e) {
  e[lt] = P.parseTwoDigitYear(i);
});
xe("Y", function(i, e) {
  e[lt] = parseInt(i, 10);
});
function Cr(i) {
  return ja(i) ? 366 : 365;
}
P.parseTwoDigitYear = function(i) {
  return he(i) + (he(i) > 68 ? 1900 : 2e3);
};
var ic = rr("FullYear", !0);
function Kg() {
  return ja(this.year());
}
function Qg(i, e, t, s, r, n, a) {
  var o;
  return i < 100 && i >= 0 ? (o = new Date(i + 400, e, t, s, r, n, a), isFinite(o.getFullYear()) && o.setFullYear(i)) : o = new Date(i, e, t, s, r, n, a), o;
}
function Yr(i) {
  var e, t;
  return i < 100 && i >= 0 ? (t = Array.prototype.slice.call(arguments), t[0] = i + 400, e = new Date(Date.UTC.apply(null, t)), isFinite(e.getUTCFullYear()) && e.setUTCFullYear(i)) : e = new Date(Date.UTC.apply(null, arguments)), e;
}
function Bn(i, e, t) {
  var s = 7 + e - t, r = (7 + Yr(i, 0, s).getUTCDay() - e) % 7;
  return -r + s - 1;
}
function sc(i, e, t, s, r) {
  var n = (7 + t - s) % 7, a = Bn(i, s, r), o = 1 + 7 * (e - 1) + n + a, l, u;
  return o <= 0 ? (l = i - 1, u = Cr(l) + o) : o > Cr(i) ? (l = i + 1, u = o - Cr(i)) : (l = i, u = o), {
    year: l,
    dayOfYear: u
  };
}
function Rr(i, e, t) {
  var s = Bn(i.year(), e, t), r = Math.floor((i.dayOfYear() - s - 1) / 7) + 1, n, a;
  return r < 1 ? (a = i.year() - 1, n = r + hi(a, e, t)) : r > hi(i.year(), e, t) ? (n = r - hi(i.year(), e, t), a = i.year() + 1) : (a = i.year(), n = r), {
    week: n,
    year: a
  };
}
function hi(i, e, t) {
  var s = Bn(i, e, t), r = Bn(i + 1, e, t);
  return (Cr(i) - s + r) / 7;
}
Q("w", ["ww", 2], "wo", "week");
Q("W", ["WW", 2], "Wo", "isoWeek");
ut("week", "w");
ut("isoWeek", "W");
ht("week", 5);
ht("isoWeek", 5);
V("w", Pe);
V("ww", Pe, It);
V("W", Pe);
V("WW", Pe, It);
tn(
  ["w", "ww", "W", "WW"],
  function(i, e, t, s) {
    e[s.substr(0, 1)] = he(i);
  }
);
function qg(i) {
  return Rr(i, this._week.dow, this._week.doy).week;
}
var Jg = {
  dow: 0,
  // Sunday is the first day of the week.
  doy: 6
  // The week that contains Jan 6th is the first week of the year.
};
function e_() {
  return this._week.dow;
}
function t_() {
  return this._week.doy;
}
function i_(i) {
  var e = this.localeData().week(this);
  return i == null ? e : this.add((i - e) * 7, "d");
}
function s_(i) {
  var e = Rr(this, 1, 4).week;
  return i == null ? e : this.add((i - e) * 7, "d");
}
Q("d", 0, "do", "day");
Q("dd", 0, 0, function(i) {
  return this.localeData().weekdaysMin(this, i);
});
Q("ddd", 0, 0, function(i) {
  return this.localeData().weekdaysShort(this, i);
});
Q("dddd", 0, 0, function(i) {
  return this.localeData().weekdays(this, i);
});
Q("e", 0, 0, "weekday");
Q("E", 0, 0, "isoWeekday");
ut("day", "d");
ut("weekday", "e");
ut("isoWeekday", "E");
ht("day", 11);
ht("weekday", 11);
ht("isoWeekday", 11);
V("d", Pe);
V("e", Pe);
V("E", Pe);
V("dd", function(i, e) {
  return e.weekdaysMinRegex(i);
});
V("ddd", function(i, e) {
  return e.weekdaysShortRegex(i);
});
V("dddd", function(i, e) {
  return e.weekdaysRegex(i);
});
tn(["dd", "ddd", "dddd"], function(i, e, t, s) {
  var r = t._locale.weekdaysParse(i, s, t._strict);
  r != null ? e.d = r : ae(t).invalidWeekday = i;
});
tn(["d", "e", "E"], function(i, e, t, s) {
  e[s] = he(i);
});
function r_(i, e) {
  return typeof i != "string" ? i : isNaN(i) ? (i = e.weekdaysParse(i), typeof i == "number" ? i : null) : parseInt(i, 10);
}
function n_(i, e) {
  return typeof i == "string" ? e.weekdaysParse(i) % 7 || 7 : isNaN(i) ? null : i;
}
function Ql(i, e) {
  return i.slice(e, 7).concat(i.slice(0, e));
}
var a_ = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), rc = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), o_ = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), l_ = en, u_ = en, h_ = en;
function c_(i, e) {
  var t = Zt(this._weekdays) ? this._weekdays : this._weekdays[i && i !== !0 && this._weekdays.isFormat.test(e) ? "format" : "standalone"];
  return i === !0 ? Ql(t, this._week.dow) : i ? t[i.day()] : t;
}
function d_(i) {
  return i === !0 ? Ql(this._weekdaysShort, this._week.dow) : i ? this._weekdaysShort[i.day()] : this._weekdaysShort;
}
function f_(i) {
  return i === !0 ? Ql(this._weekdaysMin, this._week.dow) : i ? this._weekdaysMin[i.day()] : this._weekdaysMin;
}
function p_(i, e, t) {
  var s, r, n, a = i.toLocaleLowerCase();
  if (!this._weekdaysParse)
    for (this._weekdaysParse = [], this._shortWeekdaysParse = [], this._minWeekdaysParse = [], s = 0; s < 7; ++s)
      n = ri([2e3, 1]).day(s), this._minWeekdaysParse[s] = this.weekdaysMin(
        n,
        ""
      ).toLocaleLowerCase(), this._shortWeekdaysParse[s] = this.weekdaysShort(
        n,
        ""
      ).toLocaleLowerCase(), this._weekdaysParse[s] = this.weekdays(n, "").toLocaleLowerCase();
  return t ? e === "dddd" ? (r = Ee.call(this._weekdaysParse, a), r !== -1 ? r : null) : e === "ddd" ? (r = Ee.call(this._shortWeekdaysParse, a), r !== -1 ? r : null) : (r = Ee.call(this._minWeekdaysParse, a), r !== -1 ? r : null) : e === "dddd" ? (r = Ee.call(this._weekdaysParse, a), r !== -1 || (r = Ee.call(this._shortWeekdaysParse, a), r !== -1) ? r : (r = Ee.call(this._minWeekdaysParse, a), r !== -1 ? r : null)) : e === "ddd" ? (r = Ee.call(this._shortWeekdaysParse, a), r !== -1 || (r = Ee.call(this._weekdaysParse, a), r !== -1) ? r : (r = Ee.call(this._minWeekdaysParse, a), r !== -1 ? r : null)) : (r = Ee.call(this._minWeekdaysParse, a), r !== -1 || (r = Ee.call(this._weekdaysParse, a), r !== -1) ? r : (r = Ee.call(this._shortWeekdaysParse, a), r !== -1 ? r : null));
}
function g_(i, e, t) {
  var s, r, n;
  if (this._weekdaysParseExact)
    return p_.call(this, i, e, t);
  for (this._weekdaysParse || (this._weekdaysParse = [], this._minWeekdaysParse = [], this._shortWeekdaysParse = [], this._fullWeekdaysParse = []), s = 0; s < 7; s++) {
    if (r = ri([2e3, 1]).day(s), t && !this._fullWeekdaysParse[s] && (this._fullWeekdaysParse[s] = new RegExp(
      "^" + this.weekdays(r, "").replace(".", "\\.?") + "$",
      "i"
    ), this._shortWeekdaysParse[s] = new RegExp(
      "^" + this.weekdaysShort(r, "").replace(".", "\\.?") + "$",
      "i"
    ), this._minWeekdaysParse[s] = new RegExp(
      "^" + this.weekdaysMin(r, "").replace(".", "\\.?") + "$",
      "i"
    )), this._weekdaysParse[s] || (n = "^" + this.weekdays(r, "") + "|^" + this.weekdaysShort(r, "") + "|^" + this.weekdaysMin(r, ""), this._weekdaysParse[s] = new RegExp(n.replace(".", ""), "i")), t && e === "dddd" && this._fullWeekdaysParse[s].test(i))
      return s;
    if (t && e === "ddd" && this._shortWeekdaysParse[s].test(i))
      return s;
    if (t && e === "dd" && this._minWeekdaysParse[s].test(i))
      return s;
    if (!t && this._weekdaysParse[s].test(i))
      return s;
  }
}
function __(i) {
  if (!this.isValid())
    return i != null ? this : NaN;
  var e = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
  return i != null ? (i = r_(i, this.localeData()), this.add(i - e, "d")) : e;
}
function m_(i) {
  if (!this.isValid())
    return i != null ? this : NaN;
  var e = (this.day() + 7 - this.localeData()._week.dow) % 7;
  return i == null ? e : this.add(i - e, "d");
}
function b_(i) {
  if (!this.isValid())
    return i != null ? this : NaN;
  if (i != null) {
    var e = n_(i, this.localeData());
    return this.day(this.day() % 7 ? e : e - 7);
  } else
    return this.day() || 7;
}
function y_(i) {
  return this._weekdaysParseExact ? (be(this, "_weekdaysRegex") || ql.call(this), i ? this._weekdaysStrictRegex : this._weekdaysRegex) : (be(this, "_weekdaysRegex") || (this._weekdaysRegex = l_), this._weekdaysStrictRegex && i ? this._weekdaysStrictRegex : this._weekdaysRegex);
}
function v_(i) {
  return this._weekdaysParseExact ? (be(this, "_weekdaysRegex") || ql.call(this), i ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex) : (be(this, "_weekdaysShortRegex") || (this._weekdaysShortRegex = u_), this._weekdaysShortStrictRegex && i ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex);
}
function x_(i) {
  return this._weekdaysParseExact ? (be(this, "_weekdaysRegex") || ql.call(this), i ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex) : (be(this, "_weekdaysMinRegex") || (this._weekdaysMinRegex = h_), this._weekdaysMinStrictRegex && i ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex);
}
function ql() {
  function i(c, h) {
    return h.length - c.length;
  }
  var e = [], t = [], s = [], r = [], n, a, o, l, u;
  for (n = 0; n < 7; n++)
    a = ri([2e3, 1]).day(n), o = Ct(this.weekdaysMin(a, "")), l = Ct(this.weekdaysShort(a, "")), u = Ct(this.weekdays(a, "")), e.push(o), t.push(l), s.push(u), r.push(o), r.push(l), r.push(u);
  e.sort(i), t.sort(i), s.sort(i), r.sort(i), this._weekdaysRegex = new RegExp("^(" + r.join("|") + ")", "i"), this._weekdaysShortRegex = this._weekdaysRegex, this._weekdaysMinRegex = this._weekdaysRegex, this._weekdaysStrictRegex = new RegExp(
    "^(" + s.join("|") + ")",
    "i"
  ), this._weekdaysShortStrictRegex = new RegExp(
    "^(" + t.join("|") + ")",
    "i"
  ), this._weekdaysMinStrictRegex = new RegExp(
    "^(" + e.join("|") + ")",
    "i"
  );
}
function Jl() {
  return this.hours() % 12 || 12;
}
function w_() {
  return this.hours() || 24;
}
Q("H", ["HH", 2], 0, "hour");
Q("h", ["hh", 2], 0, Jl);
Q("k", ["kk", 2], 0, w_);
Q("hmm", 0, 0, function() {
  return "" + Jl.apply(this) + ii(this.minutes(), 2);
});
Q("hmmss", 0, 0, function() {
  return "" + Jl.apply(this) + ii(this.minutes(), 2) + ii(this.seconds(), 2);
});
Q("Hmm", 0, 0, function() {
  return "" + this.hours() + ii(this.minutes(), 2);
});
Q("Hmmss", 0, 0, function() {
  return "" + this.hours() + ii(this.minutes(), 2) + ii(this.seconds(), 2);
});
function nc(i, e) {
  Q(i, 0, 0, function() {
    return this.localeData().meridiem(
      this.hours(),
      this.minutes(),
      e
    );
  });
}
nc("a", !0);
nc("A", !1);
ut("hour", "h");
ht("hour", 13);
function ac(i, e) {
  return e._meridiemParse;
}
V("a", ac);
V("A", ac);
V("H", Pe);
V("h", Pe);
V("k", Pe);
V("HH", Pe, It);
V("hh", Pe, It);
V("kk", Pe, It);
V("hmm", Zh);
V("hmmss", Kh);
V("Hmm", Zh);
V("Hmmss", Kh);
xe(["H", "HH"], Ue);
xe(["k", "kk"], function(i, e, t) {
  var s = he(i);
  e[Ue] = s === 24 ? 0 : s;
});
xe(["a", "A"], function(i, e, t) {
  t._isPm = t._locale.isPM(i), t._meridiem = i;
});
xe(["h", "hh"], function(i, e, t) {
  e[Ue] = he(i), ae(t).bigHour = !0;
});
xe("hmm", function(i, e, t) {
  var s = i.length - 2;
  e[Ue] = he(i.substr(0, s)), e[Ut] = he(i.substr(s)), ae(t).bigHour = !0;
});
xe("hmmss", function(i, e, t) {
  var s = i.length - 4, r = i.length - 2;
  e[Ue] = he(i.substr(0, s)), e[Ut] = he(i.substr(s, 2)), e[ui] = he(i.substr(r)), ae(t).bigHour = !0;
});
xe("Hmm", function(i, e, t) {
  var s = i.length - 2;
  e[Ue] = he(i.substr(0, s)), e[Ut] = he(i.substr(s));
});
xe("Hmmss", function(i, e, t) {
  var s = i.length - 4, r = i.length - 2;
  e[Ue] = he(i.substr(0, s)), e[Ut] = he(i.substr(s, 2)), e[ui] = he(i.substr(r));
});
function S_(i) {
  return (i + "").toLowerCase().charAt(0) === "p";
}
var D_ = /[ap]\.?m?\.?/i, P_ = rr("Hours", !0);
function T_(i, e, t) {
  return i > 11 ? t ? "pm" : "PM" : t ? "am" : "AM";
}
var oc = {
  calendar: gg,
  longDateFormat: yg,
  invalidDate: xg,
  ordinal: Sg,
  dayOfMonthOrdinalParse: Dg,
  relativeTime: Tg,
  months: Fg,
  monthsShort: Qh,
  week: Jg,
  weekdays: a_,
  weekdaysMin: o_,
  weekdaysShort: rc,
  meridiemParse: D_
}, Te = {}, hr = {}, Nr;
function k_(i, e) {
  var t, s = Math.min(i.length, e.length);
  for (t = 0; t < s; t += 1)
    if (i[t] !== e[t])
      return t;
  return s;
}
function ju(i) {
  return i && i.toLowerCase().replace("_", "-");
}
function C_(i) {
  for (var e = 0, t, s, r, n; e < i.length; ) {
    for (n = ju(i[e]).split("-"), t = n.length, s = ju(i[e + 1]), s = s ? s.split("-") : null; t > 0; ) {
      if (r = Fa(n.slice(0, t).join("-")), r)
        return r;
      if (s && s.length >= t && k_(n, s) >= t - 1)
        break;
      t--;
    }
    e++;
  }
  return Nr;
}
function M_(i) {
  return i.match("^[^/\\\\]*$") != null;
}
function Fa(i) {
  var e = null, t;
  if (Te[i] === void 0 && typeof module < "u" && module && module.exports && M_(i))
    try {
      e = Nr._abbr, t = require, t("./locale/" + i), Li(e);
    } catch {
      Te[i] = null;
    }
  return Te[i];
}
function Li(i, e) {
  var t;
  return i && (mt(e) ? t = bi(i) : t = eu(i, e), t ? Nr = t : typeof console < "u" && console.warn && console.warn(
    "Locale " + i + " not found. Did you forget to load it?"
  )), Nr._abbr;
}
function eu(i, e) {
  if (e !== null) {
    var t, s = oc;
    if (e.abbr = i, Te[i] != null)
      zh(
        "defineLocaleOverride",
        "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
      ), s = Te[i]._config;
    else if (e.parentLocale != null)
      if (Te[e.parentLocale] != null)
        s = Te[e.parentLocale]._config;
      else if (t = Fa(e.parentLocale), t != null)
        s = t._config;
      else
        return hr[e.parentLocale] || (hr[e.parentLocale] = []), hr[e.parentLocale].push({
          name: i,
          config: e
        }), null;
    return Te[i] = new Ul(Fo(s, e)), hr[i] && hr[i].forEach(function(r) {
      eu(r.name, r.config);
    }), Li(i), Te[i];
  } else
    return delete Te[i], null;
}
function O_(i, e) {
  if (e != null) {
    var t, s, r = oc;
    Te[i] != null && Te[i].parentLocale != null ? Te[i].set(Fo(Te[i]._config, e)) : (s = Fa(i), s != null && (r = s._config), e = Fo(r, e), s == null && (e.abbr = i), t = new Ul(e), t.parentLocale = Te[i], Te[i] = t), Li(i);
  } else
    Te[i] != null && (Te[i].parentLocale != null ? (Te[i] = Te[i].parentLocale, i === Li() && Li(i)) : Te[i] != null && delete Te[i]);
  return Te[i];
}
function bi(i) {
  var e;
  if (i && i._locale && i._locale._abbr && (i = i._locale._abbr), !i)
    return Nr;
  if (!Zt(i)) {
    if (e = Fa(i), e)
      return e;
    i = [i];
  }
  return C_(i);
}
function A_() {
  return Bo(Te);
}
function tu(i) {
  var e, t = i._a;
  return t && ae(i).overflow === -2 && (e = t[li] < 0 || t[li] > 11 ? li : t[Jt] < 1 || t[Jt] > $a(t[lt], t[li]) ? Jt : t[Ue] < 0 || t[Ue] > 24 || t[Ue] === 24 && (t[Ut] !== 0 || t[ui] !== 0 || t[os] !== 0) ? Ue : t[Ut] < 0 || t[Ut] > 59 ? Ut : t[ui] < 0 || t[ui] > 59 ? ui : t[os] < 0 || t[os] > 999 ? os : -1, ae(i)._overflowDayOfYear && (e < lt || e > Jt) && (e = Jt), ae(i)._overflowWeeks && e === -1 && (e = Rg), ae(i)._overflowWeekday && e === -1 && (e = Ng), ae(i).overflow = e), i;
}
var L_ = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, j_ = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, E_ = /Z|[+-]\d\d(?::?\d\d)?/, dn = [
  ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
  ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
  ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
  ["GGGG-[W]WW", /\d{4}-W\d\d/, !1],
  ["YYYY-DDD", /\d{4}-\d{3}/],
  ["YYYY-MM", /\d{4}-\d\d/, !1],
  ["YYYYYYMMDD", /[+-]\d{10}/],
  ["YYYYMMDD", /\d{8}/],
  ["GGGG[W]WWE", /\d{4}W\d{3}/],
  ["GGGG[W]WW", /\d{4}W\d{2}/, !1],
  ["YYYYDDD", /\d{7}/],
  ["YYYYMM", /\d{6}/, !1],
  ["YYYY", /\d{4}/, !1]
], lo = [
  ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
  ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
  ["HH:mm:ss", /\d\d:\d\d:\d\d/],
  ["HH:mm", /\d\d:\d\d/],
  ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
  ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
  ["HHmmss", /\d\d\d\d\d\d/],
  ["HHmm", /\d\d\d\d/],
  ["HH", /\d\d/]
], I_ = /^\/?Date\((-?\d+)/i, Y_ = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, R_ = {
  UT: 0,
  GMT: 0,
  EDT: -4 * 60,
  EST: -5 * 60,
  CDT: -5 * 60,
  CST: -6 * 60,
  MDT: -6 * 60,
  MST: -7 * 60,
  PDT: -7 * 60,
  PST: -8 * 60
};
function lc(i) {
  var e, t, s = i._i, r = L_.exec(s) || j_.exec(s), n, a, o, l, u = dn.length, c = lo.length;
  if (r) {
    for (ae(i).iso = !0, e = 0, t = u; e < t; e++)
      if (dn[e][1].exec(r[1])) {
        a = dn[e][0], n = dn[e][2] !== !1;
        break;
      }
    if (a == null) {
      i._isValid = !1;
      return;
    }
    if (r[3]) {
      for (e = 0, t = c; e < t; e++)
        if (lo[e][1].exec(r[3])) {
          o = (r[2] || " ") + lo[e][0];
          break;
        }
      if (o == null) {
        i._isValid = !1;
        return;
      }
    }
    if (!n && o != null) {
      i._isValid = !1;
      return;
    }
    if (r[4])
      if (E_.exec(r[4]))
        l = "Z";
      else {
        i._isValid = !1;
        return;
      }
    i._f = a + (o || "") + (l || ""), su(i);
  } else
    i._isValid = !1;
}
function N_(i, e, t, s, r, n) {
  var a = [
    $_(i),
    Qh.indexOf(e),
    parseInt(t, 10),
    parseInt(s, 10),
    parseInt(r, 10)
  ];
  return n && a.push(parseInt(n, 10)), a;
}
function $_(i) {
  var e = parseInt(i, 10);
  return e <= 49 ? 2e3 + e : e <= 999 ? 1900 + e : e;
}
function F_(i) {
  return i.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
}
function B_(i, e, t) {
  if (i) {
    var s = rc.indexOf(i), r = new Date(
      e[0],
      e[1],
      e[2]
    ).getDay();
    if (s !== r)
      return ae(t).weekdayMismatch = !0, t._isValid = !1, !1;
  }
  return !0;
}
function H_(i, e, t) {
  if (i)
    return R_[i];
  if (e)
    return 0;
  var s = parseInt(t, 10), r = s % 100, n = (s - r) / 100;
  return n * 60 + r;
}
function uc(i) {
  var e = Y_.exec(F_(i._i)), t;
  if (e) {
    if (t = N_(
      e[4],
      e[3],
      e[2],
      e[5],
      e[6],
      e[7]
    ), !B_(e[1], t, i))
      return;
    i._a = t, i._tzm = H_(e[8], e[9], e[10]), i._d = Yr.apply(null, i._a), i._d.setUTCMinutes(i._d.getUTCMinutes() - i._tzm), ae(i).rfc2822 = !0;
  } else
    i._isValid = !1;
}
function z_(i) {
  var e = I_.exec(i._i);
  if (e !== null) {
    i._d = new Date(+e[1]);
    return;
  }
  if (lc(i), i._isValid === !1)
    delete i._isValid;
  else
    return;
  if (uc(i), i._isValid === !1)
    delete i._isValid;
  else
    return;
  i._strict ? i._isValid = !1 : P.createFromInputFallback(i);
}
P.createFromInputFallback = Bt(
  "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
  function(i) {
    i._d = new Date(i._i + (i._useUTC ? " UTC" : ""));
  }
);
function Ps(i, e, t) {
  return i ?? e ?? t;
}
function X_(i) {
  var e = new Date(P.now());
  return i._useUTC ? [
    e.getUTCFullYear(),
    e.getUTCMonth(),
    e.getUTCDate()
  ] : [e.getFullYear(), e.getMonth(), e.getDate()];
}
function iu(i) {
  var e, t, s = [], r, n, a;
  if (!i._d) {
    for (r = X_(i), i._w && i._a[Jt] == null && i._a[li] == null && V_(i), i._dayOfYear != null && (a = Ps(i._a[lt], r[lt]), (i._dayOfYear > Cr(a) || i._dayOfYear === 0) && (ae(i)._overflowDayOfYear = !0), t = Yr(a, 0, i._dayOfYear), i._a[li] = t.getUTCMonth(), i._a[Jt] = t.getUTCDate()), e = 0; e < 3 && i._a[e] == null; ++e)
      i._a[e] = s[e] = r[e];
    for (; e < 7; e++)
      i._a[e] = s[e] = i._a[e] == null ? e === 2 ? 1 : 0 : i._a[e];
    i._a[Ue] === 24 && i._a[Ut] === 0 && i._a[ui] === 0 && i._a[os] === 0 && (i._nextDay = !0, i._a[Ue] = 0), i._d = (i._useUTC ? Yr : Qg).apply(
      null,
      s
    ), n = i._useUTC ? i._d.getUTCDay() : i._d.getDay(), i._tzm != null && i._d.setUTCMinutes(i._d.getUTCMinutes() - i._tzm), i._nextDay && (i._a[Ue] = 24), i._w && typeof i._w.d < "u" && i._w.d !== n && (ae(i).weekdayMismatch = !0);
  }
}
function V_(i) {
  var e, t, s, r, n, a, o, l, u;
  e = i._w, e.GG != null || e.W != null || e.E != null ? (n = 1, a = 4, t = Ps(
    e.GG,
    i._a[lt],
    Rr(De(), 1, 4).year
  ), s = Ps(e.W, 1), r = Ps(e.E, 1), (r < 1 || r > 7) && (l = !0)) : (n = i._locale._week.dow, a = i._locale._week.doy, u = Rr(De(), n, a), t = Ps(e.gg, i._a[lt], u.year), s = Ps(e.w, u.week), e.d != null ? (r = e.d, (r < 0 || r > 6) && (l = !0)) : e.e != null ? (r = e.e + n, (e.e < 0 || e.e > 6) && (l = !0)) : r = n), s < 1 || s > hi(t, n, a) ? ae(i)._overflowWeeks = !0 : l != null ? ae(i)._overflowWeekday = !0 : (o = sc(t, s, r, n, a), i._a[lt] = o.year, i._dayOfYear = o.dayOfYear);
}
P.ISO_8601 = function() {
};
P.RFC_2822 = function() {
};
function su(i) {
  if (i._f === P.ISO_8601) {
    lc(i);
    return;
  }
  if (i._f === P.RFC_2822) {
    uc(i);
    return;
  }
  i._a = [], ae(i).empty = !0;
  var e = "" + i._i, t, s, r, n, a, o = e.length, l = 0, u, c;
  for (r = Xh(i._f, i._locale).match(Wl) || [], c = r.length, t = 0; t < c; t++)
    n = r[t], s = (e.match(Eg(n, i)) || [])[0], s && (a = e.substr(0, e.indexOf(s)), a.length > 0 && ae(i).unusedInput.push(a), e = e.slice(
      e.indexOf(s) + s.length
    ), l += s.length), Es[n] ? (s ? ae(i).empty = !1 : ae(i).unusedTokens.push(n), Yg(n, s, i)) : i._strict && !s && ae(i).unusedTokens.push(n);
  ae(i).charsLeftOver = o - l, e.length > 0 && ae(i).unusedInput.push(e), i._a[Ue] <= 12 && ae(i).bigHour === !0 && i._a[Ue] > 0 && (ae(i).bigHour = void 0), ae(i).parsedDateParts = i._a.slice(0), ae(i).meridiem = i._meridiem, i._a[Ue] = U_(
    i._locale,
    i._a[Ue],
    i._meridiem
  ), u = ae(i).era, u !== null && (i._a[lt] = i._locale.erasConvertYear(u, i._a[lt])), iu(i), tu(i);
}
function U_(i, e, t) {
  var s;
  return t == null ? e : i.meridiemHour != null ? i.meridiemHour(e, t) : (i.isPM != null && (s = i.isPM(t), s && e < 12 && (e += 12), !s && e === 12 && (e = 0)), e);
}
function W_(i) {
  var e, t, s, r, n, a, o = !1, l = i._f.length;
  if (l === 0) {
    ae(i).invalidFormat = !0, i._d = new Date(NaN);
    return;
  }
  for (r = 0; r < l; r++)
    n = 0, a = !1, e = Vl({}, i), i._useUTC != null && (e._useUTC = i._useUTC), e._f = i._f[r], su(e), Xl(e) && (a = !0), n += ae(e).charsLeftOver, n += ae(e).unusedTokens.length * 10, ae(e).score = n, o ? n < s && (s = n, t = e) : (s == null || n < s || a) && (s = n, t = e, a && (o = !0));
  Di(i, t || e);
}
function G_(i) {
  if (!i._d) {
    var e = Gl(i._i), t = e.day === void 0 ? e.date : e.day;
    i._a = Bh(
      [e.year, e.month, t, e.hour, e.minute, e.second, e.millisecond],
      function(s) {
        return s && parseInt(s, 10);
      }
    ), iu(i);
  }
}
function Z_(i) {
  var e = new Jr(tu(hc(i)));
  return e._nextDay && (e.add(1, "d"), e._nextDay = void 0), e;
}
function hc(i) {
  var e = i._i, t = i._f;
  return i._locale = i._locale || bi(i._l), e === null || t === void 0 && e === "" ? La({ nullInput: !0 }) : (typeof e == "string" && (i._i = e = i._locale.preparse(e)), Kt(e) ? new Jr(tu(e)) : (qr(e) ? i._d = e : Zt(t) ? W_(i) : t ? su(i) : K_(i), Xl(i) || (i._d = null), i));
}
function K_(i) {
  var e = i._i;
  mt(e) ? i._d = new Date(P.now()) : qr(e) ? i._d = new Date(e.valueOf()) : typeof e == "string" ? z_(i) : Zt(e) ? (i._a = Bh(e.slice(0), function(t) {
    return parseInt(t, 10);
  }), iu(i)) : hs(e) ? G_(i) : fi(e) ? i._d = new Date(e) : P.createFromInputFallback(i);
}
function cc(i, e, t, s, r) {
  var n = {};
  return (e === !0 || e === !1) && (s = e, e = void 0), (t === !0 || t === !1) && (s = t, t = void 0), (hs(i) && zl(i) || Zt(i) && i.length === 0) && (i = void 0), n._isAMomentObject = !0, n._useUTC = n._isUTC = r, n._l = t, n._i = i, n._f = e, n._strict = s, Z_(n);
}
function De(i, e, t, s) {
  return cc(i, e, t, s, !1);
}
var Q_ = Bt(
  "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
  function() {
    var i = De.apply(null, arguments);
    return this.isValid() && i.isValid() ? i < this ? this : i : La();
  }
), q_ = Bt(
  "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
  function() {
    var i = De.apply(null, arguments);
    return this.isValid() && i.isValid() ? i > this ? this : i : La();
  }
);
function dc(i, e) {
  var t, s;
  if (e.length === 1 && Zt(e[0]) && (e = e[0]), !e.length)
    return De();
  for (t = e[0], s = 1; s < e.length; ++s)
    (!e[s].isValid() || e[s][i](t)) && (t = e[s]);
  return t;
}
function J_() {
  var i = [].slice.call(arguments, 0);
  return dc("isBefore", i);
}
function em() {
  var i = [].slice.call(arguments, 0);
  return dc("isAfter", i);
}
var tm = function() {
  return Date.now ? Date.now() : +new Date();
}, cr = [
  "year",
  "quarter",
  "month",
  "week",
  "day",
  "hour",
  "minute",
  "second",
  "millisecond"
];
function im(i) {
  var e, t = !1, s, r = cr.length;
  for (e in i)
    if (be(i, e) && !(Ee.call(cr, e) !== -1 && (i[e] == null || !isNaN(i[e]))))
      return !1;
  for (s = 0; s < r; ++s)
    if (i[cr[s]]) {
      if (t)
        return !1;
      parseFloat(i[cr[s]]) !== he(i[cr[s]]) && (t = !0);
    }
  return !0;
}
function sm() {
  return this._isValid;
}
function rm() {
  return Qt(NaN);
}
function Ba(i) {
  var e = Gl(i), t = e.year || 0, s = e.quarter || 0, r = e.month || 0, n = e.week || e.isoWeek || 0, a = e.day || 0, o = e.hour || 0, l = e.minute || 0, u = e.second || 0, c = e.millisecond || 0;
  this._isValid = im(e), this._milliseconds = +c + u * 1e3 + // 1000
  l * 6e4 + // 1000 * 60
  o * 1e3 * 60 * 60, this._days = +a + n * 7, this._months = +r + s * 3 + t * 12, this._data = {}, this._locale = bi(), this._bubble();
}
function Tn(i) {
  return i instanceof Ba;
}
function zo(i) {
  return i < 0 ? Math.round(-1 * i) * -1 : Math.round(i);
}
function nm(i, e, t) {
  var s = Math.min(i.length, e.length), r = Math.abs(i.length - e.length), n = 0, a;
  for (a = 0; a < s; a++)
    (t && i[a] !== e[a] || !t && he(i[a]) !== he(e[a])) && n++;
  return n + r;
}
function fc(i, e) {
  Q(i, 0, 0, function() {
    var t = this.utcOffset(), s = "+";
    return t < 0 && (t = -t, s = "-"), s + ii(~~(t / 60), 2) + e + ii(~~t % 60, 2);
  });
}
fc("Z", ":");
fc("ZZ", "");
V("Z", Na);
V("ZZ", Na);
xe(["Z", "ZZ"], function(i, e, t) {
  t._useUTC = !0, t._tzm = ru(Na, i);
});
var am = /([\+\-]|\d\d)/gi;
function ru(i, e) {
  var t = (e || "").match(i), s, r, n;
  return t === null ? null : (s = t[t.length - 1] || [], r = (s + "").match(am) || ["-", 0, 0], n = +(r[1] * 60) + he(r[2]), n === 0 ? 0 : r[0] === "+" ? n : -n);
}
function nu(i, e) {
  var t, s;
  return e._isUTC ? (t = e.clone(), s = (Kt(i) || qr(i) ? i.valueOf() : De(i).valueOf()) - t.valueOf(), t._d.setTime(t._d.valueOf() + s), P.updateOffset(t, !1), t) : De(i).local();
}
function Xo(i) {
  return -Math.round(i._d.getTimezoneOffset());
}
P.updateOffset = function() {
};
function om(i, e, t) {
  var s = this._offset || 0, r;
  if (!this.isValid())
    return i != null ? this : NaN;
  if (i != null) {
    if (typeof i == "string") {
      if (i = ru(Na, i), i === null)
        return this;
    } else
      Math.abs(i) < 16 && !t && (i = i * 60);
    return !this._isUTC && e && (r = Xo(this)), this._offset = i, this._isUTC = !0, r != null && this.add(r, "m"), s !== i && (!e || this._changeInProgress ? _c(
      this,
      Qt(i - s, "m"),
      1,
      !1
    ) : this._changeInProgress || (this._changeInProgress = !0, P.updateOffset(this, !0), this._changeInProgress = null)), this;
  } else
    return this._isUTC ? s : Xo(this);
}
function lm(i, e) {
  return i != null ? (typeof i != "string" && (i = -i), this.utcOffset(i, e), this) : -this.utcOffset();
}
function um(i) {
  return this.utcOffset(0, i);
}
function hm(i) {
  return this._isUTC && (this.utcOffset(0, i), this._isUTC = !1, i && this.subtract(Xo(this), "m")), this;
}
function cm() {
  if (this._tzm != null)
    this.utcOffset(this._tzm, !1, !0);
  else if (typeof this._i == "string") {
    var i = ru(Lg, this._i);
    i != null ? this.utcOffset(i) : this.utcOffset(0, !0);
  }
  return this;
}
function dm(i) {
  return this.isValid() ? (i = i ? De(i).utcOffset() : 0, (this.utcOffset() - i) % 60 === 0) : !1;
}
function fm() {
  return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
}
function pm() {
  if (!mt(this._isDSTShifted))
    return this._isDSTShifted;
  var i = {}, e;
  return Vl(i, this), i = hc(i), i._a ? (e = i._isUTC ? ri(i._a) : De(i._a), this._isDSTShifted = this.isValid() && nm(i._a, e.toArray()) > 0) : this._isDSTShifted = !1, this._isDSTShifted;
}
function gm() {
  return this.isValid() ? !this._isUTC : !1;
}
function _m() {
  return this.isValid() ? this._isUTC : !1;
}
function pc() {
  return this.isValid() ? this._isUTC && this._offset === 0 : !1;
}
var mm = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, bm = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
function Qt(i, e) {
  var t = i, s = null, r, n, a;
  return Tn(i) ? t = {
    ms: i._milliseconds,
    d: i._days,
    M: i._months
  } : fi(i) || !isNaN(+i) ? (t = {}, e ? t[e] = +i : t.milliseconds = +i) : (s = mm.exec(i)) ? (r = s[1] === "-" ? -1 : 1, t = {
    y: 0,
    d: he(s[Jt]) * r,
    h: he(s[Ue]) * r,
    m: he(s[Ut]) * r,
    s: he(s[ui]) * r,
    ms: he(zo(s[os] * 1e3)) * r
    // the millisecond decimal point is included in the match
  }) : (s = bm.exec(i)) ? (r = s[1] === "-" ? -1 : 1, t = {
    y: qi(s[2], r),
    M: qi(s[3], r),
    w: qi(s[4], r),
    d: qi(s[5], r),
    h: qi(s[6], r),
    m: qi(s[7], r),
    s: qi(s[8], r)
  }) : t == null ? t = {} : typeof t == "object" && ("from" in t || "to" in t) && (a = ym(
    De(t.from),
    De(t.to)
  ), t = {}, t.ms = a.milliseconds, t.M = a.months), n = new Ba(t), Tn(i) && be(i, "_locale") && (n._locale = i._locale), Tn(i) && be(i, "_isValid") && (n._isValid = i._isValid), n;
}
Qt.fn = Ba.prototype;
Qt.invalid = rm;
function qi(i, e) {
  var t = i && parseFloat(i.replace(",", "."));
  return (isNaN(t) ? 0 : t) * e;
}
function Eu(i, e) {
  var t = {};
  return t.months = e.month() - i.month() + (e.year() - i.year()) * 12, i.clone().add(t.months, "M").isAfter(e) && --t.months, t.milliseconds = +e - +i.clone().add(t.months, "M"), t;
}
function ym(i, e) {
  var t;
  return i.isValid() && e.isValid() ? (e = nu(e, i), i.isBefore(e) ? t = Eu(i, e) : (t = Eu(e, i), t.milliseconds = -t.milliseconds, t.months = -t.months), t) : { milliseconds: 0, months: 0 };
}
function gc(i, e) {
  return function(t, s) {
    var r, n;
    return s !== null && !isNaN(+s) && (zh(
      e,
      "moment()." + e + "(period, number) is deprecated. Please use moment()." + e + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."
    ), n = t, t = s, s = n), r = Qt(t, s), _c(this, r, i), this;
  };
}
function _c(i, e, t, s) {
  var r = e._milliseconds, n = zo(e._days), a = zo(e._months);
  i.isValid() && (s = s ?? !0, a && Jh(i, $n(i, "Month") + a * t), n && Uh(i, "Date", $n(i, "Date") + n * t), r && i._d.setTime(i._d.valueOf() + r * t), s && P.updateOffset(i, n || a));
}
var vm = gc(1, "add"), xm = gc(-1, "subtract");
function mc(i) {
  return typeof i == "string" || i instanceof String;
}
function wm(i) {
  return Kt(i) || qr(i) || mc(i) || fi(i) || Dm(i) || Sm(i) || i === null || i === void 0;
}
function Sm(i) {
  var e = hs(i) && !zl(i), t = !1, s = [
    "years",
    "year",
    "y",
    "months",
    "month",
    "M",
    "days",
    "day",
    "d",
    "dates",
    "date",
    "D",
    "hours",
    "hour",
    "h",
    "minutes",
    "minute",
    "m",
    "seconds",
    "second",
    "s",
    "milliseconds",
    "millisecond",
    "ms"
  ], r, n, a = s.length;
  for (r = 0; r < a; r += 1)
    n = s[r], t = t || be(i, n);
  return e && t;
}
function Dm(i) {
  var e = Zt(i), t = !1;
  return e && (t = i.filter(function(s) {
    return !fi(s) && mc(i);
  }).length === 0), e && t;
}
function Pm(i) {
  var e = hs(i) && !zl(i), t = !1, s = [
    "sameDay",
    "nextDay",
    "lastDay",
    "nextWeek",
    "lastWeek",
    "sameElse"
  ], r, n;
  for (r = 0; r < s.length; r += 1)
    n = s[r], t = t || be(i, n);
  return e && t;
}
function Tm(i, e) {
  var t = i.diff(e, "days", !0);
  return t < -6 ? "sameElse" : t < -1 ? "lastWeek" : t < 0 ? "lastDay" : t < 1 ? "sameDay" : t < 2 ? "nextDay" : t < 7 ? "nextWeek" : "sameElse";
}
function km(i, e) {
  arguments.length === 1 && (arguments[0] ? wm(arguments[0]) ? (i = arguments[0], e = void 0) : Pm(arguments[0]) && (e = arguments[0], i = void 0) : (i = void 0, e = void 0));
  var t = i || De(), s = nu(t, this).startOf("day"), r = P.calendarFormat(this, s) || "sameElse", n = e && (ni(e[r]) ? e[r].call(this, t) : e[r]);
  return this.format(
    n || this.localeData().calendar(r, this, De(t))
  );
}
function Cm() {
  return new Jr(this);
}
function Mm(i, e) {
  var t = Kt(i) ? i : De(i);
  return this.isValid() && t.isValid() ? (e = Ht(e) || "millisecond", e === "millisecond" ? this.valueOf() > t.valueOf() : t.valueOf() < this.clone().startOf(e).valueOf()) : !1;
}
function Om(i, e) {
  var t = Kt(i) ? i : De(i);
  return this.isValid() && t.isValid() ? (e = Ht(e) || "millisecond", e === "millisecond" ? this.valueOf() < t.valueOf() : this.clone().endOf(e).valueOf() < t.valueOf()) : !1;
}
function Am(i, e, t, s) {
  var r = Kt(i) ? i : De(i), n = Kt(e) ? e : De(e);
  return this.isValid() && r.isValid() && n.isValid() ? (s = s || "()", (s[0] === "(" ? this.isAfter(r, t) : !this.isBefore(r, t)) && (s[1] === ")" ? this.isBefore(n, t) : !this.isAfter(n, t))) : !1;
}
function Lm(i, e) {
  var t = Kt(i) ? i : De(i), s;
  return this.isValid() && t.isValid() ? (e = Ht(e) || "millisecond", e === "millisecond" ? this.valueOf() === t.valueOf() : (s = t.valueOf(), this.clone().startOf(e).valueOf() <= s && s <= this.clone().endOf(e).valueOf())) : !1;
}
function jm(i, e) {
  return this.isSame(i, e) || this.isAfter(i, e);
}
function Em(i, e) {
  return this.isSame(i, e) || this.isBefore(i, e);
}
function Im(i, e, t) {
  var s, r, n;
  if (!this.isValid())
    return NaN;
  if (s = nu(i, this), !s.isValid())
    return NaN;
  switch (r = (s.utcOffset() - this.utcOffset()) * 6e4, e = Ht(e), e) {
    case "year":
      n = kn(this, s) / 12;
      break;
    case "month":
      n = kn(this, s);
      break;
    case "quarter":
      n = kn(this, s) / 3;
      break;
    case "second":
      n = (this - s) / 1e3;
      break;
    case "minute":
      n = (this - s) / 6e4;
      break;
    case "hour":
      n = (this - s) / 36e5;
      break;
    case "day":
      n = (this - s - r) / 864e5;
      break;
    case "week":
      n = (this - s - r) / 6048e5;
      break;
    default:
      n = this - s;
  }
  return t ? n : Rt(n);
}
function kn(i, e) {
  if (i.date() < e.date())
    return -kn(e, i);
  var t = (e.year() - i.year()) * 12 + (e.month() - i.month()), s = i.clone().add(t, "months"), r, n;
  return e - s < 0 ? (r = i.clone().add(t - 1, "months"), n = (e - s) / (s - r)) : (r = i.clone().add(t + 1, "months"), n = (e - s) / (r - s)), -(t + n) || 0;
}
P.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
P.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
function Ym() {
  return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
}
function Rm(i) {
  if (!this.isValid())
    return null;
  var e = i !== !0, t = e ? this.clone().utc() : this;
  return t.year() < 0 || t.year() > 9999 ? Pn(
    t,
    e ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"
  ) : ni(Date.prototype.toISOString) ? e ? this.toDate().toISOString() : new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", Pn(t, "Z")) : Pn(
    t,
    e ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ"
  );
}
function Nm() {
  if (!this.isValid())
    return "moment.invalid(/* " + this._i + " */)";
  var i = "moment", e = "", t, s, r, n;
  return this.isLocal() || (i = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone", e = "Z"), t = "[" + i + '("]', s = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY", r = "-MM-DD[T]HH:mm:ss.SSS", n = e + '[")]', this.format(t + s + r + n);
}
function $m(i) {
  i || (i = this.isUtc() ? P.defaultFormatUtc : P.defaultFormat);
  var e = Pn(this, i);
  return this.localeData().postformat(e);
}
function Fm(i, e) {
  return this.isValid() && (Kt(i) && i.isValid() || De(i).isValid()) ? Qt({ to: this, from: i }).locale(this.locale()).humanize(!e) : this.localeData().invalidDate();
}
function Bm(i) {
  return this.from(De(), i);
}
function Hm(i, e) {
  return this.isValid() && (Kt(i) && i.isValid() || De(i).isValid()) ? Qt({ from: this, to: i }).locale(this.locale()).humanize(!e) : this.localeData().invalidDate();
}
function zm(i) {
  return this.to(De(), i);
}
function bc(i) {
  var e;
  return i === void 0 ? this._locale._abbr : (e = bi(i), e != null && (this._locale = e), this);
}
var yc = Bt(
  "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
  function(i) {
    return i === void 0 ? this.localeData() : this.locale(i);
  }
);
function vc() {
  return this._locale;
}
var Hn = 1e3, Is = 60 * Hn, zn = 60 * Is, xc = (365 * 400 + 97) * 24 * zn;
function Ys(i, e) {
  return (i % e + e) % e;
}
function wc(i, e, t) {
  return i < 100 && i >= 0 ? new Date(i + 400, e, t) - xc : new Date(i, e, t).valueOf();
}
function Sc(i, e, t) {
  return i < 100 && i >= 0 ? Date.UTC(i + 400, e, t) - xc : Date.UTC(i, e, t);
}
function Xm(i) {
  var e, t;
  if (i = Ht(i), i === void 0 || i === "millisecond" || !this.isValid())
    return this;
  switch (t = this._isUTC ? Sc : wc, i) {
    case "year":
      e = t(this.year(), 0, 1);
      break;
    case "quarter":
      e = t(
        this.year(),
        this.month() - this.month() % 3,
        1
      );
      break;
    case "month":
      e = t(this.year(), this.month(), 1);
      break;
    case "week":
      e = t(
        this.year(),
        this.month(),
        this.date() - this.weekday()
      );
      break;
    case "isoWeek":
      e = t(
        this.year(),
        this.month(),
        this.date() - (this.isoWeekday() - 1)
      );
      break;
    case "day":
    case "date":
      e = t(this.year(), this.month(), this.date());
      break;
    case "hour":
      e = this._d.valueOf(), e -= Ys(
        e + (this._isUTC ? 0 : this.utcOffset() * Is),
        zn
      );
      break;
    case "minute":
      e = this._d.valueOf(), e -= Ys(e, Is);
      break;
    case "second":
      e = this._d.valueOf(), e -= Ys(e, Hn);
      break;
  }
  return this._d.setTime(e), P.updateOffset(this, !0), this;
}
function Vm(i) {
  var e, t;
  if (i = Ht(i), i === void 0 || i === "millisecond" || !this.isValid())
    return this;
  switch (t = this._isUTC ? Sc : wc, i) {
    case "year":
      e = t(this.year() + 1, 0, 1) - 1;
      break;
    case "quarter":
      e = t(
        this.year(),
        this.month() - this.month() % 3 + 3,
        1
      ) - 1;
      break;
    case "month":
      e = t(this.year(), this.month() + 1, 1) - 1;
      break;
    case "week":
      e = t(
        this.year(),
        this.month(),
        this.date() - this.weekday() + 7
      ) - 1;
      break;
    case "isoWeek":
      e = t(
        this.year(),
        this.month(),
        this.date() - (this.isoWeekday() - 1) + 7
      ) - 1;
      break;
    case "day":
    case "date":
      e = t(this.year(), this.month(), this.date() + 1) - 1;
      break;
    case "hour":
      e = this._d.valueOf(), e += zn - Ys(
        e + (this._isUTC ? 0 : this.utcOffset() * Is),
        zn
      ) - 1;
      break;
    case "minute":
      e = this._d.valueOf(), e += Is - Ys(e, Is) - 1;
      break;
    case "second":
      e = this._d.valueOf(), e += Hn - Ys(e, Hn) - 1;
      break;
  }
  return this._d.setTime(e), P.updateOffset(this, !0), this;
}
function Um() {
  return this._d.valueOf() - (this._offset || 0) * 6e4;
}
function Wm() {
  return Math.floor(this.valueOf() / 1e3);
}
function Gm() {
  return new Date(this.valueOf());
}
function Zm() {
  var i = this;
  return [
    i.year(),
    i.month(),
    i.date(),
    i.hour(),
    i.minute(),
    i.second(),
    i.millisecond()
  ];
}
function Km() {
  var i = this;
  return {
    years: i.year(),
    months: i.month(),
    date: i.date(),
    hours: i.hours(),
    minutes: i.minutes(),
    seconds: i.seconds(),
    milliseconds: i.milliseconds()
  };
}
function Qm() {
  return this.isValid() ? this.toISOString() : null;
}
function qm() {
  return Xl(this);
}
function Jm() {
  return Di({}, ae(this));
}
function eb() {
  return ae(this).overflow;
}
function tb() {
  return {
    input: this._i,
    format: this._f,
    locale: this._locale,
    isUTC: this._isUTC,
    strict: this._strict
  };
}
Q("N", 0, 0, "eraAbbr");
Q("NN", 0, 0, "eraAbbr");
Q("NNN", 0, 0, "eraAbbr");
Q("NNNN", 0, 0, "eraName");
Q("NNNNN", 0, 0, "eraNarrow");
Q("y", ["y", 1], "yo", "eraYear");
Q("y", ["yy", 2], 0, "eraYear");
Q("y", ["yyy", 3], 0, "eraYear");
Q("y", ["yyyy", 4], 0, "eraYear");
V("N", au);
V("NN", au);
V("NNN", au);
V("NNNN", db);
V("NNNNN", fb);
xe(
  ["N", "NN", "NNN", "NNNN", "NNNNN"],
  function(i, e, t, s) {
    var r = t._locale.erasParse(i, s, t._strict);
    r ? ae(t).era = r : ae(t).invalidEra = i;
  }
);
V("y", nr);
V("yy", nr);
V("yyy", nr);
V("yyyy", nr);
V("yo", pb);
xe(["y", "yy", "yyy", "yyyy"], lt);
xe(["yo"], function(i, e, t, s) {
  var r;
  t._locale._eraYearOrdinalRegex && (r = i.match(t._locale._eraYearOrdinalRegex)), t._locale.eraYearOrdinalParse ? e[lt] = t._locale.eraYearOrdinalParse(i, r) : e[lt] = parseInt(i, 10);
});
function ib(i, e) {
  var t, s, r, n = this._eras || bi("en")._eras;
  for (t = 0, s = n.length; t < s; ++t) {
    switch (typeof n[t].since) {
      case "string":
        r = P(n[t].since).startOf("day"), n[t].since = r.valueOf();
        break;
    }
    switch (typeof n[t].until) {
      case "undefined":
        n[t].until = 1 / 0;
        break;
      case "string":
        r = P(n[t].until).startOf("day").valueOf(), n[t].until = r.valueOf();
        break;
    }
  }
  return n;
}
function sb(i, e, t) {
  var s, r, n = this.eras(), a, o, l;
  for (i = i.toUpperCase(), s = 0, r = n.length; s < r; ++s)
    if (a = n[s].name.toUpperCase(), o = n[s].abbr.toUpperCase(), l = n[s].narrow.toUpperCase(), t)
      switch (e) {
        case "N":
        case "NN":
        case "NNN":
          if (o === i)
            return n[s];
          break;
        case "NNNN":
          if (a === i)
            return n[s];
          break;
        case "NNNNN":
          if (l === i)
            return n[s];
          break;
      }
    else if ([a, o, l].indexOf(i) >= 0)
      return n[s];
}
function rb(i, e) {
  var t = i.since <= i.until ? 1 : -1;
  return e === void 0 ? P(i.since).year() : P(i.since).year() + (e - i.offset) * t;
}
function nb() {
  var i, e, t, s = this.localeData().eras();
  for (i = 0, e = s.length; i < e; ++i)
    if (t = this.clone().startOf("day").valueOf(), s[i].since <= t && t <= s[i].until || s[i].until <= t && t <= s[i].since)
      return s[i].name;
  return "";
}
function ab() {
  var i, e, t, s = this.localeData().eras();
  for (i = 0, e = s.length; i < e; ++i)
    if (t = this.clone().startOf("day").valueOf(), s[i].since <= t && t <= s[i].until || s[i].until <= t && t <= s[i].since)
      return s[i].narrow;
  return "";
}
function ob() {
  var i, e, t, s = this.localeData().eras();
  for (i = 0, e = s.length; i < e; ++i)
    if (t = this.clone().startOf("day").valueOf(), s[i].since <= t && t <= s[i].until || s[i].until <= t && t <= s[i].since)
      return s[i].abbr;
  return "";
}
function lb() {
  var i, e, t, s, r = this.localeData().eras();
  for (i = 0, e = r.length; i < e; ++i)
    if (t = r[i].since <= r[i].until ? 1 : -1, s = this.clone().startOf("day").valueOf(), r[i].since <= s && s <= r[i].until || r[i].until <= s && s <= r[i].since)
      return (this.year() - P(r[i].since).year()) * t + r[i].offset;
  return this.year();
}
function ub(i) {
  return be(this, "_erasNameRegex") || ou.call(this), i ? this._erasNameRegex : this._erasRegex;
}
function hb(i) {
  return be(this, "_erasAbbrRegex") || ou.call(this), i ? this._erasAbbrRegex : this._erasRegex;
}
function cb(i) {
  return be(this, "_erasNarrowRegex") || ou.call(this), i ? this._erasNarrowRegex : this._erasRegex;
}
function au(i, e) {
  return e.erasAbbrRegex(i);
}
function db(i, e) {
  return e.erasNameRegex(i);
}
function fb(i, e) {
  return e.erasNarrowRegex(i);
}
function pb(i, e) {
  return e._eraYearOrdinalRegex || nr;
}
function ou() {
  var i = [], e = [], t = [], s = [], r, n, a = this.eras();
  for (r = 0, n = a.length; r < n; ++r)
    e.push(Ct(a[r].name)), i.push(Ct(a[r].abbr)), t.push(Ct(a[r].narrow)), s.push(Ct(a[r].name)), s.push(Ct(a[r].abbr)), s.push(Ct(a[r].narrow));
  this._erasRegex = new RegExp("^(" + s.join("|") + ")", "i"), this._erasNameRegex = new RegExp("^(" + e.join("|") + ")", "i"), this._erasAbbrRegex = new RegExp("^(" + i.join("|") + ")", "i"), this._erasNarrowRegex = new RegExp(
    "^(" + t.join("|") + ")",
    "i"
  );
}
Q(0, ["gg", 2], 0, function() {
  return this.weekYear() % 100;
});
Q(0, ["GG", 2], 0, function() {
  return this.isoWeekYear() % 100;
});
function Ha(i, e) {
  Q(0, [i, i.length], 0, e);
}
Ha("gggg", "weekYear");
Ha("ggggg", "weekYear");
Ha("GGGG", "isoWeekYear");
Ha("GGGGG", "isoWeekYear");
ut("weekYear", "gg");
ut("isoWeekYear", "GG");
ht("weekYear", 1);
ht("isoWeekYear", 1);
V("G", Ra);
V("g", Ra);
V("GG", Pe, It);
V("gg", Pe, It);
V("GGGG", Kl, Zl);
V("gggg", Kl, Zl);
V("GGGGG", Ya, Ea);
V("ggggg", Ya, Ea);
tn(
  ["gggg", "ggggg", "GGGG", "GGGGG"],
  function(i, e, t, s) {
    e[s.substr(0, 2)] = he(i);
  }
);
tn(["gg", "GG"], function(i, e, t, s) {
  e[s] = P.parseTwoDigitYear(i);
});
function gb(i) {
  return Dc.call(
    this,
    i,
    this.week(),
    this.weekday(),
    this.localeData()._week.dow,
    this.localeData()._week.doy
  );
}
function _b(i) {
  return Dc.call(
    this,
    i,
    this.isoWeek(),
    this.isoWeekday(),
    1,
    4
  );
}
function mb() {
  return hi(this.year(), 1, 4);
}
function bb() {
  return hi(this.isoWeekYear(), 1, 4);
}
function yb() {
  var i = this.localeData()._week;
  return hi(this.year(), i.dow, i.doy);
}
function vb() {
  var i = this.localeData()._week;
  return hi(this.weekYear(), i.dow, i.doy);
}
function Dc(i, e, t, s, r) {
  var n;
  return i == null ? Rr(this, s, r).year : (n = hi(i, s, r), e > n && (e = n), xb.call(this, i, e, t, s, r));
}
function xb(i, e, t, s, r) {
  var n = sc(i, e, t, s, r), a = Yr(n.year, 0, n.dayOfYear);
  return this.year(a.getUTCFullYear()), this.month(a.getUTCMonth()), this.date(a.getUTCDate()), this;
}
Q("Q", 0, "Qo", "quarter");
ut("quarter", "Q");
ht("quarter", 7);
V("Q", Wh);
xe("Q", function(i, e) {
  e[li] = (he(i) - 1) * 3;
});
function wb(i) {
  return i == null ? Math.ceil((this.month() + 1) / 3) : this.month((i - 1) * 3 + this.month() % 3);
}
Q("D", ["DD", 2], "Do", "date");
ut("date", "D");
ht("date", 9);
V("D", Pe);
V("DD", Pe, It);
V("Do", function(i, e) {
  return i ? e._dayOfMonthOrdinalParse || e._ordinalParse : e._dayOfMonthOrdinalParseLenient;
});
xe(["D", "DD"], Jt);
xe("Do", function(i, e) {
  e[Jt] = he(i.match(Pe)[0]);
});
var Pc = rr("Date", !0);
Q("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
ut("dayOfYear", "DDD");
ht("dayOfYear", 4);
V("DDD", Ia);
V("DDDD", Gh);
xe(["DDD", "DDDD"], function(i, e, t) {
  t._dayOfYear = he(i);
});
function Sb(i) {
  var e = Math.round(
    (this.clone().startOf("day") - this.clone().startOf("year")) / 864e5
  ) + 1;
  return i == null ? e : this.add(i - e, "d");
}
Q("m", ["mm", 2], 0, "minute");
ut("minute", "m");
ht("minute", 14);
V("m", Pe);
V("mm", Pe, It);
xe(["m", "mm"], Ut);
var Db = rr("Minutes", !1);
Q("s", ["ss", 2], 0, "second");
ut("second", "s");
ht("second", 15);
V("s", Pe);
V("ss", Pe, It);
xe(["s", "ss"], ui);
var Pb = rr("Seconds", !1);
Q("S", 0, 0, function() {
  return ~~(this.millisecond() / 100);
});
Q(0, ["SS", 2], 0, function() {
  return ~~(this.millisecond() / 10);
});
Q(0, ["SSS", 3], 0, "millisecond");
Q(0, ["SSSS", 4], 0, function() {
  return this.millisecond() * 10;
});
Q(0, ["SSSSS", 5], 0, function() {
  return this.millisecond() * 100;
});
Q(0, ["SSSSSS", 6], 0, function() {
  return this.millisecond() * 1e3;
});
Q(0, ["SSSSSSS", 7], 0, function() {
  return this.millisecond() * 1e4;
});
Q(0, ["SSSSSSSS", 8], 0, function() {
  return this.millisecond() * 1e5;
});
Q(0, ["SSSSSSSSS", 9], 0, function() {
  return this.millisecond() * 1e6;
});
ut("millisecond", "ms");
ht("millisecond", 16);
V("S", Ia, Wh);
V("SS", Ia, It);
V("SSS", Ia, Gh);
var Pi, Tc;
for (Pi = "SSSS"; Pi.length <= 9; Pi += "S")
  V(Pi, nr);
function Tb(i, e) {
  e[os] = he(("0." + i) * 1e3);
}
for (Pi = "S"; Pi.length <= 9; Pi += "S")
  xe(Pi, Tb);
Tc = rr("Milliseconds", !1);
Q("z", 0, 0, "zoneAbbr");
Q("zz", 0, 0, "zoneName");
function kb() {
  return this._isUTC ? "UTC" : "";
}
function Cb() {
  return this._isUTC ? "Coordinated Universal Time" : "";
}
var I = Jr.prototype;
I.add = vm;
I.calendar = km;
I.clone = Cm;
I.diff = Im;
I.endOf = Vm;
I.format = $m;
I.from = Fm;
I.fromNow = Bm;
I.to = Hm;
I.toNow = zm;
I.get = Og;
I.invalidAt = eb;
I.isAfter = Mm;
I.isBefore = Om;
I.isBetween = Am;
I.isSame = Lm;
I.isSameOrAfter = jm;
I.isSameOrBefore = Em;
I.isValid = qm;
I.lang = yc;
I.locale = bc;
I.localeData = vc;
I.max = q_;
I.min = Q_;
I.parsingFlags = Jm;
I.set = Ag;
I.startOf = Xm;
I.subtract = xm;
I.toArray = Zm;
I.toObject = Km;
I.toDate = Gm;
I.toISOString = Rm;
I.inspect = Nm;
typeof Symbol < "u" && Symbol.for != null && (I[Symbol.for("nodejs.util.inspect.custom")] = function() {
  return "Moment<" + this.format() + ">";
});
I.toJSON = Qm;
I.toString = Ym;
I.unix = Wm;
I.valueOf = Um;
I.creationData = tb;
I.eraName = nb;
I.eraNarrow = ab;
I.eraAbbr = ob;
I.eraYear = lb;
I.year = ic;
I.isLeapYear = Kg;
I.weekYear = gb;
I.isoWeekYear = _b;
I.quarter = I.quarters = wb;
I.month = ec;
I.daysInMonth = Wg;
I.week = I.weeks = i_;
I.isoWeek = I.isoWeeks = s_;
I.weeksInYear = yb;
I.weeksInWeekYear = vb;
I.isoWeeksInYear = mb;
I.isoWeeksInISOWeekYear = bb;
I.date = Pc;
I.day = I.days = __;
I.weekday = m_;
I.isoWeekday = b_;
I.dayOfYear = Sb;
I.hour = I.hours = P_;
I.minute = I.minutes = Db;
I.second = I.seconds = Pb;
I.millisecond = I.milliseconds = Tc;
I.utcOffset = om;
I.utc = um;
I.local = hm;
I.parseZone = cm;
I.hasAlignedHourOffset = dm;
I.isDST = fm;
I.isLocal = gm;
I.isUtcOffset = _m;
I.isUtc = pc;
I.isUTC = pc;
I.zoneAbbr = kb;
I.zoneName = Cb;
I.dates = Bt(
  "dates accessor is deprecated. Use date instead.",
  Pc
);
I.months = Bt(
  "months accessor is deprecated. Use month instead",
  ec
);
I.years = Bt(
  "years accessor is deprecated. Use year instead",
  ic
);
I.zone = Bt(
  "moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
  lm
);
I.isDSTShifted = Bt(
  "isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
  pm
);
function Mb(i) {
  return De(i * 1e3);
}
function Ob() {
  return De.apply(null, arguments).parseZone();
}
function kc(i) {
  return i;
}
var ye = Ul.prototype;
ye.calendar = _g;
ye.longDateFormat = vg;
ye.invalidDate = wg;
ye.ordinal = Pg;
ye.preparse = kc;
ye.postformat = kc;
ye.relativeTime = kg;
ye.pastFuture = Cg;
ye.set = pg;
ye.eras = ib;
ye.erasParse = sb;
ye.erasConvertYear = rb;
ye.erasAbbrRegex = hb;
ye.erasNameRegex = ub;
ye.erasNarrowRegex = cb;
ye.months = zg;
ye.monthsShort = Xg;
ye.monthsParse = Ug;
ye.monthsRegex = Zg;
ye.monthsShortRegex = Gg;
ye.week = qg;
ye.firstDayOfYear = t_;
ye.firstDayOfWeek = e_;
ye.weekdays = c_;
ye.weekdaysMin = f_;
ye.weekdaysShort = d_;
ye.weekdaysParse = g_;
ye.weekdaysRegex = y_;
ye.weekdaysShortRegex = v_;
ye.weekdaysMinRegex = x_;
ye.isPM = S_;
ye.meridiem = T_;
function Xn(i, e, t, s) {
  var r = bi(), n = ri().set(s, e);
  return r[t](n, i);
}
function Cc(i, e, t) {
  if (fi(i) && (e = i, i = void 0), i = i || "", e != null)
    return Xn(i, e, t, "month");
  var s, r = [];
  for (s = 0; s < 12; s++)
    r[s] = Xn(i, s, t, "month");
  return r;
}
function lu(i, e, t, s) {
  typeof i == "boolean" ? (fi(e) && (t = e, e = void 0), e = e || "") : (e = i, t = e, i = !1, fi(e) && (t = e, e = void 0), e = e || "");
  var r = bi(), n = i ? r._week.dow : 0, a, o = [];
  if (t != null)
    return Xn(e, (t + n) % 7, s, "day");
  for (a = 0; a < 7; a++)
    o[a] = Xn(e, (a + n) % 7, s, "day");
  return o;
}
function Ab(i, e) {
  return Cc(i, e, "months");
}
function Lb(i, e) {
  return Cc(i, e, "monthsShort");
}
function jb(i, e, t) {
  return lu(i, e, t, "weekdays");
}
function Eb(i, e, t) {
  return lu(i, e, t, "weekdaysShort");
}
function Ib(i, e, t) {
  return lu(i, e, t, "weekdaysMin");
}
Li("en", {
  eras: [
    {
      since: "0001-01-01",
      until: 1 / 0,
      offset: 1,
      name: "Anno Domini",
      narrow: "AD",
      abbr: "AD"
    },
    {
      since: "0000-12-31",
      until: -1 / 0,
      offset: 1,
      name: "Before Christ",
      narrow: "BC",
      abbr: "BC"
    }
  ],
  dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
  ordinal: function(i) {
    var e = i % 10, t = he(i % 100 / 10) === 1 ? "th" : e === 1 ? "st" : e === 2 ? "nd" : e === 3 ? "rd" : "th";
    return i + t;
  }
});
P.lang = Bt(
  "moment.lang is deprecated. Use moment.locale instead.",
  Li
);
P.langData = Bt(
  "moment.langData is deprecated. Use moment.localeData instead.",
  bi
);
var ai = Math.abs;
function Yb() {
  var i = this._data;
  return this._milliseconds = ai(this._milliseconds), this._days = ai(this._days), this._months = ai(this._months), i.milliseconds = ai(i.milliseconds), i.seconds = ai(i.seconds), i.minutes = ai(i.minutes), i.hours = ai(i.hours), i.months = ai(i.months), i.years = ai(i.years), this;
}
function Mc(i, e, t, s) {
  var r = Qt(e, t);
  return i._milliseconds += s * r._milliseconds, i._days += s * r._days, i._months += s * r._months, i._bubble();
}
function Rb(i, e) {
  return Mc(this, i, e, 1);
}
function Nb(i, e) {
  return Mc(this, i, e, -1);
}
function Iu(i) {
  return i < 0 ? Math.floor(i) : Math.ceil(i);
}
function $b() {
  var i = this._milliseconds, e = this._days, t = this._months, s = this._data, r, n, a, o, l;
  return i >= 0 && e >= 0 && t >= 0 || i <= 0 && e <= 0 && t <= 0 || (i += Iu(Vo(t) + e) * 864e5, e = 0, t = 0), s.milliseconds = i % 1e3, r = Rt(i / 1e3), s.seconds = r % 60, n = Rt(r / 60), s.minutes = n % 60, a = Rt(n / 60), s.hours = a % 24, e += Rt(a / 24), l = Rt(Oc(e)), t += l, e -= Iu(Vo(l)), o = Rt(t / 12), t %= 12, s.days = e, s.months = t, s.years = o, this;
}
function Oc(i) {
  return i * 4800 / 146097;
}
function Vo(i) {
  return i * 146097 / 4800;
}
function Fb(i) {
  if (!this.isValid())
    return NaN;
  var e, t, s = this._milliseconds;
  if (i = Ht(i), i === "month" || i === "quarter" || i === "year")
    switch (e = this._days + s / 864e5, t = this._months + Oc(e), i) {
      case "month":
        return t;
      case "quarter":
        return t / 3;
      case "year":
        return t / 12;
    }
  else
    switch (e = this._days + Math.round(Vo(this._months)), i) {
      case "week":
        return e / 7 + s / 6048e5;
      case "day":
        return e + s / 864e5;
      case "hour":
        return e * 24 + s / 36e5;
      case "minute":
        return e * 1440 + s / 6e4;
      case "second":
        return e * 86400 + s / 1e3;
      case "millisecond":
        return Math.floor(e * 864e5) + s;
      default:
        throw new Error("Unknown unit " + i);
    }
}
function Bb() {
  return this.isValid() ? this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + he(this._months / 12) * 31536e6 : NaN;
}
function yi(i) {
  return function() {
    return this.as(i);
  };
}
var Hb = yi("ms"), zb = yi("s"), Xb = yi("m"), Vb = yi("h"), Ub = yi("d"), Wb = yi("w"), Gb = yi("M"), Zb = yi("Q"), Kb = yi("y");
function Qb() {
  return Qt(this);
}
function qb(i) {
  return i = Ht(i), this.isValid() ? this[i + "s"]() : NaN;
}
function bs(i) {
  return function() {
    return this.isValid() ? this._data[i] : NaN;
  };
}
var Jb = bs("milliseconds"), ey = bs("seconds"), ty = bs("minutes"), iy = bs("hours"), sy = bs("days"), ry = bs("months"), ny = bs("years");
function ay() {
  return Rt(this.days() / 7);
}
var oi = Math.round, Ms = {
  ss: 44,
  // a few seconds to seconds
  s: 45,
  // seconds to minute
  m: 45,
  // minutes to hour
  h: 22,
  // hours to day
  d: 26,
  // days to month/week
  w: null,
  // weeks to month
  M: 11
  // months to year
};
function oy(i, e, t, s, r) {
  return r.relativeTime(e || 1, !!t, i, s);
}
function ly(i, e, t, s) {
  var r = Qt(i).abs(), n = oi(r.as("s")), a = oi(r.as("m")), o = oi(r.as("h")), l = oi(r.as("d")), u = oi(r.as("M")), c = oi(r.as("w")), h = oi(r.as("y")), d = n <= t.ss && ["s", n] || n < t.s && ["ss", n] || a <= 1 && ["m"] || a < t.m && ["mm", a] || o <= 1 && ["h"] || o < t.h && ["hh", o] || l <= 1 && ["d"] || l < t.d && ["dd", l];
  return t.w != null && (d = d || c <= 1 && ["w"] || c < t.w && ["ww", c]), d = d || u <= 1 && ["M"] || u < t.M && ["MM", u] || h <= 1 && ["y"] || ["yy", h], d[2] = e, d[3] = +i > 0, d[4] = s, oy.apply(null, d);
}
function uy(i) {
  return i === void 0 ? oi : typeof i == "function" ? (oi = i, !0) : !1;
}
function hy(i, e) {
  return Ms[i] === void 0 ? !1 : e === void 0 ? Ms[i] : (Ms[i] = e, i === "s" && (Ms.ss = e - 1), !0);
}
function cy(i, e) {
  if (!this.isValid())
    return this.localeData().invalidDate();
  var t = !1, s = Ms, r, n;
  return typeof i == "object" && (e = i, i = !1), typeof i == "boolean" && (t = i), typeof e == "object" && (s = Object.assign({}, Ms, e), e.s != null && e.ss == null && (s.ss = e.s - 1)), r = this.localeData(), n = ly(this, !t, s, r), t && (n = r.pastFuture(+this, n)), r.postformat(n);
}
var uo = Math.abs;
function vs(i) {
  return (i > 0) - (i < 0) || +i;
}
function za() {
  if (!this.isValid())
    return this.localeData().invalidDate();
  var i = uo(this._milliseconds) / 1e3, e = uo(this._days), t = uo(this._months), s, r, n, a, o = this.asSeconds(), l, u, c, h;
  return o ? (s = Rt(i / 60), r = Rt(s / 60), i %= 60, s %= 60, n = Rt(t / 12), t %= 12, a = i ? i.toFixed(3).replace(/\.?0+$/, "") : "", l = o < 0 ? "-" : "", u = vs(this._months) !== vs(o) ? "-" : "", c = vs(this._days) !== vs(o) ? "-" : "", h = vs(this._milliseconds) !== vs(o) ? "-" : "", l + "P" + (n ? u + n + "Y" : "") + (t ? u + t + "M" : "") + (e ? c + e + "D" : "") + (r || s || i ? "T" : "") + (r ? h + r + "H" : "") + (s ? h + s + "M" : "") + (i ? h + a + "S" : "")) : "P0D";
}
var ge = Ba.prototype;
ge.isValid = sm;
ge.abs = Yb;
ge.add = Rb;
ge.subtract = Nb;
ge.as = Fb;
ge.asMilliseconds = Hb;
ge.asSeconds = zb;
ge.asMinutes = Xb;
ge.asHours = Vb;
ge.asDays = Ub;
ge.asWeeks = Wb;
ge.asMonths = Gb;
ge.asQuarters = Zb;
ge.asYears = Kb;
ge.valueOf = Bb;
ge._bubble = $b;
ge.clone = Qb;
ge.get = qb;
ge.milliseconds = Jb;
ge.seconds = ey;
ge.minutes = ty;
ge.hours = iy;
ge.days = sy;
ge.weeks = ay;
ge.months = ry;
ge.years = ny;
ge.humanize = cy;
ge.toISOString = za;
ge.toString = za;
ge.toJSON = za;
ge.locale = bc;
ge.localeData = vc;
ge.toIsoString = Bt(
  "toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
  za
);
ge.lang = yc;
Q("X", 0, 0, "unix");
Q("x", 0, 0, "valueOf");
V("x", Ra);
V("X", jg);
xe("X", function(i, e, t) {
  t._d = new Date(parseFloat(i) * 1e3);
});
xe("x", function(i, e, t) {
  t._d = new Date(he(i));
});
//! moment.js
P.version = "2.29.4";
dg(De);
P.fn = I;
P.min = J_;
P.max = em;
P.now = tm;
P.utc = ri;
P.unix = Mb;
P.months = Ab;
P.isDate = qr;
P.locale = Li;
P.invalid = La;
P.duration = Qt;
P.isMoment = Kt;
P.weekdays = jb;
P.parseZone = Ob;
P.localeData = bi;
P.isDuration = Tn;
P.monthsShort = Lb;
P.weekdaysMin = Ib;
P.defineLocale = eu;
P.updateLocale = O_;
P.locales = A_;
P.weekdaysShort = Eb;
P.normalizeUnits = Ht;
P.relativeTimeRounding = uy;
P.relativeTimeThreshold = hy;
P.calendarFormat = Tm;
P.prototype = I;
P.HTML5_FMT = {
  DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
  // <input type="datetime-local" />
  DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
  // <input type="datetime-local" step="1" />
  DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
  // <input type="datetime-local" step="0.001" />
  DATE: "YYYY-MM-DD",
  // <input type="date" />
  TIME: "HH:mm",
  // <input type="time" />
  TIME_SECONDS: "HH:mm:ss",
  // <input type="time" step="1" />
  TIME_MS: "HH:mm:ss.SSS",
  // <input type="time" step="0.001" />
  WEEK: "GGGG-[W]WW",
  // <input type="week" />
  MONTH: "YYYY-MM"
  // <input type="month" />
};
const dy = {
  props: {
    styleProps: {
      type: String,
      default: ""
    },
    isDaily: Boolean,
    displayMonth: [Number, String],
    displayYear: [Number, String],
    minDate: [Object, Date],
    maxDate: [Object, Date],
    prevBtnHandler: Function,
    nextBtnHandler: Function,
    disableModal: {
      type: Boolean,
      default: !1
    }
  },
  data() {
    return {
      isOpenedModal: !1,
      currentYear: new Date().getFullYear(),
      baseYear: new Date().getFullYear(),
      minMonth: 1,
      maxMonth: 12,
      minYear: 2016,
      maxYear: 9999,
      selectedYear: 0
    };
  },
  methods: {
    toggleModal() {
      this.disableModal || (this.isOpenedModal = !this.isOpenedModal);
    },
    closeModal(i) {
      var r;
      const e = this.$refs.calendarModalRef, t = this.$refs.calendarModalOpenBtn, s = i.target;
      s === e || (r = t == null ? void 0 : t.parentNode) != null && r.contains(s) || e.contains(s) || (this.isOpenedModal = !1);
    },
    selectYear(i) {
      this.selectedYear = i, this.$emit("setSelectedYear", i), this.isOpenedModal = !1;
    },
    headerPrevBtnHandler() {
      this.prevBtnHandler && this.prevBtnHandler(), this.isDaily || this.$emit("setSelectedYear", Number(this.displayYear) - 1), this.isOpenedModal = !1;
    },
    headerNextBtnHandler() {
      this.nextBtnHandler && this.nextBtnHandler(), this.isDaily || this.$emit("setSelectedYear", Number(this.displayYear) + 1), this.isOpenedModal = !1;
    },
    modalPrevBtnHandler() {
      this.baseYear = this.baseYear - 9;
    },
    modalNextBtnHandler() {
      this.baseYear = this.baseYear + 9;
    }
  },
  computed: {
    yearRangeComputed() {
      let i = [];
      for (let e = 0; e < 9; e++)
        i.unshift(this.baseYear - e);
      return i;
    },
    maxDateComputed() {
      return this.maxDate ? P(this.maxDate).year() : P(new Date()).year();
    },
    displayMonthComputed() {
      return typeof this.displayMonth == "string" ? Number(P().month(this.displayMonth).format("MM")) : Number(this.displayMonth);
    },
    isDisabledPrevBtn() {
      if (this.isDaily) {
        if (this.displayMonthComputed === this.minMonth && Number(this.displayYear) === this.minYear)
          return !0;
      } else if (Number(this.displayYear) === this.minYear)
        return !0;
      return !1;
    },
    isDisabledNextBtn() {
      if (this.isDaily) {
        if (this.displayMonthComputed === this.maxMonth && Number(this.displayYear) === this.maxYear)
          return !0;
      } else if (Number(this.displayYear) === this.maxDateComputed)
        return !0;
      return !1;
    }
  },
  watch: {
    isOpenedModal() {
      this.isOpenedModal ? window.addEventListener("click", this.closeModal) : window.removeEventListener("click", this.closeModal);
    }
  },
  mounted() {
    this.minDate && (this.minYear = Number(P(this.minDate).format("YYYY")), this.minMonth = Number(P(this.minDate).format("MM"))), this.maxDate && (this.maxYear = Number(P(this.maxDate).format("YYYY")), this.maxMonth = Number(P(this.maxDate).format("MM")));
  },
  unmounted() {
    window.removeEventListener("click", this.closeModal);
  }
};
var fy = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", [t("div", {
    class: i.$style["calender-header-container"],
    style: i.styleProps
  }, [t("span", {
    class: [i.$style["arrow-icon"], i.$style["-left"]],
    attrs: {
      disabled: i.isDisabledPrevBtn
    },
    on: {
      click: i.headerPrevBtnHandler
    }
  }), t("div", {
    ref: "calendarModalOpenBtn",
    class: i.$style["display-date"],
    attrs: {
      disabled: i.disableModal
    },
    on: {
      click: i.toggleModal
    }
  }, [i._t("default")], 2), t("span", {
    class: [i.$style["arrow-icon"], i.$style["-right"]],
    attrs: {
      disabled: i.isDisabledNextBtn
    },
    on: {
      click: i.headerNextBtnHandler
    }
  }), t("transition", {
    attrs: {
      name: "fade-transition"
    }
  }, [i.isOpenedModal ? t("div", {
    ref: "calendarModalRef",
    class: i.$style["inner-modal-container"]
  }, [t("div", [t("span", {
    class: [i.$style["modal-arrow-icon"], i.$style["-left"]],
    on: {
      click: i.modalPrevBtnHandler
    }
  })]), t("div", {
    class: i.$style["btn-group"]
  }, i._l(i.yearRangeComputed, function(s) {
    return t("div", {
      key: s,
      class: i.$style[`${Number(i.displayYear) === s ? "selected-year" : ""}`],
      attrs: {
        disabled: s < i.minYear || s > i.maxDateComputed
      },
      on: {
        click: function(r) {
          return i.selectYear(s);
        }
      }
    }, [i._v(" " + i._s(s) + " ")]);
  }), 0), t("div", [t("span", {
    class: [i.$style["modal-arrow-icon"], i.$style["-right"]],
    on: {
      click: i.modalNextBtnHandler
    }
  })])]) : i._e()])], 1)]);
}, py = [];
const gy = {
  "calender-header-container": "_calender-header-container_nxrn4_8",
  "display-date": "_display-date_nxrn4_17",
  "arrow-icon": "_arrow-icon_nxrn4_25",
  "-left": "_-left_nxrn4_32",
  "-right": "_-right_nxrn4_35",
  "inner-modal-container": "_inner-modal-container_nxrn4_43",
  "btn-group": "_btn-group_nxrn4_57",
  "selected-year": "_selected-year_nxrn4_84",
  "modal-arrow-icon": "_modal-arrow-icon_nxrn4_97"
};
const Uo = {};
Uo.$style = gy;
var _y = /* @__PURE__ */ te(
  dy,
  fy,
  py,
  !1,
  my,
  "5082660f",
  null,
  null
);
function my(i) {
  for (let e in Uo)
    this[e] = Uo[e];
}
const Xa = /* @__PURE__ */ function() {
  return _y.exports;
}();
var by = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    staticClass: "emdn-daily-calendar"
  }, [t("div", {
    staticClass: "daily-container"
  }, [t("calendar-header", {
    attrs: {
      "style-props": "margin-bottom: 12px;",
      "display-month": i.displayMonth,
      "display-year": i.displayYear,
      "prev-btn-handler": i.prevBtnHandler,
      "next-btn-handler": i.nextBtnHandler,
      "min-date": i.minDate,
      "max-date": i.maxDate,
      "is-daily": !0
    },
    on: {
      setSelectedYear: i.setDisplayYear
    }
  }, [t("span", [i._v(i._s(i.displayMonthComputed) + " ")]), t("span", {
    staticStyle: {
      color: "#3491ff"
    }
  }, [i._v(i._s(i.displayYear))])]), t("v-date-picker", {
    ref: "calendarRef",
    attrs: {
      attributes: i.attrs,
      mode: "single",
      "min-date": i.changeToDateObj(i.minDate),
      "max-date": i.changeToDateObj(i.maxDate),
      "is-inline": !0,
      "is-range": i.mode === "range"
    },
    on: {
      input: i.executor,
      "update:from-page": i.pageChange
    },
    scopedSlots: i._u([{
      key: "header-left-button",
      fn: function() {
        return [t("span")];
      },
      proxy: !0
    }, {
      key: "header-right-button",
      fn: function() {
        return [t("span")];
      },
      proxy: !0
    }, {
      key: "header",
      fn: function() {
        return [t("span")];
      },
      proxy: !0
    }]),
    model: {
      value: i.date,
      callback: function(s) {
        i.date = s;
      },
      expression: "date"
    }
  })], 1)]);
}, yy = [];
const vy = {
  name: "EmdnCalendar",
  components: { CalendarHeader: Xa },
  props: {
    attrs: Array,
    minDate: {
      type: [Date, Object],
      default: () => new Date(P("20160101", "YYYYMMDD"))
    },
    maxDate: {
      type: [Date, Object],
      default: () => new Date()
    },
    clickHandler: Function,
    mode: String,
    dateRangeComputed: Object,
    setDateRangeData: Function
  },
  data() {
    return {
      date: "",
      displayYear: 0,
      minMonth: 1,
      maxMonth: 12,
      displayMonth: ""
    };
  },
  computed: {
    displayMonthComputed() {
      return typeof this.displayMonth == "number" ? P(String(this.displayMonth), "MM").format("MMMM") : P(this.displayMonth, "MMMM").format("MMMM");
    }
  },
  mounted() {
    const i = this.$refs.calendarRef;
    let e = this.dateRangeComputed.start, t = this.dateRangeComputed.end;
    this.dateRangeComputed.start || (e = this.dateRangeComputed), this.minDate && (this.minMonth = Number(P(this.minDate).format("MM"))), this.maxMonth && (this.maxMonth = Number(P(this.maxDate).format("MM"))), this.mode === "single" ? (this.date = P(e).format("YYYY-MM-DD"), this.displayYear = P(e).format("YYYY"), this.displayMonth = P(e).format("MMMM"), this.setDateRangeData && this.setDateRangeData({
      start: P(e),
      end: P(e)
    }), i.move(this.date, { transition: "none" })) : (this.date = {
      ...this.date,
      start: P(e),
      end: P(t)
    }, this.displayYear = P(e).format("YYYY"), this.displayMonth = P(e).format("MMMM"), i.move(this.date.start, { transition: "none" }));
  },
  methods: {
    executor() {
      this.date && this.mode === "single" && this.clickHandler({ start: this.date, end: this.date }), this.date && this.mode === "range" && this.clickHandler(this.date);
    },
    prevBtnHandler() {
      if (typeof this.displayMonth == "string" && (this.displayMonth = Number(
        P().month(this.displayMonth).format("MM")
      )), Number(P(this.minDate).format("YYYY")) === Number(this.displayYear) && this.displayMonth === this.minMonth)
        return;
      this.$refs.calendarRef.move(-1, { transition: "none" });
    },
    nextBtnHandler() {
      if (Number(P(this.maxDate).format("YYYY")) === Number(this.displayYear) && Number(this.displayMonth) === Number(this.maxMonth))
        return;
      this.$refs.calendarRef.move(1, { transition: "none" });
    },
    pageChange(i) {
      this.displayYear = i.year, this.displayMonth = i.month;
    },
    setDisplayYear(i) {
      this.$refs.calendarRef.move(
        {
          month: i === Number(P(this.minDate).format("YYYY")) ? this.minMonth : i === Number(P(this.maxDate).format("YYYY")) ? this.maxMonth : 1,
          year: i
        },
        { transition: "none" }
      );
    },
    changeToDateObj(i) {
      return new Date(i);
    }
  }
}, Yu = {};
var xy = /* @__PURE__ */ te(
  vy,
  by,
  yy,
  !1,
  wy,
  null,
  null,
  null
);
function wy(i) {
  for (let e in Yu)
    this[e] = Yu[e];
}
const Sy = /* @__PURE__ */ function() {
  return xy.exports;
}();
var Dy = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    staticClass: "monthly-date-picker-container"
  }, [t("calendar-header", {
    attrs: {
      "style-props": "margin-bottom: 20px;",
      "prev-btn-handler": i.prevBtnHandler,
      "next-btn-handler": i.nextBtnHandler,
      "min-date": i.minDate,
      "max-date": i.maxDate,
      "display-year": i.currentYear
    },
    on: {
      setSelectedYear: i.setDisplayYear
    }
  }, [i.selectedMonth ? t("span", [i._v(i._s(i.selectedMonthToString) + " ")]) : i._e(), t("span", {
    staticStyle: {
      color: "#3491ff"
    }
  }, [i._v(i._s(i.currentYear))])]), t("div", {
    staticClass: "date-picker-body"
  }, i._l(i.getNumberOfMonth(), function(s, r) {
    return t("div", {
      key: r,
      staticClass: "date-picker-month-item"
    }, [t("span", {
      staticClass: "date-picker-month-text",
      class: {
        "date-picker-today": i.currentYear == i.getMaxYear && s == i.getCurrentMonth(i.today),
        "date-picker-selected-month": i.isSelected(s),
        "date-picker-disable": i.getIsDisabledMonth(s)
      },
      on: {
        click: function(n) {
          return i.selectMonthHandler(s, i.currentYear);
        }
      }
    }, [i._v(i._s(i.displayMonthName(s)))])]);
  }), 0)], 1);
}, Py = [];
const Ty = {
  components: { CalendarHeader: Xa },
  props: {
    dateRangeComputed: {
      type: Object,
      default: () => ({ start: P(new Date()), end: P(new Date()) })
    },
    setDateRangeData: Function,
    clickHandler: Function,
    dateRange: Object,
    minDate: {
      type: [Object, Date],
      default: () => P("20160101", "YYYYMMDD")
    },
    maxDate: { type: [Object, Date], default: () => P(new Date()) }
  },
  data() {
    return {
      today: "",
      currentYear: "",
      selectedMonth: "",
      selectedYear: ""
    };
  },
  mounted() {
    this.today = new Date(), this.dateRange.start ? this.currentYear = this.getCurrentYear(this.dateRange.start) : this.currentYear = this.getCurrentYear(this.today), this.selectMonthHandler(this.selectedMonth, this.currentYear);
  },
  watch: {
    dateRangeComputed: {
      handler(i) {
        this.selectedMonth = this.getCurrentMonth(i.end), this.selectedYear = this.getCurrentYear(i.end);
      },
      immediate: !0,
      deep: !0
    }
  },
  computed: {
    getMaxYear() {
      return this.maxDate ? P(this.maxDate).year() : P(this.today).year();
    },
    selectedMonthToString() {
      return P(this.selectedMonth, "MM").format("MMMM");
    }
  },
  methods: {
    prevBtnHandler() {
      this.currentYear--;
    },
    nextBtnHandler() {
      this.currentYear++;
    },
    displayMonthName(i) {
      return P(i, "MM").format("MMM");
    },
    getNumberOfMonth() {
      return Number(P(`${this.currentYear}1231`, "YYYYMMDD").format("MM"));
    },
    getCurrentMonth(i) {
      return Number(P(new Date(i)).format("MM"));
    },
    getIsDisabledMonth(i) {
      return Number(this.currentYear) === Number(P(this.minDate).format("YYYY")) && P(this.minDate).format("MM") > i || Number(this.currentYear) === Number(P(this.maxDate).format("YYYY")) && P(this.maxDate).format("MM") < i;
    },
    isSelected(i) {
      return i == this.selectedMonth && this.currentYear == this.selectedYear;
    },
    selectMonthHandler(i, e) {
      i < 10 && (i = "0" + i);
      let t = `${e}${i}`, s = P(t, "YYYYMM").toDate(), r = P(t, "YYYYMM").endOf("month").toDate();
      this.setDateRangeData && this.setDateRangeData({ start: s, end: r }), this.clickHandler({ start: s, end: r });
    },
    getCurrentYear(i) {
      return P(i).format("YYYY");
    },
    setDisplayYear(i) {
      this.selectedMonth = "", this.currentYear = i;
    }
  }
}, Ru = {};
var ky = /* @__PURE__ */ te(
  Ty,
  Dy,
  Py,
  !1,
  Cy,
  "1ed97250",
  null,
  null
);
function Cy(i) {
  for (let e in Ru)
    this[e] = Ru[e];
}
const My = /* @__PURE__ */ function() {
  return ky.exports;
}();
var Oy = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    staticClass: "weekly-date-picker-container"
  }, [t("calendar-header", {
    attrs: {
      "display-year": i.displayYear,
      "min-date": i.minDate,
      "max-date": i.maxDate
    },
    on: {
      setSelectedYear: i.setDisplayYear
    }
  }, [t("span", [i._v("Week ")]), i.displayYear == i.selectedYear ? t("span", [i._v(i._s(i.selectedWeek) + " ")]) : i._e(), t("span", {
    staticStyle: {
      color: "#3491ff"
    }
  }, [i._v(i._s(i.displayYear))])]), t("div", {
    staticClass: "date-picker-body"
  }, i._l(i.getNumberOfWeek(), function(s, r) {
    return t("div", {
      key: r,
      staticClass: "date-picker-week-item",
      class: {
        "date-picker-disable": i.isDisabledWeek(s, i.displayYear)
      },
      on: {
        click: function(n) {
          return i.selectWeekHandler(s, i.displayYear);
        }
      }
    }, [t("span", {
      staticClass: "date-picker-week-number",
      class: {
        "date-picker-today": i.displayYear == i.currentYear && s == i.getCurrentWeek(),
        "date-picker-selected": i.isSelectedWeek(s)
      }
    }, [i._v(" " + i._s(s) + " ")])]);
  }), 0)], 1);
}, Ay = [];
const Ly = {
  components: { CalendarHeader: Xa },
  props: {
    clickHandler: Function,
    minDate: {
      type: [Object, Date],
      default: () => P("20160101", "YYYYMMDD")
    },
    maxDate: { type: [Object, Date], default: () => P(new Date()) },
    dateRangeComputed: {
      type: Object,
      default: () => ({ start: P(), end: P() })
    },
    setDateRangeData: Function
  },
  data() {
    return {
      displayYear: 0,
      currentYear: P(new Date()).format("YYYY"),
      // 올해
      selectedWeek: null,
      // 선택된 주
      selectedYear: null,
      // 선택된 년도
      selectedSecondWeek: null,
      // 선택된 두번째 주(range일 때 사용?)
      selectedSecondYear: null
      // 선택된 두번째 년도(range 일때 사용?)
    };
  },
  watch: {
    dateRangeComputed: {
      handler(i) {
        this.selectedWeek = this.getWeek(i.end), this.selectedYear = this.getYear(i.end);
      },
      immediate: !0,
      deep: !0
    }
  },
  mounted() {
    this.dateRangeComputed.start ? this.displayYear = P(this.dateRangeComputed.end).format("YYYY") : this.displayYear = P(new Date()).format("YYYY"), this.currentYear = P(new Date()).format("YYYY"), this.selectWeekHandler(this.selectedWeek, this.selectedYear);
    let i = P(this.dateRangeComputed.end).startOf("week"), e = P(this.dateRangeComputed.end).endOf("week");
    this.setDateRangeData({ start: i, end: e });
  },
  computed: {
    getMaxYear() {
      return new Date().getFullYear();
    }
  },
  methods: {
    selectWeekHandler(i, e) {
      let t = `${e}${i}`, s = P(t, "YYYYWW").startOf("week"), r = P(t, "YYYYWW").endOf("week");
      this.setDateRangeData({ start: s, end: r }), this.clickHandler({ start: s, end: r });
    },
    // param으로 넘어온 주가 선택된 주인지 확인
    isSelectedWeek(i) {
      return i == this.selectedWeek && this.selectedYear == this.displayYear;
    },
    // 선택된 날짜가 몇째주인지 구하기
    getWeek(i) {
      return P(i, "YYYYMMDD").subtract(3, "days").format("WW");
    },
    // 오늘 날짜가 몇 번째 주인지 구하기
    getCurrentWeek() {
      return P(new Date()).format("WW");
    },
    // 현재 년도에 몇주까지 있는지 구하기
    getNumberOfWeek() {
      return Number(P(this.displayYear, "YYYY").isoWeeksInYear());
    },
    // 현재 년도가 몇인지 반환
    getYear(i) {
      return P(i, "YYYYMMDD").subtract(3, "days").format("YYYY");
    },
    // 헤더에서 받아온 연도로 displayYear 교체
    setDisplayYear(i) {
      this.displayYear = i;
    },
    // 해당 주차가 min or maxDate에 걸리는지 여부 반환
    isDisabledWeek(i, e) {
      return Number(e) === Number(P(this.minDate).format("YYYY")) && Number(P(this.minDate).format("WW")) > i || Number(e) === Number(P(this.maxDate).format("YYYY")) && Number(P(this.maxDate).format("WW")) < i;
    }
  }
}, Nu = {};
var jy = /* @__PURE__ */ te(
  Ly,
  Oy,
  Ay,
  !1,
  Ey,
  "66e0f763",
  null,
  null
);
function Ey(i) {
  for (let e in Nu)
    this[e] = Nu[e];
}
const Iy = /* @__PURE__ */ function() {
  return jy.exports;
}();
var Yy = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    staticClass: "date-block"
  }, [t("div", {
    staticClass: "yearly block"
  }, [t("calendar-header", {
    attrs: {
      "style-props": "margin-bottom: 12px;",
      "disable-modal": !0,
      "prev-btn-handler": i.prevYearRange,
      "next-btn-handler": i.nextYearRange
    }
  }, [t("span", [i._v(i._s(i.yearRange) + "-" + i._s(i.yearRange + 11))])]), i.today.getFullYear() < i.yearRange ? t("div", {
    staticClass: "wrapper-year"
  }, i._l(12, function(s) {
    return t("div", {
      key: s,
      staticClass: "year-item"
    }, [t("span", {
      staticClass: "disable year-text"
    }, [i._v(i._s(i.yearRange + s - 1))])]);
  }), 0) : i.today.getFullYear() <= i.yearRange + 11 && i.today.getFullYear() >= i.yearRange ? t("div", {
    staticClass: "wrapper-year"
  }, i._l(12, function(s) {
    return t("div", {
      key: s,
      staticClass: "year-item"
    }, [i.yearRange + s - 1 > i.today.getFullYear() ? t("span", {
      staticClass: "disable year-text"
    }, [i._v(i._s(i.yearRange + s - 1))]) : i.yearRange + s - 1 == i.today.getFullYear() ? t("span", {
      staticClass: "today year-text",
      class: {
        selected: i.isSelected(s)
      },
      on: {
        click: function(r) {
          return i.handleSelectYear(i.yearRange + s - 1);
        }
      }
    }, [i._v(i._s(i.yearRange + s - 1))]) : t("span", {
      staticClass: "year-text",
      class: {
        selected: i.isSelected(s)
      },
      on: {
        click: function(r) {
          return i.handleSelectYear(i.yearRange + s - 1);
        }
      }
    }, [i._v(i._s(i.yearRange + s - 1))])]);
  }), 0) : t("div", {
    staticClass: "wrapper-year"
  }, i._l(12, function(s) {
    return t("div", {
      key: s,
      staticClass: "year-item"
    }, [t("span", {
      staticClass: "year-text",
      class: {
        selected: i.isSelected(s)
      },
      on: {
        click: function(r) {
          return i.handleSelectYear(i.yearRange + s - 1);
        }
      }
    }, [i._v(i._s(i.yearRange + s - 1))])]);
  }), 0)], 1)]);
}, Ry = [];
const Ny = {
  components: { CalendarHeader: Xa },
  props: {
    clickHandler: Function,
    isRange: {
      type: Boolean,
      default: () => !1
    },
    minDate: {
      type: [Object, Date],
      default: () => P("20160101", "YYYYMMDD")
    },
    maxDate: { type: [Object, Date], default: () => P(new Date()) },
    currentDate: {
      type: Object,
      default: () => ({})
    },
    dateRange: {
      type: Object,
      default: () => ({
        minDate: null,
        maxDate: P(new Date())
      })
    },
    frequency: {
      type: String,
      default: () => ""
    },
    dateRangeComputed: {
      type: Object,
      default: () => ({})
    },
    setDateRangeData: Function
  },
  data() {
    return {
      date: {
        start: null,
        end: null
      },
      dateTitle: {
        start: "",
        end: ""
      },
      yearRange: 2016,
      selectedYear: null,
      selectedSecondYear: null,
      pickStep: 0,
      minYear: 0,
      maxYear: 9999
    };
  },
  created() {
    this.today = new Date();
    let i = new Date().getFullYear();
    this.dateRangeComputed ? this.handleSelectYear(
      P(this.dateRangeComputed.start).format("YYYY")
    ) : this.handleSelectYear(i), this.minDate && (this.yearRange = Number(P(this.minDate).format("YYYY")));
  },
  computed: {},
  watch: {
    frequency(i) {
      i.includes("YEAR") && this.clearPickingData();
    }
  },
  methods: {
    isSelected(i) {
      return this.yearRange + i - 1 == this.selectedYear || this.yearRange + i - 1 == this.selectedSecondYear;
    },
    getFrequency() {
      return this.isRange ? "YEARLY_RANGE" : "YEARLY";
    },
    changeDate() {
      let i = this.getDateRange(), e = {
        start: i.start ? P(i.start).format("YYYY-MM-DD") : "",
        end: i.end ? P(i.end).format("YYYY-MM-DD") : ""
      };
      this.clickHandler(i), this.$emit("change-date", i, e);
    },
    prevYearRange() {
      this.yearRange <= 18 ? this.yearRange = 1 : this.yearRange -= 12;
    },
    nextYearRange() {
      this.yearRange == 1 ? this.yearRange = 18 : this.yearRange += 12;
    },
    handleSelectYear(i) {
      this.isRange ? this.pickStep == 2 ? this.clearPickingData() : this.pickStep == 0 ? i != this.selectedYear ? (this.selectedYear = i, this.pickStep++) : this.clearPickingData() : this.pickStep == 1 && (i != this.selectedYear ? (i < this.selectedYear ? (this.selectedSecondYear = this.selectedYear, this.selectedYear = i) : this.selectedSecondYear = i, this.pickStep++) : this.clearPickingData()) : this.selectedYear != i ? this.selectedYear = i : this.selectedYear = new Date().getFullYear(), this.changeDate();
    },
    getDateRange() {
      let i = null, e = null;
      return this.isRange ? (this.selectedYear && (i = new Date(this.selectedYear, 0, 1)), this.selectedSecondYear && (e = new Date(this.selectedSecondYear, 0, 1))) : this.selectedYear && (i = new Date(this.selectedYear, 0, 1), e = new Date(this.selectedYear, 11, 31)), {
        start: i,
        end: e
      };
    },
    clearPickingData() {
      this.selectedYear = new Date().getFullYear(), this.changeDate(), this.selectedSecondYear = null, this.pickStep = 0;
    }
  }
}, $u = {};
var $y = /* @__PURE__ */ te(
  Ny,
  Yy,
  Ry,
  !1,
  Fy,
  "736262f4",
  null,
  null
);
function Fy(i) {
  for (let e in $u)
    this[e] = $u[e];
}
const By = /* @__PURE__ */ function() {
  return $y.exports;
}();
var Hy = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    staticClass: "date-picker-input-container"
  }, [t("div", {
    staticClass: "input-box"
  }, [t("label", [i._v("From")]), t("input", {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: i.fromDate,
      expression: "fromDate"
    }],
    attrs: {
      placeholder: "yyyy-mm-dd",
      type: "text"
    },
    domProps: {
      value: i.fromDate
    },
    on: {
      input: function(s) {
        s.target.composing || (i.fromDate = s.target.value);
      }
    }
  })]), t("div", {
    staticClass: "input-box"
  }, [t("label", [i._v("To")]), t("input", {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: i.toDate,
      expression: "toDate"
    }],
    attrs: {
      placeholder: "yyyy-mm-dd",
      type: "text"
    },
    domProps: {
      value: i.toDate
    },
    on: {
      input: function(s) {
        s.target.composing || (i.toDate = s.target.value);
      }
    }
  })])]);
}, zy = [];
const Xy = {
  name: "DatePickerInput",
  props: {
    dateRangeComputed: Object
  },
  data() {
    return {
      fromDate: "",
      toDate: ""
    };
  },
  watch: {
    dateRangeComputed: {
      handler(i) {
        this.fromDate = P(i.start).format("YYYY-MM-DD"), this.toDate = P(i.end).format("YYYY-MM-DD");
      },
      immediate: !0
    }
  }
}, Fu = {};
var Vy = /* @__PURE__ */ te(
  Xy,
  Hy,
  zy,
  !1,
  Uy,
  "f6e0fb66",
  null,
  null
);
function Uy(i) {
  for (let e in Fu)
    this[e] = Fu[e];
}
const Wy = /* @__PURE__ */ function() {
  return Vy.exports;
}();
var Gy = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", i._l(i.selectorOptions, function(s, r) {
    return t("CtaButton", {
      key: r,
      staticClass: "customStyle",
      attrs: {
        "color-type": s === i.timeScale ? "blue-fill" : "",
        "style-props": "width : 171px; height: 25px",
        "click-handler": function() {
          return i.executor(s);
        }
      }
    }, [i._v(" " + i._s(i.capitalizeFirstLetter(s)) + " ")]);
  }), 1);
}, Zy = [];
const Ky = {
  components: {
    CtaButton: Qr
  },
  name: "SelectorCalendar",
  props: {
    clickHandler: Function,
    timeScale: String,
    selectorOptions: {
      type: Array,
      default: () => ["date", "week", "month", "year", "custom"]
    }
  },
  methods: {
    executor(i) {
      this.clickHandler(i);
    },
    capitalizeFirstLetter(i) {
      return i.charAt(0).toUpperCase() + i.slice(1);
    }
  }
}, Bu = {};
var Qy = /* @__PURE__ */ te(
  Ky,
  Gy,
  Zy,
  !1,
  qy,
  "041f8051",
  null,
  null
);
function qy(i) {
  for (let e in Bu)
    this[e] = Bu[e];
}
const Jy = /* @__PURE__ */ function() {
  return Qy.exports;
}();
var ev = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    class: [i.$style["calendar-container"]],
    style: i.styleProps
  }, [t("div", {
    class: i.$style[i.showSelector ? "" : "calendar-single"]
  }, [i.newTimeScale === "date" ? t("Daily", {
    key: "daily",
    attrs: {
      "click-handler": i.dateClickHandler,
      attributes: i.attrs,
      mode: "single",
      "max-date": i.maxDate,
      "min-date": i.minDate,
      "date-range-computed": i.dateRangeComputed,
      "set-date-range-data": i.setDateRangeData
    }
  }) : i._e(), i.newTimeScale === "month" ? t("Monthly", {
    attrs: {
      "click-handler": i.dateClickHandler,
      "date-range-computed": i.dateRangeComputed,
      "set-date-range-data": i.setDateRangeData,
      "date-range": i.dateRange,
      "max-date": i.maxDate,
      "min-date": i.minDate
    }
  }) : i._e(), i.newTimeScale === "week" ? t("Weekly", {
    attrs: {
      "click-handler": i.dateClickHandler,
      "date-range-computed": i.dateRangeComputed,
      "set-date-range-data": i.setDateRangeData,
      "max-date": i.maxDate,
      "min-date": i.minDate
    }
  }) : i._e(), i.newTimeScale === "year" ? t("yearly", {
    attrs: {
      "click-handler": i.dateClickHandler,
      "date-range-computed": i.dateRangeComputed,
      "set-date-range-data": i.setDateRangeData,
      "max-date": i.maxDate,
      "min-date": i.minDate
    }
  }) : i._e(), i.newTimeScale === "custom" ? t("Daily", {
    key: "custom",
    attrs: {
      "click-handler": i.dateClickHandler,
      attributes: i.attrs,
      mode: "range",
      "max-date": i.maxDate,
      "min-date": i.minDate,
      "date-range-computed": i.dateRangeComputed,
      "set-date-range-data": i.setDateRangeData
    }
  }) : i._e(), i.showSelector ? t("DatePickerInput", {
    attrs: {
      "date-range-computed": i.dateRangeComputed
    }
  }) : i._e()], 1), i.showSelector ? t("Selector", {
    attrs: {
      "click-handler": i.handleChange,
      "selector-options": i.selectorOptions,
      "time-scale": i.newTimeScale
    }
  }) : i._e()], 1);
}, tv = [];
const iv = {
  "calendar-container": "_calendar-container_10iou_7",
  "calendar-single": "_calendar-single_10iou_15"
}, sv = {
  components: {
    Daily: Sy,
    Monthly: My,
    Weekly: Iy,
    Yearly: By,
    DatePickerInput: Wy,
    Selector: Jy
  },
  name: "EmdnCalendar",
  props: {
    styleProps: String,
    showSelector: {
      type: Boolean,
      default: !1
    },
    attrs: Array,
    maxDate: Object,
    minDate: Object,
    timeScale: String,
    clickHandler: Function,
    dateFormat: { type: String, default: "" },
    selectorOptions: {
      type: Array,
      default: () => ["date", "week", "month", "year", "custom"]
    },
    dateRange: {
      type: Object,
      default: () => ({ start: P(new Date()), end: P(new Date()) })
    }
  },
  data() {
    return {
      dateRangeData: {},
      newTimeScale: ""
    };
  },
  computed: {
    dateRangeComputed() {
      return this.dateRangeData.start ? this.dateRangeData : this.dateRange;
    }
  },
  methods: {
    setDateRangeData(i) {
      this.dateRangeData = i;
    },
    dateClickHandler(i) {
      var t;
      this.dateRangeData = i;
      let e = {};
      return this.dateFormat ? e = {
        start: P(i.start).format(this.dateFormat),
        end: P(i.end).format(this.dateFormat)
      } : e = {
        start: P(i.start),
        end: P(i.end)
      }, this.clickHandler && this.clickHandler(e, (t = this.newTimeScale) == null ? void 0 : t.toUpperCase()), e;
    },
    handleChange(i) {
      this.newTimeScale = i;
    }
  },
  created() {
    this.newTimeScale = this.timeScale ? this.timeScale : this.selectorOptions[0];
  }
}, Wo = {};
Wo.$style = iv;
var rv = /* @__PURE__ */ te(
  sv,
  ev,
  tv,
  !1,
  nv,
  null,
  null,
  null
);
function nv(i) {
  for (let e in Wo)
    this[e] = Wo[e];
}
const GO = /* @__PURE__ */ function() {
  return rv.exports;
}(), av = {
  props: {
    styleProps: String,
    placeholderText: {
      type: String,
      default: "placeholder-text"
    },
    // 검색어와 일치한 list
    searchList: {
      type: Array,
      default: () => []
    },
    // searchList 중에 현재 어디에 focus 되어 있는 지 표시.
    focusPosition: {
      type: Number,
      default: 0
    },
    // 검색을 시작할 때 사용될 keyword
    searchCompleteKeyword: {
      type: String,
      default: ""
    },
    // 검색을 시작하기 전 검색할 검색어를 저장시켜준다.
    setSearchCompleteKeyword: {
      type: Function,
      default: () => !0
    },
    // 포커스의 위치를 정한다.
    setFocusPosition: {
      type: Function,
      default: () => !0
    }
  },
  data() {
    return {
      keyword: "",
      timeout: null,
      focusOnSearchbar: 0
    };
  },
  methods: {
    // 검색된 keyword 를 complete keyword 로 저장한다.
    // 이미 키워드가 입력된 상태에서 함수를 실행했다면 next search handler 실행
    searchHandler() {
      this.searchCompleteKeyword === this.keyword && this.nextSearchHandler(), this.setSearchCompleteKeyword(this.keyword), this.focusOnSearchbar += 1;
    },
    // 다음 search list 로 focus를 이동.
    nextSearchHandler() {
      this.focusPosition < this.searchList.length && this.setFocusPosition(this.focusPosition + 1), this.focusPosition === this.searchList.length && this.setFocusPosition(1), this.focusOnSearchbar += 1;
    },
    // 이전 search list 로 focus 를 이동.
    previousSearchHandler() {
      this.focusPosition > 1 && this.setFocusPosition(this.focusPosition - 1), this.focusOnSearchbar += 1;
    },
    searchDebounce() {
      clearTimeout(this.timeout), this.timeout = setTimeout(() => {
        this.searchHandler();
      }, 300);
    }
  },
  watch: {
    focusOnSearchbar() {
      this.$refs.searchInputRef && this.$refs.searchInputRef.focus();
    }
  }
};
var ov = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    staticClass: "search-bar-container",
    style: i.styleProps
  }, [t("div", {
    staticClass: "search-icon",
    on: {
      click: i.searchHandler
    }
  }, [t("img", {
    staticClass: "search-icon-svg"
  })]), t("input", {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: i.keyword,
      expression: "keyword"
    }],
    ref: "searchInputRef",
    staticClass: "search-input",
    attrs: {
      placeholder: i.placeholderText,
      type: "text"
    },
    domProps: {
      value: i.keyword
    },
    on: {
      keyup: i.searchDebounce,
      input: function(s) {
        s.target.composing || (i.keyword = s.target.value);
      }
    }
  }), i.searchList.length && i.focusPosition ? t("div", {
    staticClass: "search-list-wrap"
  }, [t("div", {
    staticClass: "display-searchlist"
  }, [i._v(" " + i._s(i.focusPosition) + " of " + i._s(i.searchList.length) + " ")]), t("div", {
    staticClass: "search-btn"
  }, [t("button", {
    on: {
      click: i.previousSearchHandler
    }
  }, [t("img", {
    attrs: {
      alt: ""
    }
  })]), t("button", {
    on: {
      click: i.nextSearchHandler
    }
  }, [t("img", {
    attrs: {
      alt: ""
    }
  })])])]) : i._e()]);
}, lv = [];
const Hu = {};
var uv = /* @__PURE__ */ te(
  av,
  ov,
  lv,
  !1,
  hv,
  "9d2768f6",
  null,
  null
);
function hv(i) {
  for (let e in Hu)
    this[e] = Hu[e];
}
const Va = /* @__PURE__ */ function() {
  return uv.exports;
}(), cv = {
  name: "common-popover",
  props: {
    visible: {
      type: Boolean,
      default: !1
    },
    classes: {
      type: String,
      default: ""
    },
    position: {
      type: Object,
      default: () => ({ top: "", left: "", right: "", bottom: "" })
    }
  },
  methods: {
    handleClickOutside(i) {
      const e = this.$refs.commonPopover;
      e === i.target || e != null && e.contains(i.target) || this.handleClose();
    },
    handleClose() {
      this.$emit("close");
    }
  },
  watch: {
    visible(i) {
      i ? window.addEventListener("click", this.handleClickOutside) : window.removeEventListener("click", this.handleClickOutside);
    }
  }
};
var dv = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return i.visible ? t("div", {
    ref: "commonPopover",
    class: [i.visible ? i.$style.show : "", i.$style.common_popover],
    style: {
      left: i.position.left,
      right: i.position.right,
      top: i.position.top,
      bottom: i.position.bottom
    }
  }, [i._t("default")], 2) : i._e();
}, fv = [];
const pv = "_common_popover_v3ham_7", gv = "_show_v3ham_17", _v = {
  common_popover: pv,
  show: gv
}, Go = {};
Go.$style = _v;
var mv = /* @__PURE__ */ te(
  cv,
  dv,
  fv,
  !1,
  bv,
  null,
  null,
  null
);
function bv(i) {
  for (let e in Go)
    this[e] = Go[e];
}
const uu = /* @__PURE__ */ function() {
  return mv.exports;
}(), yv = (i, e) => new Promise((t) => {
  setTimeout(() => {
    t(e());
  }, i);
}), vv = {
  name: "Dropdown",
  props: {
    position: {
      type: Object,
      default: () => ({ top: "", left: "", right: "", bottom: "" })
    },
    titleName: {
      type: String,
      default: "title"
    },
    // props for popover
    visible: Boolean,
    items: Array,
    // option list (title: name to be displayed in option list, image: option image) (ex: {title: 'option1', [image: imageUrl, ...]})
    // On close dropdown when you click outside
    onClose: Function,
    applyHandler: {
      // Save the final result. (When using checkboxes)
      type: Function,
      default: () => 1
    },
    clickHandler: Function,
    // Click handler (if using list click without using checkbox)
    checkbox: Boolean,
    // // Set whether checkbox or no
    styleProps: {
      // type: String as PropType<StyleValue>,
      // default: "" as StyleValue,
      type: String,
      default: ""
    },
    // Set whether dropdown-list wrap-style or not (ex: {top: '10px', left: '10px', width: '10px'})
    placeholder: String,
    // Set whether placeholder or not
    infoText: {
      Type: String,
      default: ""
    },
    resourceType: {
      type: String,
      default: ""
    },
    mode: {
      type: String,
      default: "UNSELECTED"
    },
    id: String,
    // Set whether checkbox-id or not
    fetchHandler: {
      type: Function,
      default: null
    },
    displayHeader: {
      type: Boolean,
      default: !0
    },
    page: {
      type: Number,
      default: 1
    },
    hasReachedMax: {
      type: Boolean,
      default: !1
    }
  },
  // alice component
  components: {
    "search-bar": Va,
    "common-popover": uu,
    "cta-button": Qr
  },
  data() {
    return {
      isLoading: !1,
      // isThrottle: false,
      items: [],
      filteredDependency: 1,
      logTest: !1,
      inputContent: "",
      // The input value. Shows the input list searched through filtered.
      isHover: !1,
      requestParam: {
        query: ""
      }
    };
  },
  watch: {
    mode() {
      this.mode == "SELECTED" ? this.selectAll() : this.unselectAll();
    },
    visible() {
      this.visible == !0 && (this.mode == "SELECTED" ? this.selectAll() : this.unselectAll());
    }
  },
  computed: {
    // Filter your search terms
    filtered() {
      var i;
      if (this.items && this.filteredDependency) {
        const e = this.inputContent.trim();
        return !e || e == "" ? this.items : this.items != null ? (i = this.items) == null ? void 0 : i.filter((s) => s[this.titleName] != null && s[this.titleName].toUpperCase().includes(e.toUpperCase())) : this.items;
      } else
        return this.items;
    },
    checkedArray() {
      var e;
      return (e = this.filtered) == null ? void 0 : e.filter((t) => {
        if (t != null && t.checked)
          return t.checked === !0;
      });
    },
    unCheckedArray() {
      var e;
      return (e = this.filtered) == null ? void 0 : e.filter((t) => t != null && t.checked ? t.checked === !1 : !0);
    }
  },
  methods: {
    async setInitialItems() {
      const i = await this.fetchHandler();
      this.items = i;
    },
    async scrollHandler() {
      if (this.fetchHandler) {
        const i = this;
        let e = this.$refs.scrollContainer.offsetHeight, t = this.$refs.scrollContainer.scrollTop, s = this.$refs.scrollContainer.scrollHeight;
        if ((e + t) / s * 100 > 80 && !this.isLoading && !this.hasReachedMax) {
          this.isLoading = !0;
          const n = await yv(500, () => this.fetchHandler());
          n.items.slice(0, 10).map((a) => {
            i.items.push(a);
          }), this.hasReachedMax = n.hasReachedMax, this.isLoading = !1;
        }
      }
    },
    handleClick() {
      this.$nextTick(() => {
        if (this.applyHandler) {
          let i = { selected: this.checkedArray, unSelected: this.unCheckedArray, mode: this.mode, resourceType: this.resourceType };
          this.applyHandler(i);
        }
      });
    },
    getComputedStyle(i) {
      let e = "";
      return i.icon == "pie" ? e = "pie-icon" : i.icon == "tree" ? e = "tree-icon" : i.icon == "bar" ? e = "bar-icon" : i.icon == "line" && (e = "line-icon"), e;
    },
    search(i) {
      this.inputContent = i;
    },
    truncateText(i, e) {
      return i && i.length > e ? i.substring(0, e) + "..." : i;
    },
    changeHandler(i, e) {
      this.filtered[e] !== void 0 && (this.filtered[e].checked = i.target.checked, this.$set(this.filtered, e, this.filtered[e]), this.filteredDependency += 1);
    },
    // Click on option. If there is a click handler, the click handler is executed, and if there is no click handler, the checklist is saved.
    optionClick(i) {
      this.$nextTick(() => {
        this.clickHandler && this.clickHandler(i);
      });
    },
    // Full selection function. If you want to use it in the parent component, set refs and use this.$refs.locationDropdown.selectAll("location"); It can be used in the same format as
    // See OeeCenter.vue.
    selectAll() {
      let i = this.filtered.slice();
      this.filtered.splice(0), i == null || i.map((e) => {
        e.disabled || (e.checked = !0), this.filtered.push(e);
      }), this.filteredDependency += 1;
    },
    // Deselect all.
    unselectAll() {
      let i = this.filtered.slice();
      this.filtered.splice(0), i == null || i.map((e) => {
        e.default !== !0 && (e.checked = !1), this.filtered.push(e);
      }), this.filteredDependency += 1;
    },
    // handler for popover
    handleClose() {
      this.$nextTick(() => {
        this.onClose ? this.onClose() : this.visible = !1;
      });
    }
  }
};
var xv = function() {
  var i, e, t, s, r, n, a = this, o = a.$createElement, l = a._self._c || o;
  return l("common-popover", {
    style: a.styleProps,
    attrs: {
      visible: a.visible,
      position: a.position
    },
    on: {
      close: a.handleClose
    }
  }, [l("div", {
    class: a.$style.dropdown_wrap,
    style: a.styleProps
  }, [a.displayHeader && ((i = a.items) === null || i === void 0 ? void 0 : i.length) >= 5 ? l("div", [l("search-bar", {
    attrs: {
      "placeholder-text": a.placeholder || "Search",
      "request-param": a.requestParam,
      "set-search-complete-keyword": a.search
    }
  }), l("div", {
    class: a.$style.focus_border
  })], 1) : a._e(), l("ul", {
    ref: "scrollContainer",
    class: a.$style.dropdown_list,
    on: {
      scroll: a.scrollHandler
    }
  }, [a.displayHeader && a.checkbox && ((e = a.filtered) === null || e === void 0 ? void 0 : e.length) >= 5 ? l("li", {
    class: a.$style.all_select_list
  }, [l("div", {
    attrs: {
      disabled: ((t = a.checkedArray) === null || t === void 0 ? void 0 : t.length) === ((s = a.filtered) === null || s === void 0 ? void 0 : s.length)
    },
    on: {
      click: function(u) {
        return a.selectAll();
      }
    }
  }, [a._v(" Select All ")]), l("div", {
    attrs: {
      disabled: ((r = a.checkedArray) === null || r === void 0 ? void 0 : r.length) === 0
    },
    on: {
      click: function(u) {
        return a.unselectAll();
      }
    }
  }, [a._v(" Unselect All ")])]) : a._e(), l("li", [!a.checkbox && a.filtered.length == 0 ? l("label", [a._v(" All available filters are in use ")]) : a._e()]), a.infoText ? l("li", {
    class: a.$style.info_text
  }, [a._v(a._s(a.infoText))]) : a._e(), a._l(a.filtered, function(u, c) {
    return [u ? l("li", {
      key: c
    }, [l("label", {
      class: [a.checkbox ? "" : a.$style.list_hover_dropdown],
      attrs: {
        for: `dropdown-input-${c}-${a.id}`,
        disabled: u == null ? void 0 : u.disabled
      },
      on: {
        click: function(h) {
          return h.stopPropagation(), a.optionClick(u);
        }
      }
    }, [a.checkbox ? [l("input", {
      directives: [{
        name: "model",
        rawName: "v-model",
        value: u.checked,
        expression: "item.checked"
      }],
      attrs: {
        id: `dropdown-input-${c}-${a.id}`,
        type: "checkbox"
      },
      domProps: {
        value: JSON.stringify(u),
        checked: Array.isArray(u.checked) ? a._i(u.checked, JSON.stringify(u)) > -1 : u.checked
      },
      on: {
        input: function(h) {
          return a.changeHandler(h, c);
        },
        change: function(h) {
          var d = u.checked, f = h.target, g = !!f.checked;
          if (Array.isArray(d)) {
            var p = JSON.stringify(u), _ = a._i(d, p);
            f.checked ? _ < 0 && a.$set(u, "checked", d.concat([p])) : _ > -1 && a.$set(u, "checked", d.slice(0, _).concat(d.slice(_ + 1)));
          } else
            a.$set(u, "checked", g);
        }
      }
    }), l("div", {
      class: a.$style.checkbox_custom
    })] : a._e(), u != null && u.icon ? l("div", {
      class: [a.getComputedStyle(u), a.$style.defualt_style]
    }, [l("img", {
      attrs: {
        src: u.icon,
        alt: "dropdown-icon"
      }
    })]) : a._e(), a._v(" " + a._s(a.truncateText(u[a.titleName], 40)) + " ")], 2)]) : a._e()];
  }), a.isLoading ? l("div", {
    class: a.$style.spinner
  }, [l("svg", {
    attrs: {
      width: "13",
      height: "13",
      viewBox: "0 0 13 13",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg"
    }
  }, [l("circle", {
    attrs: {
      cx: "6.5",
      cy: "1.5",
      r: "1.5",
      fill: "#F4F4F4",
      "fill-opacity": "0.7"
    }
  }), l("circle", {
    attrs: {
      cx: "6.5",
      cy: "11.5",
      r: "1.5",
      fill: "#E1E1E1"
    }
  }), l("circle", {
    attrs: {
      cx: "11.5",
      cy: "6.5",
      r: "1.5",
      fill: "#D8D8D8",
      "fill-opacity": "0.85"
    }
  }), l("circle", {
    attrs: {
      cx: "1.5",
      cy: "6.5",
      r: "1.5",
      fill: "#ECECEC",
      "fill-opacity": "0.6"
    }
  }), l("circle", {
    attrs: {
      cx: "10.0356",
      cy: "2.96458",
      r: "1.5",
      transform: "rotate(45 10.0356 2.96458)",
      fill: "#F7F7F7",
      "fill-opacity": "0.8"
    }
  }), l("circle", {
    attrs: {
      cx: "2.96436",
      cy: "10.0354",
      r: "1.5",
      transform: "rotate(45 2.96436 10.0354)",
      fill: "#EAEAEA",
      "fill-opacity": "0.55"
    }
  }), l("circle", {
    attrs: {
      cx: "10.0356",
      cy: "10.0354",
      r: "1.5",
      transform: "rotate(45 10.0356 10.0354)",
      fill: "#E1E1E1",
      "fill-opacity": "0.8"
    }
  }), l("circle", {
    attrs: {
      cx: "2.96436",
      cy: "2.96458",
      r: "1.5",
      transform: "rotate(45 2.96436 2.96458)",
      fill: "#F0F0F0",
      "fill-opacity": "0.65"
    }
  })])]) : a._e()], 2), l("div", {
    class: a.$style.dropdown_footer
  }, [a.checkbox ? l("cta-button", {
    attrs: {
      disabled: ((n = a.checkedArray) === null || n === void 0 ? void 0 : n.length) === 0 && a.mode == "UNSELECTED",
      "input-text": "Apply Filter",
      "color-type": "blue-fill",
      "click-handler": a.handleClick
    }
  }, [a._v(" Apply Filter ")]) : a._e()], 1)])]);
}, wv = [];
const Sv = "_dropdown_wrap_1a9m6_7", Dv = "_dropdown_list_1a9m6_25", Pv = "_checkbox_custom_1a9m6_45", Tv = "_all_select_list_1a9m6_78", kv = "_info_text_1a9m6_97", Cv = "_list_hover_dropdown_1a9m6_103", Mv = "_spinner_1a9m6_106", Ov = "_rotate_image_1a9m6_1", Av = "_dropdown_footer_1a9m6_130", Lv = {
  dropdown_wrap: Sv,
  dropdown_list: Dv,
  checkbox_custom: Pv,
  all_select_list: Tv,
  info_text: kv,
  list_hover_dropdown: Cv,
  spinner: Mv,
  rotate_image: Ov,
  dropdown_footer: Av
}, Zo = {};
Zo.$style = Lv;
var jv = /* @__PURE__ */ te(
  vv,
  xv,
  wv,
  !1,
  Ev,
  "e878971e",
  null,
  null
);
function Ev(i) {
  for (let e in Zo)
    this[e] = Zo[e];
}
const Iv = /* @__PURE__ */ function() {
  return jv.exports;
}(), Yv = "_tooltip_fg4y3_1", Rv = "_mainTooltip_fg4y3_8", Nv = "_tooltiptextwhite_fg4y3_8", $v = "_top_fg4y3_22", Fv = "_bottom_fg4y3_33", Bv = "_left_fg4y3_44", Hv = "_right_fg4y3_55", zv = "_tooltiptextblack_fg4y3_66", Xv = {
  tooltip: Yv,
  mainTooltip: Rv,
  tooltiptextwhite: Nv,
  top: $v,
  bottom: Fv,
  left: Bv,
  right: Hv,
  tooltiptextblack: zv
}, Vv = {
  props: {
    styleProps: {
      type: String,
      default: ""
    },
    position: { type: String, default: "top" },
    color: { type: String, default: "black" }
  },
  methods: {
    handleHover() {
      const { clientWidth: i, clientHeight: e } = this.$refs.customWidth;
      this.position === "top" ? this.tooltipPos = `bottom : ${e + 9}px ` : this.position === "bottom" ? this.tooltipPos = `top : ${e + 9}px ` : this.position === "left" ? this.tooltipPos = `right : ${i + 6}px ` : this.tooltipPos = `left : ${i + 6}px `;
    }
  },
  data() {
    return {
      tooltipPos: "top : 0px"
    };
  },
  computed: {
    positionComputed() {
      let i = this.position;
      return i === "top" ? i = "top" : i === "bottom" ? i = "bottom" : i === "left" ? i = "right" : i === "right" ? i = "left" : i = "top", i;
    },
    tooltipClassComputed() {
      return `${Xv[this.positionComputed]}`;
    }
  }
};
var Uv = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    class: i.$style.tooltip,
    on: {
      mouseover: i.handleHover
    }
  }, [t("div", {
    ref: "customWidth"
  }, [i._t("context")], 2), t("div", {
    staticStyle: {
      position: "absolute"
    },
    style: i.tooltipPos
  }, [t("div", {
    class: i.$style.mainTooltip,
    style: i.styleProps
  }, [i.color === "white" ? t("span", {
    class: [i.tooltipClassComputed, i.$style.tooltiptextwhite]
  }, [i._t("body")], 2) : i._e(), i.color === "black" ? t("span", {
    class: [i.tooltipClassComputed, i.$style.tooltiptextblack]
  }, [i._t("body")], 2) : i._e()])])]);
}, Wv = [];
const Gv = "_tooltip_fg4y3_1", Zv = "_mainTooltip_fg4y3_8", Kv = "_tooltiptextwhite_fg4y3_8", Qv = "_top_fg4y3_22", qv = "_bottom_fg4y3_33", Jv = "_left_fg4y3_44", ex = "_right_fg4y3_55", tx = "_tooltiptextblack_fg4y3_66", ix = {
  tooltip: Gv,
  mainTooltip: Zv,
  tooltiptextwhite: Kv,
  top: Qv,
  bottom: qv,
  left: Jv,
  right: ex,
  tooltiptextblack: tx
}, Ko = {};
Ko.$style = ix;
var sx = /* @__PURE__ */ te(
  Vv,
  Uv,
  Wv,
  !1,
  rx,
  null,
  null,
  null
);
function rx(i) {
  for (let e in Ko)
    this[e] = Ko[e];
}
const nx = /* @__PURE__ */ function() {
  return sx.exports;
}(), ax = {
  name: "master-filter",
  props: {
    placeholder: {
      type: String,
      default: "Search Filter"
    },
    hasReachedMax: {
      type: Boolean,
      default: !1
    },
    masterDropdownList: {
      type: Array,
      default: () => []
    },
    filterResource: {
      type: Object,
      default: () => ({ resourceType: "", list: [], mode: "UNSELECTED" })
    },
    selectedList: Array,
    titleName: {
      type: String,
      default: "title"
    },
    masterDropdownPosition: {
      type: Object,
      default: () => ({ top: "", left: "", right: "", bottom: "" })
    },
    filterDropdownPosition: {
      type: Object,
      default: () => ({ top: "", left: "", right: "", bottom: "" })
    },
    masterDropdownClickHandler: Function,
    // handler for items click on dropdown (1st stage)
    applyHandler: {
      // Save the final result. (When using checkboxes)
      type: Function,
      default: () => 1
    },
    clearAll: {
      // Save the final result. (When using checkboxes)
      type: Function,
      default: () => 1
    },
    singleClear: Function,
    fetchHandler: {
      type: Function,
      default: null
    }
  },
  components: {
    "master-dropdown": Iv,
    Tooltip: nx
  },
  data() {
    return {
      // dropdown prop
      closeFilter: { show: !1 },
      masterDropdown: !1,
      filterDropdown: !1,
      styleProps: "margin-top: 1px",
      // tooltip prop
      tooltipStyles: "width: 100px;"
    };
  },
  computed: {
    computedPlaceholder() {
      var i;
      return `Search ${this.capitalizeFirstLetter((i = this.filterResource.resourceType) == null ? void 0 : i.toLowerCase())}`;
    },
    showClearAllIcon() {
      let i = !1;
      return this.selectedList && this.selectedList.forEach((e) => {
        e.list.length > 0 && (i = !0);
      }), i;
    }
  },
  methods: {
    // dropdown toggler
    toggle() {
      this.closeFilter.show = !1, this.filterDropdown = !1, this.masterDropdown = !this.masterDropdown;
    },
    handleApplyHandler(i, e) {
      this.filterDropdown = !1, e && (e.show = !1), this.applyHandler && this.applyHandler(i);
    },
    mainDropdownClickHandler(i) {
      this.masterDropdownClickHandler && this.masterDropdownClickHandler(i), this.masterDropdown = !1, this.filterDropdown = !0;
    },
    capitalizeFirstLetter(i) {
      return (i == null ? void 0 : i.charAt(0).toUpperCase()) + (i == null ? void 0 : i.slice(1));
    },
    // hide dropdown on foucsout
    onCloseMasterDropdown() {
      this.masterDropdown = !1;
    },
    onCloseFilterDropdown() {
      this.filterDropdown = !1;
    },
    filterTogleClick(i) {
      this.masterDropdown = !1, this.filterDropdown = !1, i.show = !i.show, i != this.closeFilter && (this.closeFilter.show = !1, this.closeFilter = i);
    },
    closeFilterDropdown(i) {
      i.show = !1;
    },
    handleClearClick(i) {
      this.closeFilter.show = !1, this.masterDropdown = !1, this.filterDropdown = !1, this.singleClear && this.singleClear(i);
    },
    async handleFetch() {
      if (this.fetchHandler)
        return await this.fetchHandler(this.filterResource.resourceType);
    },
    handlClearAll() {
      this.closeFilter.show = !1, this.masterDropdown = !1, this.filterDropdown = !1, this.clearAll && this.clearAll(this.selectedList);
    }
  },
  mounted() {
  },
  unmounted() {
  }
};
var ox = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    class: i.$style.filter_container
  }, [i._l(i.selectedList, function(s, r) {
    return t("div", {
      key: r,
      class: i.$style.filter_element
    }, [s.selectedCount > 0 ? t("div", {
      class: i.$style.selected_cta,
      on: {
        click: function(n) {
          return n.stopPropagation(), function() {
            return i.filterTogleClick(s);
          }.apply(null, arguments);
        }
      }
    }, [t("div", {
      class: i.$style.filter_wrapper
    }, [t("span", [i._v(i._s(s.selectedCount) + " " + i._s(i.capitalizeFirstLetter(s.resourceType.toLowerCase())))]), t("Tooltip", {
      attrs: {
        position: "top",
        color: "black",
        "style-props": i.tooltipStyles
      },
      scopedSlots: i._u([{
        key: "context",
        fn: function() {
          return [t("div", {
            on: {
              click: function(n) {
                return n.stopPropagation(), i.handleClearClick(s);
              }
            }
          }, [t("img", {
            class: i.$style.cross_icon,
            attrs: {
              alt: "cross_icon"
            }
          })])];
        },
        proxy: !0
      }, {
        key: "body",
        fn: function() {
          return [t("div", [i._v("Clear Filters")])];
        },
        proxy: !0
      }], null, !0)
    })], 1)]) : i._e(), t("master-dropdown", {
      attrs: {
        id: r.toString(),
        "style-props": i.styleProps,
        "title-name": i.titleName,
        displayHeader: !1,
        visible: s.show,
        selected: !0,
        checkbox: !0,
        items: s.list,
        "resource-type": s.resourceType,
        mode: s.mode,
        position: {
          top: "29px",
          left: "7px"
        },
        "on-close": function() {
          return i.closeFilterDropdown(s);
        },
        "apply-handler": function(n) {
          return i.handleApplyHandler(n, s);
        }
      }
    })], 1);
  }), t("div", [t("div", {
    class: i.$style.filter_cta,
    on: {
      click: function(s) {
        return s.stopPropagation(), i.toggle.apply(null, arguments);
      }
    }
  }, [t("div", {
    class: i.$style.filter_wrapper
  }, [t("span", [i._v("Add Filter")]), t("img", {
    class: i.$style.filter_icon,
    attrs: {
      alt: "filter-icon"
    }
  })])]), t("master-dropdown", {
    attrs: {
      "style-props": i.styleProps,
      "title-name": i.titleName,
      visible: i.masterDropdown,
      checkbox: !1,
      placeholder: "Search Filter",
      items: i.masterDropdownList,
      "click-handler": i.mainDropdownClickHandler,
      "on-close": i.onCloseMasterDropdown,
      position: i.masterDropdownPosition
    }
  }), t("master-dropdown", {
    attrs: {
      displayHeader: !0,
      "style-props": "min-width:205px;  margin-top:2px;",
      "title-name": i.titleName,
      visible: i.filterDropdown,
      checkbox: !0,
      "resource-type": i.filterResource.resourceType,
      mode: i.filterResource.mode,
      items: i.filterResource.list,
      placeholder: i.computedPlaceholder,
      "on-close": i.onCloseFilterDropdown,
      position: i.filterDropdownPosition,
      "apply-handler": i.handleApplyHandler,
      "fetch-handler": i.handleFetch,
      "has-reached-max": i.hasReachedMax
    }
  })], 1), i.showClearAllIcon ? t("Tooltip", {
    attrs: {
      position: "top",
      color: "white",
      "style-props": i.tooltipStyles
    },
    scopedSlots: i._u([{
      key: "context",
      fn: function() {
        return [t("div", {
          class: i.$style.clear_filter_all,
          on: {
            click: function(s) {
              return s.stopPropagation(), i.handlClearAll.apply(null, arguments);
            }
          }
        }, [t("img", {
          class: i.$style.cross_icon,
          attrs: {
            alt: "cross_icon"
          }
        })])];
      },
      proxy: !0
    }, {
      key: "body",
      fn: function() {
        return [t("div", [i._v("Clear All Filters")])];
      },
      proxy: !0
    }], null, !1, 3112583915)
  }) : i._e()], 2);
}, lx = [];
const ux = "_filter_container_1s271_1", hx = "_filter_cta_1s271_4", cx = "_selected_cta_1s271_5", dx = "_filter_wrapper_1s271_46", fx = "_filter_icon_1s271_53", px = "_cross_icon_1s271_57", gx = "_filter_element_1s271_61", _x = "_clear_filter_all_1s271_67", mx = {
  filter_container: ux,
  filter_cta: hx,
  selected_cta: cx,
  filter_wrapper: dx,
  filter_icon: fx,
  cross_icon: px,
  filter_element: gx,
  clear_filter_all: _x
}, Qo = {};
Qo.$style = mx;
var bx = /* @__PURE__ */ te(
  ax,
  ox,
  lx,
  !1,
  yx,
  "049e5154",
  null,
  null
);
function yx(i) {
  for (let e in Qo)
    this[e] = Qo[e];
}
const ZO = /* @__PURE__ */ function() {
  return bx.exports;
}();
function $t(i) {
  return Number(i) !== i;
}
function Ac(i) {
  return {}.toString.call(i);
}
function vx(i, e = "Assertion failed") {
  if (!i)
    throw new Error(e);
}
function dt(i) {
  if (i != null && !S(i)) {
    let e = Number(i);
    return $t(e) && Ii(i) && i != "" ? dt(i.replace(/[^0-9.\-]+/g, "")) : e;
  }
  return i;
}
function Lc(i) {
  if (Vn(i))
    return new Date(i);
  if (S(i))
    return new Date(i);
  {
    let e = Number(i);
    return S(e) ? new Date(e) : new Date(i);
  }
}
function jc(i) {
  if ($t(i))
    return "NaN";
  if (i === 1 / 0)
    return "Infinity";
  if (i === -1 / 0)
    return "-Infinity";
  if (i === 0 && 1 / i === -1 / 0)
    return "-0";
  let e = i < 0;
  i = Math.abs(i);
  let t = /^([0-9]+)(?:\.([0-9]+))?(?:e[\+\-]([0-9]+))?$/.exec("" + i), s = t[1], r = t[2] || "", n;
  if (t[3] === void 0)
    n = r === "" ? s : s + "." + r;
  else {
    let a = +t[3];
    if (i < 1) {
      let o = a - 1;
      n = "0." + qo("0", o) + s + r;
    } else {
      let o = a - r.length;
      o === 0 ? n = s + r : o < 0 ? n = s + r.slice(0, o) + "." + r.slice(o) : n = s + r + qo("0", o);
    }
  }
  return e ? "-" + n : n;
}
function qo(i, e) {
  return new Array(e + 1).join(i);
}
function Vn(i) {
  return Ac(i) === "[object Date]";
}
function Ii(i) {
  return typeof i == "string";
}
function S(i) {
  return typeof i == "number" && Number(i) == i;
}
function ys(i) {
  return typeof i == "object" && i !== null;
}
function Un(i) {
  return Array.isArray(i);
}
const pi = "__§§§__", ls = "__§§§§__", xx = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  PLACEHOLDER: pi,
  PLACEHOLDER2: ls,
  assert: vx,
  getType: Ac,
  isArray: Un,
  isDate: Vn,
  isNaN: $t,
  isNumber: S,
  isObject: ys,
  isString: Ii,
  numberToString: jc,
  repeat: qo,
  toDate: Lc,
  toNumber: dt
}, Symbol.toStringTag, { value: "Module" }));
function Yi(i, e) {
  const t = i.length;
  for (let s = 0; s < t; ++s)
    if (i[s] === e)
      return s;
  return -1;
}
function Ec(i, e) {
  const t = i.length;
  for (let s = 0; s < t; ++s)
    if (e(i[s]))
      return !0;
  return !1;
}
function Wn(i, e) {
  const t = i.length, s = new Array(t);
  for (let r = 0; r < t; ++r)
    s[r] = e(i[r], r);
  return s;
}
function w(i, e) {
  const t = i.length;
  for (let s = 0; s < t; ++s)
    e(i[s], s);
}
function Rs(i, e) {
  let t = i.length;
  for (; t > 0; )
    --t, e(i[t], t);
}
function hu(i, e) {
  const t = i.length;
  for (let s = 0; s < t && e(i[s], s); ++s)
    ;
}
function wx(i, e) {
  const t = i.length;
  for (let s = e; s < t; ++s)
    i[s - e] = i[s];
  i.length = t - e;
}
function Sx(i) {
  const e = i.length;
  return e ? i[e - 1] : void 0;
}
function Dx(i) {
  return i[0];
}
function Ic(i, e, t) {
  t = Math.max(0, Math.min(t, i.length)), i.splice(t, 0, e);
}
function Px(i, e, t) {
  bt(i, e), Ic(i, e, t);
}
function Tx(i, e) {
  const t = e.length;
  for (let s = 0; s < t; ++s)
    i.push(e[s]);
}
function bt(i, e) {
  let t = !1, s = 0;
  for (; ; ) {
    if (s = i.indexOf(e, s), s === -1)
      return t;
    t = !0, i.splice(s, 1);
  }
}
function nt(i, e) {
  let t = i.indexOf(e);
  return t !== -1 ? (i.splice(t, 1), !0) : !1;
}
function Yc(i, e, t) {
  let s = Yi(i, e);
  s !== -1 && Zn(i, s), t == null ? i.push(e) : Ns(i, t, e);
}
function kx(i, e, t) {
  S(t) ? t === 0 ? i.unshift(e) : i.splice(t, 0, e) : i.push(e);
}
function Bs(i, e) {
  i.indexOf(e) === -1 && i.push(e);
}
function Cx(i, e, t) {
  let s = i.indexOf(e);
  s !== -1 && i.splice(s, 1), S(t) ? i.splice(t, 0, e) : i.push(e);
}
function Mx(i) {
  return Array.isArray(i) ? i : [i];
}
function Ox(i, e) {
  return Yi(i, e) !== -1;
}
function Gn(i) {
  const e = i.length, t = new Array(e);
  for (let s = 0; s < e; ++s)
    t[s] = i[s];
  return t;
}
function Ax(i, e, t = i.length) {
  const s = new Array(t - e);
  for (let r = e; r < t; ++r)
    s[r - e] = i[r];
  return s;
}
function Ns(i, e, t) {
  i.splice(e, 0, t);
}
function Zn(i, e) {
  i.splice(e, 1);
}
function cu(i, e) {
  const t = i.length;
  for (let s = 0; s < t; ++s)
    if (e(i[s], s))
      return s;
  return -1;
}
function Rc(i, e) {
  let t = i.length;
  for (; t > 0; )
    if (--t, e(i[t], t))
      return t;
  return -1;
}
function du(i, e) {
  const t = cu(i, e);
  if (t !== -1)
    return i[t];
}
function Nc(i, e) {
  const t = Rc(i, e);
  if (t !== -1)
    return i[t];
}
function Lx(i, e) {
  const t = i.length;
  for (let s = 0; s < t; ++s) {
    const r = e(i[s], s);
    if (r !== void 0)
      return r;
  }
}
function jx(i) {
  let e = i.length, t, s;
  for (; e !== 0; )
    s = Math.floor(Math.random() * e), e -= 1, t = i[e], i[e] = i[s], i[s] = t;
}
function ji(i, e) {
  let t = 0, s = i.length, r = !1;
  for (; t < s; ) {
    const n = t + s >> 1, a = e(i[n]);
    a < 0 ? t = n + 1 : a === 0 ? (r = !0, t = n + 1) : s = n;
  }
  return {
    found: r,
    index: r ? t - 1 : t
  };
}
function $c(i, e) {
  let t = 0, s = i.length, r = !1;
  for (; t < s; ) {
    const n = t + s >> 1, a = e(i[n]);
    a < 0 ? t = n + 1 : (a === 0 && (r = !0), s = n);
  }
  return {
    found: r,
    index: t
  };
}
function sn(i, e) {
  let t = i.length;
  for (; t > 0; )
    --t, e(i[t]) || i.splice(t, 1);
}
const Ex = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  add: kx,
  any: Ec,
  copy: Gn,
  each: w,
  eachContinue: hu,
  eachReverse: Rs,
  find: du,
  findIndex: cu,
  findIndexReverse: Rc,
  findMap: Lx,
  findReverse: Nc,
  first: Dx,
  getFirstSortedIndex: $c,
  getSortedIndex: ji,
  has: Ox,
  indexOf: Yi,
  insert: Ic,
  insertIndex: Ns,
  keepIf: sn,
  last: Sx,
  map: Wn,
  move: Yc,
  pushAll: Tx,
  pushOne: Bs,
  remove: bt,
  removeFirst: nt,
  removeIndex: Zn,
  replace: Cx,
  setIndex: Px,
  shiftLeft: wx,
  shuffle: jx,
  slice: Ax,
  toArray: Mx
}, Symbol.toStringTag, { value: "Module" }));
class ar {
  /**
   * Constructor.
   */
  constructor() {
    Object.defineProperty(this, "_disposed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._disposed = !1;
  }
  /**
   * Checks if object is disposed.
   *
   * @return Disposed?
   */
  isDisposed() {
    return this._disposed;
  }
  /**
   * Disposes the object.
   */
  dispose() {
    this._disposed || (this._disposed = !0, this._dispose());
  }
}
class He {
  /**
   * Constructor.
   *
   * @param dispose  Function that disposes object
   */
  constructor(e) {
    Object.defineProperty(this, "_disposed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_dispose", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._disposed = !1, this._dispose = e;
  }
  /**
   * Checks if object is disposed.
   *
   * @return Disposed?
   */
  isDisposed() {
    return this._disposed;
  }
  /**
   * Disposes the object.
   */
  dispose() {
    this._disposed || (this._disposed = !0, this._dispose());
  }
}
class Fc extends ar {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_disposers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    });
  }
  _dispose() {
    w(this._disposers, (e) => {
      e.dispose();
    });
  }
}
class st extends ar {
  constructor(e) {
    super(), Object.defineProperty(this, "_disposers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._disposers = e;
  }
  _dispose() {
    w(this._disposers, (e) => {
      e.dispose();
    });
  }
}
class Ix extends ar {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_disposer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_value", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  _dispose() {
    this._disposer != null && (this._disposer.dispose(), this._disposer = void 0);
  }
  /**
   * Returns current value.
   *
   * @return Value
   */
  get() {
    return this._value;
  }
  /**
   * Sets value and disposes previous disposer if it was set.
   *
   * @param value     New value
   * @param disposer  Disposer
   */
  set(e, t) {
    this._disposer != null && this._disposer.dispose(), this._disposer = t, this._value = e;
  }
  /**
   * Resets the disposer value.
   */
  reset() {
    this.set(void 0, void 0);
  }
}
class Ua extends He {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_counter", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    });
  }
  /**
   * [increment description]
   *
   * @todo Description
   */
  increment() {
    return ++this._counter, new He(() => {
      --this._counter, this._counter === 0 && this.dispose();
    });
  }
}
class or {
  /**
   * Constructor
   */
  constructor() {
    Object.defineProperty(this, "_listeners", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_killed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_disabled", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_iterating", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_enabled", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_disposed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._listeners = [], this._killed = [], this._disabled = {}, this._iterating = 0, this._enabled = !0, this._disposed = !1;
  }
  /**
   * Returns if this object has been already disposed.
   *
   * @return Disposed?
   */
  isDisposed() {
    return this._disposed;
  }
  /**
   * Dispose (destroy) this object.
   */
  dispose() {
    if (!this._disposed) {
      this._disposed = !0;
      const e = this._listeners;
      this._iterating = 1, this._listeners = null, this._disabled = null;
      try {
        w(e, (t) => {
          t.disposer.dispose();
        });
      } finally {
        this._killed = null, this._iterating = null;
      }
    }
  }
  /**
   * Checks if this particular event dispatcher has any listeners set.
   *
   * @return Has listeners?
   */
  hasListeners() {
    return this._listeners.length !== 0;
  }
  /**
   * Checks if this particular event dispatcher has any particular listeners set.
   *
   * @return Has particular event listeners?
   */
  hasListenersByType(e) {
    return Ec(this._listeners, (t) => (t.type === null || t.type === e) && !t.killed);
  }
  /**
   * Enable dispatching of events if they were previously disabled by
   * `disable()`.
   */
  enable() {
    this._enabled = !0;
  }
  /**
   * Disable dispatching of events until re-enabled by `enable()`.
   */
  disable() {
    this._enabled = !1;
  }
  /**
   * Enable dispatching particular event, if it was disabled before by
   * `disableType()`.
   *
   * @param type Event type
   */
  enableType(e) {
    delete this._disabled[e];
  }
  /**
   * Disable dispatching of events for a certain event type.
   *
   * Optionally, can set how many dispatches to skip before automatically
   * re-enabling the dispatching.
   *
   * @param type    Event type
   * @param amount  Number of event dispatches to skip
   */
  disableType(e, t = 1 / 0) {
    this._disabled[e] = t;
  }
  /**
   * Removes listener from dispatcher.
   *
   * Will throw an exception if such listener does not exists.
   *
   * @param listener Listener to remove
   */
  _removeListener(e) {
    if (this._iterating === 0) {
      const t = this._listeners.indexOf(e);
      if (t === -1)
        throw new Error("Invalid state: could not remove listener");
      this._listeners.splice(t, 1);
    } else
      this._killed.push(e);
  }
  /**
   * Removes existing listener by certain parameters.
   *
   * @param once         Listener's once setting
   * @param type         Listener's type
   * @param callback     Callback function
   * @param context      Callback context
   */
  _removeExistingListener(e, t, s, r) {
    if (this._disposed)
      throw new Error("EventDispatcher is disposed");
    this._eachListener((n) => {
      n.once === e && // TODO is this correct ?
      n.type === t && (s === void 0 || n.callback === s) && n.context === r && n.disposer.dispose();
    });
  }
  /**
   * Checks if dispatching for particular event type is enabled.
   *
   * @param type  Event type
   * @return Enabled?
   */
  isEnabled(e) {
    if (this._disposed)
      throw new Error("EventDispatcher is disposed");
    return this._enabled && this._listeners.length > 0 && this.hasListenersByType(e) && this._disabled[e] === void 0;
  }
  /**
   * Removes all listeners of a particular event type
   *
   * @param type  Listener's type
   */
  removeType(e) {
    if (this._disposed)
      throw new Error("EventDispatcher is disposed");
    this._eachListener((t) => {
      t.type === e && t.disposer.dispose();
    });
  }
  /**
   * Checks if there's already a listener with specific parameters.
   *
   * @param type      Listener's type
   * @param callback  Callback function
   * @param context   Callback context
   * @return Has listener?
   */
  has(e, t, s) {
    return cu(this._listeners, (n) => n.once !== !0 && // Ignoring "once" listeners
    n.type === e && (t === void 0 || n.callback === t) && n.context === s) !== -1;
  }
  /**
   * Checks whether event of the particular type should be dispatched.
   *
   * @param type  Event type
   * @return Dispatch?
   */
  _shouldDispatch(e) {
    if (this._disposed)
      throw new Error("EventDispatcher is disposed");
    const t = this._disabled[e];
    return S(t) ? (t <= 1 ? delete this._disabled[e] : --this._disabled[e], !1) : this._enabled;
  }
  /**
   * [_eachListener description]
   *
   * All of this extra code is needed when a listener is removed while iterating
   *
   * @todo Description
   * @param fn [description]
   */
  _eachListener(e) {
    ++this._iterating;
    try {
      w(this._listeners, e);
    } finally {
      --this._iterating, this._iterating === 0 && this._killed.length !== 0 && (w(this._killed, (t) => {
        this._removeListener(t);
      }), this._killed.length = 0);
    }
  }
  /**
   * Dispatches an event immediately without waiting for next cycle.
   *
   * @param type   Event type
   * @param event  Event object
   * @todo automatically add in type and target properties if they are missing
   */
  dispatch(e, t) {
    this._shouldDispatch(e) && this._eachListener((s) => {
      !s.killed && (s.type === null || s.type === e) && s.dispatch(e, t);
    });
  }
  /**
   * Shelves the event to be dispatched within next update cycle.
   *
   * @param type   Event type
   * @param event  Event object
   * @todo automatically add in type and target properties if they are missing
   */
  /*public dispatchLater<Key extends keyof T>(type: Key, event: T[Key]): void {
      if (this._shouldDispatch(type)) {
          this._eachListener((listener) => {
              // TODO check if it's faster to use an object of listeners rather than a single big array
              if (!listener.killed && (listener.type === null || listener.type === type)) {
                  // TODO if the function throws, maybe it should keep going ?
                  // TODO dispatch during the update cycle, rather than using whenIdle
                  $async.whenIdle(() => {
                      if (!listener.killed) {
                          listener.dispatch(type, event);
                      }
                  });
              }
          });
      }
  }*/
  /**
   * Creates, catalogs and returns an [[EventListener]].
   *
   * Event listener can be disposed.
   *
   * @param once         Listener's once setting
   * @param type         Listener's type
   * @param callback     Callback function
   * @param context      Callback context
   * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied
   * @param dispatch
   * @returns An event listener
   */
  _on(e, t, s, r, n, a) {
    if (this._disposed)
      throw new Error("EventDispatcher is disposed");
    this._removeExistingListener(e, t, s, r);
    const o = {
      type: t,
      callback: s,
      context: r,
      shouldClone: n,
      dispatch: a,
      killed: !1,
      once: e,
      disposer: new He(() => {
        o.killed = !0, this._removeListener(o);
      })
    };
    return this._listeners.push(o), o;
  }
  /**
   * Creates an event listener to be invoked on **any** event.
   *
   * @param callback     Callback function
   * @param context      Callback context
   * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied
   * @returns A disposable event listener
   */
  onAll(e, t, s = !0) {
    return this._on(!1, null, e, t, s, (r, n) => e.call(t, n)).disposer;
  }
  /**
   * Creates an event listener to be invoked on a specific event type.
   *
   * ```TypeScript
   * button.events.once("click", (ev) => {
   *   console.log("Button clicked");
   * }, this);
   * ```
   * ```JavaScript
   * button.events.once("click", (ev) => {
   *   console.log("Button clicked");
   * }, this);
   * ```
   *
   * The above will invoke our custom event handler whenever series we put
   * event on is hidden.
   *
   * @param type         Listener's type
   * @param callback     Callback function
   * @param context      Callback context
   * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied
   * @returns A disposable event listener
   */
  on(e, t, s, r = !0) {
    return this._on(!1, e, t, s, r, (n, a) => t.call(s, a)).disposer;
  }
  /**
   * Creates an event listener to be invoked on a specific event type once.
   *
   * Once the event listener is invoked, it is automatically disposed.
   *
   * ```TypeScript
   * button.events.once("click", (ev) => {
   *   console.log("Button clicked");
   * }, this);
   * ```
   * ```JavaScript
   * button.events.once("click", (ev) => {
   *   console.log("Button clicked");
   * }, this);
   * ```
   *
   * The above will invoke our custom event handler the first time series we
   * put event on is hidden.
   *
   * @param type         Listener's type
   * @param callback     Callback function
   * @param context      Callback context
   * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied
   * @returns A disposable event listener
   */
  once(e, t, s, r = !0) {
    const n = this._on(!0, e, t, s, r, (a, o) => {
      n.disposer.dispose(), t.call(s, o);
    });
    return n.disposer;
  }
  /**
   * Removes the event listener with specific parameters.
   *
   * @param type         Listener's type
   * @param callback     Callback function
   * @param context      Callback context
   */
  off(e, t, s) {
    this._removeExistingListener(!1, e, t, s);
  }
  /**
   * Copies all dispatcher parameters, including listeners, from another event
   * dispatcher.
   *
   * @param source Source event dispatcher
   * @ignore
   */
  copyFrom(e) {
    if (this._disposed)
      throw new Error("EventDispatcher is disposed");
    if (e === this)
      throw new Error("Cannot copyFrom the same TargetedEventDispatcher");
    const t = [];
    return w(e._listeners, (s) => {
      !s.killed && s.shouldClone && (s.type === null ? t.push(this.onAll(s.callback, s.context)) : s.once ? t.push(this.once(s.type, s.callback, s.context)) : t.push(this.on(s.type, s.callback, s.context)));
    }), new st(t);
  }
}
function dr(i, e) {
  if (!(i >= 0 && i < e))
    throw new Error("Index out of bounds: " + i);
}
class lr {
  /**
   * Constructor
   *
   * @param initial  Inital list of values to add to list
   */
  constructor(e = []) {
    Object.defineProperty(this, "_values", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "events", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new or()
    }), this._values = e;
  }
  /**
   * An array of values in the list.
   *
   * Do not use this property to add values. Rather use dedicated methods, like
   * `push()`, `removeIndex()`, etc.
   *
   * @readonly
   * @return List values
   */
  get values() {
    return this._values;
  }
  /**
   * Checks if list contains specific item reference.
   *
   * @param item  Item to search for
   * @return `true` if found, `false` if not found
   */
  contains(e) {
    return this._values.indexOf(e) !== -1;
  }
  /**
   * Removes specific item from the list.
   *
   * @param item An item to remove
   */
  removeValue(e) {
    let t = 0, s = this._values.length;
    for (; t < s; )
      this._values[t] === e ? (this.removeIndex(t), --s) : ++t;
  }
  /**
   * Searches the list for specific item and returns its index.
   *
   * @param item  An item to search for
   * @return Index or -1 if not found
   */
  indexOf(e) {
    return Yi(this._values, e);
  }
  /**
   * Number of items in list.
   *
   * @readonly
   * @return Number of items
   */
  get length() {
    return this._values.length;
  }
  /**
   * Checks if there's a value at specific index.
   *
   * @param index  Index
   * @return Value exists?
   */
  hasIndex(e) {
    return e >= 0 && e < this._values.length;
  }
  /**
   * Returns an item at specified index.
   *
   * @param index  Index
   * @return List item
   */
  getIndex(e) {
    return this._values[e];
  }
  _onPush(e) {
    this.events.isEnabled("push") && this.events.dispatch("push", {
      type: "push",
      target: this,
      newValue: e
    });
  }
  _onInsertIndex(e, t) {
    this.events.isEnabled("insertIndex") && this.events.dispatch("insertIndex", {
      type: "insertIndex",
      target: this,
      index: e,
      newValue: t
    });
  }
  _onSetIndex(e, t, s) {
    this.events.isEnabled("setIndex") && this.events.dispatch("setIndex", {
      type: "setIndex",
      target: this,
      index: e,
      oldValue: t,
      newValue: s
    });
  }
  _onRemoveIndex(e, t) {
    this.events.isEnabled("removeIndex") && this.events.dispatch("removeIndex", {
      type: "removeIndex",
      target: this,
      index: e,
      oldValue: t
    });
  }
  _onMoveIndex(e, t, s) {
    this.events.isEnabled("moveIndex") && this.events.dispatch("moveIndex", {
      type: "moveIndex",
      target: this,
      oldIndex: e,
      newIndex: t,
      value: s
    });
  }
  _onClear(e) {
    this.events.isEnabled("clear") && this.events.dispatch("clear", {
      type: "clear",
      target: this,
      oldValues: e
    });
  }
  /**
   * Sets value at specific index.
   *
   * If there's already a value at the index, it is overwritten.
   *
   * @param index  Index
   * @param value  New value
   * @return New value
   */
  setIndex(e, t) {
    dr(e, this._values.length);
    const s = this._values[e];
    return s !== t && (this._values[e] = t, this._onSetIndex(e, s, t)), s;
  }
  /**
   * Adds an item to the list at a specific index, which pushes all the other
   * items further down the list.
   *
   * @param index Index
   * @param item  An item to add
   */
  insertIndex(e, t) {
    return dr(e, this._values.length + 1), Ns(this._values, e, t), this._onInsertIndex(e, t), t;
  }
  /**
   * Swaps indexes of two items in the list.
   *
   * @param a  Item 1
   * @param b  Item 2
   */
  swap(e, t) {
    const s = this._values.length;
    if (dr(e, s), dr(t, s), e !== t) {
      const r = this._values[e], n = this._values[t];
      this._values[e] = n, this._onSetIndex(e, r, n), this._values[t] = r, this._onSetIndex(t, n, r);
    }
  }
  /**
   * Removes a value at specific index.
   *
   * @param index  Index of value to remove
   * @return Removed value
   */
  removeIndex(e) {
    dr(e, this._values.length);
    const t = this._values[e];
    return Zn(this._values, e), this._onRemoveIndex(e, t), t;
  }
  /**
   * Moves an item to a specific index within the list.
   *
   * If the index is not specified it will move the item to the end of the
   * list.
   *
   * @param value  Item to move
   * @param index  Index to place item at
   */
  moveValue(e, t) {
    let s = this.indexOf(e);
    if (s !== -1)
      if (Zn(this._values, s), t == null) {
        const r = this._values.length;
        this._values.push(e), this._onMoveIndex(s, r, e);
      } else
        Ns(this._values, t, e), this._onMoveIndex(s, t, e);
    else
      t == null ? (this._values.push(e), this._onPush(e)) : (Ns(this._values, t, e), this._onInsertIndex(t, e));
    return e;
  }
  /**
   * Adds an item to the end of the list.
   *
   * @param item  An item to add
   */
  push(e) {
    return this._values.push(e), this._onPush(e), e;
  }
  /**
   * Adds an item as a first item in the list.
   *
   * @param item  An item to add
   */
  unshift(e) {
    return this.insertIndex(0, e), e;
  }
  /**
   * Adds multiple items to the list.
   *
   * @param items  An Array of items to add
   */
  pushAll(e) {
    w(e, (t) => {
      this.push(t);
    });
  }
  /**
   * Copies and adds items from abother list.
   *
   * @param source  A list top copy items from
   */
  copyFrom(e) {
    this.pushAll(e._values);
  }
  /**
   * Returns the last item from the list, and removes it.
   *
   * @return Item
   */
  pop() {
    return this._values.length - 1 < 0 ? void 0 : this.removeIndex(this._values.length - 1);
  }
  /**
   * Returns the first item from the list, and removes it.
   *
   * @return Item
   */
  shift() {
    return this._values.length ? this.removeIndex(0) : void 0;
  }
  /**
   * Sets multiple items to the list.
   *
   * All current items are removed.
   *
   * @param newArray  New items
   */
  setAll(e) {
    const t = this._values;
    this._values = [], this._onClear(t), w(e, (s) => {
      this._values.push(s), this._onPush(s);
    });
  }
  /**
   * Removes all items from the list.
   */
  clear() {
    this.setAll([]);
  }
  /**
   * Returns an ES6 iterator for the list.
   */
  *[Symbol.iterator]() {
    const e = this._values.length;
    for (let t = 0; t < e; ++t)
      yield this._values[t];
  }
  /**
   * Calls `f` for each element in the list.
   *
   * `f` should have at least one parameter defined which will get a current
   * item, with optional second argument - index.
   */
  each(e) {
    w(this._values, e);
  }
  /**
   * Calls `f` for each element in the list, from right to left.
   *
   * `f` should have at least one parameter defined which will get a current
   * item, with optional second argument - index.
   */
  eachReverse(e) {
    Rs(this._values, e);
  }
}
class Kn extends lr {
  constructor() {
    super(...arguments), Object.defineProperty(this, "autoDispose", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "_disposed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    });
  }
  _onSetIndex(e, t, s) {
    this.autoDispose && t.dispose(), super._onSetIndex(e, t, s);
  }
  _onRemoveIndex(e, t) {
    this.autoDispose && t.dispose(), super._onRemoveIndex(e, t);
  }
  _onClear(e) {
    this.autoDispose && w(e, (t) => {
      t.dispose();
    }), super._onClear(e);
  }
  isDisposed() {
    return this._disposed;
  }
  dispose() {
    this._disposed || (this._disposed = !0, this.autoDispose && w(this._values, (e) => {
      e.dispose();
    }));
  }
}
class ze extends Kn {
  constructor(e, t) {
    super(), Object.defineProperty(this, "template", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "make", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.template = e, this.make = t;
  }
}
class Yx extends lr {
  constructor(e) {
    super(), Object.defineProperty(this, "_disposed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_container", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_events", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._container = e, this._events = this.events.onAll((t) => {
      if (t.type === "clear")
        w(t.oldValues, (s) => {
          this._onRemoved(s);
        });
      else if (t.type === "push")
        this._onInserted(t.newValue);
      else if (t.type === "setIndex")
        this._onRemoved(t.oldValue), this._onInserted(t.newValue, t.index);
      else if (t.type === "insertIndex")
        this._onInserted(t.newValue, t.index);
      else if (t.type === "removeIndex")
        this._onRemoved(t.oldValue);
      else if (t.type === "moveIndex")
        this._onRemoved(t.value), this._onInserted(t.value, t.newIndex);
      else
        throw new Error("Unknown IListEvent type");
    });
  }
  _onInserted(e, t) {
    e._setParent(this._container, !0);
    const s = this._container._childrenDisplay;
    t === void 0 ? s.addChild(e._display) : s.addChildAt(e._display, t);
  }
  _onRemoved(e) {
    this._container._childrenDisplay.removeChild(e._display), this._container.markDirtyBounds(), this._container.markDirty();
  }
  /**
   * Returns `true` if obejct is disposed.
   */
  isDisposed() {
    return this._disposed;
  }
  /**
   * Permanently dispose this object.
   */
  dispose() {
    this._disposed || (this._disposed = !0, this._events.dispose(), w(this.values, (e) => {
      e.dispose();
    }));
  }
}
class re {
  /**
   * Constructor.
   *
   * @param percent  Percent value
   */
  constructor(e) {
    Object.defineProperty(this, "_value", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._value = e;
  }
  /**
   * Relative value.
   *
   * E.g. 100% is 1, 50% is 0.5, etc.
   *
   * This is useful to apply transformations to other values. E.g.:
   *
   * ```TypeScript
   * let value = 256;
   * let percent = new am5.p50;
   * console.log(value * percent.value); // outputs 128
   * ```
   * ```JavaScript
   * var value = 256;
   * var percent = new am5.p50;
   * console.log(value * percent.value); // outputs 128
   * ```
   *
   * Alternatively, you can use `am5.percent()` helper function:
   *
   * ```TypeScript
   * let value = 256;
   * let percent = am5.p50;
   * console.log(value * percent.value); // outputs 128
   * ```
   * ```JavaScript
   * var value = 256;
   * var percent = am5.p50;
   * console.log(value * percent.value); // outputs 128
   * ```
   *
   * @readonly
   * @return Relative value
   */
  get value() {
    return this._value / 100;
  }
  /**
   * Value in percent.
   *
   * @return Percent
   */
  get percent() {
    return this._value;
  }
  toString() {
    return "" + this._value + "%";
  }
  interpolate(e, t) {
    return e + this.value * (t - e);
  }
  static normalize(e, t, s) {
    return e instanceof re ? e : t === s ? new re(0) : new re(Math.min(Math.max((e - t) * (1 / (s - t)), 0), 1) * 100);
  }
}
function Ke(i) {
  return new re(i);
}
const Rx = Ke(0), R = Ke(100), ce = Ke(50);
function at(i, e, t, s) {
  function r(n) {
    return n instanceof t ? n : new t(function(a) {
      a(n);
    });
  }
  return new (t || (t = Promise))(function(n, a) {
    function o(c) {
      try {
        u(s.next(c));
      } catch (h) {
        a(h);
      }
    }
    function l(c) {
      try {
        u(s.throw(c));
      } catch (h) {
        a(h);
      }
    }
    function u(c) {
      c.done ? n(c.value) : r(c.value).then(o, l);
    }
    u((s = s.apply(i, e || [])).next());
  });
}
function Ne(i) {
  return Object.keys(i);
}
function fu(i, e) {
  return Ne(i).sort(e);
}
function Ti(i) {
  return Object.assign({}, i);
}
function _e(i, e) {
  Ne(i).forEach((t) => {
    e(t, i[t]);
  });
}
function Bc(i, e) {
  for (let t in i)
    if (Hc(i, t) && !e(t, i[t]))
      break;
}
function Nx(i, e, t) {
  w(fu(i, t), (s) => {
    e(s, i[s]);
  });
}
function Hc(i, e) {
  return {}.hasOwnProperty.call(i, e);
}
function $x(i, e) {
  return _e(i, (t, s) => {
    s != null && e[t] == null && (e[t] = s);
  }), e;
}
const Fx = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  copy: Ti,
  each: _e,
  eachContinue: Bc,
  eachOrdered: Nx,
  hasKey: Hc,
  keys: Ne,
  keysOrdered: fu,
  softCopyProperties: $x
}, Symbol.toStringTag, { value: "Module" }));
function zc(i) {
  if (document.readyState !== "loading")
    i();
  else {
    const e = () => {
      document.readyState !== "loading" && (document.removeEventListener("readystatechange", e), i());
    };
    document.addEventListener("readystatechange", e);
  }
}
function Xc(i) {
  i.parentNode && i.parentNode.removeChild(i);
}
function Le(i, e, t, s) {
  return i.addEventListener(e, t, s || !1), new He(() => {
    i.removeEventListener(e, t, s || !1);
  });
}
function pu(i) {
  return Le(window, "resize", (e) => {
    i();
  });
}
function Wt(i) {
  switch (i) {
    case "touchevents":
      return window.hasOwnProperty("TouchEvent");
    case "pointerevents":
      return window.hasOwnProperty("PointerEvent");
    case "mouseevents":
      return window.hasOwnProperty("MouseEvent");
    case "wheelevents":
      return window.hasOwnProperty("WheelEvent");
    case "keyboardevents":
      return window.hasOwnProperty("KeyboardEvent");
  }
  return !1;
}
function Cn(i) {
  return i.pointerId || 0;
}
function Vc() {
  if (document.activeElement && document.activeElement != document.body)
    if (document.activeElement.blur)
      document.activeElement.blur();
    else {
      let i = document.createElement("button");
      i.style.position = "fixed", i.style.top = "0px", i.style.left = "-10000px", document.body.appendChild(i), i.focus(), i.blur(), document.body.removeChild(i);
    }
}
function Uc(i) {
  i && i.focus();
}
function Qn(i) {
  if (Wt("pointerevents"))
    return i;
  if (Wt("touchevents"))
    switch (i) {
      case "pointerover":
        return "touchstart";
      case "pointerout":
        return "touchend";
      case "pointerdown":
        return "touchstart";
      case "pointermove":
        return "touchmove";
      case "pointerup":
        return "touchend";
      case "click":
        return "click";
      case "dblclick":
        return "dblclick";
    }
  else if (Wt("mouseevents"))
    switch (i) {
      case "pointerover":
        return "mouseover";
      case "pointerout":
        return "mouseout";
      case "pointerdown":
        return "mousedown";
      case "pointermove":
        return "mousemove";
      case "pointerup":
        return "mouseup";
      case "click":
        return "click";
      case "dblclick":
        return "dblclick";
    }
  return i;
}
function qn(i) {
  if (typeof Touch < "u" && i instanceof Touch)
    return !0;
  if (typeof PointerEvent < "u" && i instanceof PointerEvent && i.pointerType != null)
    switch (i.pointerType) {
      case "touch":
      case "pen":
      case 2:
        return !0;
      case "mouse":
      case 4:
        return !1;
      default:
        return !(i instanceof MouseEvent);
    }
  else if (i.type != null && i.type.match(/^mouse/))
    return !1;
  return !0;
}
function Mn(i, e, t) {
  i.style[e] = t;
}
function Wc(i, e) {
  return i.style[e];
}
function Gc(i, e) {
  let t = e;
  for (; ; ) {
    if (i === t)
      return !0;
    if (t.parentNode === null) {
      if (t.host == null)
        return !1;
      t = t.host;
    } else
      t = t.parentNode;
  }
}
function Wa(i, e) {
  return i.target && Gc(e.root.dom, i.target);
}
function Os(i, e) {
  e ? i.style.pointerEvents = "auto" : i.style.pointerEvents = "none";
}
function Zc(i) {
  let e = i;
  for (; ; ) {
    if (e.parentNode === null)
      return e.host != null ? e : null;
    e = e.parentNode;
  }
}
let ho;
function Bx(i, e, t = "") {
  const s = document.createElement("style");
  return s.type = "text/css", t != "" && s.setAttribute("nonce", t), s.textContent = e, i === null ? document.head.appendChild(s) : i.appendChild(s), s;
}
function Hx(i, e = "") {
  if (i === null) {
    if (ho == null) {
      const t = document.createElement("style");
      t.type = "text/css", e != "" && t.setAttribute("nonce", e), document.head.appendChild(t), ho = t.sheet;
    }
    return ho;
  } else {
    const t = document.createElement("style");
    return t.type = "text/css", e != "" && t.setAttribute("nonce", e), i.appendChild(t), t.sheet;
  }
}
function zx(i, e) {
  const t = i.cssRules.length;
  return i.insertRule(e + "{}", t), i.cssRules[t];
}
class Ze extends ar {
  /**
   * Constructor.
   *
   * @param selector  CSS selector
   * @param styles    An object of style attribute - value pairs
   */
  constructor(e, t, s, r = "") {
    super(), Object.defineProperty(this, "_root", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_rule", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._root = Hx(e, r);
    try {
      this._rule = zx(this._root, t), _e(s, (n, a) => {
        this.setStyle(n, a);
      });
    } catch {
      this._rule = new CSSStyleRule();
    }
  }
  /**
   * A CSS selector text.
   *
   * E.g.: `.myClass p`
   *
   * @param selector  CSS selector
   */
  set selector(e) {
    this._rule.selectorText = e;
  }
  /**
   * @return CSS selector
   */
  get selector() {
    return this._rule.selectorText;
  }
  // TODO test this
  _dispose() {
    const e = Yi(this._root.cssRules, this._rule);
    if (e === -1)
      throw new Error("Could not dispose StyleRule");
    this._root.deleteRule(e);
  }
  /**
   * Sets the same style properties with browser-specific prefixes.
   *
   * @param name   Attribute name
   * @param value  Attribute value
   */
  _setVendorPrefixName(e, t) {
    const s = this._rule.style;
    s.setProperty("-webkit-" + e, t, ""), s.setProperty("-moz-" + e, t, ""), s.setProperty("-ms-" + e, t, ""), s.setProperty("-o-" + e, t, ""), s.setProperty(e, t, "");
  }
  /**
   * Sets a value for specific style attribute.
   *
   * @param name   Attribute
   * @param value  Value
   */
  setStyle(e, t) {
    e === "transition" ? this._setVendorPrefixName(e, t) : this._rule.style.setProperty(e, t, "");
  }
}
class Xx extends ar {
  /**
   * Constructor.
   *
   * @param text  CSS stylesheet
   */
  constructor(e, t, s = "") {
    super(), Object.defineProperty(this, "_element", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._element = Bx(e, t, s);
  }
  _dispose() {
    this._element.parentNode && this._element.parentNode.removeChild(this._element);
  }
}
function Vx(i, e) {
  if (i)
    if (i.classList) {
      const t = e.split(" ");
      w(t, (s) => {
        i.classList.add(s);
      });
    } else {
      let t = i.getAttribute("class");
      t ? i.setAttribute("class", t.split(" ").filter((s) => s !== e).join(" ") + " " + e) : i.setAttribute("class", e);
    }
}
function Ux(i, e) {
  if (i)
    if (i.classList)
      i.classList.remove(e);
    else {
      let t = i.getAttribute("class");
      t && i.setAttribute("class", t.split(" ").filter((s) => s !== e).join(" "));
    }
}
function Kc() {
  return /apple/i.test(navigator.vendor) && "ontouchend" in document;
}
function Qc() {
  return Kc() ? 1 : void 0;
}
function Re(i, e) {
  return S(i) ? i : i != null && S(i.value) && S(e) ? e * i.value : 0;
}
function qc(i) {
  let e = ("" + i).match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);
  return e ? Math.max(0, (e[1] ? e[1].length : 0) - (e[2] ? +e[2] : 0)) : 0;
}
function Oe(i, e = 0, t = "0") {
  return typeof i != "string" && (i = i.toString()), e > i.length ? Array(e - i.length + 1).join(t) + i : i;
}
function Jc(i) {
  return i.replace(/^[\s]*/, "");
}
function ed(i) {
  return i.replace(/[\s]*$/, "");
}
function Mr(i) {
  return Jc(ed(i));
}
function td(i) {
  if (typeof i > "u")
    return "string";
  i = i.toLowerCase().replace(/^\[[^\]]*\]/, ""), i = i.replace(/\[[^\]]+\]/, ""), i = i.trim();
  let e = i.match(/\/(date|number|duration)$/);
  return e ? e[1] : i === "number" ? "number" : i === "date" ? "date" : i === "duration" ? "duration" : i.match(/[#0]/) ? "number" : i.match(/[ymwdhnsqaxkzgtei]/) ? "date" : "string";
}
function Ga(i) {
  return i.replace(/\/(date|number|duration)$/i, "");
}
function Jn(i) {
  return i && i.replace(/<[^>]*>/g, "");
}
function Wx(i) {
  return i && Jn(("" + i).replace(/[\n\r]+/g, ". "));
}
function Jo(i) {
  return i.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
}
function Gx(i) {
  let e = "";
  for (let t = 0; t < i.length; t++) {
    const s = i.charAt(t);
    s.toUpperCase() == s && t != 0 && (e += " "), e += s;
  }
  return e;
}
function el(i, e = !1) {
  const t = new Date(i.getFullYear(), 0, 0), s = i.getTime() - t.getTime() + (t.getTimezoneOffset() - i.getTimezoneOffset()) * 60 * 1e3, r = 1e3 * 60 * 60 * 24;
  return Math.floor(s / r);
}
function Hs(i, e = !1) {
  const t = new Date(Date.UTC(i.getFullYear(), i.getMonth(), i.getDate())), s = t.getUTCDay() || 7;
  t.setUTCDate(t.getUTCDate() + 4 - s);
  const r = new Date(Date.UTC(t.getUTCFullYear(), 0, 1));
  return Math.ceil(((t.getTime() - r.getTime()) / 864e5 + 1) / 7);
}
function id(i, e = !1) {
  const t = new Date(Date.UTC(i.getFullYear(), i.getMonth(), i.getDate())), s = t.getUTCDay() || 7;
  return t.setUTCDate(t.getUTCDate() + 4 - s), new Date(Date.UTC(t.getUTCFullYear(), 0, 1)).getFullYear();
}
function sd(i, e = !1) {
  const t = Hs(new Date(i.getFullYear(), i.getMonth(), 1), e);
  let s = Hs(i, e);
  return s == 1 && (s = 53), s - t + 1;
}
function rd(i, e, t = 1, s = !1) {
  let r = new Date(e, 0, 4, 0, 0, 0, 0);
  return s && r.setUTCFullYear(e), i * 7 + t - ((r.getDay() || 7) + 3);
}
function mr(i, e) {
  return i > 12 ? i -= 12 : i === 0 && (i = 12), e != null ? i + (e - 1) : i;
}
function br(i, e = !1, t = !1, s = !1) {
  if (s)
    return e ? "Coordinated Universal Time" : "UTC";
  let r = i.toLocaleString("UTC"), n = i.toLocaleString("UTC", { timeZoneName: e ? "long" : "short" }).substr(r.length);
  return t === !1 && (n = n.replace(/ (standard|daylight|summer|winter) /i, " ")), n;
}
function nd(i) {
  const e = new Date(Date.UTC(2012, 0, 1, 0, 0, 0, 0)), t = new Date(e.toLocaleString("en-US", { timeZone: "UTC" }));
  return (new Date(e.toLocaleString("en-US", { timeZone: i })).getTime() - t.getTime()) / 6e4 * -1;
}
function tl(i) {
  return i.charAt(0).toUpperCase() + i.slice(1);
}
function gu(i) {
  let e, t, s, r = i.h, n = i.s, a = i.l;
  if (n == 0)
    e = t = s = a;
  else {
    let o = function(h, d, f) {
      return f < 0 && (f += 1), f > 1 && (f -= 1), f < 0.16666666666666666 ? h + (d - h) * 6 * f : f < 0.5 ? d : f < 0.6666666666666666 ? h + (d - h) * (0.6666666666666666 - f) * 6 : h;
    }, l = a < 0.5 ? a * (1 + n) : a + n - a * n, u = 2 * a - l;
    e = o(u, l, r + 1 / 3), t = o(u, l, r), s = o(u, l, r - 1 / 3);
  }
  return {
    r: Math.round(e * 255),
    g: Math.round(t * 255),
    b: Math.round(s * 255)
  };
}
function _u(i) {
  let e = i.r / 255, t = i.g / 255, s = i.b / 255, r = Math.max(e, t, s), n = Math.min(e, t, s), a = 0, o = 0, l = (r + n) / 2;
  if (r === n)
    a = o = 0;
  else {
    let u = r - n;
    switch (o = l > 0.5 ? u / (2 - r - n) : u / (r + n), r) {
      case e:
        a = (t - s) / u + (t < s ? 6 : 0);
        break;
      case t:
        a = (s - e) / u + 2;
        break;
      case s:
        a = (e - t) / u + 4;
        break;
    }
    a /= 6;
  }
  return {
    h: a,
    s: o,
    l
  };
}
function ad(i, e) {
  return i && {
    r: Math.max(0, Math.min(255, i.r + Or(i.r, e))),
    g: Math.max(0, Math.min(255, i.g + Or(i.g, e))),
    b: Math.max(0, Math.min(255, i.b + Or(i.b, e))),
    a: i.a
  };
}
function Or(i, e) {
  let t = e > 0 ? 255 - i : i;
  return Math.round(t * e);
}
function od(i, e) {
  if (i) {
    let t = Math.min(Math.max(i.r, i.g, i.b), 230), s = Or(t, e);
    return {
      r: Math.max(0, Math.min(255, Math.round(i.r + s))),
      g: Math.max(0, Math.min(255, Math.round(i.g + s))),
      b: Math.max(0, Math.min(255, Math.round(i.b + s))),
      a: i.a
    };
  } else
    return i;
}
function Zx(i, e) {
  return Math.round(255 * e);
}
function il(i) {
  return (i.r * 299 + i.g * 587 + i.b * 114) / 1e3 >= 128;
}
function ld(i, e) {
  if (i === void 0 || e == 1)
    return i;
  let t = _u(i);
  return t.s = e, gu(t);
}
function ud(i, e = { r: 255, g: 255, b: 255 }, t = { r: 255, g: 255, b: 255 }) {
  let s = e, r = t;
  return il(t) && (s = t, r = e), il(i) ? r : s;
}
function ie(i, e) {
  return i || (i = []), [...i, ...e].filter((t, s, r) => r.indexOf(t) === s);
}
function mu(i, e) {
  return !(!e || i.left != e.left || i.right != e.right || i.top != e.top || i.bottom != e.bottom);
}
const Kx = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  StyleRule: Ze,
  StyleSheet: Xx,
  addClass: Vx,
  addEventListener: Le,
  addSpacing: Gx,
  alternativeColor: ud,
  blur: Vc,
  brighten: od,
  capitalizeFirst: tl,
  cleanFormat: Ga,
  contains: Gc,
  decimalPlaces: qc,
  escapeForRgex: Jo,
  focus: Uc,
  get12Hours: mr,
  getBrightnessStep: Zx,
  getDayFromWeek: rd,
  getFormat: td,
  getLightnessStep: Or,
  getMonthWeek: sd,
  getPointerId: Cn,
  getRendererEvent: Qn,
  getSafeResolution: Qc,
  getShadowRoot: Zc,
  getStyle: Wc,
  getTimeZone: br,
  getTimezoneOffset: nd,
  getWeek: Hs,
  getWeekYear: id,
  getYearDay: el,
  hslToRgb: gu,
  iOS: Kc,
  isLight: il,
  isLocalEvent: Wa,
  isTouchEvent: qn,
  lighten: ad,
  mergeTags: ie,
  onZoom: pu,
  padString: Oe,
  plainText: Wx,
  ready: zc,
  relativeToValue: Re,
  removeClass: Ux,
  removeElement: Xc,
  rgbToHsl: _u,
  sameBounds: mu,
  saturate: ld,
  setInteractive: Os,
  setStyle: Mn,
  stripTags: Jn,
  supports: Wt,
  trim: Mr,
  trimLeft: Jc,
  trimRight: ed
}, Symbol.toStringTag, { value: "Module" }));
function hd(i) {
  return i[0] === "#" && (i = i.substr(1)), i.length == 3 && (i = i[0].repeat(2) + i[1].repeat(2) + i[2].repeat(2)), parseInt(i, 16);
}
function Qx(i) {
  i = i.replace(/[ ]/g, "");
  let e = i.match(/^rgb\(([0-9]*),([0-9]*),([0-9]*)\)/i);
  if (e)
    e.push("1");
  else if (e = i.match(/^rgba\(([0-9]*),([0-9]*),([0-9]*),([.0-9]*)\)/i), !e)
    return 0;
  let t = "";
  for (let s = 1; s <= 3; s++) {
    let r = parseInt(e[s]).toString(16);
    r.length == 1 && (r = "0" + r), t += r;
  }
  return hd(t);
}
function pe(i) {
  return X.fromAny(i);
}
class X {
  constructor(e) {
    Object.defineProperty(this, "_hex", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._hex = e | 0;
  }
  /**
   * Color numeric value.
   */
  get hex() {
    return this._hex;
  }
  /**
   * Value of color's R channel.
   * @return R value
   */
  get r() {
    return this._hex >>> 16;
  }
  /**
   * Value of color's G channel.
   * @return G value
   */
  get g() {
    return this._hex >> 8 & 255;
  }
  /**
   * Value of color's B channel.
   * @return B value
   */
  get b() {
    return this._hex & 255;
  }
  /**
   * Returns color CSS representation in form of `rgba(r, g, b, a)` string.
   *
   * @param   alpha  Opacity
   * @return         CSS string
   */
  toCSS(e = 1) {
    return "rgba(" + this.r + ", " + this.g + ", " + this.b + ", " + e + ")";
  }
  /**
   * Returns color CSS representation in form of `#rgb` string.
   *
   * @return         CSS string
   */
  toCSSHex() {
    return "#" + Oe(this.r.toString(16), 2) + Oe(this.g.toString(16), 2) + Oe(this.b.toString(16), 2);
  }
  /**
   * Returns color's HSL info.
   * @param   alpha Opacity
   * @return        HSL info
   */
  toHSL(e = 1) {
    return _u({
      r: this.r,
      g: this.g,
      b: this.b,
      a: e
    });
  }
  /**
   * Converts HSL values into a new [[Color]] object.
   *
   * @param   h H value
   * @param   s S value
   * @param   l L value
   * @return    Color object
   */
  static fromHSL(e, t, s) {
    const r = gu({
      h: e,
      s: t,
      l: s
    });
    return this.fromRGB(r.r, r.g, r.b);
  }
  toString() {
    return this.toCSSHex();
  }
  /**
   * Converts hex number into a new [[Color]] object.
   *
   * ```TypeScript
   * Color.fromHex(0xff0000) // red
   * ```
   * ```JavaScript
   * Color.fromHex(0xff0000) // red
   * ```
   *
   * @param   hex  Hex color
   * @return       Color
   */
  static fromHex(e) {
    return new X(e);
  }
  /**
   * Converts RGB values to a new [[Color]] object.
   *
   * @param   r  R value
   * @param   g  G value
   * @param   b  B value
   * @return     Color
   */
  static fromRGB(e, t, s) {
    return new X((s | 0) + (t << 8) + (e << 16));
  }
  /**
   * Converts RGB string to a new [[Color]] object.
   *
   * ```TypeScript
   * Color.fromString("#ff0000") // red
   * ```
   * ```JavaScript
   * Color.fromString("#ff0000") // red
   * ```
   *
   * @param   s  RGB string
   * @return     Color
   */
  static fromString(e) {
    return new X(hd(e));
  }
  /**
   * Converts CSS rgba() syntax to a new [[Color]] object.
   *
   * ```TypeScript
   * Color.fromCSS("rgba(255, 0, 0, 1)") // red
   * ```
   * ```JavaScript
   * Color.fromCSS("rgba(255, 0, 0, 1)") // red
   * ```
   *
   * @param  {string} s [description]
   * @return {Color}    [description]
   */
  static fromCSS(e) {
    return new X(Qx(e));
  }
  /**
   * Convert to color from virtually anything.
   *
   * Will throw an exception if unable to resolve the color.
   *
   * @param   s  Source
   * @return     Color
   */
  static fromAny(e) {
    if (Ii(e)) {
      if (e[0] == "#")
        return X.fromString(e);
      if (e.substr(0, 3) == "rgb")
        return X.fromCSS(e);
    } else {
      if (S(e))
        return X.fromHex(e);
      if (e instanceof X)
        return X.fromHex(e.hex);
    }
    throw new Error("Unknown color syntax: " + e);
  }
  /**
   * Returns a new [[Color]] object based on either `lightAlternative` or
   * `darkAlternative` depending on which one is more contrasting with
   * the `color`.
   *
   * @param   color             Reference color
   * @param   lightAlternative  Light color
   * @param   darkAlternative   Dark color
   * @return                    Alternative color
   */
  static alternative(e, t, s) {
    const r = ud({ r: e.r, g: e.g, b: e.b }, t ? { r: t.r, g: t.g, b: t.b } : void 0, s ? { r: s.r, g: s.g, b: s.b } : void 0);
    return this.fromRGB(r.r, r.g, r.b);
  }
  /**
   * Returns an intermediate Color between two reference colors depending on
   * the progress (`diff`) between the two.
   *
   * @param   diff  Progress
   * @param   from  Source color
   * @param   to    Target color
   * @param   mode  Interpolation mode
   * @return        Color
   */
  static interpolate(e, t, s, r = "rgb") {
    if (r == "hsl") {
      const n = t.toHSL(), a = s.toHSL();
      return X.fromHSL(xi(e, n.h, a.h), xi(e, n.s, a.s), xi(e, n.l, a.l));
    } else
      return X.fromRGB(xi(e, t.r, s.r), xi(e, t.g, s.g), xi(e, t.b, s.b));
  }
  /**
   * Returns a new [[Color]] lightened by `percent` value.
   *
   * Use negative value to darken the color.
   *
   * @param   color    Source color
   * @param   percent  Percent
   * @return           New color
   */
  static lighten(e, t) {
    const s = ad({ r: e.r, g: e.g, b: e.b }, t);
    return X.fromRGB(s.r, s.g, s.b);
  }
  /**
   * Returns a new [[Color]] brightened by `percent` value.
   *
   * Use negative value to dim the color.
   *
   * @param   color    Source color
   * @param   percent  Percent
   * @return           New color
   */
  static brighten(e, t) {
    const s = od({ r: e.r, g: e.g, b: e.b }, t);
    return X.fromRGB(s.r, s.g, s.b);
  }
  /**
   * Returns a new [[Color]] saturated by `percent` value.
   *
   * Value range is between `0` (fully desaturated), to `1` (full color).
   *
   * @param   color    Source color
   * @param   percent  Percent
   * @return           New color
   */
  static saturate(e, t) {
    const s = ld({ r: e.r, g: e.g, b: e.b }, t);
    return X.fromRGB(s.r, s.g, s.b);
  }
}
function zu(i) {
  return at(this, void 0, void 0, function* () {
    if (i !== void 0) {
      const e = [];
      _e(i, (t, s) => {
        e.push(s.waitForStop());
      }), yield Promise.all(e);
    }
  });
}
function xi(i, e, t) {
  return e + i * (t - e);
}
function qx(i, e, t) {
  return i >= 1 ? t : e;
}
function cd(i, e, t) {
  return new re(xi(i, e.percent, t.percent));
}
function Jx(i, e, t) {
  return X.interpolate(i, e, t);
}
function e0(i, e) {
  return typeof i == "number" && typeof e == "number" ? xi : i instanceof re && e instanceof re ? cd : i instanceof X && e instanceof X ? Jx : qx;
}
const Za = Math.PI, dd = Za / 2, ps = Za / 180, cs = 180 / Za;
function qe(i, e, t) {
  if (!S(e) || e <= 0) {
    let s = Math.round(i);
    return t && s - i == 0.5 && s--, s;
  } else {
    let s = Math.pow(10, e);
    return Math.round(i * s) / s;
  }
}
function fd(i, e) {
  if (!S(e) || e <= 0)
    return Math.ceil(i);
  {
    let t = Math.pow(10, e);
    return Math.ceil(i * t) / t;
  }
}
function t0(i, e, t, s, r) {
  return { x: (-i.x + e.x / s + t.x) * s, y: (-i.y + e.y / r + t.y) * r };
}
function i0(i, e, t, s, r) {
  return { x: (i.x + e.x / s - t.x) * s, y: (i.y + e.y / r - t.y) * r };
}
function Ie(i, e, t) {
  return Math.min(Math.max(i, e), t);
}
function Lt(i) {
  return Math.sin(ps * i);
}
function s0(i) {
  return Math.tan(ps * i);
}
function jt(i) {
  return Math.cos(ps * i);
}
function zs(i) {
  return i = i % 360, i < 0 && (i += 360), i;
}
function pd(i, e, t, s, r) {
  let n = Number.MAX_VALUE, a = Number.MAX_VALUE, o = -Number.MAX_VALUE, l = -Number.MAX_VALUE, u = [];
  u.push(On(r, t)), u.push(On(r, s));
  let c = Math.min(Math.floor(t / 90) * 90, Math.floor(s / 90) * 90), h = Math.max(Math.ceil(t / 90) * 90, Math.ceil(s / 90) * 90);
  for (let d = c; d <= h; d += 90)
    d >= t && d <= s && u.push(On(r, d));
  for (let d = 0; d < u.length; d++) {
    let f = u[d];
    f.x < n && (n = f.x), f.y < a && (a = f.y), f.x > o && (o = f.x), f.y > l && (l = f.y);
  }
  return { left: i + n, top: e + a, right: i + o, bottom: e + l };
}
function On(i, e) {
  return { x: i * jt(e), y: i * Lt(e) };
}
function r0(i) {
  const e = i.length;
  if (e > 0) {
    let t = i[0], s = t.left, r = t.top, n = t.right, a = t.bottom;
    if (e > 1)
      for (let o = 1; o < e; o++)
        t = i[o], s = Math.min(t.left, s), n = Math.max(t.right, n), r = Math.min(t.top, r), a = Math.max(t.bottom, a);
    return { left: s, right: n, top: r, bottom: a };
  }
  return { left: 0, right: 0, top: 0, bottom: 0 };
}
function n0(i, e, t) {
  if (e > t) {
    let a = e;
    e = t, t = a;
  }
  i = zs(i);
  let s = (e - zs(e)) / 360;
  i < e && (i += 360 * (s + 1));
  let r = e + (t - e) / 2 + 180, n = e + (t - e) / 2 - 180;
  return i > t && (i - 360 > e ? i -= 360 : i < r ? i = t : i = e), i < e && (i > n ? i = e : i = t), i;
}
function a0(i, e) {
  return i.x >= e.left && i.y >= e.top && i.x <= e.right && i.y <= e.bottom;
}
function gd(i, e) {
  e || (e = { x: i.x * 2, y: i.y * 2 });
  let t = e.x - i.x, s = e.y - i.y, r = Math.atan2(s, t) * cs;
  return r < 0 && (r += 360), zs(r);
}
function o0(i, e, t, s) {
  let r = (1 - s) * (1 - s) * i.x + 2 * (1 - s) * s * t.x + s * s * e.x, n = (1 - s) * (1 - s) * i.y + 2 * (1 - s) * s * t.y + s * s * e.y;
  return { x: r, y: n };
}
function l0(i, e, t) {
  return { x: i.x + (e.x - i.x) * t, y: i.y + (e.y - i.y) * t };
}
function _d(i, e) {
  return i.reduce(function(t, s) {
    return Math.abs(s - e) < Math.abs(t - e) ? s : t;
  });
}
function u0(i, e) {
  return !(i.bottom < e.top || e.bottom < i.top || i.right < e.left || e.right < i.left);
}
const h0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  DEGREES: cs,
  HALFPI: dd,
  PI: Za,
  RADIANS: ps,
  boundsOverlap: u0,
  ceil: fd,
  closest: _d,
  cos: jt,
  fitAngleToRange: n0,
  fitToRange: Ie,
  getAngle: gd,
  getArcBounds: pd,
  getArcPoint: On,
  getCubicControlPointA: t0,
  getCubicControlPointB: i0,
  getPointOnLine: l0,
  getPointOnQuadraticCurve: o0,
  inBounds: a0,
  mergeBounds: r0,
  normalizeAngle: zs,
  round: qe,
  sin: Lt,
  tan: s0
}, Symbol.toStringTag, { value: "Module" }));
function sl(i) {
  return i;
}
function c0(i) {
  return i * i;
}
function As(i) {
  return i * i * i;
}
function d0(i, e) {
  return Math.pow(i, e);
}
function f0(i) {
  return Math.pow(2, 10 * i - 10);
}
function p0(i) {
  return 1 - Math.cos(i * dd);
}
function g0(i) {
  return 1 - Math.sqrt(1 - i * i);
}
function _0(i) {
  return function(e) {
    return e < 0.5 ? i(e * 2) : i((1 - e) * 2);
  };
}
function yr(i) {
  return function(e) {
    return 1 - i(1 - e);
  };
}
function m0(i) {
  return function(e) {
    return e <= 0.5 ? i(e * 2) / 2 : 1 - i((1 - e) * 2) / 2;
  };
}
let rl = 4 / 11, b0 = 6 / 11, y0 = 8 / 11, v0 = 3 / 4, x0 = 9 / 11, w0 = 10 / 11, S0 = 15 / 16, D0 = 21 / 22, P0 = 63 / 64, fn = 1 / rl / rl;
function T0(i) {
  return 1 - k0(1 - i);
}
function k0(i) {
  return i = i, i < rl ? fn * i * i : i < y0 ? fn * (i -= b0) * i + v0 : i < w0 ? fn * (i -= x0) * i + S0 : fn * (i -= D0) * i + P0;
}
let C0 = 2 * Math.PI, md = 1, bd = 0.3 / C0, M0 = Math.asin(1 / md) * bd;
function O0(i) {
  let e = i;
  return md * Math.pow(2, 10 * --e) * Math.sin((M0 - e) / bd);
}
const A0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bounce: T0,
  circle: g0,
  cubic: As,
  elastic: O0,
  exp: f0,
  inOut: m0,
  linear: sl,
  out: yr,
  pow: d0,
  quad: c0,
  sine: p0,
  yoyo: _0
}, Symbol.toStringTag, { value: "Module" }));
class L0 {
  constructor(e, t) {
    Object.defineProperty(this, "_entity", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_settings", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_userSettings", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), this._entity = e, this._settings = t, _e(t, (s) => {
      this._userSettings[s] = !0;
    });
  }
  get(e, t) {
    const s = this._settings[e];
    return s !== void 0 ? s : t;
  }
  /**
   * @ignore
   */
  setRaw(e, t) {
    this._settings[e] = t;
  }
  /**
   * Sets a setting `value` for the specified `key` to be set when the state
   * is applied.
   *
   * @param   key       Setting key
   * @param   value     Setting value
   * @return            Setting value
   */
  set(e, t) {
    this._userSettings[e] = !0, this.setRaw(e, t);
  }
  /**
   * Removes a setting value for the specified `key`.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
   * @param   key       Setting key
   */
  remove(e) {
    delete this._userSettings[e], delete this._settings[e];
  }
  /**
   * Sets multiple settings at once.
   *
   * `settings` must be an object with key: value pairs.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
   * @param settings Settings
   */
  setAll(e) {
    Ne(e).forEach((t) => {
      this.set(t, e[t]);
    });
  }
  _eachSetting(e) {
    _e(this._settings, e);
  }
  /**
   * Applies the state to the target element.
   *
   * All setting values are set immediately.
   */
  apply() {
    const e = {};
    e.stateAnimationEasing = !0, e.stateAnimationDuration = !0;
    const t = this._entity.states.lookup("default");
    this._eachSetting((s, r) => {
      e[s] || (e[s] = !0, this !== t && (s in t._settings || (t._settings[s] = this._entity.get(s))), this._entity.set(s, r));
    });
  }
  /**
   * Applies the state to the target element.
   *
   * Returns an object representing all [[Animation]] objects created for
   * each setting key transition.
   *
   * @return           Animations
   */
  applyAnimate(e) {
    e == null && (e = this._settings.stateAnimationDuration), e == null && (e = this.get("stateAnimationDuration", this._entity.get("stateAnimationDuration", 0)));
    let t = this._settings.stateAnimationEasing;
    t == null && (t = this.get("stateAnimationEasing", this._entity.get("stateAnimationEasing", As)));
    const s = this._entity.states.lookup("default"), r = {};
    r.stateAnimationEasing = !0, r.stateAnimationDuration = !0;
    const n = {};
    return this._eachSetting((a, o) => {
      if (!r[a]) {
        r[a] = !0, this != s && (a in s._settings || (s._settings[a] = this._entity.get(a)));
        const l = this._entity.animate({
          key: a,
          to: o,
          duration: e,
          easing: t
        });
        l && (n[a] = l);
      }
    }), n;
  }
}
class j0 {
  constructor(e) {
    Object.defineProperty(this, "_states", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_entity", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._entity = e;
  }
  /**
   * Checks if a state by `name` exists. Returns it there is one.
   *
   * @param  name  State name
   * @return       State
   */
  lookup(e) {
    return this._states[e];
  }
  /**
   * Sets supplied `settings` on a state by the `name`.
   *
   * If such state does not yet exists, it is created.
   *
   * @param   name      State name
   * @param   settings  Settings
   * @return            New State
   */
  create(e, t) {
    const s = this._states[e];
    if (s)
      return s.setAll(t), s;
    {
      const r = new L0(this._entity, t);
      return this._states[e] = r, r;
    }
  }
  /**
   * Removes the state called `name`.
   *
   * @param   name      State name
   */
  remove(e) {
    delete this._states[e];
  }
  /**
   * Applies a named state to the target element.
   *
   * @param  newState  State name
   */
  apply(e) {
    const t = this._states[e];
    t && t.apply(), this._entity._applyState(e);
  }
  /**
   * Applies a named state to the element.
   *
   * Returns an object representing all [[Animation]] objects created for
   * each setting key transition.
   *
   * @param   newState  State name
   * @return            Animations
   */
  applyAnimate(e, t) {
    let s;
    const r = this._states[e];
    return r && (s = r.applyAnimate(t)), this._entity._applyStateAnimated(e, t), s;
  }
}
class E0 {
  constructor() {
    Object.defineProperty(this, "version", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "5.3.7"
    }), Object.defineProperty(this, "licenses", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "entitiesById", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "rootElements", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    });
  }
}
const Ot = new E0();
function I0(i) {
  Ot.licenses.push(i);
}
function Y0() {
  let i;
  for (; i = Ot.rootElements.pop(); )
    i.dispose();
}
function Et(i, e) {
  return i === e ? 0 : i < e ? -1 : 1;
}
function yd(i, e, t) {
  const s = i.length, r = e.length, n = Math.min(s, r);
  for (let a = 0; a < n; ++a) {
    const o = t(i[a], e[a]);
    if (o !== 0)
      return o;
  }
  return Et(s, r);
}
function Xu(i, e) {
  return i === e ? 0 : i < e ? -1 : 1;
}
class R0 {
  constructor(e) {
    Object.defineProperty(this, "_entity", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_callbacks", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_disabled", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), this._entity = e;
  }
  /**
   * Add a function (`callback`) that will modify value for setting `key`.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/adapters/} for more info
   */
  add(e, t) {
    let s = this._callbacks[e];
    return s === void 0 && (s = this._callbacks[e] = []), s.push(t), this._entity._markDirtyKey(e), new He(() => {
      nt(s, t) && this._entity._markDirtyKey(e);
    });
  }
  /**
   * Removes all adapters for the specific key.
   *
   * @since 5.1.0
   */
  remove(e) {
    const t = this._callbacks[e];
    t !== void 0 && (delete this._callbacks[e], t.length !== 0 && this._entity._markDirtyKey(e));
  }
  /**
   * Enables (previously disabled) adapters for specific key.
   *
   * @since 5.1.0
   */
  enable(e) {
    this._disabled[e] && (delete this._disabled[e], this._entity._markDirtyKey(e));
  }
  /**
   * Disables all adapters for specific key.
   *
   * @since 5.1.0
   */
  disable(e) {
    this._disabled[e] || (this._disabled[e] = !0, this._entity._markDirtyKey(e));
  }
  /**
   * @ignore
   */
  fold(e, t) {
    if (!this._disabled[e]) {
      const s = this._callbacks[e];
      if (s !== void 0)
        for (let r = 0, n = s.length; r < n; ++r)
          t = s[r](t, this._entity, e);
    }
    return t;
  }
}
class pn {
  constructor(e, t, s, r, n, a, o) {
    Object.defineProperty(this, "_animation", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_from", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_to", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_duration", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_easing", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_loops", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_interpolate", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_oldTime", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_time", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_stopped", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_playing", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "events", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new or()
    }), this._animation = e, this._from = t, this._to = s, this._duration = r, this._easing = n, this._loops = a, this._interpolate = e0(t, s), this._oldTime = o;
  }
  get to() {
    return this._to;
  }
  get from() {
    return this._from;
  }
  get playing() {
    return this._playing;
  }
  get stopped() {
    return this._stopped;
  }
  stop() {
    this._stopped || (this._stopped = !0, this._playing = !1, this.events.isEnabled("stopped") && this.events.dispatch("stopped", {
      type: "stopped",
      target: this
    }));
  }
  pause() {
    this._playing = !1, this._oldTime = null;
  }
  play() {
    !this._stopped && !this._playing && (this._playing = !0, this._animation._startAnimation());
  }
  get percentage() {
    return this._time / this._duration;
  }
  waitForStop() {
    return new Promise((e, t) => {
      if (this._stopped)
        e();
      else {
        const s = () => {
          r.dispose(), e();
        }, r = this.events.on("stopped", s);
      }
    });
  }
  _checkEnded() {
    return this._loops > 1 ? (--this._loops, !1) : !0;
  }
  _run(e) {
    this._oldTime !== null && (this._time += e - this._oldTime, this._time > this._duration && (this._time = this._duration)), this._oldTime = e;
  }
  _reset(e) {
    this._oldTime = e, this._time = 0;
  }
  _value(e) {
    return this._interpolate(this._easing(e), this._from, this._to);
  }
}
let N0 = 0;
class vd {
  constructor(e) {
    Object.defineProperty(this, "uid", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ++N0
    }), Object.defineProperty(this, "_settings", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_privateSettings", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_settingEvents", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_privateSettingEvents", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_prevSettings", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_prevPrivateSettings", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_animatingSettings", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_animatingPrivateSettings", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_disposed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_userProperties", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), this._settings = e;
  }
  _checkDirty() {
    Ne(this._settings).forEach((e) => {
      this._userProperties[e] = !0, this._markDirtyKey(e);
    });
  }
  /**
   * @ignore
   */
  resetUserSettings() {
    this._userProperties = {};
  }
  _runAnimation(e) {
    if (this.isDisposed())
      return !1;
    {
      let t = !1;
      return _e(this._animatingSettings, (s, r) => {
        if (r._stopped)
          this._stopAnimation(s);
        else if (r._playing) {
          r._run(e);
          const n = r.percentage;
          n >= 1 ? r._checkEnded() ? this.set(s, r._value(1)) : (t = !0, r._reset(e), this._set(s, r._value(1))) : (t = !0, this._set(s, r._value(n)));
        }
      }), _e(this._animatingPrivateSettings, (s, r) => {
        if (r._stopped)
          this._stopAnimationPrivate(s);
        else if (r._playing) {
          r._run(e);
          const n = r.percentage;
          n >= 1 ? r._checkEnded() ? this.setPrivate(s, r._value(1)) : (t = !0, r._reset(e), this._setPrivate(s, r._value(1))) : (t = !0, this._setPrivate(s, r._value(n)));
        }
      }), t;
    }
  }
  _markDirtyKey(e) {
    this.markDirty();
  }
  _markDirtyPrivateKey(e) {
    this.markDirty();
  }
  /**
   * Sets a callback function to invoke when specific key of settings changes
   * or is set.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/events/#Settings_value_change} for more info
   * @param   key       Settings key
   * @param   callback  Callback
   * @return            Disposer for event
   */
  on(e, t) {
    let s = this._settingEvents[e];
    return s === void 0 && (s = this._settingEvents[e] = []), s.push(t), new He(() => {
      nt(s, t), s.length === 0 && delete this._settingEvents[e];
    });
  }
  /**
   * Sets a callback function to invoke when specific key of private settings
   * changes or is set.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/events/#Settings_value_change} for more info
   * @ignore
   * @param   key       Private settings key
   * @param   callback  Callback
   * @return            Disposer for event
   */
  onPrivate(e, t) {
    let s = this._privateSettingEvents[e];
    return s === void 0 && (s = this._privateSettingEvents[e] = []), s.push(t), new He(() => {
      nt(s, t), s.length === 0 && delete this._privateSettingEvents[e];
    });
  }
  /**
   * @ignore
   */
  getRaw(e, t) {
    const s = this._settings[e];
    return s !== void 0 ? s : t;
  }
  get(e, t) {
    return this.getRaw(e, t);
  }
  _sendKeyEvent(e, t) {
    const s = this._settingEvents[e];
    s !== void 0 && w(s, (r) => {
      r(t, this, e);
    });
  }
  _sendPrivateKeyEvent(e, t) {
    const s = this._privateSettingEvents[e];
    s !== void 0 && w(s, (r) => {
      r(t, this, e);
    });
  }
  /**
   * @ignore
   */
  _setRaw(e, t, s) {
    this._prevSettings[e] = t, this._sendKeyEvent(e, s);
  }
  /**
   * @ignore
   */
  setRaw(e, t) {
    const s = this._settings[e];
    this._settings[e] = t, s !== t && this._setRaw(e, s, t);
  }
  /**
   * @ignore
   */
  _set(e, t) {
    const s = this._settings[e];
    this._settings[e] = t, s !== t && (this._setRaw(e, s, t), this._markDirtyKey(e));
  }
  _stopAnimation(e) {
    const t = this._animatingSettings[e];
    t && (delete this._animatingSettings[e], t.stop());
  }
  /**
   * Sets a setting `value` for the specified `key`, and returns the same `value`.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
   * @param   key       Setting key
   * @param   value     Setting value
   * @return            Setting value
   */
  set(e, t) {
    return this._set(e, t), this._stopAnimation(e), t;
  }
  /**
   * Removes a setting value for the specified `key`;
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
   * @param   key       Setting key
   */
  remove(e) {
    e in this._settings && (this._prevSettings[e] = this._settings[e], delete this._settings[e], this._sendKeyEvent(e, void 0), this._markDirtyKey(e)), this._stopAnimation(e);
  }
  /**
   * Removes all keys;
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
   */
  removeAll() {
    w(Ne(this._settings), (e) => {
      this.remove(e);
    });
  }
  /**
   * Returns a value of a private setting.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/#Private_settings} for more info
   */
  getPrivate(e, t) {
    const s = this._privateSettings[e];
    return s !== void 0 ? s : t;
  }
  /**
   * @ignore
   */
  _setPrivateRaw(e, t, s) {
    this._prevPrivateSettings[e] = t, this._sendPrivateKeyEvent(e, s);
  }
  /**
   * @ignore
   */
  setPrivateRaw(e, t) {
    const s = this._privateSettings[e];
    this._privateSettings[e] = t, s !== t && this._setPrivateRaw(e, s, t);
  }
  /**
   * @ignore
   */
  _setPrivate(e, t) {
    const s = this._privateSettings[e];
    this._privateSettings[e] = t, s !== t && (this._setPrivateRaw(e, s, t), this._markDirtyPrivateKey(e));
  }
  _stopAnimationPrivate(e) {
    const t = this._animatingPrivateSettings[e];
    t && (t.stop(), delete this._animatingPrivateSettings[e]);
  }
  /**
   * @ignore
   */
  setPrivate(e, t) {
    return this._setPrivate(e, t), this._stopAnimationPrivate(e), t;
  }
  /**
   * @ignore
   */
  removePrivate(e) {
    e in this._privateSettings && (this._prevPrivateSettings[e] = this._privateSettings[e], delete this._privateSettings[e], this._markDirtyPrivateKey(e)), this._stopAnimationPrivate(e);
  }
  /**
   * Sets multiple settings at once.
   *
   * `settings` must be an object with key: value pairs.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
   * @param settings Settings
   */
  setAll(e) {
    _e(e, (t, s) => {
      this.set(t, s);
    });
  }
  /**
   * Animates setting values from current/start values to new ones.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/animations/#Animating_settings} for more info
   * @param   options  Animation options
   * @return           Animation object
   */
  animate(e) {
    const t = e.key, s = e.to, r = e.duration || 0, n = e.loops || 1, a = e.from === void 0 ? this.get(t) : e.from, o = e.easing === void 0 ? sl : e.easing;
    if (r === 0)
      this.set(t, s);
    else if (a === void 0 || a === s)
      this.set(t, s);
    else {
      this.set(t, a);
      const u = this._animatingSettings[t] = new pn(this, a, s, r, o, n, this._animationTime());
      return this._startAnimation(), u;
    }
    const l = new pn(this, a, s, r, o, n, null);
    return l.stop(), l;
  }
  /**
   * @ignore
   */
  animatePrivate(e) {
    const t = e.key, s = e.to, r = e.duration || 0, n = e.loops || 1, a = e.from === void 0 ? this.getPrivate(t) : e.from, o = e.easing === void 0 ? sl : e.easing;
    if (r === 0)
      this.setPrivate(t, s);
    else if (a === void 0 || a === s)
      this.setPrivate(t, s);
    else {
      this.setPrivate(t, a);
      const u = this._animatingPrivateSettings[t] = new pn(this, a, s, r, o, n, this._animationTime());
      return this._startAnimation(), u;
    }
    const l = new pn(this, a, s, r, o, n, null);
    return l.stop(), l;
  }
  _dispose() {
  }
  /**
   * Returns `true` if this element is disposed.
   *
   * @return Disposed
   */
  isDisposed() {
    return this._disposed;
  }
  /**
   * Disposes this object.
   */
  dispose() {
    this._disposed || (this._disposed = !0, this._dispose());
  }
}
class Se extends vd {
  /**
   * IMPORTANT! Do not instantiate this class via `new Class()` syntax.
   *
   * Use static method `Class.new()` instead.
   *
   * @see {@link https://www.amcharts.com/docs/v5/getting-started/#New_element_syntax} for more info
   * @ignore
   */
  constructor(e, t, s, r = []) {
    if (super(t), Object.defineProperty(this, "_root", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_user_id", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "states", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new j0(this)
    }), Object.defineProperty(this, "adapters", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new R0(this)
    }), Object.defineProperty(this, "events", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._createEvents()
    }), Object.defineProperty(this, "_userPrivateProperties", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_dirty", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_dirtyPrivate", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_template", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_templates", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_internalTemplates", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_defaultThemes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_templateDisposers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_disposers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_runSetup", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "_disposerProperties", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), !s)
      throw new Error("You cannot use `new Class()`, instead use `Class.new()`");
    this._root = e, this._internalTemplates = r, t.id && this._registerId(t.id);
  }
  /**
   * Use this method to create an instance of this class.
   *
   * @see {@link https://www.amcharts.com/docs/v5/getting-started/#New_element_syntax} for more info
   * @param   root      Root element
   * @param   settings  Settings
   * @param   template  Template
   * @return            Instantiated object
   */
  static new(e, t, s) {
    const r = new this(e, t, !0);
    return r._template = s, r._afterNew(), r;
  }
  static _new(e, t, s = []) {
    const r = new this(e, t, !0, s);
    return r._afterNew(), r;
  }
  _afterNew() {
    this._checkDirty();
    let e = !1;
    const t = this._template;
    t && (e = !0, t._setObjectTemplate(this)), w(this._internalTemplates, (s) => {
      e = !0, s._setObjectTemplate(this);
    }), e && this._applyTemplates(!1), this.states.create("default", {}), this._setDefaults();
  }
  // This is the same as _afterNew, except it also applies the themes.
  // This should only be used for classes which don't have a parent (because they extend from Entity and not Sprite).
  _afterNewApplyThemes() {
    this._checkDirty();
    const e = this._template;
    e && e._setObjectTemplate(this), w(this._internalTemplates, (t) => {
      t._setObjectTemplate(this);
    }), this.states.create("default", {}), this._setDefaults(), this._applyThemes();
  }
  _createEvents() {
    return new or();
  }
  /**
   * @ignore
   */
  get classNames() {
    return this.constructor.classNames;
  }
  /**
   * @ignore
   */
  get className() {
    return this.constructor.className;
  }
  _setDefaults() {
  }
  _setDefault(e, t) {
    e in this._settings || super.set(e, t);
  }
  _setRawDefault(e, t) {
    e in this._settings || super.setRaw(e, t);
  }
  _clearDirty() {
    Ne(this._dirty).forEach((e) => {
      this._dirty[e] = !1;
    }), Ne(this._dirtyPrivate).forEach((e) => {
      this._dirtyPrivate[e] = !1;
    });
  }
  /**
   * @ignore
   */
  isDirty(e) {
    return !!this._dirty[e];
  }
  /**
   * @ignore
   */
  isPrivateDirty(e) {
    return !!this._dirtyPrivate[e];
  }
  _markDirtyKey(e) {
    this._dirty[e] = !0, super._markDirtyKey(e);
  }
  _markDirtyPrivateKey(e) {
    this._dirtyPrivate[e] = !0, super._markDirtyKey(e);
  }
  /**
   * Checks if element is of certain class (or inherits one).
   *
   * @param   type  Class name to check
   * @return {boolean} Is of class?
   */
  isType(e) {
    return this.classNames.indexOf(e) !== -1;
  }
  _pushPropertyDisposer(e, t) {
    let s = this._disposerProperties[e];
    return s === void 0 && (s = this._disposerProperties[e] = []), s.push(t), t;
  }
  _disposeProperty(e) {
    const t = this._disposerProperties[e];
    t !== void 0 && (w(t, (s) => {
      s.dispose();
    }), delete this._disposerProperties[e]);
  }
  /**
   * @todo needs description
   * @param  value  Template
   */
  set template(e) {
    const t = this._template;
    t !== e && (this._template = e, t && t._removeObjectTemplate(this), e && e._setObjectTemplate(this), this._applyTemplates());
  }
  get template() {
    return this._template;
  }
  /**
   * @ignore
   */
  markDirty() {
    this._root._addDirtyEntity(this);
  }
  _startAnimation() {
    this._root._addAnimation(this);
  }
  _animationTime() {
    return this._root.animationTime;
  }
  _applyState(e) {
  }
  _applyStateAnimated(e, t) {
  }
  get(e, t) {
    const s = this.adapters.fold(e, this._settings[e]);
    return s !== void 0 ? s : t;
  }
  /**
   * @ignore
   */
  isUserSetting(e) {
    return this._userProperties[e] || !1;
  }
  /**
   * Sets a setting `value` for the specified `key`, and returns the same `value`.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
   * @param   key       Setting key
   * @param   value     Setting value
   * @return            Setting value
   */
  set(e, t) {
    return this._userProperties[e] = !0, super.set(e, t);
  }
  /**
   * @ignore
   */
  setRaw(e, t) {
    this._userProperties[e] = !0, super.setRaw(e, t);
  }
  /**
   * Sets a setting `value` for the specified `key` only if the value for this key was not set previously using set method, and returns the same `value`.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
   * @param   key       Setting key
   * @param   value     Setting value
   * @return            Setting value
   */
  _setSoft(e, t) {
    return this._userProperties[e] ? t : super.set(e, t);
  }
  /**
   * Removes a setting value for the specified `key`.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/settings/} for more info
   * @param   key       Setting key
   */
  remove(e) {
    delete this._userProperties[e], this._removeTemplateProperty(e);
  }
  /**
   * @ignore
   */
  setPrivate(e, t) {
    return this._userPrivateProperties[e] = !0, super.setPrivate(e, t);
  }
  /**
   * @ignore
   */
  setPrivateRaw(e, t) {
    this._userPrivateProperties[e] = !0, super.setPrivateRaw(e, t);
  }
  /**
   * @ignore
   */
  removePrivate(e) {
    delete this._userPrivateProperties[e], this._removeTemplatePrivateProperty(e);
  }
  _setTemplateProperty(e, t, s) {
    if (!this._userProperties[t]) {
      const r = this._findTemplateByKey(t);
      e === r && super.set(t, s);
    }
  }
  _setTemplatePrivateProperty(e, t, s) {
    if (!this._userPrivateProperties[t]) {
      const r = this._findTemplateByPrivateKey(t);
      e === r && super.setPrivate(t, s);
    }
  }
  _removeTemplateProperty(e) {
    if (!this._userProperties[e]) {
      const t = this._findTemplateByKey(e);
      t ? super.set(e, t._settings[e]) : super.remove(e);
    }
  }
  _removeTemplatePrivateProperty(e) {
    if (!this._userPrivateProperties[e]) {
      const t = this._findTemplateByPrivateKey(e);
      t ? super.setPrivate(e, t._privateSettings[e]) : super.removePrivate(e);
    }
  }
  _walkParents(e) {
    e(this._root._rootContainer), e(this);
  }
  // TODO faster version of this method which is specialized to just 1 key
  _applyStateByKey(e) {
    const t = this.states.create(e, {}), s = {};
    this._eachTemplate((r) => {
      const n = r.states.lookup(e);
      n && n._apply(t, s);
    }), _e(t._settings, (r) => {
      !s[r] && !t._userSettings[r] && t.remove(r);
    });
  }
  _applyTemplate(e, t) {
    this._templateDisposers.push(e._apply(this, t)), _e(e._settings, (s, r) => {
      !t.settings[s] && !this._userProperties[s] && (t.settings[s] = !0, super.set(s, r));
    }), _e(e._privateSettings, (s, r) => {
      !t.privateSettings[s] && !this._userPrivateProperties[s] && (t.privateSettings[s] = !0, super.setPrivate(s, r));
    }), this._runSetup && e.setup && (this._runSetup = !1, e.setup(this));
  }
  /**
   * Calls the closure with each template and returns the first template which is true
   */
  _findStaticTemplate(e) {
    if (this._template && e(this._template))
      return this._template;
  }
  _eachTemplate(e) {
    this._findStaticTemplate((t) => (e(t), !1)), Rs(this._internalTemplates, e), w(this._templates, e);
  }
  _applyTemplates(e = !0) {
    e && this._disposeTemplates();
    const t = {
      settings: {},
      privateSettings: {},
      states: {}
    };
    this._eachTemplate((s) => {
      this._applyTemplate(s, t);
    }), e && (_e(this._settings, (s) => {
      !this._userProperties[s] && !t.settings[s] && super.remove(s);
    }), _e(this._privateSettings, (s) => {
      !this._userPrivateProperties[s] && !t.privateSettings[s] && super.removePrivate(s);
    }));
  }
  _findTemplate(e) {
    const t = this._findStaticTemplate(e);
    if (t === void 0) {
      const s = Nc(this._internalTemplates, e);
      return s === void 0 ? du(this._templates, e) : s;
    } else
      return t;
  }
  _findTemplateByKey(e) {
    return this._findTemplate((t) => e in t._settings);
  }
  _findTemplateByPrivateKey(e) {
    return this._findTemplate((t) => e in t._privateSettings);
  }
  _disposeTemplates() {
    w(this._templateDisposers, (e) => {
      e.dispose();
    }), this._templateDisposers.length = 0;
  }
  _removeTemplates() {
    w(this._templates, (e) => {
      e._removeObjectTemplate(this);
    }), this._templates.length = 0;
  }
  _applyThemes() {
    let e = !1;
    const t = [];
    let s = [];
    const r = /* @__PURE__ */ new Set(), n = this.get("themeTagsSelf");
    return n && w(n, (a) => {
      r.add(a);
    }), this._walkParents((a) => {
      a === this._root._rootContainer && (e = !0), a._defaultThemes.length > 0 && t.push(a._defaultThemes);
      const o = a.get("themes");
      o && s.push(o);
      const l = a.get("themeTags");
      l && w(l, (u) => {
        r.add(u);
      });
    }), s = t.concat(s), this._removeTemplates(), e && Rs(this.classNames, (a) => {
      const o = [];
      w(s, (l) => {
        w(l, (u) => {
          const c = u._lookupRules(a);
          c && Rs(c, (h) => {
            if (h.tags.every((f) => r.has(f))) {
              const f = $c(o, (g) => {
                const p = Et(h.tags.length, g.tags.length);
                return p === 0 ? yd(h.tags, g.tags, Et) : p;
              });
              o.splice(f.index, 0, h);
            }
          });
        });
      }), w(o, (l) => {
        this._templates.push(l.template), l.template._setObjectTemplate(this);
      });
    }), this._applyTemplates(), e && (this._runSetup = !1), e;
  }
  _changed() {
  }
  _beforeChanged() {
    if (this.isDirty("id")) {
      const e = this.get("id");
      e && this._registerId(e);
      const t = this._prevSettings.id;
      t && delete Ot.entitiesById[t];
    }
  }
  _registerId(e) {
    if (Ot.entitiesById[e] && Ot.entitiesById[e] !== this)
      throw new Error('An entity with id "' + e + '" already exists.');
    Ot.entitiesById[e] = this;
  }
  _afterChanged() {
  }
  /**
   * @ignore
   */
  addDisposer(e) {
    return this._disposers.push(e), e;
  }
  _dispose() {
    super._dispose();
    const e = this._template;
    e && e._removeObjectTemplate(this), w(this._internalTemplates, (s) => {
      s._removeObjectTemplate(this);
    }), this._removeTemplates(), this._disposeTemplates(), this.events.dispose(), this._disposers.forEach((s) => {
      s.dispose();
    }), _e(this._disposerProperties, (s, r) => {
      w(r, (n) => {
        n.dispose();
      });
    });
    const t = this.get("id");
    t && delete Ot.entitiesById[t];
  }
  /**
   * Creates and returns a "disposable" timeout.
   *
   * @param   fn     Callback
   * @param   delay  Delay in milliseconds
   * @return         Timeout disposer
   */
  setTimeout(e, t) {
    const s = setTimeout(() => {
      this.removeDispose(r), e();
    }, t), r = new He(() => {
      clearTimeout(s);
    });
    return this._disposers.push(r), r;
  }
  /**
   * @ignore
   */
  removeDispose(e) {
    if (!this.isDisposed()) {
      let t = Yi(this._disposers, e);
      t > -1 && this._disposers.splice(t, 1);
    }
    e.dispose();
  }
  /**
   * @ignore
   */
  hasTag(e) {
    return Yi(this.get("themeTags", []), e) !== -1;
  }
  /**
   * @ignore
   */
  addTag(e) {
    if (!this.hasTag(e)) {
      const t = this.get("themeTags", []);
      t.push(e), this.set("themeTags", t);
    }
  }
  /**
   * @ignore
   */
  removeTag(e) {
    if (this.hasTag(e)) {
      const t = this.get("themeTags", []);
      bt(t, e), this.set("themeTags", t);
    }
  }
  _t(e, t, ...s) {
    return this._root.language.translate(e, t, ...s);
  }
  /**
   * An instance of [[Root]] object.
   *
   * @readonly
   * @since 5.0.6
   * @return Root object
   */
  get root() {
    return this._root;
  }
}
Object.defineProperty(Se, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Entity"
});
Object.defineProperty(Se, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: ["Entity"]
});
class $0 {
  constructor(e, t, s) {
    Object.defineProperty(this, "_settings", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_template", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._name = e, this._template = t, this._settings = s;
  }
  get(e, t) {
    const s = this._settings[e];
    return s !== void 0 ? s : t;
  }
  set(e, t) {
    this._settings[e] = t, this._template._stateChanged(this._name);
  }
  remove(e) {
    delete this._settings[e], this._template._stateChanged(this._name);
  }
  setAll(e) {
    Ne(e).forEach((t) => {
      this._settings[t] = e[t];
    }), this._template._stateChanged(this._name);
  }
  _apply(e, t) {
    _e(this._settings, (s, r) => {
      !t[s] && !e._userSettings[s] && (t[s] = !0, e.setRaw(s, r));
    });
  }
}
class F0 {
  constructor(e) {
    Object.defineProperty(this, "_template", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_states", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), this._template = e;
  }
  lookup(e) {
    return this._states[e];
  }
  create(e, t) {
    const s = this._states[e];
    if (s)
      return s.setAll(t), s;
    {
      const r = new $0(e, this._template, t);
      return this._states[e] = r, this._template._stateChanged(e), r;
    }
  }
  remove(e) {
    delete this._states[e], this._template._stateChanged(e);
  }
  _apply(e, t) {
    _e(this._states, (s, r) => {
      let n = t.states[s];
      n == null && (n = t.states[s] = {});
      const a = e.states.create(s, {});
      r._apply(a, n);
    });
  }
}
class B0 {
  constructor() {
    Object.defineProperty(this, "_callbacks", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    });
  }
  add(e, t) {
    let s = this._callbacks[e];
    return s === void 0 && (s = this._callbacks[e] = []), s.push(t), new He(() => {
      nt(s, t), s.length === 0 && delete this._callbacks[e];
    });
  }
  remove(e) {
    this._callbacks[e] !== void 0 && delete this._callbacks[e];
  }
  _apply(e) {
    const t = [];
    return _e(this._callbacks, (s, r) => {
      w(r, (n) => {
        t.push(e.adapters.add(s, n));
      });
    }), new st(t);
  }
}
class me {
  constructor(e, t) {
    if (Object.defineProperty(this, "_settings", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_privateSettings", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_settingEvents", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_privateSettingEvents", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_entities", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "states", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new F0(this)
    }), Object.defineProperty(this, "adapters", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new B0()
    }), Object.defineProperty(this, "events", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new or()
    }), Object.defineProperty(this, "setup", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), !t)
      throw new Error("You cannot use `new Class()`, instead use `Class.new()`");
    this._settings = e;
  }
  /**
   * Use this method to create an instance of this class.
   *
   * @see {@link https://www.amcharts.com/docs/v5/getting-started/#New_element_syntax} for more info
   * @param   root      Root element
   * @param   settings  Settings
   * @param   template  Template
   * @return            Instantiated object
   */
  static new(e) {
    return new me(e, !0);
  }
  get(e, t) {
    const s = this._settings[e];
    return s !== void 0 ? s : t;
  }
  setRaw(e, t) {
    this._settings[e] = t;
  }
  set(e, t) {
    this._settings[e] !== t && (this.setRaw(e, t), this._entities.forEach((s) => {
      s._setTemplateProperty(this, e, t);
    }));
  }
  remove(e) {
    e in this._settings && (delete this._settings[e], this._entities.forEach((t) => {
      t._removeTemplateProperty(e);
    }));
  }
  removeAll() {
    _e(this._settings, (e, t) => {
      this.remove(e);
    });
  }
  getPrivate(e, t) {
    const s = this._privateSettings[e];
    return s !== void 0 ? s : t;
  }
  setPrivateRaw(e, t) {
    return this._privateSettings[e] = t, t;
  }
  setPrivate(e, t) {
    return this._privateSettings[e] !== t && (this.setPrivateRaw(e, t), this._entities.forEach((s) => {
      s._setTemplatePrivateProperty(this, e, t);
    })), t;
  }
  removePrivate(e) {
    e in this._privateSettings && (delete this._privateSettings[e], this._entities.forEach((t) => {
      t._removeTemplatePrivateProperty(e);
    }));
  }
  setAll(e) {
    _e(e, (t, s) => {
      this.set(t, s);
    });
  }
  // TODO code duplication with Properties
  on(e, t) {
    let s = this._settingEvents[e];
    return s === void 0 && (s = this._settingEvents[e] = []), s.push(t), new He(() => {
      nt(s, t), s.length === 0 && delete this._settingEvents[e];
    });
  }
  // TODO code duplication with Properties
  onPrivate(e, t) {
    let s = this._privateSettingEvents[e];
    return s === void 0 && (s = this._privateSettingEvents[e] = []), s.push(t), new He(() => {
      nt(s, t), s.length === 0 && delete this._privateSettingEvents[e];
    });
  }
  _apply(e, t) {
    const s = [];
    return _e(this._settingEvents, (r, n) => {
      w(n, (a) => {
        s.push(e.on(r, a));
      });
    }), _e(this._privateSettingEvents, (r, n) => {
      w(n, (a) => {
        s.push(e.onPrivate(r, a));
      });
    }), this.states._apply(e, t), s.push(this.adapters._apply(e)), s.push(e.events.copyFrom(this.events)), new st(s);
  }
  _setObjectTemplate(e) {
    this._entities.push(e);
  }
  _removeObjectTemplate(e) {
    bt(this._entities, e);
  }
  _stateChanged(e) {
    this._entities.forEach((t) => {
      t._applyStateByKey(e);
    });
  }
}
class Ka extends or {
  constructor(e) {
    super(), Object.defineProperty(this, "_sprite", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_rendererDisposers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_dispatchParents", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), this._sprite = e;
  }
  _makePointerEvent(e, t) {
    return {
      type: e,
      originalEvent: t.event,
      point: t.point,
      simulated: t.simulated,
      native: t.native,
      target: this._sprite
    };
  }
  _onRenderer(e, t) {
    this._sprite.set("interactive", !0), this._sprite._display.interactive = !0;
    let s = this._rendererDisposers[e];
    if (s === void 0) {
      const r = this._sprite._display.on(e, (n) => {
        t.call(this, n);
      });
      s = this._rendererDisposers[e] = new Ua(() => {
        delete this._rendererDisposers[e], r.dispose();
      });
    }
    return s.increment();
  }
  _on(e, t, s, r, n, a) {
    const o = super._on(e, t, s, r, n, a), l = Ka.RENDERER_EVENTS[t];
    return l !== void 0 && (o.disposer = new st([
      o.disposer,
      this._onRenderer(t, l)
    ])), o;
  }
  /**
   * Will stop any bubbling up of the event to element's parents.
   *
   * Should be called in an event handler, e.g.:
   *
   * ```TypeScript
   * element.events.on("pointerdown", function(ev) {
   *   // Do something here and prevent from "pointerdown" bubbling up
   *   // ...
   *   ev.target.events.stopParentDispatch();
   * });
   * ```
   * ```JavaScript
   * element.events.on("pointerdown", function(ev) {
   *   // Do something here and prevent from "pointerdown" bubbling up
   *   // ...
   *   ev.target.events.stopParentDispatch();
   * });
   * ```
   */
  stopParentDispatch() {
    this._dispatchParents = !1;
  }
  /**
   * @ignore
   */
  dispatchParents(e, t) {
    const s = this._dispatchParents;
    this._dispatchParents = !0;
    try {
      this.dispatch(e, t), this._dispatchParents && this._sprite.parent && this._sprite.parent.events.dispatchParents(e, t);
    } finally {
      this._dispatchParents = s;
    }
  }
}
Object.defineProperty(Ka, "RENDERER_EVENTS", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: {
    click: function(i) {
      this.isEnabled("click") && !this._sprite.isDragging() && this._sprite._hasDown() && !this._sprite._hasMoved(this._makePointerEvent("click", i)) && this.dispatch("click", this._makePointerEvent("click", i));
    },
    rightclick: function(i) {
      this.isEnabled("rightclick") && this.dispatch("rightclick", this._makePointerEvent("rightclick", i));
    },
    middleclick: function(i) {
      this.isEnabled("middleclick") && this.dispatch("middleclick", this._makePointerEvent("middleclick", i));
    },
    dblclick: function(i) {
      this.dispatchParents("dblclick", this._makePointerEvent("dblclick", i));
    },
    pointerover: function(i) {
      this.isEnabled("pointerover") && this.dispatch("pointerover", this._makePointerEvent("pointerover", i));
    },
    pointerout: function(i) {
      this.isEnabled("pointerout") && this.dispatch("pointerout", this._makePointerEvent("pointerout", i));
    },
    pointerdown: function(i) {
      this.dispatchParents("pointerdown", this._makePointerEvent("pointerdown", i));
    },
    pointerup: function(i) {
      this.isEnabled("pointerup") && this.dispatch("pointerup", this._makePointerEvent("pointerup", i));
    },
    globalpointerup: function(i) {
      this.isEnabled("globalpointerup") && this.dispatch("globalpointerup", this._makePointerEvent("globalpointerup", i));
    },
    globalpointermove: function(i) {
      this.isEnabled("globalpointermove") && this.dispatch("globalpointermove", this._makePointerEvent("globalpointermove", i));
    },
    wheel: function(i) {
      this.dispatchParents("wheel", {
        type: "wheel",
        target: this._sprite,
        originalEvent: i.event,
        point: i.point
      });
    }
  }
});
class vt extends Se {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_adjustedLocalBounds", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: { left: 0, right: 0, top: 0, bottom: 0 }
    }), Object.defineProperty(this, "_localBounds", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: { left: 0, right: 0, top: 0, bottom: 0 }
    }), Object.defineProperty(this, "_parent", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_dataItem", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_templateField", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_sizeDirty", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_isDragging", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_dragEvent", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_dragPoint", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_isHidden", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_isShowing", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_isHiding", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_isDown", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_downPoint", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_downPoints", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_toggleDp", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_dragDp", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_tooltipDp", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_hoverDp", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_focusDp", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_tooltipMoveDp", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_tooltipPointerDp", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_statesHandled", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    });
  }
  _afterNew() {
    this.setPrivateRaw("visible", !0), super._afterNew();
  }
  _markDirtyKey(e) {
    super._markDirtyKey(e), (e == "x" || e == "y" || e == "dx" || e == "dy") && (this.markDirtyBounds(), this._addPercentagePositionChildren(), this.markDirtyPosition());
  }
  _markDirtyPrivateKey(e) {
    super._markDirtyPrivateKey(e), (e == "x" || e == "y") && this.markDirtyPosition();
  }
  _removeTemplateField() {
    this._templateField && this._templateField._removeObjectTemplate(this);
  }
  _createEvents() {
    return new Ka(this);
  }
  _processTemplateField() {
    let e;
    const t = this.get("templateField");
    if (t) {
      const s = this.dataItem;
      if (s) {
        const r = s.dataContext;
        r && (e = r[t], !(e instanceof me) && e && (e = me.new(e)));
      }
    }
    this._templateField !== e && (this._removeTemplateField(), this._templateField = e, e && e._setObjectTemplate(this), this._applyTemplates());
  }
  // TODO change this to run before the element is added to the parent, so that way
  //      it doesn't need to apply the themes twice
  _setDataItem(e) {
    const t = this._dataItem;
    this._dataItem = e, this._processTemplateField();
    const s = "dataitemchanged";
    e != t && this.events.isEnabled(s) && this.events.dispatch(s, {
      type: s,
      target: this,
      oldDataItem: t,
      newDataItem: e
    });
  }
  /**
   * A [[DataItem]] used for this element.
   *
   * NOTE: data item is being assigned automatically in most cases where it
   * matters. Use this accessor to set data item only if you know what you're
   * doing.
   *
   * @param  value  Data item
   */
  set dataItem(e) {
    this._setDataItem(e);
  }
  /**
   * @return DataItem
   */
  get dataItem() {
    if (this._dataItem)
      return this._dataItem;
    {
      let e = this._parent;
      for (; e; ) {
        if (e._dataItem)
          return e._dataItem;
        e = e._parent;
      }
    }
  }
  _addPercentageSizeChildren() {
    let e = this.parent;
    e && (this.get("width") instanceof re || this.get("height") instanceof re ? Bs(e._percentageSizeChildren, this) : nt(e._percentageSizeChildren, this));
  }
  _addPercentagePositionChildren() {
    let e = this.parent;
    e && (this.get("x") instanceof re || this.get("y") instanceof re ? Bs(e._percentagePositionChildren, this) : nt(e._percentagePositionChildren, this));
  }
  /**
   * @ignore
   */
  markDirtyPosition() {
    this._root._addDirtyPosition(this);
  }
  updatePivotPoint() {
    const e = this._localBounds;
    if (e) {
      const t = this.get("centerX");
      t != null && (this._display.pivot.x = e.left + Re(t, e.right - e.left));
      const s = this.get("centerY");
      s != null && (this._display.pivot.y = e.top + Re(s, e.bottom - e.top));
    }
  }
  _beforeChanged() {
    if (super._beforeChanged(), this._handleStates(), this.isDirty("tooltip")) {
      const e = this._prevSettings.tooltip;
      e && e.dispose();
    }
    if ((this.isDirty("layer") || this.isDirty("layerMargin")) && (this._display.setLayer(this.get("layer"), this.get("layerMargin")), this.markDirtyLayer()), this.isDirty("tooltipPosition")) {
      const e = this._tooltipMoveDp;
      e && (e.dispose(), this._tooltipMoveDp = void 0);
      const t = this._tooltipPointerDp;
      t && (t.dispose(), this._tooltipPointerDp = void 0), this.get("tooltipPosition") == "pointer" && (this._tooltipPointerDp = new st([
        this.events.on("pointerover", () => {
          this._tooltipMoveDp = this.events.on("globalpointermove", (s) => {
            this.showTooltip(s.point);
          });
        }),
        this.events.on("pointerout", () => {
          const s = this._tooltipMoveDp;
          s && (s.dispose(), this._tooltipMoveDp = void 0);
        })
      ]));
    }
  }
  _handleStates() {
    this._statesHandled || (this.isDirty("active") && (this.get("active") ? (this.states.applyAnimate("active"), this.set("ariaChecked", !0)) : (this.isHidden() || this.states.applyAnimate("default"), this.set("ariaChecked", !1)), this.markDirtyAccessibility()), this.isDirty("disabled") && (this.get("disabled") ? (this.states.applyAnimate("disabled"), this.set("ariaChecked", !1)) : (this.isHidden() || this.states.applyAnimate("default"), this.set("ariaChecked", !0)), this.markDirtyAccessibility()), this._statesHandled = !0);
  }
  _changed() {
    super._changed();
    const e = this._display, t = this.events;
    if (this.isDirty("draggable")) {
      const s = this.get("draggable");
      s ? (this.set("interactive", !0), this._dragDp = new st([
        t.on("pointerdown", (r) => {
          this.dragStart(r);
        }),
        t.on("globalpointermove", (r) => {
          this.dragMove(r);
        }),
        t.on("globalpointerup", (r) => {
          this.dragStop(r);
        })
      ])) : this._dragDp && (this._dragDp.dispose(), this._dragDp = void 0), e.cancelTouch = !!s;
    }
    if (this.isDirty("tooltipText") || this.isDirty("tooltipHTML") || this.isDirty("showTooltipOn")) {
      const s = this.get("tooltipText"), r = this.get("tooltipHTML"), n = this.get("showTooltipOn", "hover");
      this._tooltipDp && (this._tooltipDp.dispose(), this._tooltipDp = void 0), (s || r) && (n == "click" ? this._tooltipDp = new st([
        t.on("click", () => {
          this.setTimeout(() => this.showTooltip(), 10);
        }),
        Le(document, "click", (a) => {
          this.hideTooltip();
        })
      ]) : n == "always" || (this._tooltipDp = new st([
        t.on("pointerover", () => {
          this.showTooltip();
        }),
        t.on("pointerout", () => {
          this.hideTooltip();
        })
      ])));
    }
    if (this.isDirty("toggleKey")) {
      let s = this.get("toggleKey");
      s && s != "none" ? this._toggleDp = t.on("click", () => {
        this._isDragging || this.set(s, !this.get(s));
      }) : this._toggleDp && (this._toggleDp.dispose(), this._toggleDp = void 0);
    }
    if (this.isDirty("opacity") && (e.alpha = Math.max(0, this.get("opacity", 1))), this.isDirty("rotation") && (this.markDirtyBounds(), e.angle = this.get("rotation", 0)), this.isDirty("scale") && (this.markDirtyBounds(), e.scale = this.get("scale", 0)), (this.isDirty("centerX") || this.isDirty("centerY")) && (this.markDirtyBounds(), this.updatePivotPoint()), (this.isDirty("visible") || this.isPrivateDirty("visible") || this.isDirty("forceHidden")) && (!this.get("visible") || !this.getPrivate("visible") || this.get("forceHidden") ? (e.visible = !1, this.hideTooltip()) : e.visible = !0, this.markDirtyBounds(), this.get("focusable") && this.markDirtyAccessibility()), this.isDirty("width") || this.isDirty("height")) {
      this.markDirtyBounds(), this._addPercentageSizeChildren();
      const s = this.parent;
      s && (this.isDirty("width") && this.get("width") instanceof re || this.isDirty("height") && this.get("height") instanceof re) && (s.markDirty(), s._prevWidth = 0), this._sizeDirty = !0;
    }
    if ((this.isDirty("maxWidth") || this.isDirty("maxHeight") || this.isPrivateDirty("width") || this.isPrivateDirty("height") || this.isDirty("minWidth") || this.isDirty("minHeight") || this.isPrivateDirty("maxWidth") || this.isPrivateDirty("maxHeight") || this.isPrivateDirty("minWidth") || this.isPrivateDirty("minHeight")) && (this.markDirtyBounds(), this._sizeDirty = !0), this._sizeDirty && this._updateSize(), this.isDirty("wheelable")) {
      const s = this.get("wheelable");
      s && this.set("interactive", !0), e.wheelable = !!s;
    }
    if ((this.isDirty("tabindexOrder") || this.isDirty("focusableGroup")) && (this.get("focusable") ? this._root._registerTabindexOrder(this) : this._root._unregisterTabindexOrder(this)), this.isDirty("filter") && (e.filter = this.get("filter")), this.isDirty("cursorOverStyle") && (e.cursorOverStyle = this.get("cursorOverStyle")), this.isDirty("hoverOnFocus") && (this.get("hoverOnFocus") ? this._focusDp = new st([
      t.on("focus", () => {
        this.showTooltip();
      }),
      t.on("blur", () => {
        this.hideTooltip();
      })
    ]) : this._focusDp && (this._focusDp.dispose(), this._focusDp = void 0)), this.isDirty("focusable") && (this.get("focusable") ? this._root._registerTabindexOrder(this) : this._root._unregisterTabindexOrder(this), this.markDirtyAccessibility()), (this.isDirty("role") || this.isDirty("ariaLive") || this.isDirty("ariaChecked") || this.isDirty("ariaHidden") || this.isDirty("ariaOrientation") || this.isDirty("ariaValueNow") || this.isDirty("ariaValueMin") || this.isDirty("ariaValueMax") || this.isDirty("ariaValueText") || this.isDirty("ariaLabel") || this.isDirty("ariaControls")) && this.markDirtyAccessibility(), this.isDirty("exportable") && (e.exportable = this.get("exportable")), this.isDirty("interactive")) {
      const s = this.events;
      this.get("interactive") ? this._hoverDp = new st([
        s.on("click", (r) => {
          qn(r.originalEvent) && (this.getPrivate("touchHovering") || this.setTimeout(() => {
            this._handleOver(), (this.get("tooltipText") || this.get("tooltipHTML")) && this.showTooltip(), this.setPrivateRaw("touchHovering", !0), this.events.dispatch("pointerover", {
              type: "pointerover",
              target: r.target,
              originalEvent: r.originalEvent,
              point: r.point,
              simulated: r.simulated
            });
          }, 10));
        }),
        s.on("globalpointerup", (r) => {
          qn(r.originalEvent) && (this.getPrivate("touchHovering") && (this._handleOut(), (this.get("tooltipText") || this.get("tooltipHTML")) && this.hideTooltip()), this.setPrivateRaw("touchHovering", !1), this.events.dispatch("pointerout", {
            type: "pointerout",
            target: r.target,
            originalEvent: r.originalEvent,
            point: r.point,
            simulated: r.simulated
          })), this._isDown && this._handleUp(r);
        }),
        s.on("pointerover", () => {
          this._handleOver();
        }),
        s.on("pointerout", () => {
          this._handleOut();
        }),
        s.on("pointerdown", (r) => {
          this._handleDown(r);
        })
      ]) : (this._display.interactive = !1, this._hoverDp && (this._hoverDp.dispose(), this._hoverDp = void 0));
    }
    this.isDirty("forceInactive") && (this._display.inactive = this.get("forceInactive", !1)), this.get("showTooltipOn") == "always" && this._display.visible && this.showTooltip();
  }
  /**
   * @ignore
   * @todo should this be user-accessible?
   */
  dragStart(e) {
    this._dragEvent = e, this.events.stopParentDispatch();
  }
  /**
   * @ignore
   * @todo should this be user-accessible?
   */
  dragStop(e) {
    if (this._dragEvent = void 0, this._dragPoint = void 0, this.events.stopParentDispatch(), this._isDragging) {
      this._isDragging = !1;
      const t = "dragstop";
      this.events.isEnabled(t) && this.events.dispatch(t, {
        type: t,
        target: this,
        originalEvent: e.originalEvent,
        point: e.point,
        simulated: e.simulated
      });
    }
  }
  _handleOver() {
    this.isHidden() || (this.get("active") && this.states.lookup("hoverActive") ? this.states.applyAnimate("hoverActive") : this.get("disabled") && this.states.lookup("hoverDisabled") ? this.states.applyAnimate("hoverDisabled") : this.states.applyAnimate("hover"), this.get("draggable") && this._isDown && this.states.lookup("down") && this.states.applyAnimate("down"));
  }
  _handleOut() {
    this.isHidden() || (this.get("active") && this.states.lookup("active") ? this.states.applyAnimate("active") : this.get("disabled") && this.states.lookup("disabled") ? this.states.applyAnimate("disabled") : (this.states.lookup("hover") || this.states.lookup("hoverActive")) && this.states.applyAnimate("default"), this.get("draggable") && this._isDown && this.states.lookup("down") && this.states.applyAnimate("down"));
  }
  _handleUp(e) {
    if (!this.isHidden()) {
      this.get("active") && this.states.lookup("active") ? this.states.applyAnimate("active") : this.get("disabled") && this.states.lookup("disabled") ? this.states.applyAnimate("disabled") : this.states.lookup("down") && (this.isHover() ? this.states.applyAnimate("hover") : this.states.applyAnimate("default")), this._downPoint = void 0;
      const t = Cn(e.originalEvent);
      delete this._downPoints[t], Ne(this._downPoints).length == 0 && (this._isDown = !1);
    }
  }
  _hasMoved(e) {
    const t = Cn(e.originalEvent), s = this._downPoints[t];
    if (s) {
      const r = Math.abs(s.x - e.point.x), n = Math.abs(s.y - e.point.y);
      return r > 5 || n > 5;
    }
    return !1;
  }
  _hasDown() {
    return Ne(this._downPoints).length > 0;
  }
  _handleDown(e) {
    const t = this.parent;
    if (t && !this.get("draggable") && t._handleDown(e), this.get("interactive") && !this.isHidden()) {
      this.states.lookup("down") && this.states.applyAnimate("down"), this._downPoint = {
        x: e.point.x,
        y: e.point.y
      }, this._isDown = !0;
      const s = Cn(e.originalEvent);
      this._downPoints[s] = {
        x: e.point.x,
        y: e.point.y
      };
    }
  }
  /**
   * @ignore
   * @todo should this be user-accessible?
   */
  dragMove(e) {
    let t = this._dragEvent;
    if (t) {
      if (t.simulated && !e.simulated)
        return !0;
      let s = 0, r = this.parent;
      for (; r != null; )
        s += r.get("rotation", 0), r = r.parent;
      let n = e.point.x - t.point.x, a = e.point.y - t.point.y;
      const o = this.events;
      if (t.simulated && !this._isDragging) {
        this._isDragging = !0, this._dragEvent = e, this._dragPoint = {
          x: this.x(),
          y: this.y()
        };
        const l = "dragstart";
        o.isEnabled(l) && o.dispatch(l, {
          type: l,
          target: this,
          originalEvent: e.originalEvent,
          point: e.point,
          simulated: e.simulated
        });
      }
      if (this._isDragging) {
        let l = this._dragPoint;
        this.set("x", l.x + n * jt(s) + a * Lt(s)), this.set("y", l.y + a * jt(s) - n * Lt(s));
        const u = "dragged";
        o.isEnabled(u) && o.dispatch(u, {
          type: u,
          target: this,
          originalEvent: e.originalEvent,
          point: e.point,
          simulated: e.simulated
        });
      } else if (Math.hypot(n, a) > 5) {
        this._isDragging = !0, this._dragEvent = e, this._dragPoint = {
          x: this.x(),
          y: this.y()
        };
        const l = "dragstart";
        o.isEnabled(l) && o.dispatch(l, {
          type: l,
          target: this,
          originalEvent: e.originalEvent,
          point: e.point,
          simulated: e.simulated
        });
      }
    }
  }
  _updateSize() {
  }
  _getBounds() {
    this._localBounds = this._display.getLocalBounds();
  }
  /**
   * Returns depth (how deep in the hierachy of the content tree) of this
   * element.
   *
   * @return Depth
   */
  depth() {
    let e = this.parent, t = 0;
    for (; ; )
      if (e)
        ++t, e = e.parent;
      else
        return t;
  }
  /**
   * @ignore
   */
  markDirtySize() {
    this._sizeDirty = !0, this.markDirty();
  }
  /**
   * @ignore
   */
  markDirtyBounds() {
    const e = this._display;
    if (this.get("isMeasured")) {
      this._root._addDirtyBounds(this), e.isMeasured = !0, e.invalidateBounds();
      const t = this.parent;
      t && this.get("position") != "absolute" && (t.get("width") == null || t.get("height") == null || t.get("layout")) && t.markDirtyBounds(), this.get("focusable") && this.isFocus() && this.markDirtyAccessibility();
    }
  }
  /**
   * @ignore
   */
  markDirtyAccessibility() {
    this._root._invalidateAccessibility(this);
  }
  /**
   * @ignore
   */
  markDirtyLayer() {
    this._display.markDirtyLayer(!0);
  }
  /**
   * @ignore
   */
  markDirty() {
    super.markDirty(), this.markDirtyLayer();
  }
  _updateBounds() {
    const e = this._adjustedLocalBounds;
    let t;
    if (!this.get("visible") || !this.getPrivate("visible") || this.get("forceHidden") ? (t = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, this._localBounds = t, this._adjustedLocalBounds = t) : (this._getBounds(), this._fixMinBounds(this._localBounds), this.updatePivotPoint(), this._adjustedLocalBounds = this._display.getAdjustedBounds(this._localBounds), t = this._adjustedLocalBounds), !e || e.left !== t.left || e.top !== t.top || e.right !== t.right || e.bottom !== t.bottom) {
      const s = "boundschanged";
      this.events.isEnabled(s) && this.events.dispatch(s, { type: s, target: this }), this.parent && (this.parent.markDirty(), this.parent.markDirtyBounds());
    }
  }
  _fixMinBounds(e) {
    let t = this.get("minWidth", this.getPrivate("minWidth")), s = this.get("minHeight", this.getPrivate("minHeight"));
    S(t) && e.right - e.left < t && (e.right = e.left + t), S(s) && e.bottom - e.top < s && (e.bottom = e.top + s);
    let r = this.getPrivate("width"), n = this.getPrivate("height");
    S(r) && (e.right = e.left + r), S(n) && (e.bottom = e.top + n);
  }
  _removeParent(e) {
    e && (e.children.removeValue(this), nt(e._percentageSizeChildren, this), nt(e._percentagePositionChildren, this));
  }
  _clearDirty() {
    super._clearDirty(), this._sizeDirty = !1, this._statesHandled = !1;
  }
  /**
   * Simulate hover over element.
   */
  hover() {
    this.showTooltip(), this._handleOver();
  }
  /**
   * Simulate unhover over element.
   */
  unhover() {
    this.hideTooltip(), this._handleOut();
  }
  /**
   * Shows element's [[Tooltip]].
   */
  showTooltip(e) {
    const t = this.getTooltip(), s = this.get("tooltipText"), r = this.get("tooltipHTML");
    if ((s || r) && t) {
      const n = this.get("tooltipPosition"), a = this.getPrivate("tooltipTarget", this);
      (n == "fixed" || !e) && (this._display._setMatrix(), e = this.toGlobal(a._getTooltipPoint())), t.set("pointTo", e), t.set("tooltipTarget", a), t.get("x") || t.set("x", e.x), t.get("y") || t.set("y", e.y), s && t.label.set("text", s), r && t.label.set("html", r);
      const o = this.dataItem;
      if (o && t.label._setDataItem(o), this.get("showTooltipOn") == "always" && (e.x < 0 || e.x > this._root.width() || e.y < 0 || e.y > this._root.height())) {
        this.hideTooltip();
        return;
      }
      t.label.text.markDirtyText();
      const l = t.show();
      return this.setPrivateRaw("showingTooltip", !0), l;
    }
  }
  /**
   * Hides element's [[Tooltip]].
   */
  hideTooltip() {
    const e = this.getTooltip();
    if (e && e.get("tooltipTarget") == this.getPrivate("tooltipTarget", this)) {
      let t = e.get("keepTargetHover") && e.get("stateAnimationDuration", 0) == 0 ? 400 : void 0;
      const s = e.hide(t);
      return this.setPrivateRaw("showingTooltip", !1), s;
    }
  }
  _getTooltipPoint() {
    const e = this._localBounds;
    if (e) {
      let t = 0, s = 0;
      return this.get("isMeasured") ? (t = e.left + Re(this.get("tooltipX", 0), e.right - e.left), s = e.top + Re(this.get("tooltipY", 0), e.bottom - e.top)) : (t = Re(this.get("tooltipX", 0), this.width()), s = Re(this.get("tooltipY", 0), this.height())), { x: t, y: s };
    }
    return { x: 0, y: 0 };
  }
  /**
   * Returns [[Tooltip]] used for this element.
   *
   * @return Tooltip
   */
  getTooltip() {
    let e = this.get("tooltip");
    if (e)
      return e;
    {
      let t = this.parent;
      if (t)
        return t.getTooltip();
    }
  }
  _updatePosition() {
    const e = this.parent;
    let t = this.get("dx", 0), s = this.get("dy", 0), r = this.get("x"), n = this.getPrivate("x"), a = 0, o = 0;
    const l = this.get("position");
    r instanceof re && (e ? r = e.innerWidth() * r.value + e.get("paddingLeft", 0) : r = 0), S(r) ? a = r + t : n != null ? a = n : e && l == "relative" && (a = e.get("paddingLeft", 0) + t);
    let u = this.get("y"), c = this.getPrivate("y");
    u instanceof re && (e ? u = e.innerHeight() * u.value + e.get("paddingTop", 0) : u = 0), S(u) ? o = u + s : c != null ? o = c : e && l == "relative" && (o = e.get("paddingTop", 0) + s);
    const h = this._display;
    if (h.x != a || h.y != o) {
      h.invalidateBounds(), h.x = a, h.y = o;
      const d = "positionchanged";
      this.events.isEnabled(d) && this.events.dispatch(d, { type: d, target: this });
    }
    this.getPrivate("showingTooltip") && this.showTooltip();
  }
  /**
   * Returns element's actual X position in pixels.
   *
   * @return X (px)
   */
  x() {
    let e = this.get("x"), t = this.getPrivate("x");
    const s = this.parent;
    return s ? e instanceof re ? Re(e, s.innerWidth()) + s.get("paddingLeft", 0) : S(e) ? e : t ?? s.get("paddingLeft", this._display.x) : this._display.x;
  }
  /**
   * Returns element's actual Y position in pixels.
   *
   * @return Y (px)
   */
  y() {
    let e = this.getPrivate("y");
    if (e != null)
      return e;
    let t = this.get("y");
    const s = this.parent;
    return s ? t instanceof re ? Re(t, s.innerHeight()) + s.get("paddingTop", 0) : S(t) ? t : e ?? s.get("paddingTop", this._display.y) : this._display.y;
  }
  _dispose() {
    super._dispose(), this._display.dispose(), this._removeTemplateField(), this._removeParent(this.parent), this._root._removeFocusElement(this);
    const e = this.get("tooltip");
    e && e.dispose(), this.markDirty();
  }
  /**
   * @ignore
   */
  adjustedLocalBounds() {
    return this._fixMinBounds(this._adjustedLocalBounds), this._adjustedLocalBounds;
  }
  /**
   * Returns local coordinates of the element's bounds.
   *
   * @ignore
   * @return Global bounds
   */
  localBounds() {
    return this._localBounds;
  }
  /**
   * Returns adjusted local coordinates of the element's bounds.
   *
   * @ignore
   * @return Global bounds
   */
  bounds() {
    const e = this._adjustedLocalBounds, t = this.x(), s = this.y();
    return { left: e.left + t, right: e.right + t, top: e.top + s, bottom: e.bottom + s };
  }
  /**
   * Returns global coordinates of the element's bounds.
   *
   * @ignore
   * @return Global bounds
   */
  globalBounds() {
    const e = this.localBounds(), t = this.toGlobal({ x: e.left, y: e.top }), s = this.toGlobal({ x: e.right, y: e.top }), r = this.toGlobal({ x: e.right, y: e.bottom }), n = this.toGlobal({ x: e.left, y: e.bottom });
    return {
      left: Math.min(t.x, s.x, r.x, n.x),
      top: Math.min(t.y, s.y, r.y, n.y),
      right: Math.max(t.x, s.x, r.x, n.x),
      bottom: Math.max(t.y, s.y, r.y, n.y)
    };
  }
  _onShow(e) {
  }
  _onHide(e) {
  }
  /**
   * Plays initial reveal animation regardless if element is currently hidden
   * or visible.
   *
   * @param   duration  Duration of the animation in milliseconds
   * @param   delay     Delay showing of the element by X milliseconds
   * @return            Promise
   */
  appear(e, t) {
    return at(this, void 0, void 0, function* () {
      return yield this.hide(0), t ? new Promise((s, r) => {
        this.setTimeout(() => {
          s(this.show(e));
        }, t);
      }) : this.show(e);
    });
  }
  /**
   * Shows currently hidden element and returns a `Promise` which completes
   * when all showing animations are finished.
   *
   * ```TypeScript
   * series.show().then(function(ev) {
   *   console.log("Series is now fully visible");
   * })
   * ```
   * ```JavaScript
   * series.show().then(function(ev) {
   *   console.log("Series is now fully visible");
   * })
   * ```
   *
   * @return Promise
   */
  show(e) {
    return at(this, void 0, void 0, function* () {
      if (!this._isShowing) {
        this._isHidden = !1, this._isShowing = !0, this._isHiding = !1, this.states.lookup("default").get("visible") && this.set("visible", !0), this._onShow(e);
        const t = this.states.applyAnimate("default", e);
        yield zu(t), this._isShowing = !1;
      }
    });
  }
  /**
   * Hides the element and returns a `Promise` which completes when all hiding
   * animations are finished.
   *
   * ```TypeScript
   * series.hide().then(function(ev) {
   *   console.log("Series finished hiding");
   * })
   * ```
   * ```JavaScript
   * series.hide().then(function(ev) {
   *   console.log("Series finished hiding");
   * })
   * ```
   *
   * @return Promise
   */
  hide(e) {
    return at(this, void 0, void 0, function* () {
      if (!this._isHiding && !this._isHidden) {
        this._isHiding = !0, this._isShowing = !1;
        let t = this.states.lookup("hidden");
        t || (t = this.states.create("hidden", {
          opacity: 0,
          visible: !1
        })), this._isHidden = !0, this._onHide(e);
        const s = this.states.applyAnimate("hidden", e);
        yield zu(s), this._isHiding = !1;
      }
    });
  }
  /**
   * Returns `true` if this element is currently hidden.
   *
   * @return Is hidden?
   */
  isHidden() {
    return this._isHidden;
  }
  /**
   * Returns `true` if this element is currently animating to a default state.
   *
   * @return Is showing?
   */
  isShowing() {
    return this._isShowing;
  }
  /**
   * Returns `true` if this element is currently animating to a hidden state.
   *
   * @return Is hiding?
   */
  isHiding() {
    return this._isHiding;
  }
  /**
   * Returns `true` if this element is currently hovered by a pointer.
   *
   * @return Is hovered?
   */
  isHover() {
    return this._display.hovering();
  }
  /**
   * Returns `true` if this element does currently have focus.
   *
   * @return Is focused?
   */
  isFocus() {
    return this._root.focused(this);
  }
  /**
   * Returns `true` if this element is currently being dragged.
   *
   * @return Is dragged?
   */
  isDragging() {
    return this._isDragging;
  }
  /**
   * Returns `false` if if either public or private setting `visible` is set
   * to `false`, or `forceHidden` is set to `true`.
   *
   * @return Visible?
   */
  isVisible() {
    return !!(this.get("visible") && this.getPrivate("visible") && !this.get("forceHidden"));
  }
  /**
   * Same as `isVisible()`, except it checks all ascendants, too.
   *
   * @since 5.2.7
   * @return Visible?
   */
  isVisibleDeep() {
    return this._parent ? this._parent.isVisibleDeep() && this.isVisible() : this.isVisible();
  }
  /**
   * Returns an actual opacity of the element, taking into account all parents.
   *
   * @return Opacity
   * @since 5.2.11
   */
  compositeOpacity() {
    const e = this.get("opacity", 1);
    return this._parent ? this._parent.compositeOpacity() * e : e;
  }
  /**
   * Returns width of this element in pixels.
   *
   * @return Width (px)
   */
  width() {
    let e = this.get("width"), t = this.get("maxWidth", this.getPrivate("maxWidth")), s = this.get("minWidth", this.getPrivate("minWidth")), r = this.getPrivate("width"), n = 0;
    if (S(r))
      n = r;
    else if (e == null)
      this._adjustedLocalBounds && (n = this._adjustedLocalBounds.right - this._adjustedLocalBounds.left);
    else if (e instanceof re) {
      const a = this.parent;
      a ? n = a.innerWidth() * e.value : n = this._root.width() * e.value;
    } else
      S(e) && (n = e);
    return S(s) && (n = Math.max(s, n)), S(t) && (n = Math.min(t, n)), n;
  }
  /**
   * Returns maximum allowed width of this element in pixels.
   *
   * @return Maximum width (px)
   */
  maxWidth() {
    let e = this.get("maxWidth", this.getPrivate("maxWidth"));
    if (S(e))
      return e;
    {
      let s = this.get("width");
      if (S(s))
        return s;
    }
    const t = this.parent;
    return t ? t.innerWidth() : this._root.width();
  }
  /**
   * Returns maximum allowed height of this element in pixels.
   *
   * @return Maximum height (px)
   */
  maxHeight() {
    let e = this.get("maxHeight", this.getPrivate("maxHeight"));
    if (S(e))
      return e;
    {
      let s = this.get("height");
      if (S(s))
        return s;
    }
    const t = this.parent;
    return t ? t.innerHeight() : this._root.height();
  }
  /**
   * Returns height of this element in pixels.
   *
   * @return Height (px)
   */
  height() {
    let e = this.get("height"), t = this.get("maxHeight", this.getPrivate("maxHeight")), s = this.get("minHeight", this.getPrivate("minHeight")), r = this.getPrivate("height"), n = 0;
    if (S(r))
      n = r;
    else if (e == null)
      this._adjustedLocalBounds && (n = this._adjustedLocalBounds.bottom - this._adjustedLocalBounds.top);
    else if (e instanceof re) {
      const a = this.parent;
      a ? n = a.innerHeight() * e.value : n = this._root.height() * e.value;
    } else
      S(e) && (n = e);
    return S(s) && (n = Math.max(s, n)), S(t) && (n = Math.min(t, n)), n;
  }
  _findStaticTemplate(e) {
    return this._templateField && e(this._templateField) ? this._templateField : super._findStaticTemplate(e);
  }
  _walkParents(e) {
    this._parent && this._walkParent(e);
  }
  _walkParent(e) {
    this._parent && this._parent._walkParent(e), e(this);
  }
  /**
   * Parent [[Container]] of this element.
   *
   * @return Parent container
   */
  get parent() {
    return this._parent;
  }
  _setParent(e, t = !1) {
    const s = this._parent;
    e !== s && (this.markDirtyBounds(), e.markDirty(), this._parent = e, t && (this._removeParent(s), e && (this._addPercentageSizeChildren(), this._addPercentagePositionChildren())), this.markDirtyPosition(), this._applyThemes());
  }
  /**
   * Returns an instance of [[NumberFormatter]] used in this element.
   *
   * If this element does not have it set, global one form [[Root]] is used.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/using-formatters/} for more info
   * @return NumberFormatter instace
   */
  getNumberFormatter() {
    return this.get("numberFormatter", this._root.numberFormatter);
  }
  /**
   * Returns an instance of [[DateFormatter]] used in this element.
   *
   * If this element does not have it set, global one form [[Root]] is used.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/using-formatters/} for more info
   * @return DateFormatter instace
   */
  getDateFormatter() {
    return this.get("dateFormatter", this._root.dateFormatter);
  }
  /**
   * Returns an instance of [[DurationFormatter]] used in this element.
   *
   * If this element does not have it set, global one form [[Root]] is used.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/using-formatters/} for more info
   * @return DurationFormatter instace
   */
  getDurationFormatter() {
    return this.get("durationFormatter", this._root.durationFormatter);
  }
  /**
   * Converts X/Y coordinate within this element to a global coordinate.
   *
   * @param  point  Local coordinate
   * @return        Global coordinate
   */
  toGlobal(e) {
    return this._display.toGlobal(e);
  }
  /**
   * Converts global X/Y coordinate to a coordinate within this element.
   *
   * @param  point  Global coordinate
   * @return        Local coordinate
   */
  toLocal(e) {
    return this._display.toLocal(e);
  }
  _getDownPoint() {
    const e = this._getDownPointId();
    if (e)
      return this._downPoints[e];
  }
  _getDownPointId() {
    if (this._downPoints)
      return fu(this._downPoints, (e, t) => e > t ? 1 : e < t ? -1 : 0)[0];
  }
  /**
   * Moves sprite to the end of the parent's children array.
   *
   * Depending on `layout` setting of the parten container, it may effect the
   * positioning or overlapping order of the elements.
   */
  toFront() {
    const e = this.parent;
    e && e.children.moveValue(this, e.children.length - 1);
  }
  /**
   * Moves sprite to the beginning of the parent's children array.
   *
   * Depending on `layout` setting of the parten container, it may effect the
   * positioning or overlapping order of the elements.
   */
  toBack() {
    const e = this.parent;
    e && e.children.moveValue(this, 0);
  }
}
Object.defineProperty(vt, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Sprite"
});
Object.defineProperty(vt, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Se.classNames.concat([vt.className])
});
class xt extends Se {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_display", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._root._renderer.makeGraphics()
    }), Object.defineProperty(this, "_backgroundDisplay", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._root._renderer.makeGraphics()
    }), Object.defineProperty(this, "_clear", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_pattern", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  _afterNew() {
    super._afterNewApplyThemes();
  }
  get pattern() {
    return this._pattern;
  }
  _draw() {
  }
  _beforeChanged() {
    super._beforeChanged(), (this.isDirty("repetition") || this.isDirty("width") || this.isDirty("height") || this.isDirty("rotation") || this.isDirty("color") || this.isDirty("strokeWidth") || this.isDirty("strokeDasharray") || this.isDirty("strokeDashoffset") || this.isDirty("colorOpacity") || this.isDirty("fill") || this.isDirty("fillOpacity")) && (this._clear = !0);
  }
  _changed() {
    if (super._changed(), this._clear) {
      const e = this.get("repetition", ""), t = this.get("width", 100), s = this.get("height", 100), r = this.get("fill"), n = this.get("fillOpacity", 1);
      this._display.clear(), this._backgroundDisplay.clear(), r && n > 0 && (this._backgroundDisplay.beginFill(r, n), this._backgroundDisplay.drawRect(0, 0, t, s), this._backgroundDisplay.endFill()), this._display.angle = this.get("rotation", 0), this._draw(), this._pattern = this._root._renderer.createPattern(this._display, this._backgroundDisplay, e, t, s);
    }
  }
}
Object.defineProperty(xt, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Pattern"
});
Object.defineProperty(xt, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Se.classNames.concat([xt.className])
});
class Xs extends xt {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_image", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  _beforeChanged() {
    super._beforeChanged(), this._clear = !0, this.isDirty("src") && this._load();
  }
  _draw() {
    super._draw();
    const e = this._image;
    if (e) {
      const t = this.get("width", 100), s = this.get("height", 100), r = this.get("fit", "image");
      let n = 0, a = 0;
      r == "pattern" ? (n = t, a = s) : (n = e.width, a = e.height, r == "image" && (this.set("width", n), this.set("height", a)));
      const o = this.get("centered", !0);
      let l = 0, u = 0;
      o && (l = t / 2 - n / 2, u = s / 2 - a / 2), this._display.image(e, n, a, l, u);
    }
  }
  _load() {
    const e = this.get("src");
    if (e) {
      const t = new Image();
      t.src = e, t.decode().then(() => {
        this._image = t, this._draw(), this.events.isEnabled("loaded") && this.events.dispatch("loaded", { type: "loaded", target: this });
      }).catch((s) => {
      });
    }
  }
}
Object.defineProperty(Xs, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "PicturePattern"
});
Object.defineProperty(Xs, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: xt.classNames.concat([Xs.className])
});
var ea;
(function(i) {
  i.ADD = "lighter", i.COLOR = "color", i.COLOR_BURN = "color-burn", i.COLOR_DODGE = "color-dodge", i.DARKEN = "darken", i.DIFFERENCE = "difference", i.DST_OVER = "destination-over", i.EXCLUSION = "exclusion", i.HARD_LIGHT = "hard-light", i.HUE = "hue", i.LIGHTEN = "lighten", i.LUMINOSITY = "luminosity", i.MULTIPLY = "multiply", i.NORMAL = "source-over", i.OVERLAY = "overlay", i.SATURATION = "saturation", i.SCREEN = "screen", i.SOFT_LIGHT = "soft-light", i.SRC_ATOP = "source-atop", i.XOR = "xor";
})(ea || (ea = {}));
const H0 = ["fill", "fillOpacity", "stroke", "strokeWidth", "strokeOpacity", "fillPattern", "strokePattern", "fillGradient", "strokeGradient", "strokeDasharray", "strokeDashoffset"];
class le extends vt {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_display", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._root._renderer.makeGraphics()
    }), Object.defineProperty(this, "_clear", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    });
  }
  _beforeChanged() {
    if (super._beforeChanged(), (this.isDirty("draw") || this.isDirty("svgPath")) && this.markDirtyBounds(), (this.isDirty("fill") || this.isDirty("stroke") || this.isDirty("visible") || this.isDirty("forceHidden") || this.isDirty("scale") || this.isDirty("fillGradient") || this.isDirty("strokeGradient") || this.isDirty("fillPattern") || this.isDirty("strokePattern") || this.isDirty("fillOpacity") || this.isDirty("strokeOpacity") || this.isDirty("strokeWidth") || this.isDirty("draw") || this.isDirty("blendMode") || this.isDirty("strokeDasharray") || this.isDirty("strokeDashoffset") || this.isDirty("svgPath") || this.isDirty("lineJoin") || this.isDirty("shadowColor") || this.isDirty("shadowBlur") || this.isDirty("shadowOffsetX") || this.isDirty("shadowOffsetY")) && (this._clear = !0), this._display.crisp = this.get("crisp", !1), this.isDirty("fillGradient")) {
      const e = this.get("fillGradient");
      if (e) {
        this._display.isMeasured = !0;
        const t = e.get("target");
        t && (this._disposers.push(t.events.on("boundschanged", () => {
          this._markDirtyKey("fill");
        })), this._disposers.push(t.events.on("positionchanged", () => {
          this._markDirtyKey("fill");
        })));
      }
    }
    if (this.isDirty("strokeGradient")) {
      const e = this.get("strokeGradient");
      if (e) {
        this._display.isMeasured = !0;
        const t = e.get("target");
        t && (this._disposers.push(t.events.on("boundschanged", () => {
          this._markDirtyKey("stroke");
        })), this._disposers.push(t.events.on("positionchanged", () => {
          this._markDirtyKey("stroke");
        })));
      }
    }
  }
  _changed() {
    if (super._changed(), this._clear) {
      this.markDirtyBounds(), this.markDirtyLayer(), this._display.clear();
      let e = this.get("strokeDasharray");
      S(e) && (e < 0.5 ? e = [0] : e = [e]), this._display.setLineDash(e);
      const t = this.get("strokeDashoffset");
      t && this._display.setLineDashOffset(t);
      const s = this.get("blendMode", ea.NORMAL);
      this._display.blendMode = s;
      const r = this.get("draw");
      r && r(this._display, this);
      const n = this.get("svgPath");
      n != null && this._display.svgPath(n);
    }
  }
  _afterChanged() {
    if (super._afterChanged(), this._clear) {
      const e = this.get("fill"), t = this.get("fillGradient"), s = this.get("fillPattern"), r = this.get("fillOpacity"), n = this.get("stroke"), a = this.get("strokeGradient"), o = this.get("strokePattern"), l = this.get("shadowColor"), u = this.get("shadowBlur"), c = this.get("shadowOffsetX"), h = this.get("shadowOffsetY"), d = this.get("shadowOpacity");
      if (l && (u || c || h) && this._display.shadow(l, u, c, h, d), s) {
        let f = !1;
        e && (!s.get("fill") || s.get("fillInherited")) && (s.set("fill", e), s.set("fillInherited", !0), f = !0), n && (!s.get("color") || s.get("colorInherited")) && (s.set("color", n), s.set("colorInherited", !0), f = !0), f && s._changed();
        const g = s.pattern;
        g && (this._display.beginFill(g, r), this._display.endFill(), s instanceof Xs && s.events.once("loaded", () => {
          this._clear = !0, this.markDirty();
        }));
      } else if (t) {
        if (e) {
          const g = t.get("stops", []);
          g.length && w(g, (p) => {
            (!p.color || p.colorInherited) && e && (p.color = e, p.colorInherited = !0), (p.opacity == null || p.opacityInherited) && (p.opacity = r, p.opacityInherited = !0);
          });
        }
        const f = t.getFill(this);
        f && (this._display.beginFill(f, r), this._display.endFill());
      } else
        e && (this._display.beginFill(e, r), this._display.endFill());
      if (n || a || o) {
        const f = this.get("strokeOpacity");
        let g = this.get("strokeWidth", 1);
        this.get("nonScalingStroke") && (g = g / this.get("scale", 1)), this.get("crisp") && (g /= this._root._renderer.resolution);
        const p = this.get("lineJoin");
        if (o) {
          let _ = !1;
          n && (!o.get("color") || o.get("colorInherited")) && (o.set("color", n), o.set("colorInherited", !0), _ = !0), _ && o._changed();
          const m = o.pattern;
          m && (this._display.lineStyle(g, m, f, p), this._display.endStroke(), o instanceof Xs && o.events.once("loaded", () => {
            this._clear = !0, this.markDirty();
          }));
        } else if (a) {
          const _ = a.get("stops", []);
          _.length && w(_, (v) => {
            (!v.color || v.colorInherited) && n && (v.color = n, v.colorInherited = !0), (v.opacity == null || v.opacityInherited) && (v.opacity = f, v.opacityInherited = !0);
          });
          const m = a.getFill(this);
          m && (this._display.lineStyle(g, m, f, p), this._display.endStroke());
        } else
          n && (this._display.lineStyle(g, n, f, p), this._display.endStroke());
      }
    }
    this._clear = !1;
  }
}
Object.defineProperty(le, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Graphics"
});
Object.defineProperty(le, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: vt.classNames.concat([le.className])
});
class pt extends le {
  _beforeChanged() {
    super._beforeChanged(), (this.isDirty("width") || this.isDirty("height") || this.isPrivateDirty("width") || this.isPrivateDirty("height")) && (this._clear = !0);
  }
  _changed() {
    super._changed(), this._clear && !this.get("draw") && this._draw();
  }
  _draw() {
    this._display.drawRect(0, 0, this.width(), this.height());
  }
  _updateSize() {
    this.markDirty(), this._clear = !0;
  }
}
Object.defineProperty(pt, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Rectangle"
});
Object.defineProperty(pt, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: le.classNames.concat([pt.className])
});
function ci(i, e) {
  i.get("reverseChildren", !1) ? i.children.eachReverse(e) : i.children.each(e);
}
class si extends Se {
}
Object.defineProperty(si, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Layout"
});
Object.defineProperty(si, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Se.classNames.concat([si.className])
});
class gs extends si {
  /**
   * @ignore
   */
  updateContainer(e) {
    let t = e.get("paddingLeft", 0), s = e.innerWidth(), r = 0;
    ci(e, (a) => {
      if (a.isVisible() && a.get("position") == "relative") {
        let o = a.get("width");
        if (o instanceof re) {
          r += o.value;
          let l = s * o.value, u = a.get("minWidth", a.getPrivate("minWidth", -1 / 0));
          u > l && (s -= u, r -= o.value);
          let c = a.get("maxWidth", a.getPrivate("maxWidth", 1 / 0));
          l > c && (s -= c, r -= o.value);
        } else
          S(o) || (o = a.width()), s -= o + a.get("marginLeft", 0) + a.get("marginRight", 0);
      }
    }), (s <= 0 || s == 1 / 0) && (s = 0.1), ci(e, (a) => {
      if (a.isVisible() && a.get("position") == "relative") {
        let o = a.get("width");
        if (o instanceof re) {
          let l = s * o.value / r - a.get("marginLeft", 0) - a.get("marginRight", 0), u = a.get("minWidth", a.getPrivate("minWidth", -1 / 0)), c = a.get("maxWidth", a.getPrivate("maxWidth", 1 / 0));
          l = Math.min(Math.max(u, l), c), a.setPrivate("width", l);
        }
      }
    });
    let n = t;
    ci(e, (a) => {
      if (a.get("position") == "relative")
        if (a.isVisible()) {
          let o = a.adjustedLocalBounds(), l = a.get("marginLeft", 0), u = a.get("marginRight", 0), c = a.get("maxWidth"), h = o.left, d = o.right;
          c && d - h > c && (d = h + c);
          let f = n + l - h;
          a.setPrivate("x", f), n = f + d + u;
        } else
          a.setPrivate("x", void 0);
    });
  }
}
Object.defineProperty(gs, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "HorizontalLayout"
});
Object.defineProperty(gs, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: si.classNames.concat([gs.className])
});
class _s extends si {
  /**
   * @ignore
   */
  updateContainer(e) {
    let t = e.get("paddingTop", 0), s = e.innerHeight(), r = 0;
    ci(e, (a) => {
      if (a.isVisible() && a.get("position") == "relative") {
        let o = a.get("height");
        if (o instanceof re) {
          r += o.value;
          let l = s * o.value, u = a.get("minHeight", a.getPrivate("minHeight", -1 / 0));
          u > l && (s -= u, r -= o.value);
          let c = a.get("maxHeight", a.getPrivate("maxHeight", 1 / 0));
          l > c && (s -= c, r -= o.value);
        } else
          S(o) || (o = a.height()), s -= o + a.get("marginTop", 0) + a.get("marginBottom", 0);
      }
    }), (s <= 0 || s == 1 / 0) && (s = 0.1), ci(e, (a) => {
      if (a.isVisible() && a.get("position") == "relative") {
        let o = a.get("height");
        if (o instanceof re) {
          let l = s * o.value / r - a.get("marginTop", 0) - a.get("marginBottom", 0), u = a.get("minHeight", a.getPrivate("minHeight", -1 / 0)), c = a.get("maxHeight", a.getPrivate("maxHeight", 1 / 0));
          l = Math.min(Math.max(u, l), c), a.setPrivate("height", l);
        }
      }
    });
    let n = t;
    ci(e, (a) => {
      if (a.get("position") == "relative")
        if (a.isVisible()) {
          let o = a.adjustedLocalBounds(), l = a.get("marginTop", 0), u = o.top, c = o.bottom, h = a.get("maxHeight");
          h && c - u > h && (c = u + h);
          let d = a.get("marginBottom", 0), f = n + l - u;
          a.setPrivate("y", f), n = f + c + d;
        } else
          a.setPrivate("y", void 0);
    });
  }
}
Object.defineProperty(_s, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "VerticalLayout"
});
Object.defineProperty(_s, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: si.classNames.concat([_s.className])
});
class gi extends si {
  _afterNew() {
    this._setRawDefault("maxColumns", Number.MAX_VALUE), super._afterNew();
  }
  /**
   * @ignore
   */
  updateContainer(e) {
    let t = e.get("paddingLeft", 0), s = e.get("paddingRight", 0), r = e.get("paddingTop", 0), n = e.maxWidth() - t - s, a = n, o = 1;
    ci(e, (g) => {
      if (g.get("visible") && g.getPrivate("visible") && !g.get("forceHidden") && g.get("position") != "absolute") {
        let p = g.width();
        p < a && (a = p), p > o && (o = p);
      }
    }), a = Ie(a, 1, n), o = Ie(o, 1, n);
    let l = 1;
    this.get("fixedWidthGrid") ? l = n / o : l = n / a, l = Math.max(1, Math.floor(l)), l = Math.min(this.get("maxColumns", Number.MAX_VALUE), l);
    let u = this.getColumnWidths(e, l, o, n), c = r, h = 0, d = 0;
    l = u.length;
    let f = t;
    ci(e, (g) => {
      if (g.get("position") == "relative" && g.isVisible()) {
        const p = g.get("marginTop", 0), _ = g.get("marginBottom", 0);
        let m = g.adjustedLocalBounds(), v = g.get("marginLeft", 0), b = g.get("marginRight", 0), y = f + v - m.left, x = c + p - m.top;
        g.setPrivate("x", y), g.setPrivate("y", x), f += u[h] + b, d = Math.max(d, g.height() + p + _), h++, h >= l && (h = 0, f = t, c += d);
      }
    });
  }
  /**
   * @ignore
   */
  getColumnWidths(e, t, s, r) {
    let n = 0, a = [], o = 0;
    return ci(e, (l) => {
      let u = l.adjustedLocalBounds();
      l.get("position") != "absolute" && l.isVisible() && (this.get("fixedWidthGrid") ? a[o] = s : a[o] = Math.max(a[o] | 0, u.right - u.left + l.get("marginLeft", 0) + l.get("marginRight", 0)), o < e.children.length - 1 && (o++, o == t && (o = 0)));
    }), w(a, (l) => {
      n += l;
    }), n > r ? t > 2 ? (t -= 1, this.getColumnWidths(e, t, s, r)) : [r] : a;
  }
}
Object.defineProperty(gi, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "GridLayout"
});
Object.defineProperty(gi, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: si.classNames.concat([gi.className])
});
class Nt {
  /**
   * Replaces brackets with temporary placeholders.
   *
   * @ignore Exclude from docs
   * @param text  Input text
   * @return Escaped text
   */
  static escape(e) {
    return e.replace(/\[\[/g, this.prefix + "1").replace(/([^\/\]]{1})\]\]/g, "$1" + this.prefix + "2").replace(/\]\]/g, this.prefix + "2").replace(/\{\{/g, this.prefix + "3").replace(/\}\}/g, this.prefix + "4").replace(/\'\'/g, this.prefix + "5");
  }
  /**
   * Replaces placeholders back to brackets.
   *
   * @ignore Exclude from docs
   * @param text  Escaped text
   * @return Unescaped text
   */
  static unescape(e) {
    return e.replace(new RegExp(this.prefix + "1", "g"), "[[").replace(new RegExp(this.prefix + "2", "g"), "]]").replace(new RegExp(this.prefix + "3", "g"), "{{").replace(new RegExp(this.prefix + "4", "g"), "}}").replace(new RegExp(this.prefix + "5", "g"), "''");
  }
  /**
   * Cleans up the text text for leftover double square brackets.
   *
   * @ignore Exclude from docs
   * @param text  Input text
   * @return Cleaned up text
   */
  static cleanUp(e) {
    return e.replace(/\[\[/g, "[").replace(/\]\]/g, "]").replace(/\{\{/g, "{").replace(/\}\}/g, "}").replace(/\'\'/g, "'");
  }
  /**
   * Splits string into chunks. (style blocks, quoted blocks, regular blocks)
   *
   * If the second parameter `quotedBlocks` is set to `true` this method will
   * also single out text blocks enclosed within single quotes that no
   * formatting should be applied to, and they should be displayed as is.
   *
   * Default for the above is `false`, so that you can use single quote in text
   * without escaping it.
   *
   * If enabled, single quotes can be escaped by doubling it - adding two
   * single quotes, which will be replaced by a one single quote in the final
   * output.
   *
   * @ignore Exclude from docs
   * @param text          Text to chunk
   * @param quotedBlocks  Use quoted blocks
   * @param noFormatting  Formatting blocks will be treated as regular text
   * @return Array of string chunks
   */
  static chunk(e, t = !1, s = !1) {
    let r = [];
    e = this.escape(e);
    let n = t ? e.split("'") : [e];
    for (let a = 0; a < n.length; a++) {
      let o = n[a];
      if (o !== "")
        if (a % 2 === 0) {
          o = o.replace(/\]\[/g, "]" + pi + "["), o = o.replace(/\[\]/g, "[ ]");
          let l = o.split(/[\[\]]+/);
          for (let u = 0; u < l.length; u++) {
            let c = this.cleanUp(this.unescape(l[u]));
            c !== pi && c !== "" && (u % 2 === 0 ? r.push({
              type: "value",
              text: c
            }) : r.push({
              type: s ? "value" : "format",
              text: "[" + c + "]"
            }));
          }
        } else {
          let l = o.split(/[\[\]]+/);
          for (let u = 0; u < l.length; u++) {
            let c = this.cleanUp(this.unescape(l[u]));
            c !== "" && (u % 2 === 0 ? r.push({
              type: "text",
              text: c
            }) : this.isImage(c) ? r.push({
              type: "image",
              text: "[" + c + "]"
            }) : r.push({
              type: "format",
              text: "[" + c + "]"
            }));
          }
        }
    }
    return r;
  }
  /**
   * Checks if supplied format contains image information and should be
   * formatted as such.
   * I.e.: `[img: myImage.png]`
   *
   * @ignore
   * @param  text  Format
   * @return true if it is an image
   */
  static isImage(e) {
    return !!e.match(/img[ ]?:/);
  }
  static getTextStyle(e) {
    let t = {};
    if (e == "" || e == "[ ]")
      return {};
    const s = e.match(/('[^']*')|("[^"]*")/gi);
    if (s)
      for (let n = 0; n < s.length; n++)
        e = e.replace(s[n], s[n].replace(/['"]*/g, "").replace(/[ ]+/g, "+"));
    let r = e.match(/([\w\-]*:[\s]?[^;\s\]]*)|(\#[\w]{1,6})|([\w\-]+)|(\/)/gi);
    if (!r)
      return {};
    for (let n = 0; n < r.length; n++)
      if (r[n].match(/^(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900)$/i))
        t.fontWeight = r[n];
      else if (r[n].match(/^(underline|line-through)$/i))
        t.textDecoration = r[n];
      else if (r[n] != "/")
        if (!r[n].match(/:/))
          t.fill = X.fromString(r[n]);
        else {
          const a = r[n].replace("+", " ").split(/:[ ]*/);
          t[a[0]] = a[1];
        }
    return t;
  }
}
Object.defineProperty(Nt, "prefix", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "__amcharts__"
});
function $r(i, e) {
  if (e != null) {
    e = "" + e, e = Nt.escape(e);
    let t = e.match(/\{([^}]+)\}/g), s;
    if (t)
      for (s = 0; s < t.length; s++) {
        let r = t[s].replace(/\{([^}]+)\}/, "$1"), n = nl(i, r);
        n == null && (n = ""), e = e.split(t[s]).join(n);
      }
    e = Nt.unescape(e);
  } else
    e = "";
  return e;
}
function nl(i, e, t) {
  let s;
  const r = i.dataItem;
  let n = [], a = /([^.]+)\(([^)]*)\)|([^.]+)/g, o;
  for (; o = a.exec(e), o !== null; )
    if (o[3]) {
      n.push({
        prop: o[3]
      });
      const l = i.getDateFormatter().get("dateFields", []), u = i.getNumberFormatter().get("numericFields", []), c = i.getDurationFormatter().get("durationFields", []);
      l.indexOf(o[3]) !== -1 ? n.push({
        method: "formatDate",
        params: []
      }) : u.indexOf(o[3]) !== -1 ? n.push({
        method: "formatNumber",
        params: []
      }) : c.indexOf(o[3]) !== -1 && n.push({
        method: "formatDuration",
        params: []
      });
    } else {
      let l = [];
      if (Mr(o[2]) != "") {
        let u = /'([^']*)'|"([^"]*)"|([0-9\-]+)/g, c;
        for (; c = u.exec(o[2]), c !== null; )
          l.push(c[1] || c[2] || c[3]);
      }
      n.push({
        method: o[1],
        params: l
      });
    }
  if (r) {
    s = ss(i, n, r._settings), (s == null || ys(s)) && (s = ss(i, n, r));
    let l = r.dataContext;
    s == null && l && (s = ss(i, n, l), s == null && (s = ss(i, [{
      prop: e
    }], l)), s == null && l.dataContext && (s = ss(i, n, l.dataContext))), s == null && r.component && r.component.dataItem !== r && (s = nl(r.component, e));
  }
  return s == null && (s = ss(i, n, i)), s == null && i.parent && (s = nl(i.parent, e)), s;
}
function z0(i, e) {
  const t = i.getPrivate("customData");
  if (ys(t))
    return t[e];
}
function ss(i, e, t, s) {
  let r = t, n = !1;
  for (let a = 0, o = e.length; a < o; a++) {
    let l = e[a];
    if (l.prop) {
      if (r instanceof vt) {
        let u = r.get(l.prop);
        u == null && (u = r.getPrivate(l.prop)), u == null && (u = z0(r, l.prop)), u == null && (u = r[l.prop]), r = u;
      } else if (r.get) {
        let u = r.get(l.prop);
        u == null && (u = r[l.prop]), r = u;
      } else
        r = r[l.prop];
      if (r == null)
        return;
    } else
      switch (l.method) {
        case "formatNumber":
          let u = dt(r);
          u != null && (r = i.getNumberFormatter().format(u, s || l.params[0] || void 0), n = !0);
          break;
        case "formatDate":
          let c = Lc(r);
          if (!Vn(c) || $t(c.getTime()))
            return;
          c != null && (r = i.getDateFormatter().format(c, s || l.params[0] || void 0), n = !0);
          break;
        case "formatDuration":
          let h = dt(r);
          h != null && (r = i.getDurationFormatter().format(h, s || l.params[0] || void 0, l.params[1] || void 0), n = !0);
          break;
        case "urlEncode":
        case "encodeURIComponent":
          r = encodeURIComponent(r);
          break;
        default:
          r[l.method] && r[l.method].apply(t, l.params);
          break;
      }
  }
  if (!n) {
    let a = [{
      method: "",
      params: s
    }];
    if (s == null)
      S(r) ? (a[0].method = "formatNumber", a[0].params = "") : Vn(r) && (a[0].method = "formatDate", a[0].params = "");
    else {
      let o = td(s);
      o === "number" ? a[0].method = "formatNumber" : o === "date" ? a[0].method = "formatDate" : o === "duration" && (a[0].method = "formatDuration");
    }
    a[0].method && (r = ss(i, a, r));
  }
  return r;
}
class Z extends vt {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_display", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._root._renderer.makeContainer()
    }), Object.defineProperty(this, "_childrenDisplay", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._root._renderer.makeContainer()
    }), Object.defineProperty(this, "children", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new Yx(this)
    }), Object.defineProperty(this, "_percentageSizeChildren", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_percentagePositionChildren", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_prevWidth", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_prevHeight", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_contentWidth", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_contentHeight", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_contentMask", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_vsbd0", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_vsbd1", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  _afterNew() {
    super._afterNew(), this._display.addChild(this._childrenDisplay);
  }
  _dispose() {
    Rs(this.allChildren(), (e) => {
      e.dispose();
    }), this.getPrivate("htmlElement") && this._root._removeHTMLContent(this), super._dispose();
  }
  _changed() {
    if (super._changed(), this.isDirty("interactiveChildren") && (this._display.interactiveChildren = this.get("interactiveChildren", !1)), this.isDirty("layout") && (this._prevWidth = 0, this._prevHeight = 0, this.markDirtyBounds(), this._prevSettings.layout && this.children.each((e) => {
      e.removePrivate("x"), e.removePrivate("y");
    })), (this.isDirty("paddingTop") || this.isDirty("paddingBottom") || this.isDirty("paddingLeft") || this.isDirty("paddingRight")) && this.children.each((e) => {
      e.markDirtyPosition();
    }), this.isDirty("maskContent")) {
      const e = this._childrenDisplay;
      let t = this._contentMask;
      this.get("maskContent") ? t || (t = pt.new(this._root, {
        x: -0.5,
        y: -0.5,
        width: this.width() + 1,
        height: this.height() + 1
      }), this._contentMask = t, e.addChildAt(t._display, 0), e.mask = t._display) : t && (e.removeChild(t._display), e.mask = null, t.dispose(), this._contentMask = void 0);
    }
  }
  _updateSize() {
    super._updateSize(), w(this._percentageSizeChildren, (e) => {
      e._updateSize();
    }), w(this._percentagePositionChildren, (e) => {
      e.markDirtyPosition(), e._updateSize();
    }), this.updateBackground();
  }
  updateBackground() {
    const e = this.get("background");
    let t = this._localBounds;
    if (t && !this.isHidden()) {
      let s = t.left, r = t.top, n = t.right - s, a = t.bottom - r, o = this.get("maxWidth"), l = this.get("maxHeight");
      l && a > l && (a = l), o && n > o && (n = o);
      let u = this.width(), c = this.height();
      e && (e.setAll({ width: n, height: a, x: s, y: r }), this._display.interactive && (e._display.interactive = !0));
      const h = this._contentMask;
      h && h.setAll({ width: u + 1, height: c + 1 });
      const d = this.get("verticalScrollbar");
      if (d) {
        d.set("height", c), d.set("x", u - d.width() - d.get("marginRight", 0)), d.set("end", d.get("start", 0) + c / this._contentHeight);
        const f = d.get("background");
        f && f.setAll({ width: d.width(), height: c });
        let g = !0;
        this._contentHeight <= c && (g = !1), d.setPrivate("visible", g);
      }
    }
  }
  _applyThemes() {
    return super._applyThemes() ? (this.eachChildren((e) => {
      e._applyThemes();
    }), !0) : !1;
  }
  _applyState(e) {
    super._applyState(e), this.get("setStateOnChildren") && this.eachChildren((t) => {
      t.states.apply(e);
    });
  }
  _applyStateAnimated(e, t) {
    super._applyStateAnimated(e, t), this.get("setStateOnChildren") && this.eachChildren((s) => {
      s.states.applyAnimate(e, t);
    });
  }
  /**
   * Returns container's inner width (width without padding) in pixels.
   *
   * @return Inner width (px)
   */
  innerWidth() {
    return this.width() - this.get("paddingRight", 0) - this.get("paddingLeft", 0);
  }
  /**
   * Returns container's inner height (height without padding) in pixels.
   *
   * @return Inner height (px)
   */
  innerHeight() {
    return this.height() - this.get("paddingTop", 0) - this.get("paddingBottom", 0);
  }
  _getBounds() {
    let e = this.get("width"), t = this.get("height"), s = this.getPrivate("width"), r = this.getPrivate("height"), n = {
      left: 0,
      top: 0,
      right: this.width(),
      bottom: this.height()
    }, a = this.get("layout"), o = !1, l = !1;
    if ((a instanceof gs || a instanceof gi) && (o = !0), a instanceof _s && (l = !0), !((e != null || s != null) && (t != null || r != null) && !this.get("verticalScrollbar"))) {
      let u = Number.MAX_VALUE, c = u, h = -u, d = u, f = -u;
      const g = this.get("paddingLeft", 0), p = this.get("paddingTop", 0), _ = this.get("paddingRight", 0), m = this.get("paddingBottom", 0);
      this.children.each((v) => {
        if (v.get("position") != "absolute" && v.get("isMeasured")) {
          let b = v.adjustedLocalBounds(), y = v.x(), x = v.y(), D = y + b.left, A = y + b.right, T = x + b.top, j = x + b.bottom;
          o && (D -= v.get("marginLeft", 0), A += v.get("marginRight", 0)), l && (T -= v.get("marginTop", 0), j += v.get("marginBottom", 0)), D < c && (c = D), A > h && (h = A), T < d && (d = T), j > f && (f = j);
        }
      }), c == u && (c = 0), h == -u && (h = 0), d == u && (d = 0), f == -u && (f = 0), n.left = c - g, n.top = d - p, n.right = h + _, n.bottom = f + m;
    }
    this._contentWidth = n.right - n.left, this._contentHeight = n.bottom - n.top, S(e) && (n.left = 0, n.right = e), S(s) && (n.left = 0, n.right = s), S(t) && (n.top = 0, n.bottom = t), S(r) && (n.top = 0, n.bottom = r), this._localBounds = n;
  }
  _updateBounds() {
    const e = this.get("layout");
    e && e.updateContainer(this), super._updateBounds(), this.updateBackground();
  }
  /**
   * @ignore
   */
  markDirty() {
    super.markDirty(), this._root._addDirtyParent(this);
  }
  _prepareChildren() {
    const e = this.innerWidth(), t = this.innerHeight();
    if (e != this._prevWidth || t != this._prevHeight) {
      let s = this.get("layout"), r = !1, n = !1;
      s && ((s instanceof gs || s instanceof gi) && (r = !0), s instanceof _s && (n = !0)), w(this._percentageSizeChildren, (a) => {
        if (!r) {
          let o = a.get("width");
          o instanceof re && a.setPrivate("width", o.value * e);
        }
        if (!n) {
          let o = a.get("height");
          o instanceof re && a.setPrivate("height", o.value * t);
        }
      }), w(this._percentagePositionChildren, (a) => {
        a.markDirtyPosition(), a.markDirtyBounds();
      }), this._prevWidth = e, this._prevHeight = t, this._sizeDirty = !0, this.updateBackground();
    }
    this._handleStates();
  }
  _updateChildren() {
    if (this.isDirty("html")) {
      const t = this.get("html");
      t && t !== "" ? this._root._setHTMLContent(this, $r(this, this.get("html", ""))) : this._root._removeHTMLContent(this), this._root._positionHTMLElement(this);
    }
    if (this.isDirty("verticalScrollbar")) {
      const t = this.get("verticalScrollbar");
      if (t) {
        t._setParent(this), t.children.removeValue(t.startGrip), t.children.removeValue(t.endGrip), this.set("maskContent", !0), this.set("paddingRight", t.width() + t.get("marginRight", 0) + t.get("marginLeft", 0));
        let s = this.get("background");
        s || (s = this.set("background", pt.new(this._root, {
          themeTags: ["background"],
          fillOpacity: 0,
          fill: this._root.interfaceColors.get("alternativeBackground")
        }))), this._vsbd0 = this.events.on("wheel", (r) => {
          const n = r.originalEvent;
          if (Wa(n, this))
            n.preventDefault();
          else
            return;
          let a = n.deltaY / 5e3;
          const o = t.get("start", 0), l = t.get("end", 1);
          o + a <= 0 && (a = -o), l + a >= 1 && (a = 1 - l), o + a >= 0 && l + a <= 1 && (t.set("start", o + a), t.set("end", l + a));
        }), this._disposers.push(this._vsbd0), this._vsbd1 = t.events.on("rangechanged", () => {
          let r = this._contentHeight;
          const n = this._childrenDisplay, a = this._contentMask;
          n.y = -t.get("start") * r, n.markDirtyLayer(), a && (a._display.y = -n.y, n.mask = a._display);
        }), this._disposers.push(this._vsbd1), this._display.addChild(t._display);
      } else {
        const s = this._prevSettings.verticalScrollbar;
        if (s) {
          this._display.removeChild(s._display), this._vsbd0 && this._vsbd0.dispose(), this._vsbd1 && this._vsbd1.dispose();
          const r = this._childrenDisplay;
          r.y = 0, this.setPrivate("height", void 0), this.set("maskContent", !1), this.set("paddingRight", void 0);
        }
      }
    }
    if (this.isDirty("background")) {
      const t = this._prevSettings.background;
      t && this._display.removeChild(t._display);
      const s = this.get("background");
      s instanceof vt && (s.set("isMeasured", !1), s._setParent(this), this._display.addChildAt(s._display, 0));
    }
    if (this.isDirty("mask")) {
      const t = this.get("mask"), s = this._prevSettings.mask;
      if (s && (this._display.removeChild(s._display), s != t && s.dispose()), t) {
        var e = t.parent;
        e && e.children.removeValue(t), t._setParent(this), this._display.addChildAt(t._display, 0), this._childrenDisplay.mask = t._display;
      }
    }
  }
  _processTemplateField() {
    super._processTemplateField(), this.children.each((e) => {
      e._processTemplateField();
    });
  }
  /**
   * @ignore
   */
  walkChildren(e) {
    this.children.each((t) => {
      t instanceof Z && t.walkChildren(e), e(t);
    });
  }
  eachChildren(e) {
    const t = this.get("background");
    t && e(t);
    const s = this.get("verticalScrollbar");
    s && e(s);
    const r = this.get("mask");
    r && e(r), this.children.values.forEach((n) => {
      e(n);
    });
  }
  allChildren() {
    const e = [];
    return this.eachChildren((t) => {
      e.push(t);
    }), e;
  }
  _setDataItem(e) {
    const t = e !== this._dataItem;
    super._setDataItem(e);
    const s = this.get("html", "");
    s && s !== "" && t && this._root._setHTMLContent(this, $r(this, s));
  }
}
Object.defineProperty(Z, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Container"
});
Object.defineProperty(Z, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: vt.classNames.concat([Z.className])
});
class Ri extends vt {
  constructor() {
    super(...arguments), Object.defineProperty(this, "textStyle", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._root._renderer.makeTextStyle()
    }), Object.defineProperty(this, "_display", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._root._renderer.makeText("", this.textStyle)
    }), Object.defineProperty(this, "_textStyles", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: [
        "textAlign",
        "fontFamily",
        "fontSize",
        "fontStyle",
        "fontWeight",
        "fontStyle",
        "fontVariant",
        "textDecoration",
        "shadowColor",
        "shadowBlur",
        "shadowOffsetX",
        "shadowOffsetY",
        "shadowOpacity",
        // "leading",
        // "letterSpacing",
        "lineHeight",
        "baselineRatio",
        //"padding",
        // "stroke",
        // "strokeThickness",
        // "trim",
        // "wordWrap",
        "direction",
        "textBaseline",
        "oversizedBehavior",
        "breakWords",
        "ellipsis",
        "minScale"
      ]
    }), Object.defineProperty(this, "_originalScale", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  _updateBounds() {
    if (this.get("text"))
      super._updateBounds();
    else {
      let e = {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
      };
      this._adjustedLocalBounds = e;
    }
  }
  _changed() {
    super._changed(), this._display.clear();
    let e = this.textStyle;
    if (this.isDirty("opacity")) {
      let t = this.get("opacity", 1);
      this._display.alpha = t;
    }
    if ((this.isDirty("text") || this.isDirty("populateText")) && (this._display.text = this._getText(), this.markDirtyBounds(), this.get("role") == "tooltip" && this._root.updateTooltip(this)), this.isPrivateDirty("tooltipElement") && this.getPrivate("tooltipElement") && this._disposers.push(new He(() => {
      this._root._removeTooltipElement(this);
    })), this.isDirty("width") && (e.wordWrapWidth = this.width(), this.markDirtyBounds()), this.isDirty("oversizedBehavior") && (e.oversizedBehavior = this.get("oversizedBehavior", "none"), this.markDirtyBounds()), this.isDirty("breakWords") && (e.breakWords = this.get("breakWords", !1), this.markDirtyBounds()), this.isDirty("ellipsis") && (e.ellipsis = this.get("ellipsis"), this.markDirtyBounds()), this.isDirty("ignoreFormatting") && (e.ignoreFormatting = this.get("ignoreFormatting", !1), this.markDirtyBounds()), this.isDirty("minScale") && (e.minScale = this.get("minScale", 0), this.markDirtyBounds()), this.isDirty("fill")) {
      let t = this.get("fill");
      t && (e.fill = t);
    }
    if (this.isDirty("fillOpacity")) {
      let t = this.get("fillOpacity", 1);
      t && (e.fillOpacity = t);
    }
    (this.isDirty("maxWidth") || this.isPrivateDirty("maxWidth")) && (e.maxWidth = this.get("maxWidth", this.getPrivate("maxWidth")), this.markDirtyBounds()), (this.isDirty("maxHeight") || this.isPrivateDirty("maxHeight")) && (e.maxHeight = this.get("maxHeight", this.getPrivate("maxHeight")), this.markDirtyBounds()), w(this._textStyles, (t) => {
      this._dirty[t] && (e[t] = this.get(t), this.markDirtyBounds());
    }), e.fontSize = this.get("fontSize"), e.fontFamily = this.get("fontFamily"), this._display.style = e, this.isDirty("role") && this.get("role") == "tooltip" && this._root.updateTooltip(this);
  }
  _getText() {
    const e = this.get("text", "");
    return this.get("populateText") ? $r(this, e) : e;
  }
  markDirtyText() {
    this._display.text = this._getText(), this.get("role") == "tooltip" && this._root.updateTooltip(this), this.markDirtyBounds(), this.markDirty();
  }
  _setDataItem(e) {
    super._setDataItem(e), this.get("populateText") && this.markDirtyText();
  }
  getNumberFormatter() {
    return this.parent ? this.parent.getNumberFormatter() : super.getNumberFormatter();
  }
  getDateFormatter() {
    return this.parent ? this.parent.getDateFormatter() : super.getDateFormatter();
  }
  getDurationFormatter() {
    return this.parent ? this.parent.getDurationFormatter() : super.getDurationFormatter();
  }
}
Object.defineProperty(Ri, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Text"
});
Object.defineProperty(Ri, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: vt.classNames.concat([Ri.className])
});
class X0 {
  constructor() {
    Object.defineProperty(this, "_observer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_targets", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), this._observer = new ResizeObserver((e) => {
      w(e, (t) => {
        w(this._targets, (s) => {
          s.target === t.target && s.callback();
        });
      });
    });
  }
  addTarget(e, t) {
    this._observer.observe(e, { box: "border-box" }), this._targets.push({ target: e, callback: t });
  }
  removeTarget(e) {
    this._observer.unobserve(e), sn(this._targets, (t) => t.target !== e);
  }
}
class Qa {
  constructor() {
    Object.defineProperty(this, "_timer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "_targets", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    });
  }
  addTarget(e, t) {
    if (this._timer === null) {
      let r = null;
      const n = () => {
        const a = Date.now();
        (r === null || a > r + Qa.delay) && (r = a, w(this._targets, (o) => {
          let l = o.target.getBoundingClientRect();
          (l.width !== o.size.width || l.height !== o.size.height) && (o.size = l, o.callback());
        })), this._targets.length === 0 ? this._timer = null : this._timer = requestAnimationFrame(n);
      };
      this._timer = requestAnimationFrame(n);
    }
    let s = { width: 0, height: 0, left: 0, right: 0, top: 0, bottom: 0, x: 0, y: 0 };
    this._targets.push({ target: e, callback: t, size: s });
  }
  removeTarget(e) {
    sn(this._targets, (t) => t.target !== e), this._targets.length === 0 && this._timer !== null && (cancelAnimationFrame(this._timer), this._timer = null);
  }
}
Object.defineProperty(Qa, "delay", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 200
});
let gn = null;
function V0() {
  return gn === null && (typeof ResizeObserver < "u" ? gn = new X0() : gn = new Qa()), gn;
}
class U0 {
  constructor(e, t) {
    Object.defineProperty(this, "_sensor", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_element", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_listener", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_disposed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), this._sensor = V0(), this._element = e, this._listener = pu(t), this._sensor.addTarget(e, t);
  }
  isDisposed() {
    return this._disposed;
  }
  dispose() {
    this._disposed || (this._disposed = !0, this._sensor.removeTarget(this._element), this._listener.dispose());
  }
  get sensor() {
    return this._sensor;
  }
}
class Fr extends Se {
}
Object.defineProperty(Fr, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "InterfaceColors"
});
Object.defineProperty(Fr, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Se.classNames.concat([Fr.className])
});
class Xe extends Z {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_text", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_textKeys", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: [
        "text",
        "fill",
        "fillOpacity",
        "textAlign",
        "fontFamily",
        "fontSize",
        "fontStyle",
        "fontWeight",
        "fontStyle",
        "fontVariant",
        "textDecoration",
        "shadowColor",
        "shadowBlur",
        "shadowOffsetX",
        "shadowOffsetY",
        "shadowOpacity",
        // "leading",
        // "letterSpacing",
        "lineHeight",
        "baselineRatio",
        //"padding",
        // "stroke",
        // "strokeThickness",
        // "trim",
        // "wordWrap",
        "direction",
        "textBaseline",
        "oversizedBehavior",
        "breakWords",
        "ellipsis",
        "minScale",
        "populateText",
        "role",
        "ignoreFormatting"
      ]
    });
  }
  /**
   * @ignore Text is not to be used directly
   */
  get text() {
    return this._text;
  }
  _afterNew() {
    super._afterNew(), this._makeText(), w(this._textKeys, (e) => {
      const t = this.get(e);
      t != null && this._text.set(e, t);
    }), this.get("html", "") !== "" && this._text.set("text", ""), this.onPrivate("maxWidth", () => {
      this._setMaxDimentions();
    }), this.onPrivate("maxHeight", () => {
      this._setMaxDimentions();
    });
  }
  _makeText() {
    this._text = this.children.push(Ri.new(this._root, {}));
  }
  _updateChildren() {
    if (super._updateChildren(), w(this._textKeys, (e) => {
      this._text.set(e, this.get(e));
    }), this.isDirty("maxWidth") && this._setMaxDimentions(), this.isDirty("maxHeight") && this._setMaxDimentions(), this.isDirty("rotation") && this._setMaxDimentions(), this.get("html", "") !== "" ? this._text.set("text", "") : this._text.set("text", this.get("text")), this.isDirty("textAlign") || this.isDirty("width")) {
      const e = this.get("textAlign");
      let t;
      this.get("width") != null ? e == "right" ? t = R : e == "center" ? t = ce : t = 0 : e == "left" || e == "start" ? t = this.get("paddingLeft") : (e == "right" || e == "end") && (t = -this.get("paddingRight")), this.text.set("x", t);
    }
  }
  _setMaxDimentions() {
    const e = this.get("rotation"), t = e == 90 || e == 270 || e == -90, s = this.get("maxWidth", this.getPrivate("maxWidth", 1 / 0));
    S(s) ? this.text.set(t ? "maxHeight" : "maxWidth", s - this.get("paddingLeft", 0) - this.get("paddingRight", 0)) : this.text.set(t ? "maxHeight" : "maxWidth", void 0);
    const r = this.get("maxHeight", this.getPrivate("maxHeight", 1 / 0));
    S(r) ? this.text.set(t ? "maxWidth" : "maxHeight", r - this.get("paddingTop", 0) - this.get("paddingBottom", 0)) : this.text.set(t ? "maxWidth" : "maxHeight", void 0);
  }
  _setDataItem(e) {
    super._setDataItem(e), this._markDirtyKey("text"), this.text.get("populateText") && this.text.markDirtyText();
  }
  /**
   * Returns text with populated placeholders and formatting if `populateText` is
   * set to `true`.
   *
   * @return Populated text
   */
  getText() {
    return this._text._getText();
  }
}
Object.defineProperty(Xe, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Label"
});
Object.defineProperty(Xe, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Z.classNames.concat([Xe.className])
});
class ds extends le {
  _beforeChanged() {
    super._beforeChanged(), (this.isDirty("pointerBaseWidth") || this.isDirty("cornerRadius") || this.isDirty("pointerLength") || this.isDirty("pointerX") || this.isDirty("pointerY") || this.isDirty("width") || this.isDirty("height")) && (this._clear = !0);
  }
  _changed() {
    if (super._changed(), this._clear) {
      this.markDirtyBounds();
      let e = this.width(), t = this.height();
      if (e > 0 && t > 0) {
        let s = this.get("cornerRadius", 8);
        s = Ie(s, 0, Math.min(e / 2, t / 2));
        let r = this.get("pointerX", 0), n = this.get("pointerY", 0), a = this.get("pointerBaseWidth", 15) / 2, o = 0, l = 0, u = e, c = 0, h = e, d = t, f = 0, g = t, p = (r - o) * (d - l) - (n - l) * (h - o), _ = (r - f) * (c - g) - (n - g) * (u - f);
        const m = this._display;
        if (m.moveTo(s, 0), p > 0 && _ > 0) {
          let v = Math.round(Ie(r, s + a, e - a - s));
          n = Ie(n, -1 / 0, 0), m.lineTo(v - a, 0), m.lineTo(r, n), m.lineTo(v + a, 0);
        }
        if (m.lineTo(e - s, 0), m.arcTo(e, 0, e, s, s), p > 0 && _ < 0) {
          let v = Math.round(Ie(n, s + a, t - a - s));
          r = Ie(r, e, 1 / 0), m.lineTo(e, s), m.lineTo(e, Math.max(v - a, s)), m.lineTo(r, n), m.lineTo(e, v + a);
        }
        if (m.lineTo(e, t - s), m.arcTo(e, t, e - s, t, s), p < 0 && _ < 0) {
          let v = Math.round(Ie(r, s + a, e - a - s));
          n = Ie(n, t, 1 / 0), m.lineTo(e - s, t), m.lineTo(v + a, t), m.lineTo(r, n), m.lineTo(v - a, t);
        }
        if (m.lineTo(s, t), m.arcTo(0, t, 0, t - s, s), p < 0 && _ > 0) {
          let v = Math.round(Ie(n, s + a, t - s - a));
          r = Ie(r, -1 / 0, 0), m.lineTo(0, t - s), m.lineTo(0, v + a), m.lineTo(r, n), m.lineTo(0, Math.max(v - a, s));
        }
        m.lineTo(0, s), m.arcTo(0, 0, s, 0, s), m.closePath();
      }
    }
  }
}
Object.defineProperty(ds, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "PointedRectangle"
});
Object.defineProperty(ds, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: le.classNames.concat([ds.className])
});
class Mt extends Z {
  constructor(e, t, s, r = []) {
    super(e, t, s, r), Object.defineProperty(this, "_fx", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_fy", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_label", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_fillDp", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_strokeDp", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_labelDp", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_w", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_h", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_keepHoverDp", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  _afterNew() {
    this._settings.themeTags = ie(this._settings.themeTags, ["tooltip"]), super._afterNew(), this.set("background", ds.new(this._root, {
      themeTags: ["tooltip", "background"]
    })), this._label = this.children.push(Xe.new(this._root, {})), this._disposers.push(this._label.events.on("boundschanged", () => {
      this._updateBackground();
    })), this._disposers.push(this.on("bounds", () => {
      this._updateBackground();
    })), this._updateTextColor(), this._root.tooltipContainer.children.push(this), this.hide(0), this._root._tooltips.push(this);
  }
  /**
   * A [[Label]] element for the tooltip.
   *
   * @readonly
   * @return Label
   */
  get label() {
    return this._label;
  }
  /**
   * Permanently disposes the tooltip.
   */
  dispose() {
    super.dispose(), bt(this._root._tooltips, this);
  }
  _updateChildren() {
    super._updateChildren(), this.get("labelText") != null && this.label.set("text", this.get("labelText")), this.get("labelHTML") != null && this.label.set("html", this.get("labelHTML"));
  }
  _changed() {
    if (super._changed(), this.isDirty("pointTo") && this._updateBackground(), this.isDirty("tooltipTarget") && this.updateBackgroundColor(), this.isDirty("keepTargetHover"))
      if (this.get("keepTargetHover")) {
        const t = this.get("background");
        this._keepHoverDp = new st([
          t.events.on("pointerover", (s) => {
            let r = this.get("tooltipTarget");
            r && (r.parent && r.parent.getPrivate("tooltipTarget") == r && (r = r.parent), r.hover());
          }),
          t.events.on("pointerout", (s) => {
            let r = this.get("tooltipTarget");
            r && (r.parent && r.parent.getPrivate("tooltipTarget") == r && (r = r.parent), r.unhover());
          })
        ]);
      } else
        this._keepHoverDp && (this._keepHoverDp.dispose(), this._keepHoverDp = void 0);
  }
  _onShow() {
    super._onShow(), this.updateBackgroundColor();
  }
  updateBackgroundColor() {
    let e = this.get("tooltipTarget");
    const t = this.get("background");
    let s, r;
    e && t && (s = e.get("fill"), r = e.get("stroke"), s == null && (s = r), this.get("getFillFromSprite") && (this._fillDp && this._fillDp.dispose(), s != null && t.set("fill", s), this._fillDp = e.on("fill", (n) => {
      n != null && (t.set("fill", n), this._updateTextColor(n));
    }), this._disposers.push(this._fillDp)), this.get("getStrokeFromSprite") && (this._strokeDp && this._strokeDp.dispose(), s != null && t.set("stroke", s), this._strokeDp = e.on("fill", (n) => {
      n != null && t.set("stroke", n);
    }), this._disposers.push(this._strokeDp)), this.get("getLabelFillFromSprite") && (this._labelDp && this._labelDp.dispose(), s != null && this.label.set("fill", s), this._labelDp = e.on("fill", (n) => {
      n != null && this.label.set("fill", n);
    }), this._disposers.push(this._labelDp))), this._updateTextColor(s);
  }
  _updateTextColor(e) {
    this.get("autoTextColor") && (e == null && (e = this.get("background").get("fill")), e == null && (e = this._root.interfaceColors.get("background")), e instanceof X && this.label.set("fill", X.alternative(e, this._root.interfaceColors.get("alternativeText"), this._root.interfaceColors.get("text"))));
  }
  _setDataItem(e) {
    super._setDataItem(e), this.label._setDataItem(e);
  }
  _updateBackground() {
    super.updateBackground();
    const e = this._root.container;
    if (e) {
      let t = 0.5, s = 0.5, r = this.get("centerX");
      r instanceof re && (t = r.value);
      let n = this.get("centerY");
      n instanceof re && (s = n.value);
      let a = e.width(), o = e.height(), l = this.parent, u = 0, c = 0;
      if (l) {
        u = l.x(), c = l.y();
        const L = l.get("layerMargin");
        L && (u += L.left || 0, c += L.top || 0, a += (L.left || 0) + (L.right || 0), o += (L.top || 0) + (L.bottom || 0));
      }
      const h = this.get("bounds", { left: -u, top: -c, right: a - u, bottom: o - c });
      this._updateBounds();
      let d = this.width(), f = this.height();
      d === 0 && (d = this._w), f === 0 && (f = this._h);
      let g = this.get("pointTo", { x: a / 2, y: o / 2 }), p = g.x, _ = g.y, m = this.get("pointerOrientation"), v = this.get("background"), b = 0, y = 0, x = 0;
      v instanceof ds && (b = v.get("pointerLength", 0), y = v.get("strokeWidth", 0) / 2, x = y);
      let D = 0, A = 0, T = h.right - h.left, j = h.bottom - h.top;
      m == "horizontal" || m == "left" || m == "right" ? (y = 0, m == "horizontal" ? p > h.left + T / 2 ? (p -= d * (1 - t) + b, x *= -1) : p += d * t + b : m == "left" ? p += d * (1 - t) + b : (p -= d * t + b, x *= -1)) : (x = 0, m == "vertical" ? _ > h.top + f / 2 + b ? _ -= f * (1 - s) + b : (_ += f * s + b, y *= -1) : m == "down" ? _ -= f * (1 - s) + b : (_ += f * s + b, y *= -1)), p = Ie(p, h.left + d * t, h.left + T - d * (1 - t)) + x, _ = Ie(_, h.top + f * s, h.top + j - f * (1 - s)) - y, D = g.x - p + d * t + x, A = g.y - _ + f * s - y, this._fx = p, this._fy = _;
      const C = this.get("animationDuration", 0);
      if (C > 0 && this.get("visible") && this.get("opacity") > 0.1) {
        const L = this.get("animationEasing");
        this.animate({ key: "x", to: p, duration: C, easing: L }), this.animate({ key: "y", to: _, duration: C, easing: L });
      } else
        this.set("x", p), this.set("y", _);
      v instanceof ds && (v.set("pointerX", D), v.set("pointerY", A)), d > 0 && (this._w = d), f > 0 && (this._h = f);
    }
  }
}
Object.defineProperty(Mt, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Tooltip"
});
Object.defineProperty(Mt, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Z.classNames.concat([Mt.className])
});
class xd extends Se {
  _setDefaults() {
    this._setDefault("negativeBase", 0), this._setDefault("numberFormat", "#,###.#####"), this._setDefault("smallNumberThreshold", 1);
    const e = "_big_number_suffix_", t = "_small_number_suffix_", s = "_byte_suffix_";
    this._setDefault("bigNumberPrefixes", [
      { number: 1e3, suffix: this._t(e + "3") },
      { number: 1e6, suffix: this._t(e + "6") },
      { number: 1e9, suffix: this._t(e + "9") },
      { number: 1e12, suffix: this._t(e + "12") },
      { number: 1e15, suffix: this._t(e + "15") },
      { number: 1e18, suffix: this._t(e + "18") },
      { number: 1e21, suffix: this._t(e + "21") },
      { number: 1e24, suffix: this._t(e + "24") }
    ]), this._setDefault("smallNumberPrefixes", [
      { number: 1e-24, suffix: this._t(t + "24") },
      { number: 1e-21, suffix: this._t(t + "21") },
      { number: 1e-18, suffix: this._t(t + "18") },
      { number: 1e-15, suffix: this._t(t + "15") },
      { number: 1e-12, suffix: this._t(t + "12") },
      { number: 1e-9, suffix: this._t(t + "9") },
      { number: 1e-6, suffix: this._t(t + "6") },
      { number: 1e-3, suffix: this._t(t + "3") }
    ]), this._setDefault("bytePrefixes", [
      { number: 1, suffix: this._t(s + "B") },
      { number: 1024, suffix: this._t(s + "KB") },
      { number: 1048576, suffix: this._t(s + "MB") },
      { number: 1073741824, suffix: this._t(s + "GB") },
      { number: 1099511627776, suffix: this._t(s + "TB") },
      { number: 1125899906842624, suffix: this._t(s + "PB") }
    ]), super._setDefaults();
  }
  _beforeChanged() {
    super._beforeChanged();
  }
  /**
   * Formats the number according to specific format.
   *
   * @param value   Value to format
   * @param format  Format to apply
   * @return Formatted number
   */
  format(e, t, s) {
    (t == null || Ii(t) && t.toLowerCase() === "number") && (t = this.get("numberFormat", ""));
    let r, n = Number(e);
    if (ys(t))
      try {
        return this.get("intlLocales") ? new Intl.NumberFormat(this.get("intlLocales"), t).format(n) : new Intl.NumberFormat(void 0, t).format(n);
      } catch {
        return "Invalid";
      }
    else {
      t = Ga(t);
      let a = this.parseFormat(t, this._root.language), o;
      n > this.get("negativeBase") ? o = a.positive : n < this.get("negativeBase") ? o = a.negative : o = a.zero, s != null && !o.mod && (o = Ti(o), o.decimals.active = n == 0 ? 0 : s), r = o.template.split(pi).join(this.applyFormat(n, o));
    }
    return r;
  }
  /**
   * Parses supplied format into structured object which can be used to format
   * the number.
   *
   * @param format Format string, i.e. "#,###.00"
   * @param language Language
   * @ignore
   */
  parseFormat(e, t) {
    const s = t.translateEmpty("_thousandSeparator"), r = t.translateEmpty("_decimalSeparator");
    let n = {
      positive: {
        thousands: {
          active: -1,
          passive: -1,
          interval: -1,
          separator: s
        },
        decimals: {
          active: -1,
          passive: -1,
          separator: r
        },
        template: "",
        source: "",
        parsed: !1
      },
      negative: {
        thousands: {
          active: -1,
          passive: -1,
          interval: -1,
          separator: s
        },
        decimals: {
          active: -1,
          passive: -1,
          separator: r
        },
        template: "",
        source: "",
        parsed: !1
      },
      zero: {
        thousands: {
          active: -1,
          passive: -1,
          interval: -1,
          separator: s
        },
        decimals: {
          active: -1,
          passive: -1,
          separator: r
        },
        template: "",
        source: "",
        parsed: !1
      }
    };
    e = e.replace("||", ls);
    let a = e.split("|");
    return n.positive.source = a[0], typeof a[2] > "u" ? n.zero = n.positive : n.zero.source = a[2], typeof a[1] > "u" ? n.negative = n.positive : n.negative.source = a[1], _e(n, (o, l) => {
      if (l.parsed)
        return;
      let u = l.source;
      u.toLowerCase() === "number" && (u = this.get("numberFormat", "#,###.#####"));
      let c = Nt.chunk(u, !0);
      for (let h = 0; h < c.length; h++) {
        let d = c[h];
        if (d.text = d.text.replace(ls, "|"), d.type === "value") {
          let f = d.text.match(/[#0.,]+[ ]?[abespABESP%!]?[abespABESP‰!]?/);
          if (f)
            if (f === null || f[0] === "")
              l.template += d.text;
            else {
              let g = f[0].match(/[abespABESP%‰!]{2}|[abespABESP%‰]{1}$/);
              g && (l.mod = g[0].toLowerCase(), l.modSpacing = !!f[0].match(/[ ]{1}[abespABESP%‰!]{1}$/));
              let p = f[0].split(".");
              if (p[0] !== "") {
                l.thousands.active = (p[0].match(/0/g) || []).length, l.thousands.passive = (p[0].match(/\#/g) || []).length + l.thousands.active;
                let _ = p[0].split(",");
                _.length === 1 || (l.thousands.interval = (_.pop() || "").length, l.thousands.interval === 0 && (l.thousands.interval = -1));
              }
              typeof p[1] > "u" || (l.decimals.active = (p[1].match(/0/g) || []).length, l.decimals.passive = (p[1].match(/\#/g) || []).length + l.decimals.active), l.template += d.text.split(f[0]).join(pi);
            }
        } else
          l.template += d.text;
      }
      l.parsed = !0;
    }), n;
  }
  /**
   * Applies parsed format to a numeric value.
   *
   * @param value    Value
   * @param details  Parsed format as returned by parseFormat()
   * @return Formatted number
   * @ignore
   */
  applyFormat(e, t) {
    let s = e < 0;
    e = Math.abs(e);
    let r = "", n = "", a = t.mod ? t.mod.split("") : [];
    if (a.indexOf("b") !== -1) {
      let h = this.applyPrefix(e, this.get("bytePrefixes"), a.indexOf("!") !== -1);
      e = h[0], r = h[1], n = h[2], t.modSpacing && (n = " " + n);
    } else if (a.indexOf("a") !== -1) {
      let h = this.applyPrefix(e, e < this.get("smallNumberThreshold") ? this.get("smallNumberPrefixes") : this.get("bigNumberPrefixes"), a.indexOf("!") !== -1);
      e = h[0], r = h[1], n = h[2], t.modSpacing && (n = " " + n);
    } else if (a.indexOf("p") !== -1) {
      let h = Math.min(e.toString().length + 2, 21);
      e = parseFloat(e.toPrecision(h)), r = this._root.language.translate("_percentPrefix"), n = this._root.language.translate("_percentSuffix"), r == "" && n == "" && (n = "%");
    } else if (a.indexOf("%") !== -1) {
      let h = Math.min(e.toString().length + 2, 21);
      e *= 100, e = parseFloat(e.toPrecision(h)), n = "%";
    } else if (a.indexOf("‰") !== -1) {
      let h = Math.min(e.toString().length + 3, 21);
      e *= 1e3, e = parseFloat(e.toPrecision(h)), n = "‰";
    }
    if (a.indexOf("e") !== -1) {
      let h;
      t.decimals.passive >= 0 ? h = e.toExponential(t.decimals.passive).split("e") : h = e.toExponential().split("e"), e = Number(h[0]), n = "e" + h[1], t.modSpacing && (n = " " + n);
    } else if (t.decimals.passive === 0)
      e = Math.round(e);
    else if (t.decimals.passive > 0) {
      let h = Math.pow(10, t.decimals.passive);
      e = Math.round(e * h) / h;
    }
    let o = "", l = jc(e).split("."), u = l[0];
    if (u.length < t.thousands.active && (u = Array(t.thousands.active - u.length + 1).join("0") + u), t.thousands.interval > 0) {
      let h = [], d = u.split("").reverse().join("");
      for (let f = 0, g = u.length; f <= g; f += t.thousands.interval) {
        let p = d.substr(f, t.thousands.interval).split("").reverse().join("");
        p !== "" && h.unshift(p);
      }
      u = h.join(t.thousands.separator);
    }
    o += u, l.length === 1 && l.push("");
    let c = l[1];
    return c.length < t.decimals.active && (c += Array(t.decimals.active - c.length + 1).join("0")), c !== "" && (o += t.decimals.separator + c), o === "" && (o = "0"), e !== 0 && s && a.indexOf("s") === -1 && (o = "-" + o), r && (o = r + o), n && (o += n), o;
  }
  applyPrefix(e, t, s = !1) {
    let r = e, n = "", a = "", o = !1, l = 1;
    for (let u = 0, c = t.length; u < c; u++)
      t[u].number <= e && (t[u].number === 0 ? r = 0 : (r = e / t[u].number, l = t[u].number), n = t[u].prefix, a = t[u].suffix, o = !0);
    return !o && s && t.length && e != 0 && (r = e / t[0].number, n = t[0].prefix, a = t[0].suffix, o = !0), o && (r = parseFloat(r.toPrecision(Math.min(l.toString().length + Math.floor(r).toString().replace(/[^0-9]*/g, "").length, 21)))), [r, n, a];
  }
  /**
   * Replaces brackets with temporary placeholders.
   *
   * @ignore Exclude from docs
   * @param text  Input text
   * @return Escaped text
   */
  escape(e) {
    return e.replace("||", ls);
  }
  /**
   * Replaces placeholders back to brackets.
   *
   * @ignore Exclude from docs
   * @param text  Escaped text
   * @return Unescaped text
   */
  unescape(e) {
    return e.replace(ls, "|");
  }
}
function wd(i, e) {
  let t = 0, s = 0, r = 1, n = 0, a = 0, o = 0, l = 0, u = 0;
  return i.formatToParts(e).forEach((c) => {
    switch (c.type) {
      case "year":
        t = +c.value;
        break;
      case "month":
        s = +c.value - 1;
        break;
      case "day":
        r = +c.value;
        break;
      case "hour":
        n = +c.value;
        break;
      case "minute":
        a = +c.value;
        break;
      case "second":
        o = +c.value;
        break;
      case "fractionalSecond":
        l = +c.value;
        break;
      case "weekday":
        switch (c.value) {
          case "Sun":
            u = 0;
            break;
          case "Mon":
            u = 1;
            break;
          case "Tue":
            u = 2;
            break;
          case "Wed":
            u = 3;
            break;
          case "Thu":
            u = 4;
            break;
          case "Fri":
            u = 5;
            break;
          case "Sat":
            u = 6;
            break;
        }
    }
  }), n === 24 && (n = 0), { year: t, month: s, day: r, hour: n, minute: a, second: o, millisecond: l, weekday: u };
}
function Vu(i, e) {
  const { year: t, month: s, day: r, hour: n, minute: a, second: o, millisecond: l } = wd(i, e);
  return Date.UTC(t, s, r, n, a, o, l);
}
class Sd {
  constructor(e, t) {
    if (Object.defineProperty(this, "_utc", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_dtf", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), !t)
      throw new Error("You cannot use `new Class()`, instead use `Class.new()`");
    this.name = e, this._utc = new Intl.DateTimeFormat("UTC", {
      hour12: !1,
      timeZone: "UTC",
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
      weekday: "short",
      fractionalSecondDigits: 3
    }), this._dtf = new Intl.DateTimeFormat("UTC", {
      hour12: !1,
      timeZone: e,
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
      weekday: "short",
      fractionalSecondDigits: 3
    });
  }
  /**
   * Use this method to create an instance of this class.
   *
   * @see {@link https://www.amcharts.com/docs/v5/getting-started/#New_element_syntax} for more info
   * @param   timezone  IANA timezone
   * @return            Instantiated object
   */
  static new(e) {
    return new this(e, !0);
  }
  convertLocal(e) {
    const t = this.offsetUTC(e), s = e.getTimezoneOffset(), r = new Date(e);
    r.setUTCMinutes(r.getUTCMinutes() - (t - s));
    const n = r.getTimezoneOffset();
    return s != n && r.setUTCMinutes(r.getUTCMinutes() + n - s), r;
  }
  offsetUTC(e) {
    const t = Vu(this._utc, e), s = Vu(this._dtf, e);
    return (t - s) / 6e4;
  }
  parseDate(e) {
    return wd(this._dtf, e);
  }
}
class Dd extends Se {
  _setDefaults() {
    this._setDefault("capitalize", !0), this._setDefault("dateFormat", "yyyy-MM-dd"), super._setDefaults();
  }
  _beforeChanged() {
    super._beforeChanged();
  }
  format(e, t) {
    (typeof t > "u" || t === "") && (t = this.get("dateFormat", "yyyy-MM-dd"));
    let s, r = e;
    if (ys(t))
      try {
        const o = this.get("intlLocales");
        return o ? new Intl.DateTimeFormat(o, t).format(r) : new Intl.DateTimeFormat(void 0, t).format(r);
      } catch {
        return "Invalid";
      }
    let n = this.parseFormat(t);
    const a = this._root.timezone;
    return a && !this._root.utc && (r = a.convertLocal(r)), S(r.getTime()) ? (s = this.applyFormat(r, n), this.get("capitalize") && (s = s.replace(/^.{1}/, s.substr(0, 1).toUpperCase())), s) : "Invalid date";
  }
  /**
   * Applies format to Date.
   *
   * @param date      Date object
   * @param info      Parsed format information
   * @return Formatted date string
   */
  applyFormat(e, t) {
    let s = t.template, r, n, a, o, l, u, c, h, d = e.getTime();
    this._root.utc ? (r = e.getUTCFullYear(), n = e.getUTCMonth(), a = e.getUTCDay(), o = e.getUTCDate(), l = e.getUTCHours(), u = e.getUTCMinutes(), c = e.getUTCSeconds(), h = e.getUTCMilliseconds()) : (r = e.getFullYear(), n = e.getMonth(), a = e.getDay(), o = e.getDate(), l = e.getHours(), u = e.getMinutes(), c = e.getSeconds(), h = e.getMilliseconds());
    for (let f = 0, g = t.parts.length; f < g; f++) {
      let p = "";
      switch (t.parts[f]) {
        case "G":
          p = this._t(r < 0 ? "_era_bc" : "_era_ad");
          break;
        case "yyyy":
          p = Math.abs(r).toString(), r < 0 && (p += this._t("_era_bc"));
          break;
        case "yyy":
        case "yy":
        case "y":
          p = Math.abs(r).toString().substr(-t.parts[f].length), r < 0 && (p += this._t("_era_bc"));
          break;
        case "YYYY":
        case "YYY":
        case "YY":
        case "Y":
          let _ = id(e, this._root.utc);
          t.parts[f] == "YYYY" ? p = Math.abs(_).toString() : p = Math.abs(_).toString().substr(-t.parts[f].length), _ < 0 && (p += this._t("_era_bc"));
          break;
        case "u":
          break;
        case "q":
          p = "" + Math.ceil((e.getMonth() + 1) / 3);
          break;
        case "MMMMM":
          p = this._t(this._getMonth(n)).substr(0, 1);
          break;
        case "MMMM":
          p = this._t(this._getMonth(n));
          break;
        case "MMM":
          p = this._t(this._getShortMonth(n));
          break;
        case "MM":
          p = Oe(n + 1, 2, "0");
          break;
        case "M":
          p = (n + 1).toString();
          break;
        case "ww":
          p = Oe(Hs(e, this._root.utc), 2, "0");
          break;
        case "w":
          p = Hs(e, this._root.utc).toString();
          break;
        case "W":
          p = sd(e, this._root.utc).toString();
          break;
        case "dd":
          p = Oe(o, 2, "0");
          break;
        case "d":
          p = o.toString();
          break;
        case "DD":
        case "DDD":
          p = Oe(el(e, this._root.utc).toString(), t.parts[f].length, "0");
          break;
        case "D":
          p = el(e, this._root.utc).toString();
          break;
        case "F":
          break;
        case "g":
          break;
        case "t":
          p = this._root.language.translateFunc("_dateOrd").call(this, o);
          break;
        case "E":
          p = (a || 7).toString();
          break;
        case "EE":
          p = Oe((a || 7).toString(), 2, "0");
          break;
        case "EEE":
        case "eee":
          p = this._t(this._getShortWeekday(a));
          break;
        case "EEEE":
        case "eeee":
          p = this._t(this._getWeekday(a));
          break;
        case "EEEEE":
        case "eeeee":
          p = this._t(this._getShortWeekday(a)).substr(0, 1);
          break;
        case "e":
        case "ee":
          p = (a - (this._root.locale.firstDayOfWeek || 1) + 1).toString(), t.parts[f] == "ee" && (p = Oe(p, 2, "0"));
          break;
        case "a":
          l >= 12 ? p = this._t("PM") : p = this._t("AM");
          break;
        case "aa":
          l >= 12 ? p = this._t("P.M.") : p = this._t("A.M.");
          break;
        case "aaa":
          l >= 12 ? p = this._t("P") : p = this._t("A");
          break;
        case "h":
          p = mr(l).toString();
          break;
        case "hh":
          p = Oe(mr(l), 2, "0");
          break;
        case "H":
          p = l.toString();
          break;
        case "HH":
          p = Oe(l, 2, "0");
          break;
        case "K":
          p = mr(l, 0).toString();
          break;
        case "KK":
          p = Oe(mr(l, 0), 2, "0");
          break;
        case "k":
          p = (l + 1).toString();
          break;
        case "kk":
          p = Oe(l + 1, 2, "0");
          break;
        case "m":
          p = u.toString();
          break;
        case "mm":
          p = Oe(u, 2, "0");
          break;
        case "s":
          p = c.toString();
          break;
        case "ss":
          p = Oe(c, 2, "0");
          break;
        case "S":
        case "SS":
        case "SSS":
          p = Math.round(h / 1e3 * Math.pow(10, t.parts[f].length)).toString();
          break;
        case "x":
          p = d.toString();
          break;
        case "n":
        case "nn":
        case "nnn":
          p = Oe(h, t.parts[f].length, "0");
          break;
        case "z":
          p = br(e, !1, !1, this._root.utc);
          break;
        case "zz":
          p = br(e, !0, !1, this._root.utc);
          break;
        case "zzz":
          p = br(e, !1, !0, this._root.utc);
          break;
        case "zzzz":
          p = br(e, !0, !0, this._root.utc);
          break;
        case "Z":
        case "ZZ":
          let m = this._root.utc ? "UTC" : this._root.timezone;
          m instanceof Sd && (m = m.name);
          const v = m ? nd(m) : e.getTimezoneOffset();
          let b = Math.abs(v) / 60, y = Math.floor(b), x = b * 60 - y * 60;
          this._root.utc && (y = 0, x = 0), t.parts[f] == "Z" ? (p = "GMT", p += v > 0 ? "-" : "+", p += Oe(y, 2) + ":" + Oe(x, 2)) : (p = v > 0 ? "-" : "+", p += Oe(y, 2) + Oe(x, 2));
          break;
        case "i":
          p = e.toISOString();
          break;
        case "I":
          p = e.toUTCString();
          break;
      }
      s = s.replace(pi, p);
    }
    return s;
  }
  /**
   * Parses format into structured infromation.
   *
   * @param format Format template
   */
  parseFormat(e) {
    let t = {
      template: "",
      parts: []
    }, s = Nt.chunk(e, !0);
    for (let r = 0; r < s.length; r++) {
      let n = s[r];
      if (n.type === "value") {
        if (n.text.match(/^date$/i)) {
          let o = this.get("dateFormat", "yyyy-MM-dd");
          Ii(o) || (o = "yyyy-MM-dd"), n.text = o;
        }
        let a = n.text.match(/G|yyyy|yyy|yy|y|YYYY|YYY|YY|Y|u|q|MMMMM|MMMM|MMM|MM|M|ww|w|W|dd|d|DDD|DD|D|F|g|EEEEE|EEEE|EEE|EE|E|eeeee|eeee|eee|ee|e|aaa|aa|a|hh|h|HH|H|KK|K|kk|k|mm|m|ss|s|SSS|SS|S|A|zzzz|zzz|zz|z|ZZ|Z|t|x|nnn|nn|n|i|I/g);
        if (a)
          for (let o = 0; o < a.length; o++)
            t.parts.push(a[o]), n.text = n.text.replace(a[o], pi);
      }
      t.template += n.text;
    }
    return t;
  }
  _months() {
    return ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
  }
  _getMonth(e) {
    return this._months()[e];
  }
  _shortMonths() {
    return ["Jan", "Feb", "Mar", "Apr", "May(short)", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
  }
  _getShortMonth(e) {
    return this._shortMonths()[e];
  }
  _weekdays() {
    return ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
  }
  _getWeekday(e) {
    return this._weekdays()[e];
  }
  _shortWeekdays() {
    return ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
  }
  _getShortWeekday(e) {
    return this._shortWeekdays()[e];
  }
  parse(e, t) {
    if (e instanceof Date)
      return e;
    if (S(e))
      return new Date(e);
    Ii(e) || (e = e.toString());
    let s, r = "";
    t = Ga(t), t = t.substr(0, e.length);
    let n = this.parseFormat(t), a = {
      year: -1,
      year3: -1,
      year2: -1,
      year1: -1,
      month: -1,
      monthShort: -1,
      monthLong: -1,
      weekdayShort: -1,
      weekdayLong: -1,
      day: -1,
      yearDay: -1,
      week: -1,
      hourBase0: -1,
      hour12Base0: -1,
      hourBase1: -1,
      hour12Base1: -1,
      minute: -1,
      second: -1,
      millisecond: -1,
      millisecondDigits: -1,
      am: -1,
      zone: -1,
      timestamp: -1,
      iso: -1
    }, o = {
      year: 1970,
      month: 0,
      day: 1,
      hour: 0,
      minute: 0,
      second: 0,
      millisecond: 0,
      timestamp: null,
      offset: 0,
      utc: this._root.utc
    }, l = 0, u = 0;
    for (let d = 0; d < n.parts.length; d++) {
      switch (u = d + l + 1, n.parts[d]) {
        case "yyyy":
        case "YYYY":
          r += "([0-9]{4})", a.year = u;
          break;
        case "yyy":
        case "YYY":
          r += "([0-9]{3})", a.year3 = u;
          break;
        case "yy":
        case "YY":
          r += "([0-9]{2})", a.year2 = u;
          break;
        case "y":
        case "Y":
          r += "([0-9]{1})", a.year1 = u;
          break;
        case "MMMM":
          r += "(" + this.getStringList(this._months()).join("|") + ")", a.monthLong = u;
          break;
        case "MMM":
          r += "(" + this.getStringList(this._shortMonths()).join("|") + ")", a.monthShort = u;
          break;
        case "MM":
        case "M":
          r += "([0-9]{2}|[0-9]{1})", a.month = u;
          break;
        case "ww":
        case "w":
          r += "([0-9]{2}|[0-9]{1})", a.week = u;
          break;
        case "dd":
        case "d":
          r += "([0-9]{2}|[0-9]{1})", a.day = u;
          break;
        case "DDD":
        case "DD":
        case "D":
          r += "([0-9]{3}|[0-9]{2}|[0-9]{1})", a.yearDay = u;
          break;
        case "dddd":
          r += "(" + this.getStringList(this._weekdays()).join("|") + ")", a.weekdayLong = u;
          break;
        case "ddd":
          r += "(" + this.getStringList(this._shortWeekdays()).join("|") + ")", a.weekdayShort = u;
          break;
        case "aaa":
        case "aa":
        case "a":
          r += "(" + this.getStringList(["AM", "PM", "A.M.", "P.M.", "A", "P"]).join("|") + ")", a.am = u;
          break;
        case "hh":
        case "h":
          r += "([0-9]{2}|[0-9]{1})", a.hour12Base1 = u;
          break;
        case "HH":
        case "H":
          r += "([0-9]{2}|[0-9]{1})", a.hourBase0 = u;
          break;
        case "KK":
        case "K":
          r += "([0-9]{2}|[0-9]{1})", a.hour12Base0 = u;
          break;
        case "kk":
        case "k":
          r += "([0-9]{2}|[0-9]{1})", a.hourBase1 = u;
          break;
        case "mm":
        case "m":
          r += "([0-9]{2}|[0-9]{1})", a.minute = u;
          break;
        case "ss":
        case "s":
          r += "([0-9]{2}|[0-9]{1})", a.second = u;
          break;
        case "SSS":
        case "SS":
        case "S":
          r += "([0-9]{3}|[0-9]{2}|[0-9]{1})", a.millisecond = u, a.millisecondDigits = n.parts[d].length;
          break;
        case "nnn":
        case "nn":
        case "n":
          r += "([0-9]{3}|[0-9]{2}|[0-9]{1})", a.millisecond = u;
          break;
        case "x":
          r += "([0-9]{1,})", a.timestamp = u;
          break;
        case "Z":
          r += "GMT([-+]+[0-9]{2}:[0-9]{2})", a.zone = u;
          break;
        case "ZZ":
          r += "([\\-+]+[0-9]{2}[0-9]{2})", a.zone = u;
          break;
        case "i":
          r += "([0-9]{4})-?([0-9]{2})-?([0-9]{2})T?([0-9]{2}):?([0-9]{2}):?([0-9]{2})\\.?([0-9]{0,3})([zZ]|[+\\-][0-9]{2}:?[0-9]{2}|$)", a.iso = u, l += 7;
          break;
        case "G":
        case "YYYY":
        case "YYY":
        case "YY":
        case "Y":
        case "MMMMM":
        case "W":
        case "EEEEE":
        case "EEEE":
        case "EEE":
        case "EE":
        case "E":
        case "eeeee":
        case "eeee":
        case "eee":
        case "ee":
        case "e":
        case "zzzz":
        case "zzz":
        case "zz":
        case "z":
        case "t":
          l--;
          break;
      }
      r += "[^0-9]*";
    }
    let c = new RegExp(r), h = e.match(c);
    if (h) {
      if (a.year > -1 && (o.year = parseInt(h[a.year])), a.year3 > -1) {
        let d = parseInt(h[a.year3]);
        d += 1e3, o.year = d;
      }
      if (a.year2 > -1) {
        let d = parseInt(h[a.year2]);
        d > 50 ? d += 1e3 : d += 2e3, o.year = d;
      }
      if (a.year1 > -1) {
        let d = parseInt(h[a.year1]);
        d = Math.floor(new Date().getFullYear() / 10) * 10 + d, o.year = d;
      }
      if (a.monthLong > -1 && (o.month = this.resolveMonth(h[a.monthLong])), a.monthShort > -1 && (o.month = this.resolveShortMonth(h[a.monthShort])), a.month > -1 && (o.month = parseInt(h[a.month]) - 1), a.week > -1 && a.day === -1 && (o.month = 0, o.day = rd(parseInt(h[a.week]), o.year, 1, this._root.utc)), a.day > -1 && (o.day = parseInt(h[a.day])), a.yearDay > -1 && (o.month = 0, o.day = parseInt(h[a.yearDay])), a.hourBase0 > -1 && (o.hour = parseInt(h[a.hourBase0])), a.hourBase1 > -1 && (o.hour = parseInt(h[a.hourBase1]) - 1), a.hour12Base0 > -1) {
        let d = parseInt(h[a.hour12Base0]);
        d == 11 && (d = 0), a.am > -1 && !this.isAm(h[a.am]) && (d += 12), o.hour = d;
      }
      if (a.hour12Base1 > -1) {
        let d = parseInt(h[a.hour12Base1]);
        d == 12 && (d = 0), a.am > -1 && !this.isAm(h[a.am]) && (d += 12), o.hour = d;
      }
      if (a.minute > -1 && (o.minute = parseInt(h[a.minute])), a.second > -1 && (o.second = parseInt(h[a.second])), a.millisecond > -1) {
        let d = parseInt(h[a.millisecond]);
        a.millisecondDigits == 2 ? d *= 10 : a.millisecondDigits == 1 && (d *= 100), o.millisecond = d;
      }
      if (a.timestamp > -1) {
        o.timestamp = parseInt(h[a.timestamp]);
        const d = new Date(o.timestamp);
        o.year = d.getUTCFullYear(), o.month = d.getUTCMonth(), o.day = d.getUTCDate(), o.hour = d.getUTCHours(), o.minute = d.getUTCMinutes(), o.second = d.getUTCSeconds(), o.millisecond = d.getUTCMilliseconds();
      }
      a.zone > -1 && (o.offset = this.resolveTimezoneOffset(new Date(o.year, o.month, o.day), h[a.zone])), a.iso > -1 && (o.year = dt(h[a.iso + 0]), o.month = dt(h[a.iso + 1]) - 1, o.day = dt(h[a.iso + 2]), o.hour = dt(h[a.iso + 3]), o.minute = dt(h[a.iso + 4]), o.second = dt(h[a.iso + 5]), o.millisecond = dt(h[a.iso + 6]), h[a.iso + 7] == "Z" || h[a.iso + 7] == "z" ? o.utc = !0 : h[a.iso + 7] != "" && (o.offset = this.resolveTimezoneOffset(new Date(o.year, o.month, o.day), h[a.iso + 7]))), o.utc ? s = new Date(Date.UTC(o.year, o.month, o.day, o.hour, o.minute, o.second, o.millisecond)) : s = new Date(o.year, o.month, o.day, o.hour, o.minute + o.offset, o.second, o.millisecond);
    } else
      s = new Date(e);
    return s;
  }
  resolveTimezoneOffset(e, t) {
    if (t.match(/([+\-]?)([0-9]{2}):?([0-9]{2})/)) {
      let r = t.match(/([+\-]?)([0-9]{2}):?([0-9]{2})/), n = r[1], a = r[2], o = r[3], l = parseInt(a) * 60 + parseInt(o);
      n == "+" && (l *= -1);
      let u = (e || new Date()).getTimezoneOffset();
      return l - u;
    }
    return 0;
  }
  /**
   * Resolves month name (i.e. "December") into a month number (11).
   *
   * @param value  Month name
   * @return Month number
   */
  resolveMonth(e) {
    let t = this._months().indexOf(e);
    return t > -1 || !this._root.language.isDefault() && (t = this._root.language.translateAll(this._months()).indexOf(e), t > -1) ? t : 0;
  }
  /**
   * Resolves short month name (i.e. "Dec") into a month number.
   *
   * @param value  Short month name
   * @return Month number
   */
  resolveShortMonth(e) {
    let t = this._shortMonths().indexOf(e);
    return t > -1 || (t = this._months().indexOf(e), t > -1) || this._root.language && !this._root.language.isDefault() && (t = this._root.language.translateAll(this._shortMonths()).indexOf(e), t > -1) ? t : 0;
  }
  /**
   * Checks if passed in string represents AM/PM notation in many of its
   * versions.
   *
   * @param value  Source string
   * @return Is it AM/PM?
   */
  isAm(e) {
    return this.getStringList(["AM", "A.M.", "A"]).indexOf(e.toUpperCase()) > -1;
  }
  /**
   * Translates list of strings.
   *
   * @param list  Source strings
   * @return Translated strings
   */
  getStringList(e) {
    let t = [];
    for (let s = 0; s < e.length; s++)
      this._root.language ? t.push(Jo(this._t(e[s]))) : t.push(Jo(e[s]));
    return t;
  }
}
class Pd extends Se {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_unitAliases", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {
        Y: "y",
        D: "d",
        H: "h",
        K: "h",
        k: "h",
        n: "S"
      }
    });
  }
  _setDefaults() {
    const e = "_duration_millisecond", t = "_duration_second", s = "_duration_minute", r = "_duration_hour", n = "_duration_day", a = "_duration_week", o = "_duration_month", l = "_duration_year", u = "_second", c = "_minute", h = "_hour", d = "_day", f = "_week", g = "_week", p = "_year";
    this._setDefault("negativeBase", 0), this._setDefault("baseUnit", "second"), this._setDefault("durationFormats", {
      millisecond: {
        millisecond: this._t(e),
        second: this._t(e + u),
        minute: this._t(e + c),
        hour: this._t(e + h),
        day: this._t(e + d),
        week: this._t(e + f),
        month: this._t(e + g),
        year: this._t(e + p)
      },
      second: {
        second: this._t(t),
        minute: this._t(t + c),
        hour: this._t(t + h),
        day: this._t(t + d),
        week: this._t(t + f),
        month: this._t(t + g),
        year: this._t(t + p)
      },
      minute: {
        minute: this._t(s),
        hour: this._t(s + h),
        day: this._t(s + d),
        week: this._t(s + f),
        month: this._t(s + g),
        year: this._t(s + p)
      },
      hour: {
        hour: this._t(r),
        day: this._t(r + d),
        week: this._t(r + f),
        month: this._t(r + g),
        year: this._t(r + p)
      },
      day: {
        day: this._t(n),
        week: this._t(n + f),
        month: this._t(n + g),
        year: this._t(n + p)
      },
      week: {
        week: this._t(a),
        month: this._t(a + g),
        year: this._t(a + p)
      },
      month: {
        month: this._t(o),
        year: this._t(o + p)
      },
      year: {
        year: this._t(l)
      }
    }), super._setDefaults();
  }
  _beforeChanged() {
    super._beforeChanged();
  }
  /**
   * Formats the number as duration.
   *
   * For example `1000` (base unit seconds) would be converted to `16:40` as in
   * 16 minutes and 40 seconds.
   *
   * @param value   Value to format
   * @param format  Format to apply
   * @param base    Override base unit
   * @return Formatted number
   */
  format(e, t, s) {
    let r = s || this.get("baseUnit");
    (typeof t > "u" || t === "") && (this.get("durationFormat") != null ? t = this.get("durationFormat") : t = this.getFormat(dt(e), void 0, r)), t = Ga(t);
    let n = this.parseFormat(t, r), a = Number(e), o;
    a > this.get("negativeBase") ? o = n.positive : a < this.get("negativeBase") ? o = n.negative : o = n.zero;
    let l = this.applyFormat(a, o);
    return o.color !== "" && (l = "[" + o.color + "]" + l + "[/]"), l;
  }
  /**
   * Parses supplied format into structured object which can be used to format
   * the number.
   *
   * @param format  Format string, i.e. "#,###.00"
   * @param base    Override base unit
   * @return Parsed information
   */
  parseFormat(e, t) {
    let s = t || this.get("baseUnit"), r = {
      positive: {
        color: "",
        template: "",
        parts: [],
        source: "",
        baseUnit: s,
        parsed: !1,
        absolute: !1
      },
      negative: {
        color: "",
        template: "",
        parts: [],
        source: "",
        baseUnit: s,
        parsed: !1,
        absolute: !1
      },
      zero: {
        color: "",
        template: "",
        parts: [],
        source: "",
        baseUnit: s,
        parsed: !1,
        absolute: !1
      }
    };
    e = e.replace("||", ls);
    let n = e.split("|");
    return r.positive.source = n[0], typeof n[2] > "u" ? r.zero = r.positive : r.zero.source = n[2], typeof n[1] > "u" ? r.negative = r.positive : r.negative.source = n[1], _e(r, (a, o) => {
      if (o.parsed)
        return;
      let l = o.source, u = [];
      u = o.source.match(/^\[([^\]]*)\]/), u && u.length && u[0] !== "" && (l = o.source.substr(u[0].length), o.color = u[1]);
      let c = Nt.chunk(l, !0);
      for (let h = 0; h < c.length; h++) {
        let d = c[h];
        if (d.text = d.text.replace(ls, "|"), d.type === "value") {
          d.text.match(/[yYMdDwhHKkmsSn]+a/) && (o.absolute = !0, d.text = d.text.replace(/([yYMdDwhHKkmsSn]+)a/, "$1"));
          let f = d.text.match(/y+|Y+|M+|d+|D+|w+|h+|H+|K+|k+|m+|s+|S+|n+/g);
          if (f)
            for (let g = 0; g < f.length; g++)
              f[g] == null && (f[g] = this._unitAliases[f[g]]), o.parts.push(f[g]), d.text = d.text.replace(f[g], pi);
        }
        o.template += d.text;
      }
      o.parsed = !0;
    }), r;
  }
  /**
   * Applies parsed format to a numeric value.
   *
   * @param value    Value
   * @param details  Parsed format as returned by {parseFormat}
   * @return Formatted duration
   */
  applyFormat(e, t) {
    let s = !t.absolute && e < this.get("negativeBase");
    e = Math.abs(e);
    let r = this.toTimeStamp(e, t.baseUnit), n = t.template;
    for (let a = 0, o = t.parts.length; a < o; a++) {
      let l = t.parts[a], u = this._toTimeUnit(l.substr(0, 1)), c = l.length, h = Math.floor(r / this._getUnitValue(u));
      n = n.replace(pi, Oe(h, c, "0")), r -= h * this._getUnitValue(u);
    }
    return s && (n = "-" + n), n;
  }
  /**
   * Converts numeric value to timestamp in milliseconds.
   *
   * @param value     A source value
   * @param baseUnit  Base unit the source value is in: "q", "s", "i", "h", "d", "w", "m", "y"
   * @return Value representation as a timestamp in milliseconds
   */
  toTimeStamp(e, t) {
    return e * this._getUnitValue(t);
  }
  _toTimeUnit(e) {
    switch (e) {
      case "S":
        return "millisecond";
      case "s":
        return "second";
      case "m":
        return "minute";
      case "h":
        return "hour";
      case "d":
        return "day";
      case "w":
        return "week";
      case "M":
        return "month";
      case "y":
        return "year";
    }
  }
  /**
   * Returns appropriate default format for the value.
   *
   * If `maxValue` is sepcified, it will use that value to determine the time
   * unit for the format.
   *
   * For example if your `baseUnit` is `"second"` and you pass in `10`, you
   * will get `"10"`.
   *
   * However, you might want it to be formatted in the context of bigger scale,
   * say 10 minutes (600 seconds). If you pass in `600` as `maxValue`, all
   * values, including small ones will use format with minutes, e.g.:
   * `00:10`, `00:50`, `12: 30`, etc.
   *
   * @param value     Value to format
   * @param maxValue  Maximum value to be used to determine format
   * @param baseUnit  Base unit of the value
   * @return Format
   */
  getFormat(e, t, s) {
    if (this.get("durationFormat") != null)
      return this.get("durationFormat");
    if (s || (s = this.get("baseUnit")), t != null && e != t) {
      e = Math.abs(e), t = Math.abs(t);
      let r = this.getValueUnit(Math.max(e, t), s);
      return this.get("durationFormats")[s][r];
    } else {
      let r = this.getValueUnit(e, s);
      return this.get("durationFormats")[s][r];
    }
  }
  /**
   * Returns value's closest denominator time unit, e.g 100 seconds is
   * `"minute"`, while 59 seconds would still be `second`.
   *
   * @param value     Source duration value
   * @param baseUnit  Base unit
   * @return Denominator
   */
  getValueUnit(e, t) {
    t || (t = this.get("baseUnit"));
    let s, r = this.getMilliseconds(e, t);
    return Bc(this._getUnitValues(), (n, a) => {
      if (n == t || s) {
        if (r / a <= 1)
          return s || (s = n), !1;
        s = n;
      }
      return !0;
    }), s;
  }
  /**
   * Converts value to milliseconds according to `baseUnit`.
   *
   * @param value     Source duration value
   * @param baseUnit  Base unit
   * @return Value in milliseconds
   */
  getMilliseconds(e, t) {
    return t || (t = this.get("baseUnit")), e * this._getUnitValue(t);
  }
  _getUnitValue(e) {
    return this._getUnitValues()[e];
  }
  _getUnitValues() {
    return {
      millisecond: 1,
      second: 1e3,
      minute: 6e4,
      hour: 36e5,
      day: 864e5,
      week: 6048e5,
      month: 2592e6,
      year: 31536e6
    };
  }
}
const Td = {
  firstDayOfWeek: 1,
  // Number formatting options.
  // 
  // Please check with the local standards which separator is accepted to be
  // used for separating decimals, and which for thousands.
  _decimalSeparator: ".",
  _thousandSeparator: ",",
  // Position of the percent sign in numbers
  _percentPrefix: null,
  _percentSuffix: "%",
  // Suffixes for numbers
  // When formatting numbers, big or small numers might be reformatted to
  // shorter version, by applying a suffix.
  // 
  // For example, 1000000 might become "1m".
  // Or 1024 might become "1KB" if we're formatting byte numbers.
  // 
  // This section defines such suffixes for all such cases.
  _big_number_suffix_3: "k",
  _big_number_suffix_6: "M",
  _big_number_suffix_9: "G",
  _big_number_suffix_12: "T",
  _big_number_suffix_15: "P",
  _big_number_suffix_18: "E",
  _big_number_suffix_21: "Z",
  _big_number_suffix_24: "Y",
  _small_number_suffix_3: "m",
  _small_number_suffix_6: "μ",
  _small_number_suffix_9: "n",
  _small_number_suffix_12: "p",
  _small_number_suffix_15: "f",
  _small_number_suffix_18: "a",
  _small_number_suffix_21: "z",
  _small_number_suffix_24: "y",
  _byte_suffix_B: "B",
  _byte_suffix_KB: "KB",
  _byte_suffix_MB: "MB",
  _byte_suffix_GB: "GB",
  _byte_suffix_TB: "TB",
  _byte_suffix_PB: "PB",
  // Default date formats for various periods.
  // 
  // This should reflect official or de facto formatting universally accepted
  // in the country translation is being made for
  // Available format codes here:
  // https://www.amcharts.com/docs/v5/concepts/formatters/formatting-dates/#Format_codes
  // 
  // This will be used when formatting date/time for particular granularity,
  // e.g. "_date_hour" will be shown whenever we need to show time as hours.
  // 
  // "date" is used as in default date format when showing standalone dates.
  _date: "yyyy-MM-dd",
  _date_millisecond: "mm:ss SSS",
  _date_millisecond_full: "HH:mm:ss SSS",
  _date_second: "HH:mm:ss",
  _date_second_full: "HH:mm:ss",
  _date_minute: "HH:mm",
  _date_minute_full: "HH:mm - MMM dd, yyyy",
  _date_hour: "HH:mm",
  _date_hour_full: "HH:mm - MMM dd, yyyy",
  _date_day: "MMM dd",
  _date_day_full: "MMM dd, yyyy",
  _date_week: "ww",
  _date_week_full: "MMM dd, yyyy",
  _date_month: "MMM",
  _date_month_full: "MMM, yyyy",
  _date_year: "yyyy",
  // Default duration formats for various base units.
  // 
  // This will be used by DurationFormatter to format numeric values into
  // duration.
  // 
  // Notice how each duration unit comes in several versions. This is to ensure
  // that each base unit is shown correctly.
  // 
  // For example, if we have baseUnit set to "second", meaning our duration is
  // in seconds.
  // 
  // If we pass in `50` to formatter, it will know that we have just 50 seconds
  // (less than a minute) so it will use format in `"_duration_second"` ("ss"),
  // and the formatted result will be in like `"50"`.
  // 
  // If we pass in `70`, which is more than a minute, the formatter will switch
  // to `"_duration_second_minute"` ("mm:ss"), resulting in "01:10" formatted
  // text.
  // 
  // Available codes here:
  // https://www.amcharts.com/docs/v4/concepts/formatters/formatting-duration/#Available_Codes
  _duration_millisecond: "SSS",
  _duration_millisecond_second: "ss.SSS",
  _duration_millisecond_minute: "mm:ss SSS",
  _duration_millisecond_hour: "hh:mm:ss SSS",
  _duration_millisecond_day: "d'd' mm:ss SSS",
  _duration_millisecond_week: "d'd' mm:ss SSS",
  _duration_millisecond_month: "M'm' dd'd' mm:ss SSS",
  _duration_millisecond_year: "y'y' MM'm' dd'd' mm:ss SSS",
  _duration_second: "ss",
  _duration_second_minute: "mm:ss",
  _duration_second_hour: "hh:mm:ss",
  _duration_second_day: "d'd' hh:mm:ss",
  _duration_second_week: "d'd' hh:mm:ss",
  _duration_second_month: "M'm' dd'd' hh:mm:ss",
  _duration_second_year: "y'y' MM'm' dd'd' hh:mm:ss",
  _duration_minute: "mm",
  _duration_minute_hour: "hh:mm",
  _duration_minute_day: "d'd' hh:mm",
  _duration_minute_week: "d'd' hh:mm",
  _duration_minute_month: "M'm' dd'd' hh:mm",
  _duration_minute_year: "y'y' MM'm' dd'd' hh:mm",
  _duration_hour: "hh'h'",
  _duration_hour_day: "d'd' hh'h'",
  _duration_hour_week: "d'd' hh'h'",
  _duration_hour_month: "M'm' dd'd' hh'h'",
  _duration_hour_year: "y'y' MM'm' dd'd' hh'h'",
  _duration_day: "d'd'",
  _duration_day_week: "d'd'",
  _duration_day_month: "M'm' dd'd'",
  _duration_day_year: "y'y' MM'm' dd'd'",
  _duration_week: "w'w'",
  _duration_week_month: "w'w'",
  _duration_week_year: "w'w'",
  _duration_month: "M'm'",
  _duration_month_year: "y'y' MM'm'",
  _duration_year: "y'y'",
  // Era translations
  _era_ad: "AD",
  _era_bc: "BC",
  // Day part, used in 12-hour formats, e.g. 5 P.M.
  // Please note that these come in 3 variants:
  // * one letter (e.g. "A")
  // * two letters (e.g. "AM")
  // * two letters with dots (e.g. "A.M.")
  // 
  // All three need to to be translated even if they are all the same. Some
  // users might use one, some the other.
  A: "",
  P: "",
  AM: "",
  PM: "",
  "A.M.": "",
  "P.M.": "",
  // Date-related stuff.
  // 
  // When translating months, if there's a difference, use the form which is
  // best for a full date, e.g. as you would use it in "2018 January 1".
  // 
  // Note that May is listed twice. This is because in English May is the same
  // in both long and short forms, while in other languages it may not be the
  // case. Translate "May" to full word, while "May(short)" to shortened
  // version.
  // 
  // Should month names and weekdays be capitalized or not?
  // 
  // Rule of thumb is this: if the names should always be capitalized,
  // regardless of name position within date ("January", "21st January 2018",
  // etc.) use capitalized names. Otherwise enter all lowercase.
  // 
  // The date formatter will automatically capitalize names if they are the
  // first (or only) word in resulting date.
  January: "",
  February: "",
  March: "",
  April: "",
  May: "",
  June: "",
  July: "",
  August: "",
  September: "",
  October: "",
  November: "",
  December: "",
  Jan: "",
  Feb: "",
  Mar: "",
  Apr: "",
  "May(short)": "May",
  Jun: "",
  Jul: "",
  Aug: "",
  Sep: "",
  Oct: "",
  Nov: "",
  Dec: "",
  // Weekdays.
  Sunday: "",
  Monday: "",
  Tuesday: "",
  Wednesday: "",
  Thursday: "",
  Friday: "",
  Saturday: "",
  Sun: "",
  Mon: "",
  Tue: "",
  Wed: "",
  Thu: "",
  Fri: "",
  Sat: "",
  // Date ordinal function.
  // 
  // This is used when adding number ordinal when formatting days in dates.
  // 
  // E.g. "January 1st", "February 2nd".
  // 
  // The function accepts day number, and returns a string to be added to the
  // day, like in default English translation, if we pass in 2, we will receive
  // "nd" back.
  _dateOrd: function(i) {
    let e = "th";
    if (i < 11 || i > 13)
      switch (i % 10) {
        case 1:
          e = "st";
          break;
        case 2:
          e = "nd";
          break;
        case 3:
          e = "rd";
          break;
      }
    return e;
  },
  // Various chart controls.
  // Shown as a tooltip on zoom out button.
  "Zoom Out": "",
  // Timeline buttons
  Play: "",
  Stop: "",
  // Chart's Legend screen reader title.
  Legend: "",
  // Legend's item screen reader indicator.
  "Press ENTER to toggle": "",
  // Shown when the chart is busy loading something.
  Loading: "",
  // Shown as the first button in the breadcrumb navigation, e.g.:
  // Home > First level > ...
  Home: "",
  // Chart types.
  // Those are used as default screen reader titles for the main chart element
  // unless developer has set some more descriptive title.
  Chart: "",
  "Serial chart": "",
  "X/Y chart": "",
  "Pie chart": "",
  "Gauge chart": "",
  "Radar chart": "",
  "Sankey diagram": "",
  "Flow diagram": "",
  "Chord diagram": "",
  "TreeMap chart": "",
  "Force directed tree": "",
  "Sliced chart": "",
  // Series types.
  // Used to name series by type for screen readers if they do not have their
  // name set.
  Series: "",
  "Candlestick Series": "",
  "OHLC Series": "",
  "Column Series": "",
  "Line Series": "",
  "Pie Slice Series": "",
  "Funnel Series": "",
  "Pyramid Series": "",
  "X/Y Series": "",
  // Map-related stuff.
  Map: "",
  "Press ENTER to zoom in": "",
  "Press ENTER to zoom out": "",
  "Use arrow keys to zoom in and out": "",
  "Use plus and minus keys on your keyboard to zoom in and out": "",
  // Export-related stuff.
  // These prompts are used in Export menu labels.
  // 
  // "Export" is the top-level menu item.
  // 
  // "Image", "Data", "Print" as second-level indicating type of export
  // operation.
  // 
  // Leave actual format untranslated, unless you absolutely know that they
  // would convey more meaning in some other way.
  Export: "",
  Image: "",
  Data: "",
  Print: "",
  "Press ENTER or use arrow keys to navigate": "",
  "Press ENTER to open": "",
  "Press ENTER to print.": "",
  "Press ENTER to export as %1.": "",
  "(Press ESC to close this message)": "",
  "Image Export Complete": "",
  "Export operation took longer than expected. Something might have gone wrong.": "",
  "Saved from": "",
  PNG: "",
  JPG: "",
  GIF: "",
  SVG: "",
  PDF: "",
  JSON: "",
  CSV: "",
  XLSX: "",
  HTML: "",
  // Scrollbar-related stuff.
  // 
  // Scrollbar is a control which can zoom and pan the axes on the chart.
  // 
  // Each scrollbar has two grips: left or right (for horizontal scrollbar) or
  // upper and lower (for vertical one).
  // 
  // Prompts change in relation to whether Scrollbar is vertical or horizontal.
  // 
  // The final section is used to indicate the current range of selection.
  "Use TAB to select grip buttons or left and right arrows to change selection": "",
  "Use left and right arrows to move selection": "",
  "Use left and right arrows to move left selection": "",
  "Use left and right arrows to move right selection": "",
  "Use TAB select grip buttons or up and down arrows to change selection": "",
  "Use up and down arrows to move selection": "",
  "Use up and down arrows to move lower selection": "",
  "Use up and down arrows to move upper selection": "",
  "From %1 to %2": "",
  "From %1": "",
  "To %1": "",
  // Data loader-related.
  "No parser available for file: %1": "",
  "Error parsing file: %1": "",
  "Unable to load file: %1": "",
  "Invalid date": "",
  // Common actions
  Close: "",
  Minimize: ""
};
class W0 extends Se {
  _setDefaults() {
    this.setPrivate("defaultLocale", Td), super._setDefaults();
  }
  /**
   * Returns a prompt translation.
   *
   * @param   prompt   Prompt to translate
   * @param   locale   Target locale
   * @param   ...rest  Parameters
   * @return           Translation
   */
  translate(e, t, ...s) {
    t || (t = this._root.locale || this.getPrivate("defaultLocale"));
    let r = e, n = t[e];
    if (n === null)
      r = "";
    else if (n != null)
      n && (r = n);
    else if (t !== this.getPrivate("defaultLocale"))
      return this.translate(e, this.getPrivate("defaultLocale"), ...s);
    if (s.length)
      for (let a = s.length, o = 0; o < a; ++o)
        r = r.split("%" + (o + 1)).join(s[o]);
    return r;
  }
  /**
   * Returns a prompt translation, including custom prompts.
   *
   * @param   prompt   Prompt to translate
   * @param   locale   Target locale
   * @param   ...rest  Parameters
   * @return           Translation
   */
  translateAny(e, t, ...s) {
    return this.translate(e, t, ...s);
  }
  /**
   * Add a custom prompt to locale.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/locales/creating-translations/#Extending_locale_with_custom_prompts}
   * @param  prompt       Source prompt
   * @param  translation  Tanslation
   * @param  locale       Target locale
   */
  setTranslationAny(e, t, s) {
    const r = s || this._root.locale;
    r[e] = t;
  }
  /**
   * Add a batch of custom prompts.
   *
   * @since 5.3.3
   * @see {@link https://www.amcharts.com/docs/v5/concepts/locales/creating-translations/#Extending_locale_with_custom_prompts}
   * @param  translations  Translations
   * @param  locale        Target locale
   */
  setTranslationsAny(e, t) {
    _e(e, (s, r) => {
      this.setTranslationAny(s, r, t);
    });
  }
  translateEmpty(e, t, ...s) {
    let r = this.translate(e, t, ...s);
    return r == e ? "" : r;
  }
  translateFunc(e, t) {
    return this._root.locale[e] ? this._root.locale[e] : t !== this.getPrivate("defaultLocale") ? this.translateFunc(e, this.getPrivate("defaultLocale")) : () => "";
  }
  /**
   * Translates a btach of prompts.
   *
   * @param  list    Array of prompts to translate
   * @param  locale  Target locale
   * @return         Array of translations
   */
  translateAll(e, t) {
    return this.isDefault() ? e : Wn(e, (s) => this.translate(s, t));
  }
  /**
   * Returns `true` if the currently selected locale is a default locale.
   *
   * @return `true` if locale is default; `false` if it is not.
   */
  isDefault() {
    return this.getPrivate("defaultLocale") === this._root.locale;
  }
}
class rn {
  constructor(e, t) {
    if (Object.defineProperty(this, "_root", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_rules", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), this._root = e, !t)
      throw new Error("You cannot use `new Class()`, instead use `Class.new()`");
  }
  /**
   * Use this method to create an instance of this class.
   *
   * @see {@link https://www.amcharts.com/docs/v5/getting-started/#New_element_syntax} for more info
   * @param   root      Root element
   * @param   settings  Settings
   * @param   template  Template
   * @return            Instantiated object
   */
  static new(e) {
    const t = new this(e, !0);
    return t.setupDefaultRules(), t;
  }
  setupDefaultRules() {
  }
  /**
   * Looks up the rules for a specific theme class.
   *
   * @see {@link https://www.amcharts.com/docs/v5/themes/} for more info
   * @param   themeClass Theme class
   * @return             Array<IRule<A>>
   */
  _lookupRules(e) {
    return this._rules[e];
  }
  /**
   * Creates a [[Template]] for specific theme class and tags.
   *
   * NOTE: the difference from `rule()` is that `ruleRaw()` does not do any
   * type checks.
   *
   * @see {@link https://www.amcharts.com/docs/v5/themes/} for more info
   * @param   themeClass Theme class
   * @param   themeTags  Theme tags
   * @return             Template
   */
  ruleRaw(e, t = []) {
    let s = this._rules[e];
    s || (s = this._rules[e] = []), t.sort(Et);
    const { index: r, found: n } = ji(s, (a) => {
      const o = Et(a.tags.length, t.length);
      return o === 0 ? yd(a.tags, t, Et) : o;
    });
    if (n)
      return s[r].template;
    {
      const a = me.new({});
      return s.splice(r, 0, {
        tags: t,
        template: a
      }), a;
    }
  }
  /**
   * Creates a [[Template]] for specific theme class and tags.
   *
   * @see {@link https://www.amcharts.com/docs/v5/themes/} for more info
   * @param   themeClass Theme class
   * @param   themeTags  Theme tags
   * @return             Template
   */
  rule(e, t = []) {
    return this.ruleRaw(e, t);
  }
}
function K(i, e, t, s) {
  i.set(e, t.get(s)), t.on(s, (r) => {
    i.set(e, r);
  });
}
class G0 extends rn {
  setupDefaultRules() {
    super.setupDefaultRules();
    const e = this._root.language, t = this._root.interfaceColors, s = this._root.horizontalLayout, r = this._root.verticalLayout, n = this.rule.bind(this);
    n("InterfaceColors").setAll({
      stroke: X.fromHex(15066597),
      fill: X.fromHex(15987699),
      primaryButton: X.fromHex(6788316),
      primaryButtonHover: X.fromHex(6779356),
      primaryButtonDown: X.fromHex(6872182),
      primaryButtonActive: X.fromHex(6872182),
      primaryButtonText: X.fromHex(16777215),
      primaryButtonStroke: X.fromHex(16777215),
      secondaryButton: X.fromHex(14277081),
      secondaryButtonHover: X.fromHex(10724259),
      secondaryButtonDown: X.fromHex(9276813),
      secondaryButtonActive: X.fromHex(15132390),
      secondaryButtonText: X.fromHex(0),
      secondaryButtonStroke: X.fromHex(16777215),
      grid: X.fromHex(0),
      background: X.fromHex(16777215),
      alternativeBackground: X.fromHex(0),
      text: X.fromHex(0),
      alternativeText: X.fromHex(16777215),
      disabled: X.fromHex(11382189),
      positive: X.fromHex(5288704),
      negative: X.fromHex(11730944)
    });
    {
      const a = n("ColorSet");
      a.setAll({
        passOptions: {
          hue: 0.05,
          saturation: 0,
          lightness: 0
        },
        colors: [
          X.fromHex(6797276)
        ],
        step: 1,
        //baseColor: Color.fromRGB(103, 183, 220),
        //count: 20,
        reuse: !1,
        startIndex: 0
      }), a.setPrivate("currentStep", 0), a.setPrivate("currentPass", 0);
    }
    n("Entity").setAll({
      stateAnimationDuration: 0,
      stateAnimationEasing: yr(As)
    }), n("Component").setAll({
      interpolationDuration: 0,
      interpolationEasing: yr(As)
    }), n("Sprite").setAll({
      visible: !0,
      scale: 1,
      opacity: 1,
      rotation: 0,
      position: "relative",
      tooltipX: ce,
      tooltipY: ce,
      tooltipPosition: "fixed",
      isMeasured: !0
    }), n("Sprite").states.create("default", { visible: !0, opacity: 1 }), n("Container").setAll({
      interactiveChildren: !0,
      setStateOnChildren: !1
    }), n("Graphics").setAll({
      strokeWidth: 1
    }), n("Chart").setAll({
      width: R,
      height: R,
      interactiveChildren: !1
    }), n("Sprite", ["horizontal", "center"]).setAll({
      centerX: ce,
      x: ce
    }), n("Sprite", ["vertical", "center"]).setAll({
      centerY: ce,
      y: ce
    }), n("Container", ["horizontal", "layout"]).setAll({
      layout: s
    }), n("Container", ["vertical", "layout"]).setAll({
      layout: r
    }), n("Pattern").setAll({
      repetition: "repeat",
      width: 50,
      height: 50,
      rotation: 0,
      fillOpacity: 1
    }), n("LinePattern").setAll({
      gap: 6,
      colorOpacity: 1,
      width: 49,
      height: 49
    }), n("RectanglePattern").setAll({
      gap: 6,
      checkered: !1,
      centered: !0,
      maxWidth: 5,
      maxHeight: 5,
      width: 48,
      height: 48,
      strokeWidth: 0
    }), n("CirclePattern").setAll({
      gap: 5,
      checkered: !1,
      centered: !1,
      radius: 3,
      strokeWidth: 0,
      width: 45,
      height: 45
    }), n("LinearGradient").setAll({
      rotation: 90
    }), n("Legend").setAll({
      fillField: "fill",
      strokeField: "stroke",
      nameField: "name",
      layout: gi.new(this._root, {}),
      layer: 30,
      clickTarget: "itemContainer"
    }), n("Container", ["legend", "item", "itemcontainer"]).setAll({
      paddingLeft: 5,
      paddingRight: 5,
      paddingBottom: 5,
      paddingTop: 5,
      layout: s,
      setStateOnChildren: !0,
      interactiveChildren: !1,
      ariaChecked: !0,
      focusable: !0,
      ariaLabel: e.translate("Press ENTER to toggle"),
      role: "checkbox"
    });
    {
      const a = n("Rectangle", ["legend", "item", "background"]);
      a.setAll({
        fillOpacity: 0
      }), K(a, "fill", t, "background");
    }
    n("Container", ["legend", "marker"]).setAll({
      setStateOnChildren: !0,
      centerY: ce,
      paddingLeft: 0,
      paddingRight: 0,
      paddingBottom: 0,
      paddingTop: 0,
      width: 18,
      height: 18
    }), n("RoundedRectangle", ["legend", "marker", "rectangle"]).setAll({
      width: R,
      height: R,
      cornerRadiusBL: 3,
      cornerRadiusTL: 3,
      cornerRadiusBR: 3,
      cornerRadiusTR: 3
    });
    {
      const a = n("RoundedRectangle", ["legend", "marker", "rectangle"]).states.create("disabled", {});
      K(a, "fill", t, "disabled"), K(a, "stroke", t, "disabled");
    }
    n("Label", ["legend", "label"]).setAll({
      centerY: ce,
      marginLeft: 5,
      paddingRight: 0,
      paddingLeft: 0,
      paddingTop: 0,
      paddingBottom: 0,
      populateText: !0
    });
    {
      const a = n("Label", ["legend", "label"]).states.create("disabled", {});
      K(a, "fill", t, "disabled");
    }
    n("Label", ["legend", "value", "label"]).setAll({
      centerY: ce,
      marginLeft: 5,
      paddingRight: 0,
      paddingLeft: 0,
      paddingTop: 0,
      paddingBottom: 0,
      width: 50,
      centerX: R,
      populateText: !0
    });
    {
      const a = n("Label", ["legend", "value", "label"]).states.create("disabled", {});
      K(a, "fill", t, "disabled");
    }
    n("HeatLegend").setAll({
      stepCount: 1
    }), n("RoundedRectangle", ["heatlegend", "marker"]).setAll({
      cornerRadiusTR: 0,
      cornerRadiusBR: 0,
      cornerRadiusTL: 0,
      cornerRadiusBL: 0
    }), n("RoundedRectangle", ["vertical", "heatlegend", "marker"]).setAll({
      height: R,
      width: 15
    }), n("RoundedRectangle", ["horizontal", "heatlegend", "marker"]).setAll({
      width: R,
      height: 15
    }), n("HeatLegend", ["vertical"]).setAll({
      height: R
    }), n("HeatLegend", ["horizontal"]).setAll({
      width: R
    }), n("Label", ["heatlegend", "start"]).setAll({
      paddingLeft: 5,
      paddingRight: 5,
      paddingTop: 5,
      paddingBottom: 5
    }), n("Label", ["heatlegend", "end"]).setAll({
      paddingLeft: 5,
      paddingRight: 5,
      paddingTop: 5,
      paddingBottom: 5
    });
    {
      const a = n("Label");
      a.setAll({
        paddingTop: 8,
        paddingBottom: 8,
        paddingLeft: 10,
        paddingRight: 10,
        fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"',
        fontSize: "1em",
        populateText: !1
      }), K(a, "fill", t, "text");
    }
    n("RadialLabel").setAll({
      textType: "regular",
      centerY: ce,
      centerX: ce,
      inside: !1,
      radius: 0,
      baseRadius: R,
      orientation: "auto",
      textAlign: "center"
    }), n("RoundedRectangle").setAll({
      cornerRadiusTL: 8,
      cornerRadiusBL: 8,
      cornerRadiusTR: 8,
      cornerRadiusBR: 8
    }), n("PointedRectangle").setAll({
      pointerBaseWidth: 15,
      pointerLength: 10,
      cornerRadius: 8
    }), n("Slice").setAll({
      shiftRadius: 0,
      dRadius: 0,
      dInnerRadius: 0
    });
    {
      const a = n("Tick");
      a.setAll({
        strokeOpacity: 0.15,
        isMeasured: !1,
        length: 4.5,
        position: "absolute",
        crisp: !0
      }), K(a, "stroke", t, "grid");
    }
    n("Bullet").setAll({
      locationX: 0.5,
      locationY: 0.5
    }), n("Tooltip").setAll({
      position: "absolute",
      getFillFromSprite: !0,
      getStrokeFromSprite: !1,
      autoTextColor: !0,
      paddingTop: 9,
      paddingBottom: 8,
      paddingLeft: 10,
      paddingRight: 10,
      marginBottom: 5,
      pointerOrientation: "vertical",
      centerX: ce,
      centerY: ce,
      animationEasing: yr(As),
      exportable: !1
      //layer: 100
    }), n("PointedRectangle", ["tooltip", "background"]).setAll({
      strokeOpacity: 0.9,
      cornerRadius: 4,
      pointerLength: 4,
      pointerBaseWidth: 8,
      fillOpacity: 0.9,
      stroke: X.fromHex(16777215)
    });
    {
      const a = n("Label", ["tooltip"]);
      a.setAll({
        role: "tooltip",
        populateText: !0,
        paddingRight: 0,
        paddingTop: 0,
        paddingLeft: 0,
        paddingBottom: 0
      }), K(a, "fill", t, "alternativeText");
    }
    n("Button").setAll({
      paddingTop: 8,
      paddingBottom: 8,
      paddingLeft: 10,
      paddingRight: 10,
      interactive: !0,
      layout: s,
      interactiveChildren: !1,
      setStateOnChildren: !0,
      focusable: !0
    }), n("Button").states.create("hover", {}), n("Button").states.create("down", { stateAnimationDuration: 0 }), n("Button").states.create("active", {});
    {
      const a = n("RoundedRectangle", ["button", "background"]);
      K(a, "fill", t, "primaryButton"), K(a, "stroke", t, "primaryButtonStroke");
    }
    {
      const a = n("RoundedRectangle", ["button", "background"]).states.create("hover", {});
      K(a, "fill", t, "primaryButtonHover");
    }
    {
      const a = n("RoundedRectangle", ["button", "background"]).states.create("down", { stateAnimationDuration: 0 });
      K(a, "fill", t, "primaryButtonDown");
    }
    {
      const a = n("RoundedRectangle", ["button", "background"]).states.create("active", {});
      K(a, "fill", t, "primaryButtonActive");
    }
    {
      const a = n("Graphics", ["button", "icon"]);
      K(a, "stroke", t, "primaryButtonText");
    }
    {
      const a = n("Label", ["button"]);
      K(a, "fill", t, "primaryButtonText");
    }
    n("Button", ["zoom"]).setAll({
      paddingTop: 18,
      paddingBottom: 18,
      paddingLeft: 12,
      paddingRight: 12,
      centerX: 46,
      centerY: -10,
      y: 0,
      x: R,
      role: "button",
      ariaLabel: e.translate("Zoom Out"),
      layer: 30
    });
    {
      const a = n("RoundedRectangle", ["background", "button", "zoom"]);
      a.setAll({
        cornerRadiusBL: 40,
        cornerRadiusBR: 40,
        cornerRadiusTL: 40,
        cornerRadiusTR: 40
      }), K(a, "fill", t, "primaryButton");
    }
    {
      const a = n("RoundedRectangle", ["background", "button", "zoom"]).states.create("hover", {});
      K(a, "fill", t, "primaryButtonHover");
    }
    {
      const a = n("RoundedRectangle", ["background", "button", "zoom"]).states.create("down", { stateAnimationDuration: 0 });
      K(a, "fill", t, "primaryButtonDown");
    }
    {
      const a = n("Graphics", ["icon", "button", "zoom"]);
      a.setAll({
        crisp: !0,
        strokeOpacity: 0.7,
        draw: (o) => {
          o.moveTo(0, 0), o.lineTo(12, 0);
        }
      }), K(a, "stroke", t, "primaryButtonText");
    }
    n("Button", ["resize"]).setAll({
      paddingTop: 9,
      paddingBottom: 9,
      paddingLeft: 13,
      paddingRight: 13,
      draggable: !0,
      centerX: ce,
      centerY: ce,
      position: "absolute",
      role: "slider",
      ariaValueMin: "0",
      ariaValueMax: "100",
      ariaLabel: e.translate("Use up and down arrows to move selection")
    });
    {
      const a = n("RoundedRectangle", ["background", "resize", "button"]);
      a.setAll({
        cornerRadiusBL: 40,
        cornerRadiusBR: 40,
        cornerRadiusTL: 40,
        cornerRadiusTR: 40
      }), K(a, "fill", t, "secondaryButton"), K(a, "stroke", t, "secondaryButtonStroke");
    }
    {
      const a = n("RoundedRectangle", ["background", "resize", "button"]).states.create("hover", {});
      K(a, "fill", t, "secondaryButtonHover");
    }
    {
      const a = n("RoundedRectangle", ["background", "resize", "button"]).states.create("down", { stateAnimationDuration: 0 });
      K(a, "fill", t, "secondaryButtonDown");
    }
    {
      const a = n("Graphics", ["resize", "button", "icon"]);
      a.setAll({
        interactive: !1,
        crisp: !0,
        strokeOpacity: 0.5,
        draw: (o) => {
          o.moveTo(0, 0.5), o.lineTo(0, 12.5), o.moveTo(4, 0.5), o.lineTo(4, 12.5);
        }
      }), K(a, "stroke", t, "secondaryButtonText");
    }
    n("Button", ["resize", "vertical"]).setAll({
      rotation: 90,
      cursorOverStyle: "ns-resize"
    }), n("Button", ["resize", "horizontal"]).setAll({
      cursorOverStyle: "ew-resize"
    }), n("Button", ["play"]).setAll({
      paddingTop: 13,
      paddingBottom: 13,
      paddingLeft: 14,
      paddingRight: 14,
      ariaLabel: e.translate("Play"),
      toggleKey: "active"
    });
    {
      const a = n("RoundedRectangle", ["play", "background"]);
      a.setAll({
        strokeOpacity: 0.5,
        cornerRadiusBL: 100,
        cornerRadiusBR: 100,
        cornerRadiusTL: 100,
        cornerRadiusTR: 100
      }), K(a, "fill", t, "primaryButton");
    }
    {
      const a = n("Graphics", ["play", "icon"]);
      a.setAll({
        stateAnimationDuration: 0,
        dx: 1,
        draw: (o) => {
          o.moveTo(0, -5), o.lineTo(8, 0), o.lineTo(0, 5), o.lineTo(0, -5);
        }
      }), K(a, "fill", t, "primaryButtonText");
    }
    n("Graphics", ["play", "icon"]).states.create("default", {
      stateAnimationDuration: 0
    }), n("Graphics", ["play", "icon"]).states.create("active", {
      stateAnimationDuration: 0,
      draw: (a) => {
        a.moveTo(-4, -5), a.lineTo(-1, -5), a.lineTo(-1, 5), a.lineTo(-4, 5), a.lineTo(-4, -5), a.moveTo(4, -5), a.lineTo(1, -5), a.lineTo(1, 5), a.lineTo(4, 5), a.lineTo(4, -5);
      }
    }), n("Button", ["switch"]).setAll({
      paddingTop: 4,
      paddingBottom: 4,
      paddingLeft: 4,
      paddingRight: 4,
      ariaLabel: e.translate("Press ENTER to toggle"),
      toggleKey: "active",
      width: 40,
      height: 24,
      layout: null
    });
    {
      const a = n("RoundedRectangle", ["switch", "background"]);
      a.setAll({
        strokeOpacity: 0.5,
        cornerRadiusBL: 100,
        cornerRadiusBR: 100,
        cornerRadiusTL: 100,
        cornerRadiusTR: 100
      }), K(a, "fill", t, "primaryButton");
    }
    {
      const a = n("Circle", ["switch", "icon"]);
      a.setAll({
        radius: 8,
        centerY: 0,
        centerX: 0,
        dx: 0
      }), K(a, "fill", t, "primaryButtonText");
    }
    n("Graphics", ["switch", "icon"]).states.create("active", {
      dx: 16
    }), n("Scrollbar").setAll({
      start: 0,
      end: 1,
      layer: 30,
      animationEasing: yr(As)
    }), n("Scrollbar", ["vertical"]).setAll({
      marginRight: 13,
      marginLeft: 13,
      minWidth: 12,
      height: R
    }), n("Scrollbar", ["horizontal"]).setAll({
      marginTop: 13,
      marginBottom: 13,
      minHeight: 12,
      width: R
    }), this.rule("Button", ["scrollbar"]).setAll({
      exportable: !1
    });
    {
      const a = n("RoundedRectangle", ["scrollbar", "main", "background"]);
      a.setAll({
        cornerRadiusTL: 8,
        cornerRadiusBL: 8,
        cornerRadiusTR: 8,
        cornerRadiusBR: 8,
        fillOpacity: 0.8
      }), K(a, "fill", t, "fill");
    }
    {
      const a = n("RoundedRectangle", ["scrollbar", "thumb"]);
      a.setAll({
        role: "slider",
        ariaLive: "polite",
        position: "absolute",
        draggable: !0
      }), K(a, "fill", t, "secondaryButton");
    }
    {
      const a = n("RoundedRectangle", ["scrollbar", "thumb"]).states.create("hover", {});
      K(a, "fill", t, "secondaryButtonHover");
    }
    {
      const a = n("RoundedRectangle", ["scrollbar", "thumb"]).states.create("down", { stateAnimationDuration: 0 });
      K(a, "fill", t, "secondaryButtonDown");
    }
    n("RoundedRectangle", ["scrollbar", "thumb", "vertical"]).setAll({
      x: ce,
      width: R,
      centerX: ce,
      ariaLabel: e.translate("Use up and down arrows to move selection")
    }), n("RoundedRectangle", ["scrollbar", "thumb", "horizontal"]).setAll({
      y: ce,
      centerY: ce,
      height: R,
      ariaLabel: e.translate("Use left and right arrows to move selection")
    });
    {
      const a = n("PointedRectangle", ["axis", "tooltip", "background"]);
      a.setAll({
        cornerRadius: 0
      }), K(a, "fill", t, "alternativeBackground");
    }
    n("Label", ["axis", "tooltip"]).setAll({
      role: void 0
    }), n("Label", ["axis", "tooltip", "y"]).setAll({
      textAlign: "right"
    }), n("Label", ["axis", "tooltip", "y", "opposite"]).setAll({
      textAlign: "left"
    }), n("Label", ["axis", "tooltip", "x"]).setAll({
      textAlign: "center"
    }), n("Tooltip", ["categoryaxis"]).setAll({
      labelText: "{category}"
    }), n("Star").setAll({
      spikes: 5,
      innerRadius: 5,
      radius: 10
    }), n("Tooltip", ["stock"]).setAll({
      paddingTop: 6,
      paddingBottom: 5,
      paddingLeft: 7,
      paddingRight: 7
    }), n("PointedRectangle", ["tooltip", "stock", "axis"]).setAll({
      pointerLength: 0,
      pointerBaseWidth: 0,
      cornerRadius: 3
    }), n("Label", ["tooltip", "stock"]).setAll({
      fontSize: "0.8em"
    }), n("SpriteResizer").setAll({
      rotationStep: 10
    }), n("Container", ["resizer", "grip"]).states.create("hover", {});
    {
      const a = n("RoundedRectangle", ["resizer", "grip"]);
      a.setAll({
        strokeOpacity: 0.7,
        strokeWidth: 1,
        fillOpacity: 1,
        width: 12,
        height: 12
      }), K(a, "fill", t, "background"), K(a, "stroke", t, "alternativeBackground");
    }
    {
      const a = n("RoundedRectangle", ["resizer", "grip", "outline"]);
      a.setAll({
        strokeOpacity: 0,
        fillOpacity: 0,
        width: 20,
        height: 20
      }), a.states.create("hover", {
        fillOpacity: 0.3
      }), K(a, "fill", t, "alternativeBackground");
    }
    n("RoundedRectangle", ["resizer", "grip", "left"]).setAll({
      cornerRadiusBL: 0,
      cornerRadiusBR: 0,
      cornerRadiusTL: 0,
      cornerRadiusTR: 0
    }), n("RoundedRectangle", ["resizer", "grip", "right"]).setAll({
      cornerRadiusBL: 0,
      cornerRadiusBR: 0,
      cornerRadiusTL: 0,
      cornerRadiusTR: 0
    });
    {
      const a = n("Rectangle", ["resizer", "rectangle"]);
      a.setAll({
        strokeDasharray: [2, 2],
        strokeOpacity: 0.5,
        strokeWidth: 1
      }), K(a, "stroke", t, "alternativeBackground");
    }
  }
}
class co {
  constructor(e = 1, t = 0, s = 0, r = 1, n = 0, a = 0) {
    Object.defineProperty(this, "a", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "b", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "c", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "d", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tx", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "ty", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.a = e, this.b = t, this.c = s, this.d = r, this.tx = n, this.ty = a;
  }
  /**
   * Sets the matrix based on all the available properties
   */
  setTransform(e, t, s, r, n, a = 1) {
    this.a = Math.cos(n) * a, this.b = Math.sin(n) * a, this.c = -Math.sin(n) * a, this.d = Math.cos(n) * a, this.tx = e - (s * this.a + r * this.c), this.ty = t - (s * this.b + r * this.d);
  }
  /**
   * Get a new position with the current transformation applied.
   * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)
   */
  apply(e) {
    return {
      x: this.a * e.x + this.c * e.y + this.tx,
      y: this.b * e.x + this.d * e.y + this.ty
    };
  }
  /**
   * Get a new position with the inverse of the current transformation applied.
   * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)
   */
  applyInverse(e) {
    const t = 1 / (this.a * this.d + this.c * -this.b);
    return {
      x: this.d * t * e.x + -this.c * t * e.y + (this.ty * this.c - this.tx * this.d) * t,
      y: this.a * t * e.y + -this.b * t * e.x + (-this.ty * this.a + this.tx * this.b) * t
    };
  }
  /**
   * Appends the given Matrix to this Matrix.
   */
  append(e) {
    const t = this.a, s = this.b, r = this.c, n = this.d;
    this.a = e.a * t + e.b * r, this.b = e.a * s + e.b * n, this.c = e.c * t + e.d * r, this.d = e.c * s + e.d * n, this.tx = e.tx * t + e.ty * r + this.tx, this.ty = e.tx * s + e.ty * n + this.ty;
  }
  /**
   * Prepends the given Matrix to this Matrix.
   */
  prepend(e) {
    const t = this.tx;
    if (e.a !== 1 || e.b !== 0 || e.c !== 0 || e.d !== 1) {
      const s = this.a, r = this.c;
      this.a = s * e.a + this.b * e.c, this.b = s * e.b + this.b * e.d, this.c = r * e.a + this.d * e.c, this.d = r * e.b + this.d * e.d;
    }
    this.tx = t * e.a + this.ty * e.c + e.tx, this.ty = t * e.b + this.ty * e.d + e.ty;
  }
  /**
   * Copies the other matrix's properties into this matrix
   */
  copyFrom(e) {
    this.a = e.a, this.b = e.b, this.c = e.c, this.d = e.d, this.tx = e.tx, this.ty = e.ty;
  }
}
var Z0 = function() {
  function i(e, t) {
    var s = [], r = !0, n = !1, a = void 0;
    try {
      for (var o = e[Symbol.iterator](), l; !(r = (l = o.next()).done) && (s.push(l.value), !(t && s.length === t)); r = !0)
        ;
    } catch (u) {
      n = !0, a = u;
    } finally {
      try {
        !r && o.return && o.return();
      } finally {
        if (n)
          throw a;
      }
    }
    return s;
  }
  return function(e, t) {
    if (Array.isArray(e))
      return e;
    if (Symbol.iterator in Object(e))
      return i(e, t);
    throw new TypeError("Invalid attempt to destructure non-iterable instance");
  };
}(), Ar = Math.PI * 2, fo = function(e, t, s, r, n, a, o) {
  var l = e.x, u = e.y;
  l *= t, u *= s;
  var c = r * l - n * u, h = n * l + r * u;
  return {
    x: c + a,
    y: h + o
  };
}, K0 = function(e, t) {
  var s = t === 1.5707963267948966 ? 0.551915024494 : t === -1.5707963267948966 ? -0.551915024494 : 1.3333333333333333 * Math.tan(t / 4), r = Math.cos(e), n = Math.sin(e), a = Math.cos(e + t), o = Math.sin(e + t);
  return [{
    x: r - n * s,
    y: n + r * s
  }, {
    x: a + o * s,
    y: o - a * s
  }, {
    x: a,
    y: o
  }];
}, Uu = function(e, t, s, r) {
  var n = e * r - t * s < 0 ? -1 : 1, a = e * s + t * r;
  return a > 1 && (a = 1), a < -1 && (a = -1), n * Math.acos(a);
}, Q0 = function(e, t, s, r, n, a, o, l, u, c, h, d) {
  var f = Math.pow(n, 2), g = Math.pow(a, 2), p = Math.pow(h, 2), _ = Math.pow(d, 2), m = f * g - f * _ - g * p;
  m < 0 && (m = 0), m /= f * _ + g * p, m = Math.sqrt(m) * (o === l ? -1 : 1);
  var v = m * n / a * d, b = m * -a / n * h, y = c * v - u * b + (e + s) / 2, x = u * v + c * b + (t + r) / 2, D = (h - v) / n, A = (d - b) / a, T = (-h - v) / n, j = (-d - b) / a, C = Uu(1, 0, D, A), L = Uu(D, A, T, j);
  return l === 0 && L > 0 && (L -= Ar), l === 1 && L < 0 && (L += Ar), [y, x, C, L];
}, q0 = function(e) {
  var t = e.px, s = e.py, r = e.cx, n = e.cy, a = e.rx, o = e.ry, l = e.xAxisRotation, u = l === void 0 ? 0 : l, c = e.largeArcFlag, h = c === void 0 ? 0 : c, d = e.sweepFlag, f = d === void 0 ? 0 : d, g = [];
  if (a === 0 || o === 0)
    return [];
  var p = Math.sin(u * Ar / 360), _ = Math.cos(u * Ar / 360), m = _ * (t - r) / 2 + p * (s - n) / 2, v = -p * (t - r) / 2 + _ * (s - n) / 2;
  if (m === 0 && v === 0)
    return [];
  a = Math.abs(a), o = Math.abs(o);
  var b = Math.pow(m, 2) / Math.pow(a, 2) + Math.pow(v, 2) / Math.pow(o, 2);
  b > 1 && (a *= Math.sqrt(b), o *= Math.sqrt(b));
  var y = Q0(t, s, r, n, a, o, h, f, p, _, m, v), x = Z0(y, 4), D = x[0], A = x[1], T = x[2], j = x[3], C = Math.abs(j) / (Ar / 4);
  Math.abs(1 - C) < 1e-7 && (C = 1);
  var L = Math.max(Math.ceil(C), 1);
  j /= L;
  for (var E = 0; E < L; E++)
    g.push(K0(T, j)), T += j;
  return g.map(function(N) {
    var q = fo(N[0], a, o, _, p, D, A), z = q.x, H = q.y, Y = fo(N[1], a, o, _, p, D, A), W = Y.x, B = Y.y, oe = fo(N[2], a, o, _, p, D, A), O = oe.x, k = oe.y;
    return { x1: z, y1: H, x2: W, y2: B, x: O, y: k };
  });
};
function J0(i, e, t) {
  if (e !== t)
    throw new Error("Required " + t + " arguments for " + i + " but got " + e);
}
function vr(i, e, t) {
  if (e < t)
    throw new Error("Required at least " + t + " arguments for " + i + " but got " + e);
}
function St(i, e, t) {
  if (vr(i, e, t), e % t !== 0)
    throw new Error("Arguments for " + i + " must be in pairs of " + t);
}
function ew(i) {
  for (let e = 0; e < i.length; e += 7) {
    let t = e + 3, s = i[t];
    if (s.length > 1) {
      const r = /^([01])([01])(.*)$/.exec(s);
      r !== null && (i.splice(t, 0, r[1]), ++t, i.splice(t, 0, r[2]), ++t, r[3].length > 0 ? i[t] = r[3] : i.splice(t, 1));
    }
    if (++t, s = i[t], s.length > 1) {
      const r = /^([01])(.+)$/.exec(s);
      r !== null && (i.splice(t, 0, r[1]), ++t, i[t] = r[2]);
    }
  }
}
function Wu(i) {
  if (i === 0 || i === 1)
    return i;
  throw new Error("Flag must be 0 or 1");
}
function tw(i) {
  const e = [0, 0, 0];
  for (let t = 0; t < 24; t++)
    e[t % 3] <<= 1, e[t % 3] |= i & 1, i >>= 1;
  return (e[2] | 0) + (e[1] << 8) + (e[0] << 16);
}
function _n(i, e) {
  for (; !(i.interactive && !e(i)); )
    if (i._parent)
      i = i._parent;
    else
      break;
}
function iw(i, e, t) {
  return Le(i, Qn(e), (s) => {
    let r = s.touches;
    r ? (r.length == 0 && (r = s.changedTouches), t(Gn(r))) : t([s]);
  });
}
function Gu(i) {
  const e = document.createElement("canvas");
  e.width = 1, e.height = 1;
  const t = e.getContext("2d", { willReadFrequently: !0 });
  t.drawImage(i, 0, 0, 1, 1);
  try {
    return t.getImageData(0, 0, 1, 1), !1;
  } catch {
    return console.warn('Image "' + i.src + '" is loaded from different host and is not covered by CORS policy. For more information about the implications read here: https://www.amcharts.com/docs/v5/concepts/cors'), !0;
  }
}
function xr(i) {
  i.width = 0, i.height = 0, i.style.width = "0px", i.style.height = "0px";
}
class sw {
  constructor() {
    Object.defineProperty(this, "_x", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_y", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    });
  }
  get x() {
    return this._x;
  }
  get y() {
    return this._y;
  }
  set x(e) {
    this._x = e;
  }
  set y(e) {
    this._y = e;
  }
}
class qa extends ar {
  constructor(e) {
    super(), Object.defineProperty(this, "_layer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "mask", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "visible", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "exportable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "interactive", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "inactive", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "wheelable", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "cancelTouch", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "isMeasured", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "buttonMode", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "alpha", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), Object.defineProperty(this, "compoundAlpha", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), Object.defineProperty(this, "angle", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "scale", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), Object.defineProperty(this, "x", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "y", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "crisp", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "pivot", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new sw()
    }), Object.defineProperty(this, "filter", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "cursorOverStyle", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_replacedCursorStyle", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_localMatrix", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new co()
    }), Object.defineProperty(this, "_matrix", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new co()
    }), Object.defineProperty(this, "_uMatrix", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new co()
    }), Object.defineProperty(this, "_renderer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_parent", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_localBounds", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_bounds", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_colorId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._renderer = e;
  }
  _dispose() {
    this._renderer._removeObject(this), this.getLayer().dirty = !0;
  }
  getCanvas() {
    return this.getLayer().view;
  }
  getLayer() {
    let e = this;
    for (; ; ) {
      if (e._layer)
        return e._layer;
      if (e._parent)
        e = e._parent;
      else
        return this._renderer.defaultLayer;
    }
  }
  setLayer(e, t) {
    e == null ? this._layer = void 0 : (this._layer = this._renderer.getLayer(e, !0), this._layer.visible = !0, this._layer.margin = t, t && Os(this._layer.view, !1), this._renderer._ghostLayer.setMargin(this._renderer.layers), this._parent && this._parent.registerChildLayer(this._layer), this._layer.dirty = !0, this._renderer.resizeLayer(this._layer), this._renderer.resizeGhost());
  }
  markDirtyLayer() {
    this.getLayer().dirty = !0;
  }
  clear() {
    this.invalidateBounds();
  }
  invalidateBounds() {
    this._localBounds = void 0;
  }
  _addBounds(e) {
  }
  _getColorId() {
    return this._colorId === void 0 && (this._colorId = this._renderer.paintId(this)), this._colorId;
  }
  _isInteractive() {
    return this.inactive == !1 && (this.interactive || this._renderer._forceInteractive > 0);
  }
  _isInteractiveMask() {
    return this._isInteractive();
  }
  contains(e) {
    for (; ; ) {
      if (e === this)
        return !0;
      if (e._parent)
        e = e._parent;
      else
        return !1;
    }
  }
  toGlobal(e) {
    return this._matrix.apply(e);
  }
  toLocal(e) {
    return this._matrix.applyInverse(e);
  }
  getLocalMatrix() {
    return this._uMatrix.setTransform(0, 0, this.pivot.x, this.pivot.y, this.angle * Math.PI / 180, this.scale), this._uMatrix;
  }
  getLocalBounds() {
    return this._localBounds || (this._localBounds = {
      left: 1e7,
      top: 1e7,
      right: -1e7,
      bottom: -1e7
    }, this._addBounds(this._localBounds)), this._localBounds;
  }
  getAdjustedBounds(e) {
    this._setMatrix();
    const t = this.getLocalMatrix(), s = t.apply({ x: e.left, y: e.top }), r = t.apply({ x: e.right, y: e.top }), n = t.apply({ x: e.right, y: e.bottom }), a = t.apply({ x: e.left, y: e.bottom });
    return {
      left: Math.min(s.x, r.x, n.x, a.x),
      top: Math.min(s.y, r.y, n.y, a.y),
      right: Math.max(s.x, r.x, n.x, a.x),
      bottom: Math.max(s.y, r.y, n.y, a.y)
    };
  }
  on(e, t, s) {
    return this.interactive ? this._renderer._addEvent(this, e, t, s) : new He(() => {
    });
  }
  _setMatrix() {
    this._localMatrix.setTransform(
      this.x,
      this.y,
      this.pivot.x,
      this.pivot.y,
      // Converts degrees to radians
      this.angle * Math.PI / 180,
      this.scale
    ), this._matrix.copyFrom(this._localMatrix), this._parent && this._matrix.prepend(this._parent._matrix);
  }
  _transform(e, t) {
    const s = this._matrix;
    let r = s.tx * t, n = s.ty * t;
    this.crisp && (r = Math.floor(r) + 0.5, n = Math.floor(n) + 0.5), e.setTransform(s.a * t, s.b * t, s.c * t, s.d * t, r, n);
  }
  _transformMargin(e, t, s) {
    const r = this._matrix;
    e.setTransform(r.a * t, r.b * t, r.c * t, r.d * t, (r.tx + s.left) * t, (r.ty + s.top) * t);
  }
  _transformLayer(e, t, s) {
    s.margin ? this._transformMargin(e, s.scale || t, s.margin) : this._transform(e, s.scale || t);
  }
  render(e) {
    if (this.visible && (this.exportable !== !1 || !this._renderer._omitTainted)) {
      this._setMatrix();
      const t = this._renderer.resolution, s = this._renderer.layers, r = this._renderer._ghostLayer, n = r.context, a = this.mask;
      a && a._setMatrix(), w(s, (o) => {
        if (o) {
          const l = o.context;
          l.save(), a && (a._transformLayer(l, t, o), a._runPath(l), l.clip()), l.globalAlpha = this.compoundAlpha * this.alpha, this._transformLayer(l, t, o), this.filter && (l.filter = this.filter);
        }
      }), n.save(), a && this._isInteractiveMask() && (a._transformMargin(n, t, r.margin), a._runPath(n), n.clip()), this._transformMargin(n, t, r.margin), this._render(e), n.restore(), w(s, (o) => {
        o && o.context.restore();
      });
    }
  }
  _render(e) {
    if (this.exportable === !1) {
      const t = this._layer || e;
      t.tainted = !0;
    }
  }
  hovering() {
    return this._renderer._hovering.has(this);
  }
  dragging() {
    return this._renderer._dragging.some((e) => e.value === this);
  }
  shouldCancelTouch() {
    const e = this._renderer;
    return e.tapToActivate && !e._touchActive ? !1 : this.cancelTouch ? !0 : this._parent ? this._parent.shouldCancelTouch() : !1;
  }
}
class rw extends qa {
  constructor() {
    super(...arguments), Object.defineProperty(this, "interactiveChildren", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "_childLayers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_children", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    });
  }
  _isInteractiveMask() {
    return this.interactiveChildren || super._isInteractiveMask();
  }
  addChild(e) {
    e._parent = this, this._children.push(e), e._layer && this.registerChildLayer(e._layer);
  }
  addChildAt(e, t) {
    e._parent = this, this._children.splice(t, 0, e), e._layer && this.registerChildLayer(e._layer);
  }
  removeChild(e) {
    e._parent = void 0, nt(this._children, e);
  }
  _render(e) {
    super._render(e);
    const t = this._renderer;
    this.interactive && this.interactiveChildren && ++t._forceInteractive;
    const s = this._layer || e;
    w(this._children, (r) => {
      r.compoundAlpha = this.compoundAlpha * this.alpha, r.render(s);
    }), this.interactive && this.interactiveChildren && --t._forceInteractive;
  }
  registerChildLayer(e) {
    this._childLayers || (this._childLayers = []), Bs(this._childLayers, e), this._parent && this._parent.registerChildLayer(e);
  }
  markDirtyLayer(e = !1) {
    super.markDirtyLayer(), e && this._childLayers && w(this._childLayers, (t) => t.dirty = !0);
  }
  _dispose() {
    super._dispose(), this._childLayers && w(this._childLayers, (e) => {
      e.dirty = !0;
    });
  }
}
function $e(i, e) {
  i.left = Math.min(i.left, e.x), i.top = Math.min(i.top, e.y), i.right = Math.max(i.right, e.x), i.bottom = Math.max(i.bottom, e.y);
}
class Ge {
  colorize(e, t) {
  }
  path(e) {
  }
  addBounds(e) {
  }
}
class nw extends Ge {
  colorize(e, t) {
    e.beginPath();
  }
}
class po extends Ge {
  constructor(e) {
    super(), Object.defineProperty(this, "color", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
    });
  }
  colorize(e, t) {
    t !== void 0 ? e.fillStyle = t : e.fillStyle = this.color;
  }
}
class aw extends Ge {
  constructor(e) {
    super(), Object.defineProperty(this, "clearShadow", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
    });
  }
  colorize(e, t) {
    e.fill(), this.clearShadow && (e.shadowColor = "", e.shadowBlur = 0, e.shadowOffsetX = 0, e.shadowOffsetY = 0);
  }
}
class ow extends Ge {
  colorize(e, t) {
    e.stroke();
  }
}
class go extends Ge {
  constructor(e, t, s) {
    super(), Object.defineProperty(this, "width", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
    }), Object.defineProperty(this, "color", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
    }), Object.defineProperty(this, "lineJoin", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: s
    });
  }
  colorize(e, t) {
    t !== void 0 ? e.strokeStyle = t : e.strokeStyle = this.color, e.lineWidth = this.width, this.lineJoin && (e.lineJoin = this.lineJoin);
  }
}
class lw extends Ge {
  constructor(e) {
    super(), Object.defineProperty(this, "dash", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
    });
  }
  colorize(e, t) {
    e.setLineDash(this.dash);
  }
}
class uw extends Ge {
  constructor(e) {
    super(), Object.defineProperty(this, "dashOffset", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
    });
  }
  colorize(e, t) {
    e.lineDashOffset = this.dashOffset;
  }
}
class hw extends Ge {
  constructor(e, t, s, r) {
    super(), Object.defineProperty(this, "x", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
    }), Object.defineProperty(this, "y", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
    }), Object.defineProperty(this, "width", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: s
    }), Object.defineProperty(this, "height", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: r
    });
  }
  path(e) {
    e.rect(this.x, this.y, this.width, this.height);
  }
  addBounds(e) {
    const t = this.x, s = this.y, r = t + this.width, n = s + this.height;
    $e(e, { x: t, y: s }), $e(e, { x: r, y: s }), $e(e, { x: t, y: n }), $e(e, { x: r, y: n });
  }
}
class cw extends Ge {
  constructor(e, t, s) {
    super(), Object.defineProperty(this, "x", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
    }), Object.defineProperty(this, "y", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
    }), Object.defineProperty(this, "radius", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: s
    });
  }
  path(e) {
    e.moveTo(this.x + this.radius, this.y), e.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
  }
  // TODO handle skewing and rotation
  addBounds(e) {
    $e(e, { x: this.x - this.radius, y: this.y - this.radius }), $e(e, { x: this.x + this.radius, y: this.y + this.radius });
  }
}
class dw extends Ge {
  constructor(e, t, s, r) {
    super(), Object.defineProperty(this, "x", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
    }), Object.defineProperty(this, "y", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
    }), Object.defineProperty(this, "radiusX", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: s
    }), Object.defineProperty(this, "radiusY", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: r
    });
  }
  path(e) {
    e.ellipse(0, 0, this.radiusX, this.radiusY, 0, 0, Math.PI * 2);
  }
  // TODO handle skewing and rotation
  addBounds(e) {
    $e(e, { x: this.x - this.radiusX, y: this.y - this.radiusY }), $e(e, { x: this.x + this.radiusX, y: this.y + this.radiusY });
  }
}
class fw extends Ge {
  constructor(e, t, s, r, n, a) {
    super(), Object.defineProperty(this, "cx", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
    }), Object.defineProperty(this, "cy", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
    }), Object.defineProperty(this, "radius", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: s
    }), Object.defineProperty(this, "startAngle", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: r
    }), Object.defineProperty(this, "endAngle", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: n
    }), Object.defineProperty(this, "anticlockwise", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: a
    });
  }
  path(e) {
    this.radius > 0 && e.arc(this.cx, this.cy, this.radius, this.startAngle, this.endAngle, this.anticlockwise);
  }
  addBounds(e) {
    let t = pd(this.cx, this.cy, this.startAngle * cs, this.endAngle * cs, this.radius);
    $e(e, { x: t.left, y: t.top }), $e(e, { x: t.right, y: t.bottom });
  }
}
class pw extends Ge {
  constructor(e, t, s, r, n) {
    super(), Object.defineProperty(this, "x1", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
    }), Object.defineProperty(this, "y1", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
    }), Object.defineProperty(this, "x2", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: s
    }), Object.defineProperty(this, "y2", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: r
    }), Object.defineProperty(this, "radius", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: n
    });
  }
  path(e) {
    this.radius > 0 && e.arcTo(this.x1, this.y1, this.x2, this.y2, this.radius);
  }
  // TODO: add points
  addBounds(e) {
  }
}
class gw extends Ge {
  constructor(e, t) {
    super(), Object.defineProperty(this, "x", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
    }), Object.defineProperty(this, "y", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
    });
  }
  path(e) {
    e.lineTo(this.x, this.y);
  }
  addBounds(e) {
    $e(e, { x: this.x, y: this.y });
  }
}
class _w extends Ge {
  constructor(e, t) {
    super(), Object.defineProperty(this, "x", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
    }), Object.defineProperty(this, "y", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
    });
  }
  path(e) {
    e.moveTo(this.x, this.y);
  }
  addBounds(e) {
    $e(e, { x: this.x, y: this.y });
  }
}
class mw extends Ge {
  path(e) {
    e.closePath();
  }
}
class bw extends Ge {
  constructor(e, t, s, r, n, a) {
    super(), Object.defineProperty(this, "cpX", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
    }), Object.defineProperty(this, "cpY", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
    }), Object.defineProperty(this, "cpX2", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: s
    }), Object.defineProperty(this, "cpY2", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: r
    }), Object.defineProperty(this, "toX", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: n
    }), Object.defineProperty(this, "toY", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: a
    });
  }
  path(e) {
    e.bezierCurveTo(this.cpX, this.cpY, this.cpX2, this.cpY2, this.toX, this.toY);
  }
  // TODO: OK?
  addBounds(e) {
    $e(e, { x: this.cpX, y: this.cpY }), $e(e, { x: this.cpX2, y: this.cpY2 }), $e(e, { x: this.toX, y: this.toY });
  }
}
class yw extends Ge {
  constructor(e, t, s, r) {
    super(), Object.defineProperty(this, "cpX", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
    }), Object.defineProperty(this, "cpY", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
    }), Object.defineProperty(this, "toX", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: s
    }), Object.defineProperty(this, "toY", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: r
    });
  }
  path(e) {
    e.quadraticCurveTo(this.cpX, this.cpY, this.toX, this.toY);
  }
  // TODO: OK?
  addBounds(e) {
    $e(e, { x: this.cpX, y: this.cpY }), $e(e, { x: this.toX, y: this.toY });
  }
}
class vw extends Ge {
  constructor(e, t, s, r, n) {
    super(), Object.defineProperty(this, "color", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
    }), Object.defineProperty(this, "blur", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
    }), Object.defineProperty(this, "offsetX", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: s
    }), Object.defineProperty(this, "offsetY", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: r
    }), Object.defineProperty(this, "opacity", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: n
    });
  }
  colorize(e, t) {
    this.opacity && (e.fillStyle = this.color), e.shadowColor = this.color, e.shadowBlur = this.blur, e.shadowOffsetX = this.offsetX, e.shadowOffsetY = this.offsetY;
  }
}
class xw extends Ge {
  constructor(e, t, s, r, n) {
    super(), Object.defineProperty(this, "image", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
    }), Object.defineProperty(this, "width", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
    }), Object.defineProperty(this, "height", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: s
    }), Object.defineProperty(this, "x", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: r
    }), Object.defineProperty(this, "y", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: n
    });
  }
  path(e) {
    e.drawImage(this.image, this.x, this.y, this.width, this.height);
  }
  // TODO: OK?
  addBounds(e) {
    $e(e, { x: this.x, y: this.y }), $e(e, { x: this.width, y: this.height });
  }
}
class ww extends qa {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_operations", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "blendMode", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ea.NORMAL
    }), Object.defineProperty(this, "_hasShadows", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_fillAlpha", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_strokeAlpha", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  clear() {
    super.clear(), this._operations.length = 0;
  }
  _pushOp(e) {
    this._operations.push(e);
  }
  beginFill(e, t = 1) {
    this._fillAlpha = t, e ? e instanceof X ? this._pushOp(new po(e.toCSS(t))) : (this.isMeasured = !0, this._pushOp(new po(e))) : this._pushOp(new po("rgba(0, 0, 0, " + t + ")"));
  }
  endFill() {
    this._pushOp(new aw(this._hasShadows));
  }
  endStroke() {
    this._pushOp(new ow());
  }
  beginPath() {
    this._pushOp(new nw());
  }
  lineStyle(e = 0, t, s = 1, r) {
    this._strokeAlpha = s, t ? t instanceof X ? this._pushOp(new go(e, t.toCSS(s), r)) : this._pushOp(new go(e, t, r)) : this._pushOp(new go(e, "rgba(0, 0, 0, " + s + ")", r));
  }
  setLineDash(e) {
    this._pushOp(new lw(e || []));
  }
  setLineDashOffset(e = 0) {
    this._pushOp(new uw(e));
  }
  drawRect(e, t, s, r) {
    this._pushOp(new hw(e, t, s, r));
  }
  drawCircle(e, t, s) {
    this._pushOp(new cw(e, t, s));
  }
  drawEllipse(e, t, s, r) {
    this._pushOp(new dw(e, t, s, r));
  }
  arc(e, t, s, r, n, a = !1) {
    this._pushOp(new fw(e, t, s, r, n, a));
  }
  arcTo(e, t, s, r, n) {
    this._pushOp(new pw(e, t, s, r, n));
  }
  lineTo(e, t) {
    this._pushOp(new gw(e, t));
  }
  moveTo(e, t) {
    this._pushOp(new _w(e, t));
  }
  bezierCurveTo(e, t, s, r, n, a) {
    this._pushOp(new bw(e, t, s, r, n, a));
  }
  quadraticCurveTo(e, t, s, r) {
    this._pushOp(new yw(e, t, s, r));
  }
  closePath() {
    this._pushOp(new mw());
  }
  shadow(e, t = 0, s = 0, r = 0, n) {
    this._hasShadows = !0, this._pushOp(new vw(n ? e.toCSS(n) : e.toCSS(this._fillAlpha || this._strokeAlpha), t, s, r));
  }
  image(e, t, s, r, n) {
    this._pushOp(new xw(e, t, s, r, n));
  }
  // https://svgwg.org/svg2-draft/paths.html#DProperty
  // TODO better error checking
  svgPath(e) {
    let t = 0, s = 0, r = null, n = null, a = null, o = null;
    const l = /([MmZzLlHhVvCcSsQqTtAa])([^MmZzLlHhVvCcSsQqTtAa]*)/g, u = /[\u0009\u0020\u000A\u000C\u000D]*([\+\-]?[0-9]*\.?[0-9]+(?:[eE][\+\-]?[0-9]+)?)[\u0009\u0020\u000A\u000C\u000D]*,?/g;
    let c;
    for (; (c = l.exec(e)) !== null; ) {
      const h = c[1], d = c[2], f = [];
      for (; (c = u.exec(d)) !== null; )
        f.push(c[1]);
      switch (h !== "S" && h !== "s" && h !== "C" && h !== "c" && (r = null, n = null), h !== "Q" && h !== "q" && h !== "T" && h !== "t" && (a = null, o = null), h) {
        case "M":
          St(h, f.length, 2), t = +f[0], s = +f[1], this.moveTo(t, s);
          for (let p = 2; p < f.length; p += 2)
            t = +f[p], s = +f[p + 1], this.lineTo(t, s);
          break;
        case "m":
          St(h, f.length, 2), t += +f[0], s += +f[1], this.moveTo(t, s);
          for (let p = 2; p < f.length; p += 2)
            t += +f[p], s += +f[p + 1], this.lineTo(t, s);
          break;
        case "L":
          St(h, f.length, 2);
          for (let p = 0; p < f.length; p += 2)
            t = +f[p], s = +f[p + 1], this.lineTo(t, s);
          break;
        case "l":
          St(h, f.length, 2);
          for (let p = 0; p < f.length; p += 2)
            t += +f[p], s += +f[p + 1], this.lineTo(t, s);
          break;
        case "H":
          vr(h, f.length, 1);
          for (let p = 0; p < f.length; ++p)
            t = +f[p], this.lineTo(t, s);
          break;
        case "h":
          vr(h, f.length, 1);
          for (let p = 0; p < f.length; ++p)
            t += +f[p], this.lineTo(t, s);
          break;
        case "V":
          vr(h, f.length, 1);
          for (let p = 0; p < f.length; ++p)
            s = +f[p], this.lineTo(t, s);
          break;
        case "v":
          vr(h, f.length, 1);
          for (let p = 0; p < f.length; ++p)
            s += +f[p], this.lineTo(t, s);
          break;
        case "C":
          St(h, f.length, 6);
          for (let p = 0; p < f.length; p += 6) {
            const _ = +f[p], m = +f[p + 1];
            r = +f[p + 2], n = +f[p + 3], t = +f[p + 4], s = +f[p + 5], this.bezierCurveTo(_, m, r, n, t, s);
          }
          break;
        case "c":
          St(h, f.length, 6);
          for (let p = 0; p < f.length; p += 6) {
            const _ = +f[p] + t, m = +f[p + 1] + s;
            r = +f[p + 2] + t, n = +f[p + 3] + s, t += +f[p + 4], s += +f[p + 5], this.bezierCurveTo(_, m, r, n, t, s);
          }
          break;
        case "S":
          St(h, f.length, 4), (r === null || n === null) && (r = t, n = s);
          for (let p = 0; p < f.length; p += 4) {
            const _ = 2 * t - r, m = 2 * s - n;
            r = +f[p], n = +f[p + 1], t = +f[p + 2], s = +f[p + 3], this.bezierCurveTo(_, m, r, n, t, s);
          }
          break;
        case "s":
          St(h, f.length, 4), (r === null || n === null) && (r = t, n = s);
          for (let p = 0; p < f.length; p += 4) {
            const _ = 2 * t - r, m = 2 * s - n;
            r = +f[p] + t, n = +f[p + 1] + s, t += +f[p + 2], s += +f[p + 3], this.bezierCurveTo(_, m, r, n, t, s);
          }
          break;
        case "Q":
          St(h, f.length, 4);
          for (let p = 0; p < f.length; p += 4)
            a = +f[p], o = +f[p + 1], t = +f[p + 2], s = +f[p + 3], this.quadraticCurveTo(a, o, t, s);
          break;
        case "q":
          St(h, f.length, 4);
          for (let p = 0; p < f.length; p += 4)
            a = +f[p] + t, o = +f[p + 1] + s, t += +f[p + 2], s += +f[p + 3], this.quadraticCurveTo(a, o, t, s);
          break;
        case "T":
          St(h, f.length, 2), (a === null || o === null) && (a = t, o = s);
          for (let p = 0; p < f.length; p += 2)
            a = 2 * t - a, o = 2 * s - o, t = +f[p], s = +f[p + 1], this.quadraticCurveTo(a, o, t, s);
          break;
        case "t":
          St(h, f.length, 2), (a === null || o === null) && (a = t, o = s);
          for (let p = 0; p < f.length; p += 2)
            a = 2 * t - a, o = 2 * s - o, t += +f[p], s += +f[p + 1], this.quadraticCurveTo(a, o, t, s);
          break;
        case "A":
        case "a":
          const g = h === "a";
          ew(f), St(h, f.length, 7);
          for (let p = 0; p < f.length; p += 7) {
            let _ = +f[p + 5], m = +f[p + 6];
            g && (_ += t, m += s);
            const v = q0({
              px: t,
              py: s,
              rx: +f[p],
              ry: +f[p + 1],
              xAxisRotation: +f[p + 2],
              largeArcFlag: Wu(+f[p + 3]),
              sweepFlag: Wu(+f[p + 4]),
              cx: _,
              cy: m
            });
            w(v, (b) => {
              this.bezierCurveTo(b.x1, b.y1, b.x2, b.y2, b.x, b.y), t = b.x, s = b.y;
            });
          }
          break;
        case "Z":
        case "z":
          J0(h, f.length, 0), this.closePath();
          break;
      }
    }
  }
  _runPath(e) {
    e.beginPath(), w(this._operations, (t) => {
      t.path(e);
    });
  }
  _render(e) {
    super._render(e);
    const t = this._layer || e, s = t.dirty, r = this._isInteractive();
    if (s || r) {
      const n = t.context, a = this._renderer._ghostLayer.context;
      s && (n.globalCompositeOperation = this.blendMode, n.beginPath());
      let o;
      r && (a.beginPath(), o = this._getColorId()), w(this._operations, (l) => {
        s && (l.path(n), l.colorize(n, void 0)), r && (l.path(a), l.colorize(a, o));
      });
    }
  }
  renderDetached(e) {
    if (this.visible) {
      this._setMatrix(), e.save();
      const t = this.mask;
      t && (t._setMatrix(), t._transform(e, 1), t._runPath(e), e.clip()), e.globalAlpha = this.compoundAlpha * this.alpha, this._transform(e, 1), this.filter && (e.filter = this.filter), e.globalCompositeOperation = this.blendMode, e.beginPath(), w(this._operations, (s) => {
        s.path(e), s.colorize(e, void 0);
      }), e.restore();
    }
  }
  _addBounds(e) {
    this.visible && this.isMeasured && w(this._operations, (t) => {
      t.addBounds(e);
    });
  }
}
class kd extends qa {
  constructor(e, t, s) {
    super(e), Object.defineProperty(this, "text", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "style", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "resolution", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), Object.defineProperty(this, "_textInfo", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_textVisible", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "_originalScale", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), this.text = t, this.style = s;
  }
  invalidateBounds() {
    super.invalidateBounds(), this._textInfo = void 0;
  }
  _shared(e) {
    this.style.textAlign && (e.textAlign = this.style.textAlign), this.style.direction && (e.direction = this.style.direction), this.style.textBaseline && (e.textBaseline = this.style.textBaseline);
  }
  _prerender(e, t = !1, s = !1) {
    super._render(e);
    const r = e.context, n = this._renderer._ghostLayer.context, a = this.style;
    let o = this._getFontStyle(void 0, s);
    r.font = o, this._isInteractive() && !t && (n.font = o), a.fill && (a.fill instanceof X ? r.fillStyle = a.fill.toCSS(a.fillOpacity != null ? a.fillOpacity : 1) : r.fillStyle = a.fill), a.shadowColor && (e.context.shadowColor = a.shadowColor.toCSS(a.shadowOpacity || 1)), a.shadowBlur && (e.context.shadowBlur = a.shadowBlur), a.shadowOffsetX && (e.context.shadowOffsetX = a.shadowOffsetX), a.shadowOffsetY && (e.context.shadowOffsetY = a.shadowOffsetY), this._shared(r), this._isInteractive() && !t && (n.fillStyle = this._getColorId(), this._shared(n));
  }
  _getFontStyle(e, t = !1) {
    const s = this.style;
    let r = [];
    return e && e.fontVariant ? r.push(e.fontVariant) : s.fontVariant && r.push(s.fontVariant), t || (e && e.fontWeight ? r.push(e.fontWeight) : s.fontWeight && r.push(s.fontWeight)), e && e.fontStyle ? r.push(e.fontStyle) : s.fontStyle && r.push(s.fontStyle), e && e.fontSize ? (S(e.fontSize) && (e.fontSize = e.fontSize + "px"), r.push(e.fontSize)) : s.fontSize && (S(s.fontSize) && (s.fontSize = s.fontSize + "px"), r.push(s.fontSize)), e && e.fontFamily ? r.push(e.fontFamily) : s.fontFamily ? r.push(s.fontFamily) : r.length && r.push("Arial"), r.join(" ");
  }
  _render(e) {
    const t = this._layer || e;
    if (this._textInfo || this._measure(t), this._textVisible) {
      const s = this._isInteractive(), r = t.context, n = t.dirty, a = this._renderer._ghostLayer.context;
      r.save(), a.save(), this._prerender(t), w(this._textInfo, (o, l) => {
        w(o.textChunks, (u, c) => {
          if (u.style && (r.save(), a.save(), r.font = u.style, this._isInteractive() && (a.font = u.style)), u.fill && (r.save(), r.fillStyle = u.fill.toCSS()), n && r.fillText(u.text, u.offsetX, o.offsetY + u.offsetY), u.textDecoration == "underline" || u.textDecoration == "line-through") {
            let h = 1, d = 1, f = u.height, g = u.offsetX;
            switch (this.style.textAlign) {
              case "right":
              case "end":
                g -= u.width;
                break;
              case "center":
                g -= u.width / 2;
                break;
            }
            if (u.style)
              switch (Nt.getTextStyle(u.style).fontWeight) {
                case "bolder":
                case "bold":
                case "700":
                case "800":
                case "900":
                  h = 2;
                  break;
              }
            f && (d = f / 20);
            let p;
            u.textDecoration == "line-through" ? p = h + o.offsetY + u.offsetY - u.height / 2 : p = h + d * 1.5 + o.offsetY + u.offsetY, r.save(), r.beginPath(), u.fill ? r.strokeStyle = u.fill.toCSS() : this.style.fill && this.style.fill instanceof X && (r.strokeStyle = this.style.fill.toCSS()), r.lineWidth = h * d, r.moveTo(g, p), r.lineTo(g + u.width, p), r.stroke(), r.restore();
          }
          s && this.interactive && a.fillText(u.text, u.offsetX, o.offsetY + u.offsetY), u.fill && r.restore(), u.style && (r.restore(), a.restore());
        });
      }), r.restore(), a.restore();
    }
  }
  _addBounds(e) {
    if (this.visible && this.isMeasured) {
      const t = this._measure(this.getLayer());
      $e(e, { x: t.left, y: t.top }), $e(e, { x: t.right, y: t.bottom });
    }
  }
  _ignoreFontWeight() {
    return /apple/i.test(navigator.vendor);
  }
  _measure(e) {
    const t = e.context, s = this._renderer._ghostLayer.context, r = this.style.direction == "rtl";
    this._textInfo = [];
    const n = this.style.oversizedBehavior, a = this.style.maxWidth, o = S(a) && n == "truncate", l = S(a) && (n == "wrap" || n == "wrap-no-break");
    t.save(), s.save(), this._prerender(e, !0, this._ignoreFontWeight());
    const u = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ", c = this.text.toString().replace(/\r/g, "").split(/\n/);
    let h = !0, d = 0, f = 0, g = 0, p;
    w(c, (m, v) => {
      let b;
      for (m == "" ? b = [{
        type: "value",
        text: ""
      }] : b = Nt.chunk(m, !1, this.style.ignoreFormatting); b.length > 0; ) {
        let y = {
          offsetY: g,
          ascent: 0,
          width: 0,
          height: 0,
          left: 0,
          right: 0,
          textChunks: []
        };
        const x = this._measureText(u, t), D = x.actualBoundingBoxAscent + x.actualBoundingBoxDescent;
        y.height = D, y.ascent = x.actualBoundingBoxAscent;
        let A, T = this.style.textDecoration, j, C, L = !1, E = !0, N = [], q;
        hu(b, (z, H) => {
          if (z.type == "format")
            if (z.text == "[/]")
              h || (t.restore(), s.restore(), h = !0), j = void 0, p = void 0, C = void 0, T = this.style.textDecoration, q = void 0, A = z.text;
            else {
              h || (t.restore(), s.restore());
              let Y = Nt.getTextStyle(z.text);
              const W = this._getFontStyle(Y);
              t.save(), s.save(), t.font = W, p = W, A = z.text, Y.textDecoration && (T = Y.textDecoration), Y.fill && (j = Y.fill), Y.width && (C = dt(Y.width)), Y.verticalAlign && (q = Y.verticalAlign), h = !1;
              const B = this._measureText(u, t), oe = B.actualBoundingBoxAscent + B.actualBoundingBoxDescent;
              oe > y.height && (y.height = oe), B.actualBoundingBoxAscent > y.ascent && (y.ascent = B.actualBoundingBoxAscent);
            }
          else if (z.type == "value" && !L) {
            const Y = this._measureText(z.text, t);
            let W = Y.actualBoundingBoxLeft + Y.actualBoundingBoxRight;
            if (o) {
              let k = E || this.style.breakWords || !1;
              const M = this.style.ellipsis || "", $ = this._measureText(M, t), J = $.actualBoundingBoxLeft + $.actualBoundingBoxRight;
              if (y.width + W > a) {
                const U = a - y.width - J;
                z.text = this._truncateText(t, z.text, U, k), z.text += M, L = !0;
              }
            } else if (l && y.width + W > a) {
              const k = a - y.width, M = this._truncateText(t, z.text, k, !1, E && this.style.oversizedBehavior != "wrap-no-break");
              if (M == "")
                return this._textVisible = !0, !1;
              N = b.slice(H + 1), Mr(M) != Mr(z.text) && (N.unshift({
                type: "value",
                text: z.text.substr(M.length)
              }), A && N.unshift({
                type: "format",
                text: A
              })), z.text = Mr(M), b = [], L = !0;
            }
            let B = 1, oe = 1;
            if (p && C && C > W) {
              const k = W / C;
              switch (this.style.textAlign) {
                case "right":
                case "end":
                  B = k;
                  break;
                case "center":
                  B = k, oe = k;
                  break;
                default:
                  oe = k;
              }
              W = C;
            }
            const O = Y.actualBoundingBoxAscent + Y.actualBoundingBoxDescent;
            O > y.height && (y.height = O), Y.actualBoundingBoxAscent > y.ascent && (y.ascent = Y.actualBoundingBoxAscent), y.width += W, y.left += Y.actualBoundingBoxLeft / B, y.right += Y.actualBoundingBoxRight / oe, y.textChunks.push({
              style: p,
              fill: j,
              text: z.text,
              width: W,
              height: O,
              left: Y.actualBoundingBoxLeft,
              right: Y.actualBoundingBoxRight,
              ascent: Y.actualBoundingBoxAscent,
              offsetX: 0,
              offsetY: 0,
              textDecoration: T,
              verticalAlign: q
            }), E = !1;
          }
          return !0;
        }), this.style.lineHeight instanceof re ? (y.height *= this.style.lineHeight.value, y.ascent *= this.style.lineHeight.value) : (y.height *= this.style.lineHeight || 1.2, y.ascent *= this.style.lineHeight || 1.2), d < y.left && (d = y.left), f < y.right && (f = y.right), this._textInfo.push(y), g += y.height, b = N || [];
      }
    }), h || (t.restore(), s.restore()), w(this._textInfo, (m, v) => {
      let b = 0;
      w(m.textChunks, (y) => {
        if (y.offsetX = b + y.left - m.left, y.offsetY += m.height - m.height * (this.style.baselineRatio || 0.19), b += y.width, y.verticalAlign)
          switch (y.verticalAlign) {
            case "super":
              y.offsetY -= m.height / 2 - y.height / 2;
              break;
            case "sub":
              y.offsetY += y.height / 2;
              break;
          }
      });
    });
    const _ = {
      left: r ? -f : -d,
      top: 0,
      right: r ? d : f,
      bottom: g
    };
    if (n !== "none") {
      const m = this._fitRatio(_);
      if (m < 1)
        if (n == "fit")
          S(this.style.minScale) && m < this.style.minScale ? this._textVisible = !1 : ((!this._originalScale || this._originalScale == 1) && (this._originalScale = this.scale), this.scale = m, this._textVisible = !0);
        else if (n == "hide")
          this._textVisible = !1;
        else {
          switch (this.style.textAlign) {
            case "right":
            case "end":
              _.left = -a, _.right = 0;
              break;
            case "center":
              _.left = -a / 2, _.right = a / 2;
              break;
            default:
              _.left = 0, _.right = a;
          }
          this.scale = this._originalScale || 1, this._originalScale = void 0, this._textVisible = !0;
        }
      else
        this.scale = this._originalScale || 1, this._originalScale = void 0, this._textVisible = !0;
    }
    return t.restore(), s.restore(), _;
  }
  _fitRatio(e) {
    const t = this.style.maxWidth, s = this.style.maxHeight;
    if (!S(t) && !S(s))
      return 1;
    const r = e.right - e.left, n = e.bottom - e.top;
    return Math.min(t / r || 1, s / n || 1);
  }
  _truncateText(e, t, s, r = !1, n = !0) {
    let a;
    do {
      if (r)
        t = t.slice(0, -1);
      else {
        let l = t.replace(/[^,;:!?\\\/\s]+[,;:!?\\\/\s]*$/g, "");
        if (l == "" && n)
          r = !0;
        else {
          if (l == "")
            return t;
          t = l;
        }
      }
      const o = this._measureText(t, e);
      a = o.actualBoundingBoxLeft + o.actualBoundingBoxRight;
    } while (a > s && t != "");
    return t;
  }
  _measureText(e, t) {
    let s = t.measureText(e), r = {};
    if (s.actualBoundingBoxAscent == null) {
      const a = document.createElement("div");
      a.innerText = e, a.style.visibility = "hidden", a.style.position = "absolute", a.style.top = "-1000000px;", a.style.fontFamily = this.style.fontFamily || "", a.style.fontSize = this.style.fontSize + "", document.body.appendChild(a);
      const o = a.getBoundingClientRect();
      document.body.removeChild(a);
      const l = o.height, u = s.width;
      r = {
        actualBoundingBoxAscent: l,
        actualBoundingBoxDescent: 0,
        actualBoundingBoxLeft: 0,
        actualBoundingBoxRight: u,
        fontBoundingBoxAscent: l,
        fontBoundingBoxDescent: 0,
        width: u
      };
    } else
      r = {
        actualBoundingBoxAscent: s.actualBoundingBoxAscent,
        actualBoundingBoxDescent: s.actualBoundingBoxDescent,
        actualBoundingBoxLeft: s.actualBoundingBoxLeft,
        actualBoundingBoxRight: s.actualBoundingBoxRight,
        fontBoundingBoxAscent: s.actualBoundingBoxAscent,
        fontBoundingBoxDescent: s.actualBoundingBoxDescent,
        width: s.width
      };
    const n = s.width;
    switch (this.style.textAlign) {
      case "right":
      case "end":
        r.actualBoundingBoxLeft = n, r.actualBoundingBoxRight = 0;
        break;
      case "center":
        r.actualBoundingBoxLeft = n / 2, r.actualBoundingBoxRight = n / 2;
        break;
      default:
        r.actualBoundingBoxLeft = 0, r.actualBoundingBoxRight = n;
    }
    return r;
  }
}
class Sw {
  constructor() {
    Object.defineProperty(this, "fill", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "fillOpacity", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "textAlign", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "fontFamily", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "fontSize", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "fontWeight", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "fontStyle", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "fontVariant", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "textDecoration", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shadowColor", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shadowBlur", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shadowOffsetX", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shadowOffsetY", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shadowOpacity", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "lineHeight", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Ke(120)
    }), Object.defineProperty(this, "baselineRatio", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0.19
    }), Object.defineProperty(this, "direction", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "textBaseline", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "oversizedBehavior", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "none"
    }), Object.defineProperty(this, "breakWords", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "ellipsis", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "…"
    }), Object.defineProperty(this, "maxWidth", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "maxHeight", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "minScale", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "ignoreFormatting", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    });
  }
}
class Dw extends kd {
  constructor() {
    super(...arguments), Object.defineProperty(this, "textType", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "circular"
    }), Object.defineProperty(this, "radius", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "startAngle", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "inside", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "orientation", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "auto"
    }), Object.defineProperty(this, "kerning", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_textReversed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    });
  }
  _render(e) {
    switch (this.textType) {
      case "circular":
        this._renderCircular(e);
        break;
      default:
        super._render(e);
        break;
    }
  }
  _renderCircular(e) {
    if (this._textVisible) {
      const t = this._layer || e;
      this._prerender(t);
      const s = this._isInteractive(), r = t.context, n = t.dirty, a = this._renderer._ghostLayer.context;
      r.save(), s && a.save(), this._textInfo || this._measure(t);
      let o = this.radius || 0, l = this.startAngle || 0, u = 0, c = this.orientation, h = c == "auto" ? "auto" : c == "inward";
      const d = this.inside, f = this.style.textAlign || "left", g = this.kerning || 0;
      let p = f == "left" ? 1 : -1;
      const _ = !this._textReversed;
      if (h == "auto") {
        let m = 0, v = 0;
        w(this._textInfo, (b, y) => {
          const x = l + b.width / (o - b.height) / 2 * -p;
          x > m && (m = x);
        }), f == "left" ? v = (m + u / 2) * cs : f == "right" ? v = (m - u / 2) * cs : v = l * cs, v = zs(v), h = v >= 270 || v <= 90;
      }
      h == !0 && _ && (this._textInfo.reverse(), this._textReversed = !0), w(this._textInfo, (m, v) => {
        const b = m.height;
        d || (o += b), (p == -1 && h || p == 1 && !h) && _ && m.textChunks.reverse();
        let y = l;
        u = 0, f == "center" && (y += m.width / (o - b) / 2 * -p, u = y - l), y += Math.PI * (h ? 0 : 1), r.save(), s && a.save(), r.rotate(y), s && a.rotate(y);
        let x = 0;
        w(m.textChunks, (D, A) => {
          const T = D.text, j = D.width;
          x = j / 2 / (o - b) * p, r.rotate(x), s && a.rotate(x), D.style && (r.save(), a.save(), r.font = D.style, s && (a.font = D.style)), D.fill && (r.save(), r.fillStyle = D.fill.toCSS()), r.textBaseline = "middle", r.textAlign = "center", s && (a.textBaseline = "middle", a.textAlign = "center"), n && r.fillText(T, 0, (h ? 1 : -1) * (0 - o + b / 2)), s && a.fillText(T, 0, (h ? 1 : -1) * (0 - o + b / 2)), D.fill && r.restore(), D.style && (r.restore(), a.restore()), x = (j / 2 + g) / (o - b) * p, r.rotate(x), s && a.rotate(x);
        }), r.restore(), s && a.restore(), d && (o -= b);
      }), r.restore(), s && a.restore();
    }
  }
  _measure(e) {
    switch (this.textType) {
      case "circular":
        return this._measureCircular(e);
      default:
        return super._measure(e);
    }
  }
  _measureCircular(e) {
    const t = e.context, s = this._renderer._ghostLayer.context, r = this.style.direction == "rtl", n = this.style.oversizedBehavior, a = this.style.maxWidth, o = S(a) && n == "truncate", l = this.style.ellipsis || "";
    let u;
    this._textVisible = !0, this._textInfo = [], this._textReversed = !1, t.save(), s.save(), this._prerender(e, !0);
    const c = this.text.toString().replace(/\r/g, "").split(/\n/);
    let h = !0, d = 0, f = 0;
    return w(c, (g, p) => {
      let _ = Nt.chunk(g, !1, this.style.ignoreFormatting), m = {
        offsetY: f,
        ascent: 0,
        width: 0,
        height: 0,
        left: 0,
        right: 0,
        textChunks: []
      }, v, b, y;
      w(_, (x, D) => {
        if (x.type == "format") {
          if (x.text == "[/]")
            h || (t.restore(), s.restore(), h = !0), b = void 0, v = void 0, y = void 0;
          else {
            let A = Nt.getTextStyle(x.text);
            const T = this._getFontStyle(A);
            t.save(), s.save(), t.font = T, v = T, A.fill && (b = A.fill), A.width && (y = dt(A.width)), h = !1;
          }
          o && (u = this._measureText(l, t));
        } else if (x.type == "value") {
          const A = x.text.match(/./ug) || [];
          r && A.reverse();
          for (let T = 0; T < A.length; T++) {
            const j = A[T], C = this._measureText(j, t);
            let L = C.width;
            v && y && y > L && (L = y);
            const E = C.actualBoundingBoxAscent + C.actualBoundingBoxDescent;
            if (E > m.height && (m.height = E), C.actualBoundingBoxAscent > m.ascent && (m.ascent = C.actualBoundingBoxAscent), m.width += L, m.left += C.actualBoundingBoxLeft, m.right += C.actualBoundingBoxRight, m.textChunks.push({
              style: v,
              fill: b,
              text: j,
              width: L,
              height: E + C.actualBoundingBoxDescent,
              left: C.actualBoundingBoxLeft,
              right: C.actualBoundingBoxRight,
              ascent: C.actualBoundingBoxAscent,
              offsetX: 0,
              offsetY: E,
              textDecoration: void 0
            }), d += L, o) {
              u || (u = this._measureText(l, t));
              const N = u.actualBoundingBoxLeft + u.actualBoundingBoxRight;
              if (d += N, d + N > a) {
                m.textChunks.length == 1 ? this._textVisible = !1 : (m.width += N, m.left += u.actualBoundingBoxLeft, m.right += u.actualBoundingBoxRight, m.textChunks.push({
                  style: v,
                  fill: b,
                  text: l,
                  width: N,
                  height: E + u.actualBoundingBoxDescent,
                  left: u.actualBoundingBoxLeft,
                  right: u.actualBoundingBoxRight,
                  ascent: u.actualBoundingBoxAscent,
                  offsetX: 0,
                  offsetY: E,
                  textDecoration: void 0
                }));
                break;
              }
            }
            if (r)
              break;
          }
        }
      }), this.style.lineHeight instanceof re ? m.height *= this.style.lineHeight.value : m.height *= this.style.lineHeight || 1.2, this._textInfo.push(m), f += m.height;
    }), h || (t.restore(), s.restore()), n == "hide" && d > a && (this._textVisible = !1), w(this._textInfo, (g) => {
      w(g.textChunks, (p) => {
        p.offsetY += Math.round((g.height - p.height + (g.ascent - p.ascent)) / 2);
      });
    }), t.restore(), s.restore(), {
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
  }
}
class Pw extends qa {
  constructor(e, t) {
    super(e), Object.defineProperty(this, "width", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "height", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "image", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tainted", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shadowColor", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shadowBlur", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shadowOffsetX", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shadowOffsetY", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shadowOpacity", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_imageMask", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.image = t;
  }
  _dispose() {
    super._dispose(), this._imageMask && xr(this._imageMask);
  }
  getLocalBounds() {
    if (!this._localBounds) {
      let e = 0, t = 0;
      this.width && (e = this.width), this.height && (t = this.height), this._localBounds = {
        left: 0,
        top: 0,
        right: e,
        bottom: t
      }, this._addBounds(this._localBounds);
    }
    return this._localBounds;
  }
  _render(e) {
    if (super._render(e), this.image) {
      const t = this._layer || e;
      if (this.tainted === void 0 && (this.tainted = Gu(this.image), t.tainted = !0), this.tainted && this._renderer._omitTainted)
        return;
      if (t.dirty) {
        this.shadowColor && (t.context.shadowColor = this.shadowColor.toCSS(this.shadowOpacity || 1)), this.shadowBlur && (t.context.shadowBlur = this.shadowBlur), this.shadowOffsetX && (t.context.shadowOffsetX = this.shadowOffsetX), this.shadowOffsetY && (t.context.shadowOffsetY = this.shadowOffsetY);
        const s = this.width || this.image.naturalWidth, r = this.height || this.image.naturalHeight;
        t.context.drawImage(this.image, 0, 0, s, r);
      }
      if (this.interactive && this._isInteractive()) {
        const s = this._getMask(this.image);
        this._renderer._ghostLayer.context.drawImage(s, 0, 0);
      }
    }
  }
  clear() {
    super.clear(), this.image = void 0, this._imageMask = void 0;
  }
  _getMask(e) {
    if (this._imageMask === void 0) {
      const t = this.width || e.naturalWidth, s = this.height || e.naturalHeight, r = document.createElement("canvas");
      r.width = t, r.height = s;
      const n = r.getContext("2d");
      n.imageSmoothingEnabled = !1, n.fillStyle = this._getColorId(), n.fillRect(0, 0, t, s), Gu(e) || (n.globalCompositeOperation = "destination-in", n.drawImage(e, 0, 0, t, s)), this._imageMask = r;
    }
    return this._imageMask;
  }
}
class Tw {
  constructor(e, t, s, r) {
    Object.defineProperty(this, "event", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
    }), Object.defineProperty(this, "originalPoint", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
    }), Object.defineProperty(this, "point", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: s
    }), Object.defineProperty(this, "bbox", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: r
    }), Object.defineProperty(this, "id", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "simulated", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "native", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Wt("touchevents") && e instanceof Touch ? this.id = e.identifier : this.id = null;
  }
}
class kw extends Fc {
  /*protected _mouseMoveThrottler: Throttler = new Throttler(() => {
      this._dispatchGlobalMousemove(this._lastPointerMoveEvent.event, this._lastPointerMoveEvent.native);
  });
  */
  constructor(e) {
    if (super(), Object.defineProperty(this, "view", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: document.createElement("div")
    }), Object.defineProperty(this, "_layerDom", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: document.createElement("div")
    }), Object.defineProperty(this, "layers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_dirtyLayers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "defaultLayer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.getLayer(0)
    }), Object.defineProperty(this, "_ghostLayer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new Cw()
    }), Object.defineProperty(this, "_patternCanvas", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: document.createElement("canvas")
    }), Object.defineProperty(this, "_patternContext", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._patternCanvas.getContext("2d")
    }), Object.defineProperty(this, "_domWidth", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_domHeight", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_canvasWidth", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_canvasHeight", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "resolution", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "interactionsEnabled", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "_listeners", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_events", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_colorId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_colorMap", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_forceInteractive", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_omitTainted", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_hovering", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: /* @__PURE__ */ new Set()
    }), Object.defineProperty(this, "_dragging", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_mousedown", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_lastPointerMoveEvent", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tapToActivate", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "tapToActivateTimeout", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 3e3
    }), Object.defineProperty(this, "_touchActive", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_touchActiveTimeout", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), e == null ? this.resolution = window.devicePixelRatio : this.resolution = e, this.view.style.position = "absolute", this.view.appendChild(this._layerDom), this._disposers.push(new He(() => {
      _e(this._events, (t, s) => {
        s.disposer.dispose();
      }), w(this.layers, (t) => {
        xr(t.view), t.exportableView && xr(t.exportableView);
      }), xr(this._ghostLayer.view), xr(this._patternCanvas);
    })), this._disposers.push(pu(() => {
      e == null && (this.resolution = window.devicePixelRatio);
    })), Wt("touchevents")) {
      const t = (s) => {
        this._dragging.length !== 0 && hu(this._dragging, (r) => r.value.shouldCancelTouch() ? (s.preventDefault(), !1) : !0), this._touchActiveTimeout && this._delayTouchDeactivate();
      };
      this._disposers.push(Le(window, "touchstart", t, { passive: !1 })), this._disposers.push(Le(this.view, "touchstart", t, { passive: !1 })), this._disposers.push(Le(this.view, "touchmove", () => {
        this._touchActiveTimeout && this._delayTouchDeactivate();
      }, { passive: !0 })), this._disposers.push(Le(window, "click", (s) => {
        this._touchActive = !1;
      }, { passive: !0 })), this._disposers.push(Le(this.view, "click", (s) => {
        window.setTimeout(() => {
          this._touchActive = !0, this._delayTouchDeactivate();
        }, 100);
      }, { passive: !0 }));
    }
    Wt("wheelevents") && this._disposers.push(Le(this.view, "wheel", (t) => {
      let s = !1;
      this._hovering.forEach((r) => {
        if (r.wheelable)
          return s = !0, !1;
      }), s && t.preventDefault();
    }, { passive: !1 }));
  }
  _delayTouchDeactivate() {
    this._touchActiveTimeout && clearTimeout(this._touchActiveTimeout), this.tapToActivateTimeout > 0 && (this._touchActiveTimeout = window.setTimeout(() => {
      this._touchActive = !1;
    }, this.tapToActivateTimeout));
  }
  get debugGhostView() {
    return !!this._ghostLayer.view.parentNode;
  }
  set debugGhostView(e) {
    e ? this._ghostLayer.view.parentNode || this.view.appendChild(this._ghostLayer.view) : this._ghostLayer.view.parentNode && this._ghostLayer.view.parentNode.removeChild(this._ghostLayer.view);
  }
  createLinearGradient(e, t, s, r) {
    return this.defaultLayer.context.createLinearGradient(e, t, s, r);
  }
  createRadialGradient(e, t, s, r, n, a) {
    return this.defaultLayer.context.createRadialGradient(e, t, s, r, n, a);
  }
  createPattern(e, t, s, r, n) {
    return this._patternCanvas.width = r, this._patternCanvas.height = n, this._patternContext.clearRect(0, 0, r, n), t.renderDetached(this._patternContext), e.renderDetached(this._patternContext), this._patternContext.createPattern(this._patternCanvas, s);
  }
  makeContainer() {
    return new rw(this);
  }
  makeGraphics() {
    return new ww(this);
  }
  makeText(e, t) {
    return new kd(this, e, t);
  }
  makeTextStyle() {
    return new Sw();
  }
  makeRadialText(e, t) {
    return new Dw(this, e, t);
  }
  makePicture(e) {
    return new Pw(this, e);
  }
  resizeLayer(e) {
    e.resize(this._canvasWidth, this._canvasHeight, this._domWidth, this._domHeight, this.resolution);
  }
  resizeGhost() {
    this._ghostLayer.resize(this._canvasWidth, this._canvasHeight, this._domWidth, this._domHeight, this.resolution);
  }
  resize(e, t, s, r) {
    this._canvasWidth = e, this._canvasHeight = t, this._domWidth = s, this._domHeight = r, w(this.layers, (n) => {
      n && (n.dirty = !0, this.resizeLayer(n));
    }), this.resizeGhost(), this.view.style.width = s + "px", this.view.style.height = r + "px";
  }
  createDetachedLayer(e = !1) {
    const t = document.createElement("canvas"), s = t.getContext("2d", { willReadFrequently: e }), r = new Mw(t, s);
    return t.style.position = "absolute", t.style.top = "0px", t.style.left = "0px", r;
  }
  getLayerByOrder(e) {
    const t = this.layers, s = t.length;
    for (let r = 0; r < s; r++) {
      const n = t[r];
      if (n.order == e)
        return n;
    }
  }
  getLayer(e, t = !0) {
    let s = this.getLayerByOrder(e);
    if (s)
      return s;
    const r = this.createDetachedLayer(e == 99);
    r.order = e, r.visible = t, r.visible && this.resizeLayer(r);
    const n = this.layers;
    n.push(r), n.sort((u, c) => u.order > c.order ? 1 : u.order < c.order ? -1 : 0);
    const a = n.length, o = Yi(n, r);
    let l;
    for (let u = o + 1; u < a; u++)
      if (n[u].visible) {
        l = n[u];
        break;
      }
    return r.visible && (l === void 0 ? this._layerDom.appendChild(r.view) : this._layerDom.insertBefore(r.view, l.view)), r;
  }
  render(e) {
    if (this._dirtyLayers.length = 0, w(this.layers, (t) => {
      t && t.dirty && t.visible && (this._dirtyLayers.push(t), t.clear());
    }), this._ghostLayer.clear(), e.render(this.defaultLayer), this._ghostLayer.context.restore(), w(this.layers, (t) => {
      if (t) {
        const s = t.context;
        s.beginPath(), s.moveTo(0, 0), s.stroke();
      }
    }), w(this._dirtyLayers, (t) => {
      t.context.restore(), t.dirty = !1;
    }), this._hovering.size && this._lastPointerMoveEvent) {
      const t = this._lastPointerMoveEvent.native;
      w(this._lastPointerMoveEvent.events, (s) => {
        this._dispatchGlobalMousemove(s, t);
      });
    }
  }
  paintId(e) {
    const t = tw(++this._colorId), s = X.fromHex(t).toCSS();
    return this._colorMap[s] = e, s;
  }
  _removeObject(e) {
    e._colorId !== void 0 && delete this._colorMap[e._colorId];
  }
  // protected _identifyObjectByColor(colorId: number): CanvasDisplayObject | undefined {
  // 	return this._colorMap[colorId];
  // }
  _adjustBoundingBox(e) {
    const t = this._ghostLayer.margin;
    return new DOMRect(e.left - t.left, e.top - t.top, e.width + t.left + t.right, e.height + t.top + t.bottom);
  }
  getEvent(e, t = !0) {
    const s = this.view.getBoundingClientRect(), r = {
      x: e.clientX || 0,
      y: e.clientY || 0
    }, n = {
      x: r.x - (t ? s.left : 0),
      y: r.y - (t ? s.top : 0)
    };
    return new Tw(e, r, n, this._adjustBoundingBox(s));
  }
  _getHitTarget(e, t, s) {
    if (t.width === 0 || t.height === 0 || e.x < t.left || e.x > t.right || e.y < t.top || e.y > t.bottom || !this._layerDom.contains(s.target))
      return;
    const r = this._ghostLayer.getImageData(e, t);
    if (r.data[0] === 0 && r.data[1] === 0 && r.data[2] === 0)
      return !1;
    const n = X.fromRGB(r.data[0], r.data[1], r.data[2]).toCSS();
    return this._colorMap[n];
  }
  _withEvents(e, t) {
    const s = this._events[e];
    if (s !== void 0) {
      s.dispatching = !0;
      try {
        t(s);
      } finally {
        s.dispatching = !1, s.cleanup && (s.cleanup = !1, sn(s.callbacks, (r) => !r.disposed), s.callbacks.length === 0 && (s.disposer.dispose(), delete this._events[e]));
      }
    }
  }
  _dispatchEventAll(e, t) {
    this.interactionsEnabled && this._withEvents(e, (s) => {
      w(s.callbacks, (r) => {
        r.disposed || r.callback.call(r.context, t);
      });
    });
  }
  _dispatchEvent(e, t, s) {
    if (!this.interactionsEnabled)
      return !1;
    let r = !1;
    return this._withEvents(e, (n) => {
      w(n.callbacks, (a) => {
        !a.disposed && a.object === t && (a.callback.call(a.context, s), r = !0);
      });
    }), r;
  }
  _dispatchMousedown(e) {
    const t = e.button;
    if (t != 0 && t != 2 && t != 1 && t !== void 0)
      return;
    const s = this.getEvent(e), r = this._getHitTarget(s.originalPoint, s.bbox, e);
    if (r) {
      const n = s.id;
      let a = !1;
      _n(r, (o) => {
        const l = { id: n, value: o };
        return this._mousedown.push(l), !a && this._dispatchEvent("pointerdown", o, s) && (a = !0, this._dragging.some((c) => c.value === o && c.id === n) || this._dragging.push(l)), !0;
      });
    }
  }
  _dispatchGlobalMousemove(e, t) {
    const s = this.getEvent(e), r = this._getHitTarget(s.originalPoint, s.bbox, e);
    s.native = t, r ? (this._hovering.forEach((n) => {
      n.contains(r) || (this._hovering.delete(n), n.cursorOverStyle && Mn(document.body, "cursor", n._replacedCursorStyle), this._dispatchEvent("pointerout", n, s));
    }), s.native && _n(r, (n) => (this._hovering.has(n) || (this._hovering.add(n), n.cursorOverStyle && (n._replacedCursorStyle = Wc(document.body, "cursor"), Mn(document.body, "cursor", n.cursorOverStyle)), this._dispatchEvent("pointerover", n, s)), !0))) : (this._hovering.forEach((n) => {
      n.cursorOverStyle && Mn(document.body, "cursor", n._replacedCursorStyle), this._dispatchEvent("pointerout", n, s);
    }), this._hovering.clear()), this._dispatchEventAll("globalpointermove", s);
  }
  _dispatchGlobalMouseup(e, t) {
    const s = this.getEvent(e);
    s.native = t, this._dispatchEventAll("globalpointerup", s);
  }
  _dispatchDragMove(e) {
    if (this._dragging.length !== 0) {
      const t = this.getEvent(e), s = t.id;
      this._dragging.forEach((r) => {
        r.id === s && this._dispatchEvent("pointermove", r.value, t);
      });
    }
  }
  _dispatchDragEnd(e) {
    const t = e.button;
    let s;
    if (t == 0 || t === void 0)
      s = "click";
    else if (t == 2)
      s = "rightclick";
    else if (t == 1)
      s = "middleclick";
    else
      return;
    const r = this.getEvent(e), n = r.id;
    if (this._mousedown.length !== 0) {
      const a = this._getHitTarget(r.originalPoint, r.bbox, e);
      a && this._mousedown.forEach((o) => {
        o.id === n && o.value.contains(a) && this._dispatchEvent(s, o.value, r);
      }), this._mousedown.length = 0;
    }
    this._dragging.length !== 0 && (this._dragging.forEach((a) => {
      a.id === n && this._dispatchEvent("pointerup", a.value, r);
    }), this._dragging.length = 0);
  }
  _dispatchDoubleClick(e) {
    const t = this.getEvent(e), s = this._getHitTarget(t.originalPoint, t.bbox, e);
    s && _n(s, (r) => !this._dispatchEvent("dblclick", r, t));
  }
  _dispatchWheel(e) {
    const t = this.getEvent(e), s = this._getHitTarget(t.originalPoint, t.bbox, e);
    s && _n(s, (r) => !this._dispatchEvent("wheel", r, t));
  }
  _makeSharedEvent(e, t) {
    if (this._listeners[e] === void 0) {
      const s = t();
      this._listeners[e] = new Ua(() => {
        delete this._listeners[e], s.dispose();
      });
    }
    return this._listeners[e].increment();
  }
  _onPointerEvent(e, t) {
    let s = !1, r = null;
    function n() {
      r = null, s = !1;
    }
    return new st([
      new He(() => {
        r !== null && clearTimeout(r), n();
      }),
      Le(this.view, Qn(e), (a) => {
        s = !0, r !== null && clearTimeout(r), r = window.setTimeout(n, 0);
      }),
      iw(window, e, (a) => {
        r !== null && (clearTimeout(r), r = null), t(a, s), s = !1;
      })
    ]);
  }
  // This ensures that only a single DOM event is added (e.g. only a single mousemove event listener)
  _initEvent(e) {
    switch (e) {
      case "globalpointermove":
      case "pointerover":
      case "pointerout":
        return this._makeSharedEvent("pointermove", () => {
          const t = (s, r) => {
            this._lastPointerMoveEvent = { events: s, native: r }, w(s, (n) => {
              this._dispatchGlobalMousemove(n, r);
            });
          };
          return new st([
            this._onPointerEvent("pointerdown", t),
            this._onPointerEvent("pointermove", t)
          ]);
        });
      case "globalpointerup":
        return this._makeSharedEvent("pointerup", () => {
          var t = this._onPointerEvent("pointerup", (r, n) => {
            w(r, (a) => {
              this._dispatchGlobalMouseup(a, n);
            }), this._lastPointerMoveEvent = { events: r, native: n };
          }), s = this._onPointerEvent("pointercancel", (r, n) => {
            w(r, (a) => {
              this._dispatchGlobalMouseup(a, n);
            }), this._lastPointerMoveEvent = { events: r, native: n };
          });
          return new He(() => {
            t.dispose(), s.dispose();
          });
        });
      case "click":
      case "rightclick":
      case "middleclick":
      case "pointerdown":
      case "pointermove":
      case "pointerup":
        return this._makeSharedEvent("pointerdown", () => {
          const t = this._onPointerEvent("pointerdown", (a) => {
            w(a, (o) => {
              this._dispatchMousedown(o);
            });
          }), s = this._onPointerEvent("pointermove", (a) => {
            w(a, (o) => {
              this._dispatchDragMove(o);
            });
          }), r = this._onPointerEvent("pointerup", (a) => {
            w(a, (o) => {
              this._dispatchDragEnd(o);
            });
          }), n = this._onPointerEvent("pointercancel", (a) => {
            w(a, (o) => {
              this._dispatchDragEnd(o);
            });
          });
          return new He(() => {
            t.dispose(), s.dispose(), r.dispose(), n.dispose();
          });
        });
      case "dblclick":
        return this._makeSharedEvent("dblclick", () => this._onPointerEvent("dblclick", (t) => {
          w(t, (s) => {
            this._dispatchDoubleClick(s);
          });
        }));
      case "wheel":
        return this._makeSharedEvent("wheel", () => Le(window, Qn("wheel"), (t) => {
          this._dispatchWheel(t);
        }, { passive: !1 }));
    }
  }
  _addEvent(e, t, s, r) {
    let n = this._events[t];
    n === void 0 && (n = this._events[t] = {
      disposer: this._initEvent(t),
      callbacks: [],
      dispatching: !1,
      cleanup: !1
    });
    const a = { object: e, context: r, callback: s, disposed: !1 };
    return n.callbacks.push(a), new He(() => {
      a.disposed = !0, n.dispatching ? n.cleanup = !0 : (nt(n.callbacks, a), n.callbacks.length === 0 && (n.disposer.dispose(), delete this._events[t]));
    });
  }
  getCanvas(e, t) {
    this.render(e), t || (t = {});
    let s = this.resolution, r = Math.floor(this._canvasWidth * this.resolution), n = Math.floor(this._canvasHeight * this.resolution);
    if (t.minWidth && t.minWidth > r) {
      let f = t.minWidth / r;
      f > s && (s = f * this.resolution);
    }
    if (t.minHeight && t.minHeight > n) {
      let f = t.minHeight / n;
      f > s && (s = f * this.resolution);
    }
    if (t.maxWidth && t.maxWidth < r) {
      let f = t.maxWidth / r;
      f < s && (s = f * this.resolution);
    }
    if (t.maxHeight && t.maxHeight > n) {
      let f = t.maxHeight / n;
      f < s && (s = f * this.resolution);
    }
    t.maintainPixelRatio && (s /= this.resolution);
    const a = [];
    let o = !1;
    const l = document.createElement("canvas");
    s != this.resolution && (o = !0, r = r * s / this.resolution, n = n * s / this.resolution), l.width = r, l.height = n, l.style.position = "fixed", l.style.top = "-10000px", this.view.appendChild(l), a.push(l);
    const u = l.getContext("2d");
    let c = 0, h = 0, d = !1;
    return w(this.layers, (f) => {
      f && f.visible && (f.tainted || o) && (d = !0, f.exportableView = f.view, f.exportableContext = f.context, f.view = document.createElement("canvas"), f.view.style.position = "fixed", f.view.style.top = "-10000px", this.view.appendChild(f.view), a.push(f.view), f.view.width = r, f.view.height = n, f.context = f.view.getContext("2d"), f.dirty = !0, f.scale = s);
    }), d && (this._omitTainted = !0, this.render(e), this._omitTainted = !1), w(this.layers, (f) => {
      f && f.visible && (u.drawImage(f.view, 0, 0), f.exportableView && (f.view = f.exportableView, f.exportableView = void 0), f.exportableContext && (f.context = f.exportableContext, f.exportableContext = void 0), c < f.view.clientWidth && (c = f.view.clientWidth), h < f.view.clientHeight && (h = f.view.clientHeight), f.scale = void 0);
    }), l.style.width = c + "px", l.style.height = h + "px", w(a, (f) => {
      f.style.position = "", f.style.top = "", this.view.removeChild(f);
    }), l;
  }
}
class Cw {
  constructor() {
    Object.defineProperty(this, "view", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "context", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "margin", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
      }
    }), Object.defineProperty(this, "_width", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_height", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), this.view = document.createElement("canvas"), this.context = this.view.getContext("2d", { alpha: !1, willReadFrequently: !0 }), this.context.imageSmoothingEnabled = !1, this.view.style.position = "absolute", this.view.style.top = "0px", this.view.style.left = "0px";
  }
  resize(e, t, s, r, n) {
    e += this.margin.left + this.margin.right, t += this.margin.top + this.margin.bottom, s += this.margin.left + this.margin.right, r += this.margin.top + this.margin.bottom, this.view.style.left = -this.margin.left + "px", this.view.style.top = -this.margin.top + "px", this._width = Math.floor(e * n), this._height = Math.floor(t * n), this.view.width = this._width, this.view.style.width = s + "px", this.view.height = this._height, this.view.style.height = r + "px";
  }
  getImageData(e, t) {
    return this.context.getImageData(
      // TODO should this round ?
      Math.round((e.x - t.left) / t.width * this._width),
      Math.round((e.y - t.top) / t.height * this._height),
      1,
      1
    );
  }
  setMargin(e) {
    this.margin.left = 0, this.margin.right = 0, this.margin.top = 0, this.margin.bottom = 0, w(e, (t) => {
      t.margin && (this.margin.left = Math.max(this.margin.left, t.margin.left), this.margin.right = Math.max(this.margin.right, t.margin.right), this.margin.top = Math.max(this.margin.top, t.margin.top), this.margin.bottom = Math.max(this.margin.bottom, t.margin.bottom));
    });
  }
  clear() {
    this.context.save(), this.context.fillStyle = "#000", this.context.fillRect(0, 0, this._width, this._height);
  }
}
class Mw {
  constructor(e, t) {
    Object.defineProperty(this, "view", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "context", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tainted", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "margin", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "order", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "visible", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "width", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "height", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "scale", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "dirty", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "exportableView", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "exportableContext", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_width", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_height", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), this.view = e, this.context = t;
  }
  resize(e, t, s, r, n) {
    this.width != null && (e = this.width, s = this.width), this.height != null && (t = this.height, r = this.height), this.margin ? (e += this.margin.left + this.margin.right, t += this.margin.top + this.margin.bottom, s += this.margin.left + this.margin.right, r += this.margin.top + this.margin.bottom, this.view.style.left = -this.margin.left + "px", this.view.style.top = -this.margin.top + "px") : (this.view.style.left = "0px", this.view.style.top = "0px"), this._width = Math.floor(e * n), this._height = Math.floor(t * n), this.view.width = this._width, this.view.style.width = s + "px", this.view.height = this._height, this.view.style.height = r + "px";
  }
  clear() {
    this.context.save(), this.context.clearRect(0, 0, this._width, this._height);
  }
}
function Zu(i, e) {
  i == null ? requestAnimationFrame(e) : setTimeout(() => {
    requestAnimationFrame(e);
  }, 1e3 / i);
}
class Ja {
  constructor(e, t = {}, s) {
    if (Object.defineProperty(this, "dom", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_inner", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_settings", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_isDirty", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_isDirtyParents", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_dirty", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_dirtyParents", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_dirtyBounds", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_dirtyPositions", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_ticker", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "_tickers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_updateTick", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "events", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new or()
    }), Object.defineProperty(this, "animationTime", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "_animations", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_renderer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_rootContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "container", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "tooltipContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_tooltipContainerSettings", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_tooltip", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "language", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: W0.new(this, {})
    }), Object.defineProperty(this, "locale", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Td
    }), Object.defineProperty(this, "utc", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "timezone", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "fps", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "numberFormatter", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: xd.new(this, {})
    }), Object.defineProperty(this, "dateFormatter", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Dd.new(this, {})
    }), Object.defineProperty(this, "durationFormatter", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Pd.new(this, {})
    }), Object.defineProperty(this, "tabindex", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_tabindexes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_a11yD", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_focusElementDirty", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_focusElementContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_focusedSprite", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_isShift", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_keyboardDragPoint", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_tooltipElementContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_readerAlertElement", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_logo", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_tooltipDiv", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "nonce", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "interfaceColors", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "verticalLayout", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: _s.new(this, {})
    }), Object.defineProperty(this, "horizontalLayout", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: gs.new(this, {})
    }), Object.defineProperty(this, "gridLayout", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: gi.new(this, {})
    }), Object.defineProperty(this, "autoResize", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "_fontHash", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ""
    }), Object.defineProperty(this, "_isDisposed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_disposers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_resizeSensorDisposer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_tooltips", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_htmlElementContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_htmlEnabledContainers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), !s)
      throw new Error("You cannot use `new Class()`, instead use `Class.new()`");
    this._settings = t, t.accessible == !1 && (this._a11yD = !0), t.useSafeResolution == null && (t.useSafeResolution = !0);
    let r;
    t.useSafeResolution && (r = Qc()), this._renderer = new kw(r);
    let n;
    if (e instanceof HTMLElement ? n = e : n = document.getElementById(e), w(Ot.rootElements, (l) => {
      if (l.dom === n)
        throw new Error("You cannot have multiple Roots on the same DOM node");
    }), this.interfaceColors = Fr.new(this, {}), n === null)
      throw new Error("Could not find HTML element with id `" + e + "`");
    this.dom = n;
    let a = document.createElement("div");
    a.style.position = "relative", a.style.height = "100%", n.appendChild(a);
    const o = t.tooltipContainerBounds;
    o && (this._tooltipContainerSettings = o), this._inner = a, this._updateComputedStyles(), Ot.rootElements.push(this);
  }
  static new(e, t) {
    const s = new Ja(e, t, !0);
    return s._init(), s;
  }
  moveDOM(e) {
    let t;
    if (e instanceof HTMLElement ? t = e : t = document.getElementById(e), t) {
      for (; this.dom.childNodes.length > 0; )
        t.appendChild(this.dom.childNodes[0]);
      this.dom = t, this._initResizeSensor(), this.resize();
    }
  }
  _handleLogo() {
    if (this._logo) {
      const e = this.dom.offsetWidth, t = this.dom.offsetHeight;
      e <= 150 || t <= 60 ? this._logo.hide() : this._logo.show();
    }
  }
  _showBranding() {
    if (!this._logo) {
      const e = this.tooltipContainer.children.push(Z.new(this, {
        interactive: !0,
        interactiveChildren: !1,
        position: "absolute",
        setStateOnChildren: !0,
        paddingTop: 9,
        paddingRight: 9,
        paddingBottom: 9,
        paddingLeft: 9,
        scale: 0.6,
        y: Ke(100),
        centerY: R,
        tooltipText: "Created using amCharts 5",
        tooltipX: R,
        cursorOverStyle: "pointer",
        background: pt.new(this, {
          fill: pe(4671320),
          fillOpacity: 0,
          tooltipY: 5
        })
      })), t = Mt.new(this, {
        pointerOrientation: "horizontal",
        paddingTop: 4,
        paddingRight: 7,
        paddingBottom: 4,
        paddingLeft: 7
      });
      t.label.setAll({
        fontSize: 12
      }), t.get("background").setAll({
        fill: this.interfaceColors.get("background"),
        stroke: this.interfaceColors.get("grid"),
        strokeOpacity: 0.3
      }), e.set("tooltip", t), e.events.on("click", () => {
        window.open("https://www.amcharts.com/", "_blank");
      }), e.states.create("hover", {}), e.children.push(le.new(this, {
        stroke: pe(13421772),
        strokeWidth: 3,
        svgPath: "M5 25 L13 25h13.6c3.4 0 6 0 10.3-4.3s5.2-12 8.6-12c3.4 0 4.3 8.6 7.7 8.6M83.4 25H79.8c-3.4 0-6 0-10.3-4.3s-5.2-12-8.6-12-4.3 8.6-7.7 8.6"
      })).states.create("hover", { stroke: pe(3976191) }), e.children.push(le.new(this, {
        stroke: pe(8947848),
        strokeWidth: 3,
        svgPath: "M83.4 25h-31C37 25 39.5 4.4 28.4 4.4S18.9 24.2 4.3 25H0"
      })).states.create("hover", { stroke: pe(4671320) }), this._logo = e, this._handleLogo();
    }
  }
  _getRealSize() {
    return this.dom.getBoundingClientRect();
  }
  _getCalculatedSize(e) {
    return this._settings.calculateSize ? this._settings.calculateSize(e) : {
      width: e.width,
      height: e.height
    };
  }
  _init() {
    const e = this._renderer, t = this._getRealSize(), s = this._getCalculatedSize(t), r = Math.floor(s.width), n = Math.floor(s.height), a = Math.floor(t.width), o = Math.floor(t.height), l = Z.new(this, {
      visible: !0,
      width: a,
      height: o
    });
    this._rootContainer = l, this._rootContainer._defaultThemes.push(G0.new(this));
    const u = l.children.push(Z.new(this, { visible: !0, width: R, height: R }));
    this.container = u, e.resize(a, o, r, n), this._inner.appendChild(e.view), this._initResizeSensor();
    const c = document.createElement("div");
    if (this._htmlElementContainer = c, c.className = "am5-html-container", c.style.position = "absolute", c.style.pointerEvents = "none", this._tooltipContainerSettings || (c.style.overflow = "hidden"), this._inner.appendChild(c), this._a11yD !== !0) {
      const h = document.createElement("div");
      h.className = "am5-reader-container", h.setAttribute("role", "alert"), h.style.zIndex = "-100000", h.style.opacity = "0", h.style.position = "absolute", h.style.top = "0", this._readerAlertElement = h, this._inner.appendChild(this._readerAlertElement);
      const d = document.createElement("div");
      d.className = "am5-focus-container", d.style.position = "absolute", d.style.pointerEvents = "none", d.style.top = "0px", d.style.left = "0px", d.style.overflow = "hidden", d.style.width = r + "px", d.style.height = n + "px", d.setAttribute("role", "application"), Os(d, !1), this._focusElementContainer = d, this._inner.appendChild(this._focusElementContainer);
      const f = document.createElement("div");
      this._tooltipElementContainer = f, f.className = "am5-tooltip-container", this._inner.appendChild(f), Wt("keyboardevents") && (this._disposers.push(Le(window, "keydown", (g) => {
        g.keyCode == 16 && (this._isShift = !0);
      })), this._disposers.push(Le(window, "keyup", (g) => {
        g.keyCode == 16 && (this._isShift = !1);
      })), this._disposers.push(Le(d, "keydown", (g) => {
        const p = this._focusedSprite;
        if (p) {
          g.keyCode == 27 && (Vc(), this._focusedSprite = void 0);
          let _ = 0, m = 0;
          switch (g.keyCode) {
            case 13:
              g.preventDefault();
              const v = e.getEvent(new MouseEvent("click"));
              p.events.dispatch("click", {
                type: "click",
                originalEvent: v.event,
                point: v.point,
                simulated: !0,
                target: p
              });
              return;
            case 37:
              _ = -6;
              break;
            case 39:
              _ = 6;
              break;
            case 38:
              m = -6;
              break;
            case 40:
              m = 6;
              break;
            default:
              return;
          }
          if (_ != 0 || m != 0) {
            if (g.preventDefault(), !p.isDragging()) {
              this._keyboardDragPoint = {
                x: 0,
                y: 0
              };
              const y = e.getEvent(new MouseEvent("mousedown", {
                clientX: 0,
                clientY: 0
              }));
              p.events.isEnabled("pointerdown") && p.events.dispatch("pointerdown", {
                type: "pointerdown",
                originalEvent: y.event,
                point: y.point,
                simulated: !0,
                target: p
              });
            }
            const v = this._keyboardDragPoint;
            v.x += _, v.y += m;
            const b = e.getEvent(new MouseEvent("mousemove", {
              clientX: v.x,
              clientY: v.y
            }), !1);
            p.events.isEnabled("globalpointermove") && p.events.dispatch("globalpointermove", {
              type: "globalpointermove",
              originalEvent: b.event,
              point: b.point,
              simulated: !0,
              target: p
            });
          }
        }
      })), this._disposers.push(Le(d, "keyup", (g) => {
        if (this._focusedSprite) {
          const p = this._focusedSprite, _ = g.keyCode;
          switch (_) {
            case 37:
            case 39:
            case 38:
            case 40:
              if (p.isDragging()) {
                const m = this._keyboardDragPoint, v = e.getEvent(new MouseEvent("mouseup", {
                  clientX: m.x,
                  clientY: m.y
                }));
                p.events.isEnabled("globalpointerup") && p.events.dispatch("globalpointerup", {
                  type: "globalpointerup",
                  originalEvent: v.event,
                  point: v.point,
                  simulated: !0,
                  target: p
                }), this._keyboardDragPoint = void 0;
                return;
              } else if (p.get("focusableGroup")) {
                const m = p.get("focusableGroup"), v = this._tabindexes.filter((x) => x.get("focusableGroup") == m);
                let b = v.indexOf(p);
                const y = v.length - 1;
                b += _ == 39 || _ == 40 ? 1 : -1, b < 0 ? b = y : b > y && (b = 0), Uc(v[b].getPrivate("focusElement").dom);
              }
              break;
          }
        }
      })));
    }
    this._startTicker(), this.setThemes([]), this._addTooltip(), this._hasLicense() || this._showBranding();
  }
  _initResizeSensor() {
    this._resizeSensorDisposer && this._resizeSensorDisposer.dispose(), this._resizeSensorDisposer = new U0(this.dom, () => {
      this.autoResize && this.resize();
    }), this._disposers.push(this._resizeSensorDisposer);
  }
  /**
   * If automatic resizing of char is disabled (`root.autoResize = false`), it
   * can be resized manually by calling this method.
   */
  resize() {
    const e = this._getRealSize(), t = this._getCalculatedSize(e), s = Math.floor(t.width), r = Math.floor(t.height);
    if (s > 0 && r > 0) {
      const n = Math.floor(e.width), a = Math.floor(e.height), o = this._htmlElementContainer;
      if (o.style.width = s + "px", o.style.height = r + "px", this._a11yD !== !0) {
        const u = this._focusElementContainer;
        u.style.width = s + "px", u.style.height = r + "px";
      }
      this._renderer.resize(n, a, s, r);
      const l = this._rootContainer;
      l.setPrivate("width", n), l.setPrivate("height", a), this._render(), this._handleLogo();
    }
  }
  _render() {
    this._renderer.render(this._rootContainer._display), this._focusElementDirty && (this._updateCurrentFocus(), this._focusElementDirty = !1);
  }
  _runTickers(e) {
    w(this._tickers, (t) => {
      t(e);
    });
  }
  _runAnimations(e) {
    sn(this._animations, (t) => t._runAnimation(e));
  }
  _runDirties() {
    let e = {};
    for (; this._isDirtyParents; )
      this._isDirtyParents = !1, Ne(this._dirtyParents).forEach((a) => {
        const o = this._dirtyParents[a];
        delete this._dirtyParents[a], o.isDisposed() || (e[o.uid] = o, o._prepareChildren());
      });
    Ne(e).forEach((a) => {
      e[a]._updateChildren();
    });
    const t = [];
    Ne(this._dirty).forEach((a) => {
      const o = this._dirty[a];
      o.isDisposed() ? delete this._dirty[o.uid] : (t.push(o), o._beforeChanged());
    }), t.forEach((a) => {
      a._changed(), delete this._dirty[a.uid], a._clearDirty();
    }), this._isDirty = !1;
    const s = {}, r = [];
    Ne(this._dirtyBounds).forEach((a) => {
      const o = this._dirtyBounds[a];
      delete this._dirtyBounds[a], o.isDisposed() || (s[o.uid] = o.depth(), r.push(o));
    }), r.sort((a, o) => Et(s[o.uid], s[a.uid])), r.forEach((a) => {
      a._updateBounds();
    });
    const n = this._dirtyPositions;
    Ne(n).forEach((a) => {
      const o = n[a];
      delete n[a], o.isDisposed() || o._updatePosition();
    }), t.forEach((a) => {
      a._afterChanged();
    });
  }
  _renderFrame(e) {
    return this._updateTick ? (this.events.isEnabled("framestarted") && this.events.dispatch("framestarted", {
      type: "framestarted",
      target: this,
      timestamp: e
    }), this._checkComputedStyles(), this._runTickers(e), this._runAnimations(e), this._runDirties(), this._render(), this._positionHTMLElements(), this.events.isEnabled("frameended") && this.events.dispatch("frameended", {
      type: "frameended",
      target: this,
      timestamp: e
    }), this._tickers.length === 0 && this._animations.length === 0 && !this._isDirty) : !0;
  }
  _runTicker(e) {
    this.isDisposed() || (this.animationTime = e, this._renderFrame(e) ? (this._ticker = null, this.animationTime = null) : Zu(this.fps, this._ticker));
  }
  _runTickerNow() {
    if (!this.isDisposed())
      for (; ; ) {
        const e = performance.now();
        if (this.animationTime = e, this._renderFrame(e)) {
          this.animationTime = null;
          break;
        }
      }
  }
  _startTicker() {
    this._ticker === null && (this.animationTime = null, this._ticker = (e) => {
      this._runTicker(e);
    }, Zu(this.fps, this._ticker));
  }
  /**
   * Returns whether the root is updating or not.
   */
  get updateTick() {
    return this._updateTick;
  }
  /**
   * Enables or disables the root updating.
   */
  set updateTick(e) {
    this._updateTick = e, e && this._startTicker();
  }
  _addDirtyEntity(e) {
    this._dirty[e.uid] === void 0 && (this._isDirty = !0, this._dirty[e.uid] = e, this._startTicker());
  }
  _addDirtyParent(e) {
    this._dirtyParents[e.uid] === void 0 && (this._isDirty = !0, this._isDirtyParents = !0, this._dirtyParents[e.uid] = e, this._startTicker());
  }
  _addDirtyBounds(e) {
    this._dirtyBounds[e.uid] === void 0 && (this._isDirty = !0, this._dirtyBounds[e.uid] = e, this._startTicker());
  }
  _addDirtyPosition(e) {
    this._dirtyPositions[e.uid] === void 0 && (this._isDirty = !0, this._dirtyPositions[e.uid] = e, this._startTicker());
  }
  _addAnimation(e) {
    this._animations.indexOf(e) === -1 && (this._animations.push(e), this._startTicker());
  }
  _markDirty() {
    this._isDirty = !0;
  }
  _markDirtyRedraw() {
    this.events.once("frameended", () => {
      this._isDirty = !0, this._startTicker();
    });
  }
  eachFrame(e) {
    return this._tickers.push(e), this._startTicker(), new He(() => {
      nt(this._tickers, e);
    });
  }
  markDirtyGlobal(e) {
    e || (e = this.container), e.walkChildren((t) => {
      t instanceof Z && this.markDirtyGlobal(t), t.markDirty(), t.markDirtyBounds();
    });
  }
  /**
   * Returns width of the target container, in pixels.
   *
   * @return Width
   */
  width() {
    return Math.floor(this._getCalculatedSize(this._getRealSize()).width);
  }
  /**
   * Returns height of the target container, in pixels.
   *
   * @return Height
   */
  height() {
    return Math.floor(this._getCalculatedSize(this._getRealSize()).height);
  }
  /**
   * Disposes root and all the content in it.
   */
  dispose() {
    this._isDisposed || (this._isDisposed = !0, this._rootContainer.dispose(), this._renderer.dispose(), this.horizontalLayout.dispose(), this.verticalLayout.dispose(), this.interfaceColors.dispose(), w(this._disposers, (e) => {
      e.dispose();
    }), this._inner && Xc(this._inner), bt(Ot.rootElements, this));
  }
  /**
   * Returns `true` if root element is disposed.
   *
   * @return Disposed?
   */
  isDisposed() {
    return this._isDisposed;
  }
  /**
   * Triggers screen reader read out a message.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/accessibility/} for more info
   * @param  text  Alert text
   */
  readerAlert(e) {
    this._a11yD !== !0 && (this._readerAlertElement.innerHTML = Jn(e));
  }
  /**
   * Sets themes to be used for the chart.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/themes/} for more info
   * @param  themes  A list of themes
   */
  setThemes(e) {
    this._rootContainer.set("themes", e);
    const t = this.tooltipContainer;
    t && t._applyThemes();
    const s = this.interfaceColors;
    s && s._applyThemes();
  }
  _addTooltip() {
    if (!this.tooltipContainer) {
      const e = this._tooltipContainerSettings, t = this._rootContainer.children.push(Z.new(this, {
        position: "absolute",
        isMeasured: !1,
        width: R,
        height: R,
        layer: e ? 35 : 30,
        layerMargin: e || void 0
      }));
      this.tooltipContainer = t;
      const s = Mt.new(this, {});
      this.container.set("tooltip", s), s.hide(0), this._tooltip = s;
    }
  }
  /**
   * Accesibility
   */
  _registerTabindexOrder(e) {
    this._a11yD != !0 && (e.get("focusable") ? Bs(this._tabindexes, e) : bt(this._tabindexes, e), this._invalidateTabindexes());
  }
  _unregisterTabindexOrder(e) {
    this._a11yD != !0 && (bt(this._tabindexes, e), this._invalidateTabindexes());
  }
  _invalidateTabindexes() {
    if (this._a11yD == !0)
      return;
    this._tabindexes.sort((t, s) => {
      const r = t.get("tabindexOrder", 0), n = s.get("tabindexOrder", 0);
      return r == n ? 0 : r > n ? 1 : -1;
    });
    const e = [];
    w(this._tabindexes, (t, s) => {
      t.getPrivate("focusElement") ? this._moveFocusElement(s, t) : this._makeFocusElement(s, t);
      const r = t.get("focusableGroup");
      r && (e.indexOf(r) !== -1 ? t.getPrivate("focusElement").dom.setAttribute("tabindex", "-1") : e.push(r));
    });
  }
  _updateCurrentFocus() {
    this._a11yD != !0 && this._focusedSprite && (this._decorateFocusElement(this._focusedSprite), this._positionFocusElement(this._focusedSprite));
  }
  _decorateFocusElement(e, t) {
    if (this._a11yD == !0 || (t || (t = e.getPrivate("focusElement").dom), !t))
      return;
    e.get("visible") && e.get("role") != "tooltip" && !e.isHidden() ? t.getAttribute("tabindex") != "-1" && t.setAttribute("tabindex", "" + this.tabindex) : t.removeAttribute("tabindex");
    const s = e.get("role");
    s ? t.setAttribute("role", s) : t.removeAttribute("role");
    const r = e.get("ariaLabel");
    if (r) {
      const f = $r(e, r);
      t.setAttribute("aria-label", f);
    } else
      t.removeAttribute("aria-label");
    const n = e.get("ariaLive");
    n ? t.setAttribute("aria-live", n) : t.removeAttribute("aria-live");
    const a = e.get("ariaChecked");
    a != null ? t.setAttribute("aria-checked", a ? "true" : "false") : t.removeAttribute("aria-checked"), e.get("ariaHidden") ? t.setAttribute("aria-hidden", "hidden") : t.removeAttribute("aria-hidden");
    const o = e.get("ariaOrientation");
    o ? t.setAttribute("aria-orientation", o) : t.removeAttribute("aria-orientation");
    const l = e.get("ariaValueNow");
    l ? t.setAttribute("aria-valuenow", l) : t.removeAttribute("aria-valuenow");
    const u = e.get("ariaValueMin");
    u ? t.setAttribute("aria-valuemin", u) : t.removeAttribute("aria-valuemin");
    const c = e.get("ariaValueMax");
    c ? t.setAttribute("aria-valuemax", c) : t.removeAttribute("aria-valuemax");
    const h = e.get("ariaValueText");
    h ? t.setAttribute("aria-valuetext", h) : t.removeAttribute("aria-valuetext");
    const d = e.get("ariaControls");
    d ? t.setAttribute("aria-controls", d) : t.removeAttribute("aria-controls");
  }
  _makeFocusElement(e, t) {
    if (t.getPrivate("focusElement") || this._a11yD == !0)
      return;
    const s = document.createElement("div");
    t.get("role") != "tooltip" && (s.tabIndex = this.tabindex), s.style.position = "absolute", Os(s, !1);
    const r = [];
    t.setPrivate("focusElement", {
      dom: s,
      disposers: r
    }), this._decorateFocusElement(t), r.push(Le(s, "focus", (n) => {
      this._handleFocus(n, e);
    })), r.push(Le(s, "blur", (n) => {
      this._handleBlur(n, e);
    })), this._moveFocusElement(e, t);
  }
  _removeFocusElement(e) {
    if (this._a11yD == !0)
      return;
    bt(this._tabindexes, e);
    const t = e.getPrivate("focusElement");
    t && (this._focusElementContainer.removeChild(t.dom), w(t.disposers, (r) => {
      r.dispose();
    }));
  }
  _hideFocusElement(e) {
    if (this._a11yD == !0)
      return;
    const t = e.getPrivate("focusElement");
    t.dom.style.display = "none";
  }
  _moveFocusElement(e, t) {
    if (this._a11yD == !0)
      return;
    const s = this._focusElementContainer, r = t.getPrivate("focusElement").dom;
    if (r === this._focusElementContainer.children[e])
      return;
    const n = this._focusElementContainer.children[e + 1];
    n ? s.insertBefore(r, n) : s.append(r);
  }
  _positionFocusElement(e) {
    if (this._a11yD == !0)
      return;
    const t = e.globalBounds(), s = t.right == t.left ? e.width() : t.right - t.left, r = t.top == t.bottom ? e.height() : t.bottom - t.top, n = e.getPrivate("focusElement").dom;
    n.style.top = t.top - 2 + "px", n.style.left = t.left - 2 + "px", n.style.width = s + 4 + "px", n.style.height = r + 4 + "px";
  }
  _handleFocus(e, t) {
    if (this._a11yD == !0)
      return;
    const s = this._tabindexes[t];
    if (!s.isVisibleDeep()) {
      this._focusNext(e.target, this._isShift ? -1 : 1);
      return;
    }
    this._positionFocusElement(s), this._focusedSprite = s, s.events.isEnabled("focus") && s.events.dispatch("focus", {
      type: "focus",
      originalEvent: e,
      target: s
    });
  }
  _focusNext(e, t) {
    if (this._a11yD == !0)
      return;
    var s = Array.from(document.querySelectorAll([
      "a[href]",
      "area[href]",
      "button:not([disabled])",
      "details",
      "input:not([disabled])",
      "iframe:not([disabled])",
      "select:not([disabled])",
      "textarea:not([disabled])",
      '[contentEditable=""]',
      '[contentEditable="true"]',
      '[contentEditable="TRUE"]',
      '[tabindex]:not([tabindex^="-"])'
      //':not([disabled])'
    ].join(",")));
    let r = s.indexOf(e) + t;
    r < 0 ? r = s.length - 1 : r >= s.length && (r = 0), s[r].focus();
  }
  _handleBlur(e, t) {
    if (this._a11yD == !0)
      return;
    const s = this._focusedSprite;
    s && s.events.isEnabled("blur") && s.events.dispatch("blur", {
      type: "blur",
      originalEvent: e,
      target: s
    }), this._focusedSprite = void 0;
  }
  /**
   * @ignore
   */
  updateTooltip(e) {
    if (this._a11yD == !0)
      return;
    const t = Jn(e._getText());
    let s = e.getPrivate("tooltipElement");
    e.get("role") == "tooltip" && t != "" ? (s || (s = this._makeTooltipElement(e)), s.innerHTML != t && (s.innerHTML = t)) : s && (s.remove(), e.removePrivate("tooltipElement"));
  }
  _makeTooltipElement(e) {
    const t = this._tooltipElementContainer, s = document.createElement("div");
    return s.style.position = "absolute", s.style.top = "-1000000px", s.style.opacity = "0.0000001", Os(s, !1), this._decorateFocusElement(e, s), t.append(s), e.setPrivate("tooltipElement", s), s;
  }
  _removeTooltipElement(e) {
    if (this._a11yD == !0)
      return;
    const t = e.getPrivate("tooltipElement");
    if (t) {
      const s = t.parentElement;
      s && s.removeChild(t);
    }
  }
  _invalidateAccessibility(e) {
    if (this._a11yD == !0)
      return;
    this._focusElementDirty = !0;
    const t = e.getPrivate("focusElement");
    e.get("focusable") ? t && (this._decorateFocusElement(e), this._positionFocusElement(e)) : t && this._removeFocusElement(e);
  }
  /**
   * Returns `true` if `target` is currently focused.
   *
   * @param   target  Target
   * @return          Focused?
   */
  focused(e) {
    return this._focusedSprite === e;
  }
  /**
   * Converts document coordinates to coordinates withing root element.
   *
   * @param   point  Document point
   * @return         Root point
   */
  documentPointToRoot(e) {
    const t = this.dom.getBoundingClientRect();
    return {
      x: e.x - t.left,
      y: e.y - t.top
    };
  }
  /**
   * Converts root coordinates to document
   *
   * @param   point  Document point
   * @return         Root point
   */
  rootPointToDocument(e) {
    const t = this.dom.getBoundingClientRect();
    return {
      x: e.x + t.left,
      y: e.y + t.top
    };
  }
  /**
   * @ignore
   */
  addDisposer(e) {
    return this._disposers.push(e), e;
  }
  _updateComputedStyles() {
    const e = window.getComputedStyle(this.dom);
    let t = "";
    _e(e, (r, n) => {
      Ii(r) && r.match(/^font/) && (t += n);
    });
    const s = t != this._fontHash;
    return s && (this._fontHash = t), s;
  }
  _checkComputedStyles() {
    this._updateComputedStyles() && this._invalidateLabelBounds(this.container);
  }
  _invalidateLabelBounds(e) {
    e instanceof Z ? e.children.each((t) => {
      this._invalidateLabelBounds(t);
    }) : e instanceof Ri && e.markDirtyBounds();
  }
  /**
   * To all the clever heads out there. Yes, we did not make any attempts to
   * scramble this.
   *
   * This is a part of a tool meant for our users to manage their commercial
   * licenses for removal of amCharts branding from charts.
   *
   * The only legit way to do so is to purchase a commercial license for amCharts:
   * https://www.amcharts.com/online-store/
   *
   * Removing or altering this code, or disabling amCharts branding in any other
   * way is against the license and thus illegal.
   */
  _hasLicense() {
    for (let e = 0; e < Ot.licenses.length; e++)
      if (Ot.licenses[e].match(/^AM5C.{5,}/i))
        return !0;
    return !1;
  }
  _licenseApplied() {
    this._logo && this._logo.set("forceHidden", !0);
  }
  /**
   * @ignore
   */
  get debugGhostView() {
    return this._renderer.debugGhostView;
  }
  /**
   * @ignore
   */
  set debugGhostView(e) {
    this._renderer.debugGhostView = e;
  }
  /**
   * Set this to `true` if you need chart to require first a tap onto it before
   * touch gesture related functionality like zoom/pan is turned on.
   *
   * @see {@link https://www.amcharts.com/docs/v5/getting-started/root-element/#Touch_related_options} for more info
   * @default false
   * @since 5.2.9
   * @param  value  Needs a tap to activate touch functions
   */
  set tapToActivate(e) {
    this._renderer.tapToActivate = e;
  }
  /**
   * @return Needs a tap to activate touch functions
   */
  get tapToActivate() {
    return this._renderer.tapToActivate;
  }
  /**
   * If `tapToActivate` is set to `true`, this setting will determine number
   * of milliseconds the chart will stay "active", before releasing the
   * controls back to the page.
   *
   * @see {@link https://www.amcharts.com/docs/v5/getting-started/root-element/#Touch_related_options} for more info
   * @default 3000
   * @since 5.2.9
   * @param  value  Timeout
   */
  set tapToActivateTimeout(e) {
    this._renderer.tapToActivateTimeout = e;
  }
  /**
   * @return Timeout
   */
  get tapToActivateTimeout() {
    return this._renderer.tapToActivateTimeout;
  }
  _makeHTMLElement(e) {
    const t = this._htmlElementContainer, s = document.createElement("div");
    return e.setPrivate("htmlElement", s), s.style.position = "absolute", s.style.overflow = "auto", s.style.boxSizing = "border-box", Os(s, !0), e.events.isEnabled("click") && this._disposers.push(Le(s, "click", (r) => {
      const n = this._renderer.getEvent(r);
      e.events.dispatch("click", {
        type: "click",
        originalEvent: n.event,
        point: n.point,
        simulated: !1,
        target: e
      });
    })), this._positionHTMLElement(e), t.append(s), Bs(this._htmlEnabledContainers, e), s;
  }
  _positionHTMLElements() {
    w(this._htmlEnabledContainers, (e) => {
      this._positionHTMLElement(e);
    });
  }
  _positionHTMLElement(e) {
    const t = e.getPrivate("htmlElement");
    if (t) {
      w(["paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "minWidth", "minHeight", "maxWidth", "maxHeight"], (h) => {
        const d = e.get(h);
        d ? t.style[h] = d + "px" : t.style[h] = "";
      });
      const r = e.compositeOpacity();
      setTimeout(() => {
        t.style.opacity = r + "";
      }, 10);
      const n = e.isVisibleDeep();
      n && (t.style.display = "block");
      const a = e.globalBounds();
      t.style.top = a.top + "px", t.style.left = a.left + "px";
      const o = e.get("width"), l = e.get("height");
      let u = 0, c = 0;
      if (o && (u = e.width()), l && (c = e.height()), !o || !l) {
        t.style.position = "fixed", t.style.width = "", t.style.height = "";
        const h = t.getBoundingClientRect();
        t.style.position = "absolute", u = h.width, c = h.height, e._adjustedLocalBounds = { left: 0, right: 0, top: 0, bottom: 0 }, e.setPrivate("minWidth", u), e.setPrivate("minHeight", c);
      } else
        e.removePrivate("minWidth"), e.removePrivate("minHeight");
      u > 0 && (t.style.minWidth = u + "px"), c > 0 && (t.style.minHeight = c + "px"), (!n || r == 0) && (t.style.display = "none");
    }
  }
  _setHTMLContent(e, t) {
    let s = e.getPrivate("htmlElement");
    s || (s = this._makeHTMLElement(e)), s.innerHTML != t && (s.innerHTML = t);
  }
  _removeHTMLContent(e) {
    let t = e.getPrivate("htmlElement");
    t && this._htmlElementContainer.removeChild(t), bt(this._htmlEnabledContainers, e);
  }
}
let mn;
function Ow(i, e, t) {
  const s = e.interfaceColors, r = s.get("secondaryButton").toCSS(), n = s.get("text").toCSS(), a = s.get("alternativeBackground").toCSS(0.45);
  if (!mn) {
    const o = new st([
      new Ze(i, ".am5-modal", {
        width: "100%",
        height: "100%",
        position: "absolute",
        "z-index": "100000",
        top: "0",
        left: "0"
      }),
      new Ze(i, ".am5-modal-curtain", {
        top: "0",
        left: "0",
        width: "100%",
        height: "100%",
        position: "absolute",
        background: s.get("background").toCSS(0.5),
        "z-index": "100"
      }),
      new Ze(i, ".am5-modal-wrapper", {
        top: "0",
        left: "0",
        width: "100%",
        height: "100%",
        position: "absolute",
        "text-align": "center",
        "white-space": "nowrap",
        background: s.get("background").toCSS(0.5),
        "z-index": "101"
      }),
      new Ze(i, ".am5-modal-wrapper:before", {
        content: "''",
        display: "inline-block",
        height: "100%",
        "vertical-align": "middle",
        "margin-right": "-0.25em"
      }),
      new Ze(i, ".am5-modal-content", {
        display: "inline-block",
        padding: "1.2em",
        "vertical-align": "middle",
        "text-align": "left",
        "white-space": "normal",
        background: s.get("background").toCSS(),
        //"border": "1px solid " + ic.get("alternativeBackground")!.toCSS(),
        "border-radius": "4px",
        "-webkit-box-shadow": "0px 0px 36px 0px " + a,
        "box-shadow": "0px 0px 36px 0px " + a,
        color: n
      }),
      new Ze(i, ".am5-modal-content h1", {
        "font-size": "1em",
        margin: "0 0 0.5em 0"
      }),
      new Ze(i, ".am5-modal-table", {
        display: "table",
        margin: "1em 0"
      }),
      new Ze(i, ".am5-modal-table-row", {
        display: "table-row"
      }),
      new Ze(i, ".am5-modal-table-heading", {
        display: "table-heading",
        padding: "3px 10px 3px 0"
      }),
      new Ze(i, ".am5-modal-table-cell", {
        display: "table-cell",
        padding: "3px 0 3px 0"
      }),
      new Ze(i, ".am5-modal-table-cell > *", {
        "vertical-align": "middle"
      }),
      new Ze(i, ".am5-modal-content input[type=text], .am5-modal-content input[type=number], .am5-modal-content select", {
        border: "1px solid " + r,
        "border-radius": "4px",
        padding: "3px 5px",
        margin: "2px"
      }),
      new Ze(i, ".am5-modal-input-narrow", {
        width: "50px"
      }),
      new Ze(i, ".am5-modal-button", {
        "font-weight": "400",
        color: s.get("secondaryButtonText").toCSS(),
        "line-height": "1.5",
        "text-align": "center",
        "text-decoration": "none",
        "vertical-align": "middle",
        cursor: "pointer",
        padding: "0.2em 0.8em",
        "font-size": "1em",
        "border-radius": "0.25em",
        margin: "0 0.25em 0 0",
        border: "1px solid " + s.get("secondaryButtonStroke").toCSS(),
        background: s.get("secondaryButton").toCSS()
      }),
      new Ze(i, ".am5-modal-button:hover", {
        background: s.get("secondaryButtonHover").toCSS()
      }),
      new Ze(i, ".am5-modal-button.am5-modal-primary", {
        color: s.get("primaryButtonText").toCSS(),
        border: "1px solid " + s.get("primaryButtonStroke").toCSS(),
        background: s.get("primaryButton").toCSS()
      }),
      new Ze(i, ".am5-modal-button.am5-modal-primary:hover", {
        background: s.get("primaryButtonHover").toCSS()
      })
    ]);
    mn = new Ua(() => {
      mn = void 0, o.dispose();
    });
  }
  return mn.increment();
}
class ta extends Se {
  //protected _currentPass: number = 0;
  _afterNew() {
    super._afterNewApplyThemes(), this._setRawDefault("deactivateRoot", !0), Ow(Zc(this._root.dom), this._root);
    const e = document.createElement("div");
    e.className = "am5-modal", e.style.display = "none", this.root._inner.appendChild(e), this.setPrivate("container", e);
    const t = document.createElement("div");
    t.className = "am5-modal-curtain", e.appendChild(t), this.setPrivate("curtain", t), Le(t, "click", () => {
      this.cancel();
    });
    const s = document.createElement("div");
    s.className = "am5-modal-wrapper", e.appendChild(s), this.setPrivate("wrapper", s);
    const r = document.createElement("div");
    r.className = "am5-modal-content", s.appendChild(r), this.setPrivate("content", r);
    const n = this.get("content");
    n && (r.innerHTML = n), Wt("keyboardevents") && this._disposers.push(Le(document, "keydown", (a) => {
      this.isOpen() && a.keyCode == 27 && this.cancel();
    }));
  }
  _beforeChanged() {
    super._beforeChanged(), this.isDirty("content") && (this.getPrivate("content").innerHTML = this.get("content", ""));
  }
  /**
   * Returns `true` if modal is currently open.
   *
   * @return  Modal open?
   */
  isOpen() {
    return this.getPrivate("container").style.display != "none";
  }
  /**
   * Opens modal.
   */
  open() {
    this.getPrivate("container").style.display = "block", this.get("deactivateRoot") && this.setTimeout(() => {
      this._root._renderer.interactionsEnabled = !1;
    }, 10), this.events.dispatch("opened", {
      type: "opened",
      target: this
    });
  }
  /**
   * Closes modal.
   */
  close() {
    this.getPrivate("container").style.display = "none", this.get("deactivateRoot") && (this._root._renderer.interactionsEnabled = !0), this.events.dispatch("closed", {
      type: "closed",
      target: this
    });
  }
  /**
   * Closes modal and invokes `cancelled` event.
   */
  cancel() {
    this.getPrivate("container").style.display = "none", this.get("deactivateRoot") && (this._root._renderer.interactionsEnabled = !0), this.events.dispatch("cancelled", {
      type: "cancelled",
      target: this
    });
  }
  /**
   * Disposes modal.
   */
  dispose() {
    super.dispose(), this.root.dom.removeChild(this.getPrivate("container"));
  }
}
Object.defineProperty(ta, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Modal"
});
Object.defineProperty(ta, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Se.classNames.concat([ta.className])
});
class ki extends Se {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_index", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "series", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  _afterNew() {
    super._afterNewApplyThemes();
  }
  _beforeChanged() {
    if (super._beforeChanged(), this.isDirty("sprite")) {
      const e = this.get("sprite");
      e && (e.setAll({ position: "absolute", role: "figure" }), this._disposers.push(e));
    }
    (this.isDirty("locationX") || this.isDirty("locationY")) && this.series && this.series._positionBullet(this);
  }
}
Object.defineProperty(ki, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Bullet"
});
Object.defineProperty(ki, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Se.classNames.concat([ki.className])
});
class et extends pt {
  _beforeChanged() {
    super._beforeChanged(), (this.isDirty("cornerRadiusTL") || this.isDirty("cornerRadiusTR") || this.isDirty("cornerRadiusBR") || this.isDirty("cornerRadiusBL")) && (this._clear = !0);
  }
  _draw() {
    let e = this.width(), t = this.height(), s = e, r = t, n = s / Math.abs(e), a = r / Math.abs(t);
    if (S(s) && S(r)) {
      let o = Math.min(s, r) / 2, l = Re(this.get("cornerRadiusTL", 8), o), u = Re(this.get("cornerRadiusTR", 8), o), c = Re(this.get("cornerRadiusBR", 8), o), h = Re(this.get("cornerRadiusBL", 8), o), d = Math.min(Math.abs(s / 2), Math.abs(r / 2));
      l = Ie(l, 0, d), u = Ie(u, 0, d), c = Ie(c, 0, d), h = Ie(h, 0, d);
      const f = this._display;
      f.moveTo(l * n, 0), f.lineTo(s - u * n, 0), u > 0 && f.arcTo(s, 0, s, u * a, u), f.lineTo(s, r - c * a), c > 0 && f.arcTo(s, r, s - c * n, r, c), f.lineTo(h * n, r), h > 0 && f.arcTo(0, r, 0, r - h * a, h), f.lineTo(0, l * a), l > 0 && f.arcTo(0, 0, l * n, 0, l), f.closePath();
    }
  }
}
Object.defineProperty(et, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "RoundedRectangle"
});
Object.defineProperty(et, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: pt.classNames.concat([et.className])
});
class Vs extends Z {
  _afterNew() {
    this._settings.themeTags = ie(this._settings.themeTags, ["button"]), super._afterNew(), this._settings.background || this.set("background", et.new(this._root, {
      themeTags: ie(this._settings.themeTags, ["background"])
    }));
  }
  _prepareChildren() {
    if (super._prepareChildren(), this.isDirty("icon")) {
      const e = this._prevSettings.icon, t = this.get("icon");
      t !== e && (this._disposeProperty("icon"), e && e.dispose(), t && this.children.push(t), this._prevSettings.icon = t);
    }
    if (this.isDirty("label")) {
      const e = this._prevSettings.label, t = this.get("label");
      t !== e && (this._disposeProperty("label"), e && e.dispose(), t && this.children.push(t), this._prevSettings.label = t);
    }
  }
}
Object.defineProperty(Vs, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Button"
});
Object.defineProperty(Vs, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Z.classNames.concat([Vs.className])
});
class Ci extends le {
  _beforeChanged() {
    super._beforeChanged(), this.isDirty("radius") && (this._clear = !0);
  }
  _changed() {
    super._changed(), this._clear && this._display.drawCircle(0, 0, this.get("radius", 10));
  }
}
Object.defineProperty(Ci, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Circle"
});
Object.defineProperty(Ci, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: le.classNames.concat([Ci.className])
});
class ia extends le {
  _beforeChanged() {
    super._beforeChanged(), (this.isDirty("radiusX") || this.isDirty("radiusY") || this.isDirty("rotation")) && (this._clear = !0);
  }
  _changed() {
    super._changed(), this._clear && this._display.drawEllipse(0, 0, Math.abs(this.get("radiusX")), Math.abs(this.get("radiusY")));
  }
}
Object.defineProperty(ia, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Ellipse"
});
Object.defineProperty(ia, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: le.classNames.concat([ia.className])
});
class sa extends le {
  _beforeChanged() {
    super._beforeChanged(), (this.isDirty("radius") || this.isDirty("innerRadius") || this.isDirty("spikes")) && (this._clear = !0);
  }
  _changed() {
    if (super._changed(), this._clear) {
      const e = this._display, t = this.get("radius", 0), s = Re(this.get("innerRadius", 0), t), r = this.get("spikes", 0), n = Math.PI / r;
      let a = Math.PI / 2 * 3;
      e.moveTo(0, -t);
      for (let o = 0; o < r; o++)
        e.lineTo(Math.cos(a) * t, Math.sin(a) * t), a += n, e.lineTo(Math.cos(a) * s, Math.sin(a) * s), a += n;
      e.lineTo(0, -t), e.closePath();
    }
  }
}
Object.defineProperty(sa, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Star"
});
Object.defineProperty(sa, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: le.classNames.concat([sa.className])
});
class Cd extends lr {
  constructor() {
    super(...arguments), Object.defineProperty(this, "processor", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  /**
   * @ignore
   */
  incrementRef() {
  }
  /**
   * @ignore
   */
  decrementRef() {
  }
  _onPush(e) {
    this.processor && this.processor.processRow(e), super._onPush(e);
  }
  _onInsertIndex(e, t) {
    this.processor && this.processor.processRow(t), super._onInsertIndex(e, t);
  }
  _onSetIndex(e, t, s) {
    this.processor && this.processor.processRow(s), super._onSetIndex(e, t, s);
  }
}
class Aw {
  constructor(e) {
    Object.defineProperty(this, "processor", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_value", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this._value = e;
  }
  incrementRef() {
  }
  decrementRef() {
  }
}
class Gt extends vd {
  constructor(e, t, s) {
    super(s), Object.defineProperty(this, "component", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "dataContext", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "bullets", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "open", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "close", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.dataContext = t, this.component = e, this._settings.visible = !0, this._checkDirty();
  }
  /**
   * @ignore
   */
  markDirty() {
    this.component.markDirtyValues(this);
  }
  _startAnimation() {
    this.component._root._addAnimation(this);
  }
  _animationTime() {
    return this.component._root.animationTime;
  }
  _dispose() {
    this.component && this.component.disposeDataItem(this), super._dispose();
  }
  /**
   * Shows a data item that's currently hidden.
   */
  show(e) {
    this.setRaw("visible", !0), this.component && this.component.showDataItem(this, e);
  }
  /**
   * Hides a data item that's currently visible.
   */
  hide(e) {
    this.setRaw("visible", !1), this.component && this.component.hideDataItem(this, e);
  }
  isHidden() {
    return !this.get("visible");
  }
}
class Ni extends Z {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new Cd()
    }), Object.defineProperty(this, "_dataItems", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_mainDataItems", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._dataItems
    }), Object.defineProperty(this, "valueFields", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "fields", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ["id"]
    }), Object.defineProperty(this, "_valueFields", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_valueFieldsF", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_fields", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_fieldsF", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_valuesDirty", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_dataChanged", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_dataGrouped", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "inited", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    });
  }
  /**
   * Component's data.
   *
   * @see {@link https://www.amcharts.com/docs/v5/concepts/data/} for more info
   */
  set data(e) {
    e.incrementRef(), this._data.decrementRef(), this._data = e;
  }
  /**
   * @return  Data
   */
  get data() {
    return this._data;
  }
  _dispose() {
    super._dispose(), this._data.decrementRef();
  }
  _onDataClear() {
  }
  _afterNew() {
    super._afterNew(), this._data.incrementRef(), this._updateFields(), this._disposers.push(this.data.events.onAll((e) => {
      const t = this._mainDataItems;
      if (this.markDirtyValues(), this._markDirtyGroup(), this._dataChanged = !0, e.type === "clear")
        w(t, (s) => {
          s.dispose();
        }), t.length = 0, this._onDataClear();
      else if (e.type === "push") {
        const s = new Gt(this, e.newValue, this._makeDataItem(e.newValue));
        t.push(s), this.processDataItem(s);
      } else if (e.type === "setIndex") {
        const s = t[e.index], r = this._makeDataItem(e.newValue);
        s.bullets = void 0, Ne(r).forEach((n) => {
          s.animate({
            key: n,
            to: r[n],
            duration: this.get("interpolationDuration", 0),
            easing: this.get("interpolationEasing")
          });
        }), s.dataContext = e.newValue;
      } else if (e.type === "insertIndex") {
        const s = new Gt(this, e.newValue, this._makeDataItem(e.newValue));
        t.splice(e.index, 0, s), this.processDataItem(s);
      } else if (e.type === "removeIndex")
        t[e.index].dispose(), t.splice(e.index, 1);
      else if (e.type === "moveIndex") {
        const s = t[e.oldIndex];
        t.splice(e.oldIndex, 1), t.splice(e.newIndex, 0, s);
      } else
        throw new Error("Unknown IStreamEvent type");
      this._afterDataChange();
    }));
  }
  _updateFields() {
    this.valueFields && (this._valueFields = [], this._valueFieldsF = {}, w(this.valueFields, (e) => {
      this.get(e + "Field") && (this._valueFields.push(e), this._valueFieldsF[e] = { fieldKey: e + "Field", workingKey: e + "Working" });
    })), this.fields && (this._fields = [], this._fieldsF = {}, w(this.fields, (e) => {
      this.get(e + "Field") && (this._fields.push(e), this._fieldsF[e] = e + "Field");
    }));
  }
  /**
   * A list of component's data items.
   *
   * @return  Data items
   */
  get dataItems() {
    return this._dataItems;
  }
  processDataItem(e) {
  }
  _makeDataItem(e) {
    const t = {};
    return this._valueFields && w(this._valueFields, (s) => {
      const r = this.get(this._valueFieldsF[s].fieldKey);
      t[s] = e[r], t[this._valueFieldsF[s].workingKey] = t[s];
    }), this._fields && w(this._fields, (s) => {
      const r = this.get(this._fieldsF[s]);
      t[s] = e[r];
    }), t;
  }
  /**
   * @ignore
   */
  makeDataItem(e) {
    let t = new Gt(this, void 0, e);
    return this.processDataItem(t), t;
  }
  /**
   * @ignore
   */
  pushDataItem(e) {
    const t = this.makeDataItem(e);
    return this._mainDataItems.push(t), t;
  }
  /**
   * @ignore
   */
  disposeDataItem(e) {
  }
  /**
   * Shows component's data item.
   *
   * @param   dataItem   Data item
   * @param   _duration  Animation duration in milliseconds
   * @return             Promise
   */
  showDataItem(e, t) {
    return at(this, void 0, void 0, function* () {
      e.set("visible", !0);
    });
  }
  /**
   * Hides component's data item.
   *
   * @param   dataItem   Data item
   * @param   _duration  Animation duration in milliseconds
   * @return             Promise
   */
  hideDataItem(e, t) {
    return at(this, void 0, void 0, function* () {
      e.set("visible", !1);
    });
  }
  _clearDirty() {
    super._clearDirty(), this._valuesDirty = !1;
  }
  _afterDataChange() {
  }
  _afterChanged() {
    if (super._afterChanged(), this._dataChanged) {
      const e = "datavalidated";
      this.events.isEnabled(e) && this.events.dispatch(e, { type: e, target: this }), this._dataChanged = !1;
    }
    this.inited = !0;
  }
  /**
   * Forces a repaint of the element which relies on data.
   *
   * @since 5.0.21
   */
  markDirtyValues(e) {
    this.markDirty(), this._valuesDirty = !0;
  }
  _markDirtyGroup() {
    this._dataGrouped = !1;
  }
  /**
   * @ignore
   */
  markDirtySize() {
    this._sizeDirty = !0, this.markDirty();
  }
}
Object.defineProperty(Ni, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Component"
});
Object.defineProperty(Ni, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Z.classNames.concat([Ni.className])
});
class $i extends Se {
  _afterNew() {
    super._afterNewApplyThemes();
  }
  /**
   * @ignore
   */
  getFill(e) {
    return {
      addColorStop: (t, s) => {
      }
    };
  }
  _changed() {
    super._changed();
  }
  /**
   * @ignore
   */
  getBounds(e) {
    const t = this.get("target");
    if (t) {
      let s = t.globalBounds();
      const r = e.toLocal({ x: s.left, y: s.top }), n = e.toLocal({ x: s.right, y: s.top }), a = e.toLocal({ x: s.right, y: s.bottom }), o = e.toLocal({ x: s.left, y: s.bottom });
      return {
        left: Math.min(r.x, n.x, a.x, o.x),
        top: Math.min(r.y, n.y, a.y, o.y),
        right: Math.max(r.x, n.x, a.x, o.x),
        bottom: Math.max(r.y, n.y, a.y, o.y)
      };
    }
    return e._display.getLocalBounds();
  }
}
Object.defineProperty($i, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Gradient"
});
Object.defineProperty($i, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Se.classNames.concat([$i.className])
});
class Br extends $i {
  /**
   * @ignore
   */
  getFill(e) {
    const t = this.get("rotation", 0);
    let s = this.getBounds(e), r = s.left || 0, n = s.right || 0, a = s.top || 0, o = s.bottom || 0, l = jt(t), u = Lt(t), c = l * (n - r), h = u * (o - a), d = Math.max(c, h);
    const f = this._root._renderer.createLinearGradient(r, a, r + d * l, a + d * u), g = this.get("stops");
    if (g) {
      let p = 0;
      w(g, (_) => {
        let m = _.offset;
        S(m) || (m = p / (g.length - 1));
        let v = _.opacity;
        S(v) || (v = 1);
        let b = _.color;
        if (b) {
          const y = _.lighten;
          y && (b = X.lighten(b, y));
          const x = _.brighten;
          x && (b = X.brighten(b, x)), f.addColorStop(m, "rgba(" + b.r + "," + b.g + "," + b.b + "," + v + ")");
        }
        p++;
      });
    }
    return f;
  }
}
Object.defineProperty(Br, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "LinearGradient"
});
Object.defineProperty(Br, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: $i.classNames.concat([Br.className])
});
class ra extends Z {
  constructor() {
    super(...arguments), Object.defineProperty(this, "labelContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.children.push(Z.new(this._root, {}))
    }), Object.defineProperty(this, "markerContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.children.push(Z.new(this._root, {}))
    }), Object.defineProperty(this, "startLabel", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.labelContainer.children.push(Xe.new(this._root, { themeTags: ["start"] }))
    }), Object.defineProperty(this, "endLabel", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.labelContainer.children.push(Xe.new(this._root, { themeTags: ["end"] }))
    }), Object.defineProperty(this, "markers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new ze(me.new({}), () => et._new(this._root, {
        themeTags: ie(this.markers.template.get("themeTags", []), [this.get("orientation"), "heatlegend", "marker"])
      }, [this.markers.template]))
    });
  }
  _afterNew() {
    this._settings.themeTags = ie(this._settings.themeTags, ["heatlegend", this._settings.orientation]), super._afterNew(), this.set("tooltip", Mt.new(this._root, {
      themeTags: ["heatlegend"]
    }));
  }
  /**
   * @ignore
   */
  makeMarker() {
    const e = this.markers.make();
    return e.states.create("disabled", {}), e;
  }
  /**
   * Moves and shows tooltip at specific value.
   *
   * Can also specify optional text to show in tooltip, as well as the color.
   *
   * @param  value  Value
   * @param  text   Text
   * @param  color  Color
   */
  showValue(e, t, s) {
    const r = this.getTooltip();
    if (r && S(e)) {
      const n = this.get("startValue", 0), a = this.get("endValue", 1), o = (e - n) / (a - n), l = this.get("startColor"), u = this.get("endColor");
      t || (t = this.getNumberFormatter().format(e)), s || (s = X.interpolate(o, l, u)), r.label.set("text", t);
      let c;
      this.get("orientation") == "vertical" ? c = this.markerContainer.toGlobal({ x: 0, y: this.innerHeight() * (1 - o) }) : c = this.markerContainer.toGlobal({ x: this.innerWidth() * o, y: 0 });
      let h = r.get("background");
      h && h.set("fill", X.interpolate(o, l, u)), r.set("pointTo", c), r.show();
    }
  }
  _prepareChildren() {
    super._prepareChildren();
    const e = this.labelContainer, t = this.get("orientation"), s = this.startLabel, r = this.endLabel, n = this.getTooltip();
    if (this.isDirty("orientation") && (t == "vertical" ? (this.markerContainer.setAll({ layout: this._root.verticalLayout, height: R }), this.set("layout", this._root.horizontalLayout), s.setAll({ y: R, x: void 0, centerY: R, centerX: R }), r.setAll({ y: 0, x: void 0, centerY: 0, centerX: R }), e.setAll({ height: R, width: void 0 }), n && n.set("pointerOrientation", "horizontal")) : (this.markerContainer.setAll({ layout: this._root.horizontalLayout, width: R }), this.set("layout", this._root.verticalLayout), s.setAll({ x: 0, y: void 0, centerX: 0, centerY: 0 }), r.setAll({ x: R, y: void 0, centerX: R, centerY: 0 }), e.setAll({ width: R, height: void 0 }), n && n.set("pointerOrientation", "vertical"))), this.isDirty("stepCount")) {
      const a = this.get("stepCount", 1), o = this.get("startColor"), l = this.get("endColor");
      if (this.markerContainer.children.clear(), a > 1)
        for (let u = 0; u < a; u++) {
          const c = this.makeMarker();
          t == "vertical" ? this.markerContainer.children.moveValue(c, 0) : this.markerContainer.children.push(c), o && l && c.set("fill", X.interpolate(u / a, o, l));
        }
      else if (a == 1) {
        const u = this.makeMarker();
        this.markerContainer.children.push(u);
        const c = Br.new(this._root, { stops: [{ color: o }, { color: l }] });
        if (t == "vertical") {
          c.set("rotation", 90);
          let h = c.get("stops");
          h && h.reverse();
        } else
          c.set("rotation", 0);
        o && l && u.set("fillGradient", c);
      }
    }
    (this.isDirty("startText") || this.isDirty("startValue")) && s.set("text", this.get("startText", this.getNumberFormatter().format(this.get("startValue", 0)))), (this.isDirty("endText") || this.isDirty("endValue")) && r.set("text", this.get("endText", this.getNumberFormatter().format(this.get("endValue", 1))));
  }
}
Object.defineProperty(ra, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "HeatLegend"
});
Object.defineProperty(ra, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Z.classNames.concat([ra.className])
});
function Md(i) {
  return new Promise((e, t) => {
    setTimeout(e, i);
  });
}
let eo = {
  millisecond: 1,
  second: 1e3,
  minute: 6e4,
  hour: 36e5,
  day: 864e5,
  week: 6048e5,
  month: 365.242 / 12 * 864e5,
  year: 31536e6
};
function nn(i) {
  switch (i) {
    case "year":
      return;
    case "month":
      return "year";
    case "week":
      return "month";
    case "day":
      return "month";
    case "hour":
      return "day";
    case "minute":
      return "hour";
    case "second":
      return "minute";
    case "millisecond":
      return "second";
  }
}
function yt(i, e) {
  return e == null && (e = 1), eo[i] * e;
}
function kt(i) {
  return i ? eo[i.timeUnit] * i.count : 0;
}
function An(i, e, t, s, r) {
  const n = i.timeUnit, a = i.count;
  if (n == "hour" || n == "minute" || n == "second" || n == "millisecond")
    return eo[i.timeUnit] * i.count;
  {
    const o = Ve(new Date(e.getTime()), n, a, t, s, void 0, r).getTime();
    let l = o + a * yt(n) * 1.05;
    return l = Ve(new Date(l), n, 1, t, s, void 0, r).getTime(), l - o;
  }
}
function Od() {
  return new Date();
}
function Lw() {
  return Od().getTime();
}
function jw(i) {
  return new Date(i.getTime());
}
function an(i, e, t, s, r) {
  if (e - i > yt(t, 1.2))
    return !0;
  let n = new Date(i), a = new Date(e);
  r && (n = r.convertLocal(n), a = r.convertLocal(a));
  let o = 0, l = 0;
  !s && t != "millisecond" && (o = n.getTimezoneOffset(), n.setUTCMinutes(n.getUTCMinutes() - o), l = a.getTimezoneOffset(), a.setUTCMinutes(a.getUTCMinutes() - l));
  let u = !1;
  switch (t) {
    case "year":
      n.getUTCFullYear() != a.getUTCFullYear() && (u = !0);
      break;
    case "month":
      (n.getUTCFullYear() != a.getUTCFullYear() || n.getUTCMonth() != a.getUTCMonth()) && (u = !0);
      break;
    case "day":
      (n.getUTCMonth() != a.getUTCMonth() || n.getUTCDate() != a.getUTCDate()) && (u = !0);
      break;
    case "hour":
      n.getUTCHours() != a.getUTCHours() && (u = !0);
      break;
    case "minute":
      n.getUTCMinutes() != a.getUTCMinutes() && (u = !0);
      break;
    case "second":
      n.getUTCSeconds() != a.getUTCSeconds() && (u = !0);
      break;
    case "millisecond":
      n.getTime() != a.getTime() && (u = !0);
      break;
  }
  if (u)
    return u;
  let c = nn(t);
  return c ? an(i, e, c, s, r) : !1;
}
function Ad(i, e, t, s, r) {
  let n = 0;
  switch (!s && e != "millisecond" && (n = i.getTimezoneOffset(), r && (n -= r.offsetUTC(i)), i.setUTCMinutes(i.getUTCMinutes() - n)), e) {
    case "day":
      let a = i.getUTCDate();
      i.setUTCDate(a + t);
      break;
    case "second":
      let o = i.getUTCSeconds();
      i.setUTCSeconds(o + t);
      break;
    case "millisecond":
      let l = i.getUTCMilliseconds();
      i.setUTCMilliseconds(l + t);
      break;
    case "hour":
      let u = i.getUTCHours();
      i.setUTCHours(u + t);
      break;
    case "minute":
      let c = i.getUTCMinutes();
      i.setUTCMinutes(c + t);
      break;
    case "year":
      let h = i.getUTCFullYear();
      i.setUTCFullYear(h + t);
      break;
    case "month":
      let d = i.getUTCMonth();
      i.setUTCMonth(d + t);
      break;
    case "week":
      let f = i.getUTCDate();
      i.setUTCDate(f + t * 7);
      break;
  }
  if (!s && e != "millisecond" && (i.setUTCMinutes(i.getUTCMinutes() + n), e == "day" || e == "week" || e == "month" || e == "year")) {
    let a = i.getTimezoneOffset();
    if (r && (a += r.offsetUTC(i)), a != n) {
      let o = a - n;
      i.setUTCMinutes(i.getUTCMinutes() + o), i.getTimezoneOffset() != a && i.setUTCMinutes(i.getUTCMinutes() - o);
    }
  }
  return i;
}
function Ve(i, e, t, s, r, n, a) {
  if (!a || r) {
    let o = 0;
    switch (!r && e != "millisecond" && (o = i.getTimezoneOffset(), i.setUTCMinutes(i.getUTCMinutes() - o)), e) {
      case "day":
        let l = i.getUTCDate();
        if (t > 1) {
          if (n) {
            n = Ve(n, "day", 1);
            let m = i.getTime() - n.getTime(), v = Math.floor(m / yt("day") / t), b = yt("day", v * t);
            i.setTime(n.getTime() + b - o * yt("minute"));
          }
        } else
          i.setUTCDate(l);
        i.setUTCHours(0, 0, 0, 0);
        break;
      case "second":
        let u = i.getUTCSeconds();
        t > 1 && (u = Math.floor(u / t) * t), i.setUTCSeconds(u, 0);
        break;
      case "millisecond":
        if (t == 1)
          return i;
        let c = i.getUTCMilliseconds();
        c = Math.floor(c / t) * t, i.setUTCMilliseconds(c);
        break;
      case "hour":
        let h = i.getUTCHours();
        t > 1 && (h = Math.floor(h / t) * t), i.setUTCHours(h, 0, 0, 0);
        break;
      case "minute":
        let d = i.getUTCMinutes();
        t > 1 && (d = Math.floor(d / t) * t), i.setUTCMinutes(d, 0, 0);
        break;
      case "month":
        let f = i.getUTCMonth();
        t > 1 && (f = Math.floor(f / t) * t), i.setUTCMonth(f, 1), i.setUTCHours(0, 0, 0, 0);
        break;
      case "year":
        let g = i.getUTCFullYear();
        t > 1 && (g = Math.floor(g / t) * t), i.setUTCFullYear(g, 0, 1), i.setUTCHours(0, 0, 0, 0);
        break;
      case "week":
        let p = i.getUTCDate(), _ = i.getUTCDay();
        S(s) || (s = 1), _ >= s ? p = p - _ + s : p = p - (7 + _) + s, i.setUTCDate(p), i.setUTCHours(0, 0, 0, 0);
        break;
    }
    if (!r && e != "millisecond" && (i.setUTCMinutes(i.getUTCMinutes() + o), e == "day" || e == "week" || e == "month" || e == "year")) {
      let l = i.getTimezoneOffset();
      if (l != o) {
        let u = l - o;
        i.setUTCMinutes(i.getUTCMinutes() + u);
      }
    }
    return i;
  } else {
    if (isNaN(i.getTime()))
      return i;
    let o = a.offsetUTC(i), l = i.getTimezoneOffset(), u = a.parseDate(i), c = u.year, h = u.month, d = u.day, f = u.hour, g = u.minute, p = u.second, _ = u.millisecond, m = u.weekday;
    switch (e) {
      case "day":
        if (t > 1 && n) {
          n = Ve(n, "day", 1, s, r, void 0, a);
          let b = i.getTime() - n.getTime(), y = Math.floor(b / yt("day") / t), x = yt("day", y * t);
          i.setTime(n.getTime() + x), u = a.parseDate(i), c = u.year, h = u.month, d = u.day;
        }
        f = 0, g = o - l, p = 0, _ = 0;
        break;
      case "second":
        g += o - l, t > 1 && (p = Math.floor(p / t) * t), _ = 0;
        break;
      case "millisecond":
        g += o - l, t > 1 && (_ = Math.floor(_ / t) * t);
        break;
      case "hour":
        t > 1 && (f = Math.floor(f / t) * t), g = o - l, p = 0, _ = 0;
        break;
      case "minute":
        t > 1 && (g = Math.floor(g / t) * t), g += o - l, p = 0, _ = 0;
        break;
      case "month":
        t > 1 && (h = Math.floor(h / t) * t), d = 1, f = 0, g = o - l, p = 0, _ = 0;
        break;
      case "year":
        t > 1 && (c = Math.floor(c / t) * t), h = 0, d = 1, f = 0, g = o - l, p = 0, _ = 0;
        break;
      case "week":
        S(s) || (s = 1), m >= s ? d = d - m + s : d = d - (7 + m) + s, f = 0, g = o - l, p = 0, _ = 0;
        break;
    }
    i = new Date(c, h, d, f, g, p, _);
    let v = i.getTimezoneOffset();
    return v != l && i.setTime(i.getTime() + (l - v) * 6e4), i;
  }
}
function Us(i, e, t, s) {
  let r = s[i], n = kt(r), a = s.length - 1;
  if (i >= a)
    return Object.assign({}, s[a]);
  let o = Math.ceil(e / n);
  return e < n && i > 0 ? Object.assign({}, s[i - 1]) : o <= t ? Object.assign({}, s[i]) : i + 1 < s.length ? Us(i + 1, e, t, s) : Object.assign({}, s[i]);
}
function Ld(i, e) {
  switch (e) {
    case "day":
      return i.getDate();
    case "second":
      return i.getSeconds();
    case "millisecond":
      return i.getMilliseconds();
    case "hour":
      return i.getHours();
    case "minute":
      return i.getMinutes();
    case "month":
      return i.getMonth();
    case "year":
      return i.getFullYear();
    case "week":
      return Hs(i);
  }
}
const Ew = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  add: Ad,
  checkChange: an,
  chooseInterval: Us,
  copy: jw,
  getDateIntervalDuration: An,
  getDuration: yt,
  getIntervalDuration: kt,
  getNextUnit: nn,
  getTime: Lw,
  getUnitValue: Ld,
  now: Od,
  round: Ve,
  sleep: Md,
  timeUnitDurations: eo
}, Symbol.toStringTag, { value: "Module" }));
class Fi extends Ni {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_aggregatesCalculated", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_selectionAggregatesCalculated", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_dataProcessed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_psi", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_pei", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "chart", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "bullets", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new lr()
    }), Object.defineProperty(this, "bulletsContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Z.new(this._root, { width: R, height: R, position: "absolute" })
    });
  }
  _afterNew() {
    this.valueFields.push("value"), super._afterNew(), this.setPrivate("customData", {}), this._disposers.push(this.bullets.events.onAll((e) => {
      if (e.type === "clear")
        this._handleBullets(this.dataItems);
      else if (e.type === "push")
        this._handleBullets(this.dataItems);
      else if (e.type === "setIndex")
        this._handleBullets(this.dataItems);
      else if (e.type === "insertIndex")
        this._handleBullets(this.dataItems);
      else if (e.type === "removeIndex")
        this._handleBullets(this.dataItems);
      else if (e.type === "moveIndex")
        this._handleBullets(this.dataItems);
      else
        throw new Error("Unknown IListEvent type");
    }));
  }
  _dispose() {
    this.bulletsContainer.dispose(), super._dispose();
  }
  startIndex() {
    let e = this.dataItems.length;
    return Math.min(this.getPrivate("startIndex", 0), e);
  }
  endIndex() {
    let e = this.dataItems.length;
    return Math.min(this.getPrivate("endIndex", e), e);
  }
  _handleBullets(e) {
    w(e, (t) => {
      const s = t.bullets;
      s && (w(s, (r) => {
        r.dispose();
      }), t.bullets = void 0);
    }), this.markDirtyValues();
  }
  /**
   * Looks up and returns a data item by its ID.
   *
   * @param   id  ID
   * @return      Data item
   */
  getDataItemById(e) {
    return du(this.dataItems, (t) => t.get("id") == e);
  }
  _makeBullets(e) {
    this._shouldMakeBullet(e) && (e.bullets = [], this.bullets.each((t) => {
      this._makeBullet(e, t);
    }));
  }
  _shouldMakeBullet(e) {
    return !0;
  }
  _makeBullet(e, t, s) {
    const r = t(this._root, this, e);
    if (r) {
      let n = r.get("sprite");
      n && (n._setDataItem(e), n.setRaw("position", "absolute"), this.bulletsContainer.children.push(n)), r._index = s, r.series = this, e.bullets.push(r);
    }
    return r;
  }
  _clearDirty() {
    super._clearDirty(), this._aggregatesCalculated = !1, this._selectionAggregatesCalculated = !1;
  }
  _prepareChildren() {
    super._prepareChildren();
    let e = this.startIndex(), t = this.endIndex();
    if (this.isDirty("heatRules") && (this._valuesDirty = !0), this.isPrivateDirty("baseValueSeries")) {
      const r = this.getPrivate("baseValueSeries");
      r && this._disposers.push(r.onPrivate("startIndex", () => {
        this.markDirtyValues();
      }));
    }
    if (this.get("calculateAggregates") && (this._valuesDirty && !this._dataProcessed && (this._aggregatesCalculated || (this._calculateAggregates(0, this.dataItems.length), this._aggregatesCalculated = !0)), (this._psi != e || this._pei != t) && !this._selectionAggregatesCalculated && (e === 0 && t === this.dataItems.length && this._aggregatesCalculated || this._calculateAggregates(e, t), this._selectionAggregatesCalculated = !0)), this.isDirty("tooltip")) {
      let r = this.get("tooltip");
      r && (r.hide(0), r.set("tooltipTarget", this));
    }
    if (this.isDirty("fill") || this.isDirty("stroke")) {
      let r;
      const n = this.get("legendDataItem");
      if (n && (r = n.get("markerRectangle"), r && this.isVisible())) {
        if (this.isDirty("stroke")) {
          let a = this.get("stroke");
          r.set("stroke", a);
        }
        if (this.isDirty("fill")) {
          let a = this.get("fill");
          r.set("fill", a);
        }
      }
      this.updateLegendMarker(void 0);
    }
    if (this.bullets.length > 0) {
      let r = this.startIndex(), n = this.endIndex();
      n < this.dataItems.length && n++;
      for (let a = r; a < n; a++) {
        let o = this.dataItems[a];
        o.bullets || this._makeBullets(o);
      }
    }
  }
  _calculateAggregates(e, t) {
    let s = this._valueFields;
    if (!s)
      throw new Error("No value fields are set for the series.");
    const r = {}, n = {}, a = {}, o = {}, l = {}, u = {}, c = {}, h = {}, d = {};
    w(s, (f) => {
      r[f] = 0, n[f] = 0, a[f] = 0;
    }), w(s, (f) => {
      let g = f + "Change", p = f + "ChangePercent", _ = f + "ChangePrevious", m = f + "ChangePreviousPercent", v = f + "ChangeSelection", b = f + "ChangeSelectionPercent", y = "valueY";
      (f == "valueX" || f == "openValueX" || f == "lowValueX" || f == "highValueX") && (y = "valueX");
      const x = this.getPrivate("baseValueSeries");
      for (let D = e; D < t; D++) {
        const A = this.dataItems[D];
        let T = A.get(f);
        T != null && (a[f]++, r[f] += T, n[f] += Math.abs(T), h[f] = r[f] / a[f], (o[f] > T || o[f] == null) && (o[f] = T), (l[f] < T || l[f] == null) && (l[f] = T), c[f] = T, u[f] == null && (u[f] = T, d[f] = T, x && (u[y] = x._getBase(y))), e === 0 && (A.setRaw(g, T - u[y]), A.setRaw(p, (T - u[y]) / u[y] * 100)), A.setRaw(_, T - d[y]), A.setRaw(m, (T - d[y]) / d[y] * 100), A.setRaw(v, T - u[y]), A.setRaw(b, (T - u[y]) / u[y] * 100), d[f] = T);
      }
    }), w(s, (f) => {
      this.setPrivate(f + "AverageSelection", h[f]), this.setPrivate(f + "CountSelection", a[f]), this.setPrivate(f + "SumSelection", r[f]), this.setPrivate(f + "AbsoluteSumSelection", n[f]), this.setPrivate(f + "LowSelection", o[f]), this.setPrivate(f + "HighSelection", l[f]), this.setPrivate(f + "OpenSelection", u[f]), this.setPrivate(f + "CloseSelection", c[f]);
    }), e === 0 && t === this.dataItems.length && w(s, (f) => {
      this.setPrivate(f + "Average", h[f]), this.setPrivate(f + "Count", a[f]), this.setPrivate(f + "Sum", r[f]), this.setPrivate(f + "AbsoluteSum", n[f]), this.setPrivate(f + "Low", o[f]), this.setPrivate(f + "High", l[f]), this.setPrivate(f + "Open", u[f]), this.setPrivate(f + "Close", c[f]);
    });
  }
  _updateChildren() {
    super._updateChildren(), this._psi = this.startIndex(), this._pei = this.endIndex(), this.isDirty("visible") && this.bulletsContainer.set("visible", this.get("visible"));
    const e = this.get("heatRules");
    if (this._valuesDirty && e && e.length > 0 && w(e, (t) => {
      const s = t.minValue || this.getPrivate(t.dataField + "Low") || 0, r = t.maxValue || this.getPrivate(t.dataField + "High") || 0;
      w(t.target._entities, (n) => {
        const a = n.dataItem.get(t.dataField);
        if (!S(a)) {
          t.neutral && n.set(t.key, t.neutral);
          return;
        }
        let o;
        t.logarithmic ? o = (Math.log(a) * Math.LOG10E - Math.log(s) * Math.LOG10E) / (Math.log(r) * Math.LOG10E - Math.log(s) * Math.LOG10E) : o = (a - s) / (r - s), S(a) && (!S(o) || Math.abs(o) == 1 / 0) && (o = 0.5);
        let l;
        S(t.min) ? l = t.min + (t.max - t.min) * o : t.min instanceof X ? l = X.interpolate(o, t.min, t.max) : t.min instanceof re && (l = cd(o, t.min, t.max)), t.customFunction ? t.customFunction.call(this, n, s, r, a) : n.set(t.key, l);
      });
    }), this.bullets.length > 0) {
      let t = this.dataItems.length, s = this.startIndex(), r = this.endIndex();
      r < t && r++, s > 0 && s--;
      for (let n = 0; n < s; n++)
        this._hideBullets(this.dataItems[n]);
      for (let n = s; n < r; n++)
        this._positionBullets(this.dataItems[n]);
      for (let n = r; n < t; n++)
        this._hideBullets(this.dataItems[n]);
    }
  }
  _positionBullets(e) {
    e.bullets && w(e.bullets, (t) => {
      this._positionBullet(t);
      const s = t.get("sprite");
      t.get("dynamic") && (s && (s._markDirtyKey("fill"), s.markDirtySize()), s instanceof Z && s.walkChildren((r) => {
        r._markDirtyKey("fill"), r.markDirtySize(), r instanceof Xe && r.text.markDirtyText();
      })), s instanceof Xe && s.get("populateText") && s.text.markDirtyText();
    });
  }
  _hideBullets(e) {
    e.bullets && w(e.bullets, (t) => {
      let s = t.get("sprite");
      s && s.setPrivate("visible", !1);
    });
  }
  _positionBullet(e) {
  }
  _placeBulletsContainer(e) {
    e.bulletsContainer.children.moveValue(this.bulletsContainer);
  }
  _removeBulletsContainer() {
    const e = this.bulletsContainer;
    e.parent && e.parent.children.removeValue(e);
  }
  /**
   * @ignore
   */
  disposeDataItem(e) {
    const t = e.bullets;
    t && w(t, (s) => {
      s.dispose();
    });
  }
  _getItemReaderLabel() {
    return "";
  }
  /**
   * Shows series's data item.
   *
   * @param   dataItem  Data item
   * @param   duration  Animation duration in milliseconds
   * @return            Promise
   */
  showDataItem(e, t) {
    const s = Object.create(null, {
      showDataItem: { get: () => super.showDataItem }
    });
    return at(this, void 0, void 0, function* () {
      const r = [s.showDataItem.call(this, e, t)], n = e.bullets;
      n && w(n, (a) => {
        r.push(a.get("sprite").show(t));
      }), yield Promise.all(r);
    });
  }
  /**
   * Hides series's data item.
   *
   * @param   dataItem  Data item
   * @param   duration  Animation duration in milliseconds
   * @return            Promise
   */
  hideDataItem(e, t) {
    const s = Object.create(null, {
      hideDataItem: { get: () => super.hideDataItem }
    });
    return at(this, void 0, void 0, function* () {
      const r = [s.hideDataItem.call(this, e, t)], n = e.bullets;
      n && w(n, (a) => {
        r.push(a.get("sprite").hide(t));
      }), yield Promise.all(r);
    });
  }
  _sequencedShowHide(e, t) {
    return at(this, void 0, void 0, function* () {
      if (this.get("sequencedInterpolation"))
        if (S(t) || (t = this.get("interpolationDuration", 0)), t > 0) {
          const s = this.startIndex(), r = this.endIndex();
          yield Promise.all(Wn(this.dataItems, (n, a) => at(this, void 0, void 0, function* () {
            let o = t || 0;
            (a < s - 10 || a > r + 10) && (o = 0);
            let l = this.get("sequencedDelay", 0) + o / (r - s);
            yield Md(l * (a - s)), e ? yield this.showDataItem(n, o) : yield this.hideDataItem(n, o);
          })));
        } else
          yield Promise.all(Wn(this.dataItems, (s) => e ? this.showDataItem(s, 0) : this.hideDataItem(s, 0)));
    });
  }
  /**
   * @ignore
   */
  updateLegendValue(e) {
    if (e) {
      const t = e.get("legendDataItem");
      if (t) {
        const s = t.get("valueLabel");
        if (s) {
          const n = s.text;
          let a = "";
          s._setDataItem(e), a = this.get("legendValueText", n.get("text", "")), s.set("text", a), n.markDirtyText();
        }
        const r = t.get("label");
        if (r) {
          const n = r.text;
          let a = "";
          r._setDataItem(e), a = this.get("legendLabelText", n.get("text", "")), r.set("text", a), n.markDirtyText();
        }
      }
    }
  }
  /**
   * @ignore
   */
  updateLegendMarker(e) {
  }
  _onHide() {
    super._onHide();
    const e = this.getTooltip();
    e && e.hide();
  }
  /**
   * @ignore
   */
  hoverDataItem(e) {
  }
  /**
   * @ignore
   */
  unhoverDataItem(e) {
  }
  /**
   * @ignore
   */
  _getBase(e) {
    const t = this.dataItems[this.startIndex()];
    return t ? t.get(e) : 0;
  }
}
Object.defineProperty(Fi, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Series"
});
Object.defineProperty(Fi, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Ni.classNames.concat([Fi.className])
});
class Hr extends Fi {
  constructor() {
    super(...arguments), Object.defineProperty(this, "itemContainers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new ze(me.new({}), () => Z._new(this._root, {
        themeTags: ie(this.itemContainers.template.get("themeTags", []), ["legend", "item"]),
        themeTagsSelf: ie(this.itemContainers.template.get("themeTagsSelf", []), ["itemcontainer"]),
        background: et.new(this._root, {
          themeTags: ie(this.itemContainers.template.get("themeTags", []), ["legend", "item", "background"]),
          themeTagsSelf: ie(this.itemContainers.template.get("themeTagsSelf", []), ["itemcontainer"])
        })
      }, [this.itemContainers.template]))
    }), Object.defineProperty(this, "markers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new ze(me.new({}), () => Z._new(this._root, {
        themeTags: ie(this.markers.template.get("themeTags", []), ["legend", "marker"])
      }, [this.markers.template]))
    }), Object.defineProperty(this, "labels", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new ze(me.new({}), () => Xe._new(this._root, {
        themeTags: ie(this.labels.template.get("themeTags", []), ["legend", "label"])
      }, [this.labels.template]))
    }), Object.defineProperty(this, "valueLabels", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new ze(me.new({}), () => Xe._new(this._root, {
        themeTags: ie(this.valueLabels.template.get("themeTags", []), ["legend", "label", "value"])
      }, [this.valueLabels.template]))
    }), Object.defineProperty(this, "markerRectangles", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new ze(me.new({}), () => et._new(this._root, {
        themeTags: ie(this.markerRectangles.template.get("themeTags", []), ["legend", "marker", "rectangle"])
      }, [this.markerRectangles.template]))
    });
  }
  _afterNew() {
    this._settings.themeTags = ie(this._settings.themeTags, ["legend"]), this.fields.push("name", "stroke", "fill"), super._afterNew();
  }
  /**
   * @ignore
   */
  makeItemContainer(e) {
    const t = this.children.push(this.itemContainers.make());
    return t._setDataItem(e), this.itemContainers.push(t), t.states.create("disabled", {}), t;
  }
  /**
   * @ignore
   */
  makeMarker() {
    const e = this.markers.make();
    return this.markers.push(e), e.states.create("disabled", {}), e;
  }
  /**
   * @ignore
   */
  makeLabel() {
    const e = this.labels.make();
    return e.states.create("disabled", {}), e;
  }
  /**
   * @ignore
   */
  makeValueLabel() {
    const e = this.valueLabels.make();
    return e.states.create("disabled", {}), e;
  }
  /**
   * @ignore
   */
  makeMarkerRectangle() {
    const e = this.markerRectangles.make();
    return e.states.create("disabled", {}), e;
  }
  processDataItem(e) {
    super.processDataItem(e);
    const t = this.makeItemContainer(e), s = this.get("nameField"), r = this.get("fillField"), n = this.get("strokeField");
    if (t) {
      const o = this.get("clickTarget", "itemContainer"), l = e.dataContext;
      l && l.set && l.set("legendDataItem", e), t._setDataItem(e), e.set("itemContainer", t);
      const u = this.makeMarker();
      if (u) {
        t.children.push(u), u._setDataItem(e), e.set("marker", u);
        const d = this.get("useDefaultMarker"), f = u.children.push(this.makeMarkerRectangle());
        let g = e.get("fill"), p = e.get("stroke");
        e.set("markerRectangle", f), l && l.get && (g = l.get(r, g), p = l.get(n, p)), p || (p = g), d ? l.on && (l.on(r, () => {
          f.set("fill", l.get(r));
        }), l.on(n, () => {
          f.set("stroke", l.get(n));
        })) : l && l.createLegendMarker && l.createLegendMarker(), f.setAll({ fill: g, stroke: p });
        const _ = l.component;
        _ && _.updateLegendMarker && _.updateLegendMarker(l);
      }
      const c = this.makeLabel();
      if (c) {
        t.children.push(c), c._setDataItem(e), e.set("label", c), c.text.on("text", () => {
          t.set("ariaLabel", c.text._getText() + "; " + this._t("Press ENTER to toggle"));
        }), l && l.get && e.set("name", l.get(s));
        let d = e.get("name");
        d && c.set("text", d);
      }
      const h = this.makeValueLabel();
      if (h && (t.children.push(h), h._setDataItem(e), e.set("valueLabel", h)), l && l.show && (this._disposers.push(l.on("visible", (d) => {
        t.set("disabled", !d);
      })), l.get("visible") || t.set("disabled", !0), o != "none")) {
        var a = t;
        o == "marker" && (a = u), this._addClickEvents(a, l, e);
      }
      this.children.values.sort((d, f) => {
        var g = d.dataItem.dataContext, p = f.dataItem.dataContext;
        if (g && p) {
          var _ = this.data.indexOf(g), m = this.data.indexOf(p);
          if (_ > m)
            return 1;
          if (_ < m)
            return -1;
        }
        return 0;
      }), l && l.updateLegendValue && l.updateLegendValue();
    }
  }
  _addClickEvents(e, t, s) {
    e.set("cursorOverStyle", "pointer"), e.events.on("pointerover", () => {
      const r = t.component;
      r && r.hoverDataItem && r.hoverDataItem(t);
    }), e.events.on("pointerout", () => {
      const r = t.component;
      r && r.hoverDataItem && r.unhoverDataItem(t);
    }), e.events.on("click", () => {
      const r = s.get("label").text._getText();
      t.show && t.isHidden && (t.isHidden() || t.get("visible") === !1) ? (t.show(), e.set("disabled", !1), this._root.readerAlert(this._t("%1 shown", this._root.locale, r))) : t.hide && (t.hide(), e.set("disabled", !0), this._root.readerAlert(this._t("%1 hidden", this._root.locale, r)));
    });
  }
  /**
   * @ignore
   */
  disposeDataItem(e) {
    super.disposeDataItem(e);
    const t = e.dataContext;
    t && t.get && t.get("legendDataItem") == e && t.set("legendDataItem", void 0);
    let s = e.get("itemContainer");
    s && (this.itemContainers.removeValue(s), s.dispose());
    let r = e.get("marker");
    r && (this.markers.removeValue(r), r.dispose());
    let n = e.get("markerRectangle");
    n && (this.markerRectangles.removeValue(n), n.dispose());
    let a = e.get("label");
    a && (this.labels.removeValue(a), a.dispose());
    let o = e.get("valueLabel");
    o && (this.valueLabels.removeValue(o), o.dispose());
  }
}
Object.defineProperty(Hr, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Legend"
});
Object.defineProperty(Hr, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Fi.classNames.concat([Hr.className])
});
function Ku(i, e) {
  for (let t = 0, s = e.length; t < s; t++) {
    const r = e[t];
    if (r.length > 0) {
      let n = r[0];
      if (n.length > 0) {
        let a = n[0];
        i.moveTo(a.x, a.y);
        for (let o = 0, l = r.length; o < l; o++)
          Iw(i, r[o]);
      }
    }
  }
}
function Iw(i, e) {
  for (let t = 0, s = e.length; t < s; t++) {
    const r = e[t];
    i.lineTo(r.x, r.y);
  }
}
class Ws extends le {
  _beforeChanged() {
    super._beforeChanged(), (this.isDirty("points") || this.isDirty("segments") || this._sizeDirty || this.isPrivateDirty("width") || this.isPrivateDirty("height")) && (this._clear = !0);
  }
  _changed() {
    if (super._changed(), this._clear) {
      const e = this.get("points"), t = this.get("segments");
      if (e && e.length > 0) {
        let s = e[0];
        this._display.moveTo(s.x, s.y), Ku(this._display, [[e]]);
      } else if (t)
        Ku(this._display, t);
      else if (!this.get("draw")) {
        let s = this.width(), r = this.height();
        this._display.moveTo(0, 0), this._display.lineTo(s, r);
      }
    }
  }
}
Object.defineProperty(Ws, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Line"
});
Object.defineProperty(Ws, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: le.classNames.concat([Ws.className])
});
class na extends vt {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_display", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._root._renderer.makePicture(void 0)
    });
  }
  _changed() {
    if (super._changed(), this.isDirty("width")) {
      const e = this.get("width");
      this._display.width = S(e) ? e : void 0;
    }
    if (this.isDirty("height")) {
      const e = this.get("height");
      this._display.height = S(e) ? e : void 0;
    }
    if (this.isDirty("shadowColor")) {
      this._display.clear();
      const e = this.get("shadowColor");
      this._display.shadowColor = e ?? void 0;
    }
    this.isDirty("shadowBlur") && (this._display.clear(), this._display.shadowBlur = this.get("shadowBlur")), this.isDirty("shadowOffsetX") && (this._display.clear(), this._display.shadowOffsetX = this.get("shadowOffsetX")), this.isDirty("shadowOffsetY") && (this._display.clear(), this._display.shadowOffsetY = this.get("shadowOffsetY")), this.isDirty("shadowOpacity") && (this._display.clear(), this._display.shadowOpacity = this.get("shadowOpacity")), (this.isDirty("src") || this.isDirty("cors")) && (this._display.clear(), this._load());
  }
  _load() {
    const e = this.get("src");
    if (e) {
      const t = new Image();
      t.crossOrigin = this.get("cors", "anonymous"), t.src = e, t.decode().then(() => {
        this._display.image = t, this._updateSize();
      }).catch((s) => {
      });
    }
  }
  _updateSize() {
    super._updateSize();
    const e = this._display.image;
    if (e) {
      let t = this.getPrivate("width", this.get("width")), s = this.getPrivate("height", this.get("height"));
      const r = e.width && e.height ? e.width / e.height : 0;
      S(t) && S(s) ? (this._display.width = t, this._display.height = s) : S(t) && r ? s = t / r : S(s) && r ? t = s * r : (t = e.width, s = e.height), S(t) && (this._display.width = t), S(s) && (this._display.height = s), this.markDirtyBounds(), this.markDirty();
    }
  }
}
Object.defineProperty(na, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Picture"
});
Object.defineProperty(na, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: vt.classNames.concat([na.className])
});
class zr extends Ri {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_display", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._root._renderer.makeRadialText("", this.textStyle)
    });
  }
  _afterNew() {
    super._afterNew();
  }
  _beforeChanged() {
    super._beforeChanged(), this._display.clear(), this.isDirty("textType") && (this._display.textType = this.get("textType"), this.markDirtyBounds()), this.isDirty("radius") && (this._display.radius = this.get("radius"), this.markDirtyBounds()), this.isDirty("startAngle") && (this._display.startAngle = (this.get("startAngle", 0) + 90) * ps, this.markDirtyBounds()), this.isDirty("inside") && (this._display.inside = this.get("inside"), this.markDirtyBounds()), this.isDirty("orientation") && (this._display.orientation = this.get("orientation"), this.markDirtyBounds()), this.isDirty("kerning") && (this._display.kerning = this.get("kerning"), this.markDirtyBounds());
  }
}
Object.defineProperty(zr, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "RadialText"
});
Object.defineProperty(zr, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Ri.classNames.concat([zr.className])
});
class Gs extends Xe {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_flipped", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    });
  }
  _afterNew() {
    this._textKeys.push("textType", "kerning"), super._afterNew();
  }
  _makeText() {
    this._text = this.children.push(zr.new(this._root, {}));
  }
  /**
   * Returns base radius in pixels.
   *
   * @return Base radius
   */
  baseRadius() {
    const e = this.getPrivate("radius", 0), t = this.getPrivate("innerRadius", 0), s = this.get("baseRadius", 0);
    return t + Re(s, e - t);
  }
  /**
   * Returns radius adjustment in pixels.
   *
   * @return Radius
   */
  radius() {
    const e = this.get("inside", !1);
    return this.baseRadius() + this.get("radius", 0) * (e ? -1 : 1);
  }
  _updateChildren() {
    if (super._updateChildren(), this.isDirty("baseRadius") || this.isPrivateDirty("radius") || this.isPrivateDirty("innerRadius") || this.isDirty("labelAngle") || this.isDirty("radius") || this.isDirty("inside") || this.isDirty("orientation") || this.isDirty("textType")) {
      const e = this.get("textType", "adjusted"), t = this.get("inside", !1), s = this.get("orientation");
      let r = zs(this.get("labelAngle", 0));
      this._text.set("startAngle", this.get("labelAngle", 0)), this._text.set("inside", t);
      const n = Lt(r), a = jt(r);
      let o = this.baseRadius(), l = this.radius();
      if (this._display.angle = 0, e == "circular")
        this.setAll({
          paddingTop: 0,
          paddingBottom: 0,
          paddingLeft: 0,
          paddingRight: 0
        }), this._text.set("orientation", s), this._text.set("radius", l);
      else {
        o == 0 && (r = 0, l = 0);
        let u = l * a, c = l * n;
        e == "radial" ? (this.setRaw("x", u), this.setRaw("y", c), r < 90 || r > 270 || s != "auto" ? (this._display.angle = r, this._flipped = !1) : (this._display.angle = r + 180, this._flipped = !0), this._dirty.rotation = !1) : e == "adjusted" ? (this.setRaw("centerX", ce), this.setRaw("centerY", ce), this.setRaw("x", u), this.setRaw("y", c)) : e == "regular" && (this.setRaw("x", u), this.setRaw("y", c));
      }
      this.markDirtyPosition(), this.markDirtyBounds();
    }
  }
  _updatePosition() {
    const e = this.get("textType", "regular"), t = this.get("inside", !1);
    let s = 0, r = 0, n = this.get("labelAngle", 0), a = this.localBounds(), o = a.right - a.left, l = a.bottom - a.top;
    if (e == "radial") {
      if (this._flipped) {
        let u = this.get("centerX");
        u instanceof re && (o = o * (1 - u.value * 2)), s = o * jt(n), r = o * Lt(n);
      }
    } else
      !t && e == "adjusted" && (s = o / 2 * jt(n), r = l / 2 * Lt(n));
    this.setRaw("dx", s), this.setRaw("dy", r), super._updatePosition();
  }
  /**
   * @ignore
   */
  get text() {
    return this._text;
  }
}
Object.defineProperty(Gs, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "RadialLabel"
});
Object.defineProperty(Gs, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Xe.classNames.concat([Gs.className])
});
class aa extends le {
  _beforeChanged() {
    super._beforeChanged(), (this.isDirty("width") || this.isDirty("height") || this.isPrivateDirty("width") || this.isPrivateDirty("height")) && (this._clear = !0);
  }
  _changed() {
    super._changed(), this._clear && !this.get("draw") && this._draw();
  }
  _draw() {
    const e = this.width(), t = this.height(), s = this._display;
    s.moveTo(-e / 2, t / 2), s.lineTo(0, -t / 2), s.lineTo(e / 2, t / 2), s.lineTo(-e / 2, t / 2), s.closePath();
  }
  _updateSize() {
    this.markDirty(), this._clear = !0;
  }
}
Object.defineProperty(aa, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Triangle"
});
Object.defineProperty(aa, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: le.classNames.concat([aa.className])
});
class _i extends Z {
  constructor() {
    super(...arguments), Object.defineProperty(this, "thumb", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._makeThumb()
    }), Object.defineProperty(this, "startGrip", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._makeButton()
    }), Object.defineProperty(this, "endGrip", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._makeButton()
    }), Object.defineProperty(this, "_thumbBusy", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_startDown", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_endDown", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_thumbDown", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_gripDown", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  _addOrientationClass() {
    this._settings.themeTags = ie(this._settings.themeTags, ["scrollbar", this._settings.orientation]), this._settings.background || (this._settings.background = et.new(this._root, {
      themeTags: ie(this._settings.themeTags, ["main", "background"])
    }));
  }
  _makeButton() {
    return this.children.push(Vs.new(this._root, {
      themeTags: ["resize", "button", this.get("orientation")],
      icon: le.new(this._root, {
        themeTags: ["icon"]
      })
    }));
  }
  _makeThumb() {
    return this.children.push(et.new(this._root, {
      themeTags: ["thumb", this.get("orientation")]
    }));
  }
  _handleAnimation(e) {
    e && this._disposers.push(e.events.on("stopped", () => {
      this.setPrivateRaw("isBusy", !1), this._thumbBusy = !1;
    }));
  }
  _afterNew() {
    this._addOrientationClass(), super._afterNew();
    const e = this.startGrip, t = this.endGrip, s = this.thumb, r = this.get("background");
    r && this._disposers.push(r.events.on("click", (n) => {
      this.setPrivateRaw("isBusy", !0);
      const a = this._display.toLocal(n.point), o = this.width(), l = this.height(), u = this.get("orientation");
      let c;
      u == "vertical" ? c = (a.y - s.height() / 2) / l : c = (a.x - s.width() / 2) / o;
      let h, d;
      u == "vertical" ? (h = c * l, d = "y") : (h = c * o, d = "x");
      const f = this.get("animationDuration", 0);
      f > 0 ? (this._thumbBusy = !0, this._handleAnimation(this.thumb.animate({ key: d, to: h, duration: f, easing: this.get("animationEasing") }))) : (this.thumb.set(d, h), this._root.events.once("frameended", () => {
        this.setPrivateRaw("isBusy", !1);
      }));
    })), this._disposers.push(s.events.on("dblclick", (n) => {
      if (!Wa(n.originalEvent, this))
        return;
      const a = this.get("animationDuration", 0), o = this.get("animationEasing");
      this.animate({ key: "start", to: 0, duration: a, easing: o }), this.animate({ key: "end", to: 1, duration: a, easing: o });
    })), this._disposers.push(e.events.on("pointerdown", () => {
      this.setPrivateRaw("isBusy", !0), this._startDown = !0, this._gripDown = "start";
    })), this._disposers.push(t.events.on("pointerdown", () => {
      this.setPrivateRaw("isBusy", !0), this._endDown = !0, this._gripDown = "end";
    })), this._disposers.push(s.events.on("pointerdown", () => {
      this.setPrivateRaw("isBusy", !0), this._thumbDown = !0, this._gripDown = void 0;
    })), this._disposers.push(e.events.on("globalpointerup", () => {
      this._startDown && this.setPrivateRaw("isBusy", !1), this._startDown = !1;
    })), this._disposers.push(t.events.on("globalpointerup", () => {
      this._endDown && this.setPrivateRaw("isBusy", !1), this._endDown = !1;
    })), this._disposers.push(s.events.on("globalpointerup", () => {
      this._thumbDown && this.setPrivateRaw("isBusy", !1), this._thumbDown = !1;
    })), this._disposers.push(e.on("x", () => {
      this._updateThumb();
    })), this._disposers.push(t.on("x", () => {
      this._updateThumb();
    })), this._disposers.push(e.on("y", () => {
      this._updateThumb();
    })), this._disposers.push(t.on("y", () => {
      this._updateThumb();
    })), this._disposers.push(s.events.on("positionchanged", () => {
      this._updateGripsByThumb();
    })), this.get("orientation") == "vertical" ? (e.set("x", 0), t.set("x", 0), this._disposers.push(s.adapters.add("y", (n) => Math.max(Math.min(Number(n), this.height() - s.height()), 0))), this._disposers.push(s.adapters.add("x", (n) => this.width() / 2)), this._disposers.push(e.adapters.add("x", (n) => this.width() / 2)), this._disposers.push(t.adapters.add("x", (n) => this.width() / 2)), this._disposers.push(e.adapters.add("y", (n) => Math.max(Math.min(Number(n), this.height()), 0))), this._disposers.push(t.adapters.add("y", (n) => Math.max(Math.min(Number(n), this.height()), 0)))) : (e.set("y", 0), t.set("y", 0), this._disposers.push(s.adapters.add("x", (n) => Math.max(Math.min(Number(n), this.width() - s.width()), 0))), this._disposers.push(s.adapters.add("y", (n) => this.height() / 2)), this._disposers.push(e.adapters.add("y", (n) => this.height() / 2)), this._disposers.push(t.adapters.add("y", (n) => this.height() / 2)), this._disposers.push(e.adapters.add("x", (n) => Math.max(Math.min(Number(n), this.width()), 0))), this._disposers.push(t.adapters.add("x", (n) => Math.max(Math.min(Number(n), this.width()), 0))));
  }
  _updateChildren() {
    super._updateChildren(), (this.isDirty("end") || this.isDirty("start") || this._sizeDirty) && this.updateGrips();
  }
  _changed() {
    if (super._changed(), this.isDirty("start") || this.isDirty("end")) {
      const e = "rangechanged";
      this.events.isEnabled(e) && this.events.dispatch(e, { type: e, target: this, start: this.get("start", 0), end: this.get("end", 1), grip: this._gripDown });
    }
  }
  /**
   * @ignore
   */
  updateGrips() {
    const e = this.startGrip, t = this.endGrip, s = this.get("orientation"), r = this.height(), n = this.width();
    s == "vertical" ? (e.set("y", r * this.get("start", 0)), t.set("y", r * this.get("end", 1))) : (e.set("x", n * this.get("start", 0)), t.set("x", n * this.get("end", 1)));
    const a = this.getPrivate("positionTextFunction"), o = Math.round(this.get("start", 0) * 100), l = Math.round(this.get("end", 0) * 100);
    let u, c;
    a ? (u = a.call(this, this.get("start", 0)), c = a.call(this, this.get("end", 0))) : (u = o + "%", c = l + "%"), e.set("ariaLabel", this._t("From %1", void 0, u)), e.set("ariaValueNow", "" + o), e.set("ariaValueText", o + "%"), e.set("ariaValueMin", "0"), e.set("ariaValueMax", "100"), t.set("ariaLabel", this._t("To %1", void 0, c)), t.set("ariaValueNow", "" + l), t.set("ariaValueText", l + "%"), t.set("ariaValueMin", "0"), t.set("ariaValueMax", "100");
  }
  _updateThumb() {
    const e = this.thumb, t = this.startGrip, s = this.endGrip, r = this.height(), n = this.width();
    let a = t.x(), o = s.x(), l = t.y(), u = s.y(), c = 0, h = 1;
    this.get("orientation") == "vertical" ? S(l) && S(u) && (!this._thumbBusy && !e.isDragging() && (e.set("height", u - l), e.set("y", l)), c = l / r, h = u / r) : S(a) && S(o) && (!this._thumbBusy && !e.isDragging() && (e.set("width", o - a), e.set("x", a)), c = a / n, h = o / n), this.getPrivate("isBusy") && (this.get("start") != c || this.get("end") != h) && (this.set("start", c), this.set("end", h));
    const d = this.getPrivate("positionTextFunction"), f = Math.round(this.get("start", 0) * 100), g = Math.round(this.get("end", 0) * 100);
    let p, _;
    d ? (p = d.call(this, this.get("start", 0)), _ = d.call(this, this.get("end", 0))) : (p = f + "%", _ = g + "%"), e.set("ariaLabel", this._t("From %1 to %2", void 0, p, _)), e.set("ariaValueNow", "" + f), e.set("ariaValueText", f + "%");
  }
  _updateGripsByThumb() {
    const e = this.thumb, t = this.startGrip, s = this.endGrip;
    if (this.get("orientation") == "vertical") {
      const r = e.height();
      t.set("y", e.y()), s.set("y", e.y() + r);
    } else {
      const r = e.width();
      t.set("x", e.x()), s.set("x", e.x() + r);
    }
  }
}
Object.defineProperty(_i, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Scrollbar"
});
Object.defineProperty(_i, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Z.classNames.concat([_i.className])
});
let oa = class extends _i {
  _afterNew() {
    this._addOrientationClass(), super._afterNew(), this.endGrip.setPrivate("visible", !1), this.thumb.setPrivate("visible", !1);
  }
  /**
   * @ignore
   */
  updateGrips() {
    super.updateGrips();
    const e = this.startGrip;
    this.endGrip.setAll({ x: e.x(), y: e.y() }), this.setRaw("end", this.get("start"));
  }
};
Object.defineProperty(oa, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Slider"
});
Object.defineProperty(oa, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: _i.classNames.concat([oa.className])
});
var al = Math.PI, ol = 2 * al, rs = 1e-6, Yw = ol - rs;
function ll() {
  this._x0 = this._y0 = // start of current subpath
  this._x1 = this._y1 = null, this._ = "";
}
function to() {
  return new ll();
}
ll.prototype = to.prototype = {
  constructor: ll,
  moveTo: function(i, e) {
    this._ += "M" + (this._x0 = this._x1 = +i) + "," + (this._y0 = this._y1 = +e);
  },
  closePath: function() {
    this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._ += "Z");
  },
  lineTo: function(i, e) {
    this._ += "L" + (this._x1 = +i) + "," + (this._y1 = +e);
  },
  quadraticCurveTo: function(i, e, t, s) {
    this._ += "Q" + +i + "," + +e + "," + (this._x1 = +t) + "," + (this._y1 = +s);
  },
  bezierCurveTo: function(i, e, t, s, r, n) {
    this._ += "C" + +i + "," + +e + "," + +t + "," + +s + "," + (this._x1 = +r) + "," + (this._y1 = +n);
  },
  arcTo: function(i, e, t, s, r) {
    i = +i, e = +e, t = +t, s = +s, r = +r;
    var n = this._x1, a = this._y1, o = t - i, l = s - e, u = n - i, c = a - e, h = u * u + c * c;
    if (r < 0)
      throw new Error("negative radius: " + r);
    if (this._x1 === null)
      this._ += "M" + (this._x1 = i) + "," + (this._y1 = e);
    else if (h > rs)
      if (!(Math.abs(c * o - l * u) > rs) || !r)
        this._ += "L" + (this._x1 = i) + "," + (this._y1 = e);
      else {
        var d = t - n, f = s - a, g = o * o + l * l, p = d * d + f * f, _ = Math.sqrt(g), m = Math.sqrt(h), v = r * Math.tan((al - Math.acos((g + h - p) / (2 * _ * m))) / 2), b = v / m, y = v / _;
        Math.abs(b - 1) > rs && (this._ += "L" + (i + b * u) + "," + (e + b * c)), this._ += "A" + r + "," + r + ",0,0," + +(c * d > u * f) + "," + (this._x1 = i + y * o) + "," + (this._y1 = e + y * l);
      }
  },
  arc: function(i, e, t, s, r, n) {
    i = +i, e = +e, t = +t, n = !!n;
    var a = t * Math.cos(s), o = t * Math.sin(s), l = i + a, u = e + o, c = 1 ^ n, h = n ? s - r : r - s;
    if (t < 0)
      throw new Error("negative radius: " + t);
    this._x1 === null ? this._ += "M" + l + "," + u : (Math.abs(this._x1 - l) > rs || Math.abs(this._y1 - u) > rs) && (this._ += "L" + l + "," + u), t && (h < 0 && (h = h % ol + ol), h > Yw ? this._ += "A" + t + "," + t + ",0,1," + c + "," + (i - a) + "," + (e - o) + "A" + t + "," + t + ",0,1," + c + "," + (this._x1 = l) + "," + (this._y1 = u) : h > rs && (this._ += "A" + t + "," + t + ",0," + +(h >= al) + "," + c + "," + (this._x1 = i + t * Math.cos(r)) + "," + (this._y1 = e + t * Math.sin(r))));
  },
  rect: function(i, e, t, s) {
    this._ += "M" + (this._x0 = this._x1 = +i) + "," + (this._y0 = this._y1 = +e) + "h" + +t + "v" + +s + "h" + -t + "Z";
  },
  toString: function() {
    return this._;
  }
};
function Ye(i) {
  return function() {
    return i;
  };
}
var Qu = Math.abs, tt = Math.atan2, Ji = Math.cos, Rw = Math.max, _o = Math.min, qt = Math.sin, Ls = Math.sqrt, _t = 1e-12, Xr = Math.PI, la = Xr / 2, Nw = 2 * Xr;
function $w(i) {
  return i > 1 ? 0 : i < -1 ? Xr : Math.acos(i);
}
function qu(i) {
  return i >= 1 ? la : i <= -1 ? -la : Math.asin(i);
}
function Fw(i) {
  return i.innerRadius;
}
function Bw(i) {
  return i.outerRadius;
}
function Hw(i) {
  return i.startAngle;
}
function zw(i) {
  return i.endAngle;
}
function Xw(i) {
  return i && i.padAngle;
}
function Vw(i, e, t, s, r, n, a, o) {
  var l = t - i, u = s - e, c = a - r, h = o - n, d = h * l - c * u;
  if (!(d * d < _t))
    return d = (c * (e - n) - h * (i - r)) / d, [i + d * l, e + d * u];
}
function bn(i, e, t, s, r, n, a) {
  var o = i - t, l = e - s, u = (a ? n : -n) / Ls(o * o + l * l), c = u * l, h = -u * o, d = i + c, f = e + h, g = t + c, p = s + h, _ = (d + g) / 2, m = (f + p) / 2, v = g - d, b = p - f, y = v * v + b * b, x = r - n, D = d * p - g * f, A = (b < 0 ? -1 : 1) * Ls(Rw(0, x * x * y - D * D)), T = (D * b - v * A) / y, j = (-D * v - b * A) / y, C = (D * b + v * A) / y, L = (-D * v + b * A) / y, E = T - _, N = j - m, q = C - _, z = L - m;
  return E * E + N * N > q * q + z * z && (T = C, j = L), {
    cx: T,
    cy: j,
    x01: -c,
    y01: -h,
    x11: T * (r / x - 1),
    y11: j * (r / x - 1)
  };
}
function Uw() {
  var i = Fw, e = Bw, t = Ye(0), s = null, r = Hw, n = zw, a = Xw, o = null;
  function l() {
    var u, c, h = +i.apply(this, arguments), d = +e.apply(this, arguments), f = r.apply(this, arguments) - la, g = n.apply(this, arguments) - la, p = Qu(g - f), _ = g > f;
    if (o || (o = u = to()), d < h && (c = d, d = h, h = c), !(d > _t))
      o.moveTo(0, 0);
    else if (p > Nw - _t)
      o.moveTo(d * Ji(f), d * qt(f)), o.arc(0, 0, d, f, g, !_), h > _t && (o.moveTo(h * Ji(g), h * qt(g)), o.arc(0, 0, h, g, f, _));
    else {
      var m = f, v = g, b = f, y = g, x = p, D = p, A = a.apply(this, arguments) / 2, T = A > _t && (s ? +s.apply(this, arguments) : Ls(h * h + d * d)), j = _o(Qu(d - h) / 2, +t.apply(this, arguments)), C = j, L = j, E, N;
      if (T > _t) {
        var q = qu(T / h * qt(A)), z = qu(T / d * qt(A));
        (x -= q * 2) > _t ? (q *= _ ? 1 : -1, b += q, y -= q) : (x = 0, b = y = (f + g) / 2), (D -= z * 2) > _t ? (z *= _ ? 1 : -1, m += z, v -= z) : (D = 0, m = v = (f + g) / 2);
      }
      var H = d * Ji(m), Y = d * qt(m), W = h * Ji(y), B = h * qt(y);
      if (j > _t) {
        var oe = d * Ji(v), O = d * qt(v), k = h * Ji(b), M = h * qt(b), $;
        if (p < Xr && ($ = Vw(H, Y, k, M, oe, O, W, B))) {
          var J = H - $[0], U = Y - $[1], de = oe - $[0], ve = O - $[1], wt = 1 / qt($w((J * de + U * ve) / (Ls(J * J + U * U) * Ls(de * de + ve * ve))) / 2), Ki = Ls($[0] * $[0] + $[1] * $[1]);
          C = _o(j, (h - Ki) / (wt - 1)), L = _o(j, (d - Ki) / (wt + 1));
        }
      }
      D > _t ? L > _t ? (E = bn(k, M, H, Y, d, L, _), N = bn(oe, O, W, B, d, L, _), o.moveTo(E.cx + E.x01, E.cy + E.y01), L < j ? o.arc(E.cx, E.cy, L, tt(E.y01, E.x01), tt(N.y01, N.x01), !_) : (o.arc(E.cx, E.cy, L, tt(E.y01, E.x01), tt(E.y11, E.x11), !_), o.arc(0, 0, d, tt(E.cy + E.y11, E.cx + E.x11), tt(N.cy + N.y11, N.cx + N.x11), !_), o.arc(N.cx, N.cy, L, tt(N.y11, N.x11), tt(N.y01, N.x01), !_))) : (o.moveTo(H, Y), o.arc(0, 0, d, m, v, !_)) : o.moveTo(H, Y), !(h > _t) || !(x > _t) ? o.lineTo(W, B) : C > _t ? (E = bn(W, B, oe, O, h, -C, _), N = bn(H, Y, k, M, h, -C, _), o.lineTo(E.cx + E.x01, E.cy + E.y01), C < j ? o.arc(E.cx, E.cy, C, tt(E.y01, E.x01), tt(N.y01, N.x01), !_) : (o.arc(E.cx, E.cy, C, tt(E.y01, E.x01), tt(E.y11, E.x11), !_), o.arc(0, 0, h, tt(E.cy + E.y11, E.cx + E.x11), tt(N.cy + N.y11, N.cx + N.x11), _), o.arc(N.cx, N.cy, C, tt(N.y11, N.x11), tt(N.y01, N.x01), !_))) : o.arc(0, 0, h, y, b, _);
    }
    if (o.closePath(), u)
      return o = null, u + "" || null;
  }
  return l.centroid = function() {
    var u = (+i.apply(this, arguments) + +e.apply(this, arguments)) / 2, c = (+r.apply(this, arguments) + +n.apply(this, arguments)) / 2 - Xr / 2;
    return [Ji(c) * u, qt(c) * u];
  }, l.innerRadius = function(u) {
    return arguments.length ? (i = typeof u == "function" ? u : Ye(+u), l) : i;
  }, l.outerRadius = function(u) {
    return arguments.length ? (e = typeof u == "function" ? u : Ye(+u), l) : e;
  }, l.cornerRadius = function(u) {
    return arguments.length ? (t = typeof u == "function" ? u : Ye(+u), l) : t;
  }, l.padRadius = function(u) {
    return arguments.length ? (s = u == null ? null : typeof u == "function" ? u : Ye(+u), l) : s;
  }, l.startAngle = function(u) {
    return arguments.length ? (r = typeof u == "function" ? u : Ye(+u), l) : r;
  }, l.endAngle = function(u) {
    return arguments.length ? (n = typeof u == "function" ? u : Ye(+u), l) : n;
  }, l.padAngle = function(u) {
    return arguments.length ? (a = typeof u == "function" ? u : Ye(+u), l) : a;
  }, l.context = function(u) {
    return arguments.length ? (o = u ?? null, l) : o;
  }, l;
}
function jd(i) {
  this._context = i;
}
jd.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(i, e) {
    switch (i = +i, e = +e, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(i, e) : this._context.moveTo(i, e);
        break;
      case 1:
        this._point = 2;
      default:
        this._context.lineTo(i, e);
        break;
    }
  }
};
function Ed(i) {
  return new jd(i);
}
function Id(i) {
  return i[0];
}
function Yd(i) {
  return i[1];
}
function Rd() {
  var i = Id, e = Yd, t = Ye(!0), s = null, r = Ed, n = null;
  function a(o) {
    var l, u = o.length, c, h = !1, d;
    for (s == null && (n = r(d = to())), l = 0; l <= u; ++l)
      !(l < u && t(c = o[l], l, o)) === h && ((h = !h) ? n.lineStart() : n.lineEnd()), h && n.point(+i(c, l, o), +e(c, l, o));
    if (d)
      return n = null, d + "" || null;
  }
  return a.x = function(o) {
    return arguments.length ? (i = typeof o == "function" ? o : Ye(+o), a) : i;
  }, a.y = function(o) {
    return arguments.length ? (e = typeof o == "function" ? o : Ye(+o), a) : e;
  }, a.defined = function(o) {
    return arguments.length ? (t = typeof o == "function" ? o : Ye(!!o), a) : t;
  }, a.curve = function(o) {
    return arguments.length ? (r = o, s != null && (n = r(s)), a) : r;
  }, a.context = function(o) {
    return arguments.length ? (o == null ? s = n = null : n = r(s = o), a) : s;
  }, a;
}
function Ww() {
  var i = Id, e = null, t = Ye(0), s = Yd, r = Ye(!0), n = null, a = Ed, o = null;
  function l(c) {
    var h, d, f, g = c.length, p, _ = !1, m, v = new Array(g), b = new Array(g);
    for (n == null && (o = a(m = to())), h = 0; h <= g; ++h) {
      if (!(h < g && r(p = c[h], h, c)) === _)
        if (_ = !_)
          d = h, o.areaStart(), o.lineStart();
        else {
          for (o.lineEnd(), o.lineStart(), f = h - 1; f >= d; --f)
            o.point(v[f], b[f]);
          o.lineEnd(), o.areaEnd();
        }
      _ && (v[h] = +i(p, h, c), b[h] = +t(p, h, c), o.point(e ? +e(p, h, c) : v[h], s ? +s(p, h, c) : b[h]));
    }
    if (m)
      return o = null, m + "" || null;
  }
  function u() {
    return Rd().defined(r).curve(a).context(n);
  }
  return l.x = function(c) {
    return arguments.length ? (i = typeof c == "function" ? c : Ye(+c), e = null, l) : i;
  }, l.x0 = function(c) {
    return arguments.length ? (i = typeof c == "function" ? c : Ye(+c), l) : i;
  }, l.x1 = function(c) {
    return arguments.length ? (e = c == null ? null : typeof c == "function" ? c : Ye(+c), l) : e;
  }, l.y = function(c) {
    return arguments.length ? (t = typeof c == "function" ? c : Ye(+c), s = null, l) : t;
  }, l.y0 = function(c) {
    return arguments.length ? (t = typeof c == "function" ? c : Ye(+c), l) : t;
  }, l.y1 = function(c) {
    return arguments.length ? (s = c == null ? null : typeof c == "function" ? c : Ye(+c), l) : s;
  }, l.lineX0 = l.lineY0 = function() {
    return u().x(i).y(t);
  }, l.lineY1 = function() {
    return u().x(i).y(s);
  }, l.lineX1 = function() {
    return u().x(e).y(t);
  }, l.defined = function(c) {
    return arguments.length ? (r = typeof c == "function" ? c : Ye(!!c), l) : r;
  }, l.curve = function(c) {
    return arguments.length ? (a = c, n != null && (o = a(n)), l) : a;
  }, l.context = function(c) {
    return arguments.length ? (c == null ? n = o = null : o = a(n = c), l) : n;
  }, l;
}
function Ju(i, e, t) {
  i._context.bezierCurveTo(
    i._x1 + i._k * (i._x2 - i._x0),
    i._y1 + i._k * (i._y2 - i._y0),
    i._x2 + i._k * (i._x1 - e),
    i._y2 + i._k * (i._y1 - t),
    i._x2,
    i._y2
  );
}
function Nd(i, e) {
  this._context = i, this._k = (1 - e) / 6;
}
Nd.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        Ju(this, this._x1, this._y1);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(i, e) {
    switch (i = +i, e = +e, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(i, e) : this._context.moveTo(i, e);
        break;
      case 1:
        this._point = 2, this._x1 = i, this._y1 = e;
        break;
      case 2:
        this._point = 3;
      default:
        Ju(this, i, e);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = i, this._y0 = this._y1, this._y1 = this._y2, this._y2 = e;
  }
};
const eh = function i(e) {
  function t(s) {
    return new Nd(s, e);
  }
  return t.tension = function(s) {
    return i(+s);
  }, t;
}(0);
function $d(i, e) {
  this._context = i, this._t = e;
}
$d.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN, this._point = 0;
  },
  lineEnd: function() {
    0 < this._t && this._t < 1 && this._point === 2 && this._context.lineTo(this._x, this._y), (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line >= 0 && (this._t = 1 - this._t, this._line = 1 - this._line);
  },
  point: function(i, e) {
    switch (i = +i, e = +e, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(i, e) : this._context.moveTo(i, e);
        break;
      case 1:
        this._point = 2;
      default: {
        if (this._t <= 0)
          this._context.lineTo(this._x, e), this._context.lineTo(i, e);
        else {
          var t = this._x * (1 - this._t) + i * this._t;
          this._context.lineTo(t, this._y), this._context.lineTo(t, e);
        }
        break;
      }
    }
    this._x = i, this._y = e;
  }
};
function Gw(i) {
  return new $d(i, 1);
}
class ua extends le {
  constructor() {
    super(...arguments), Object.defineProperty(this, "ix", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "iy", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_generator", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Uw()
    });
  }
  _getTooltipPoint() {
    let e = this.get("tooltipX"), t = this.get("tooltipY"), s = 0, r = 0;
    S(e) && (s = e), S(t) && (r = t);
    let n = this.get("radius", 0), a = this.get("innerRadius", 0), o = this.get("dRadius", 0), l = this.get("dInnerRadius", 0);
    return n += o, a += l, a < 0 && (a = n + a), e instanceof re && (s = this.ix * (a + (n - a) * e.value)), t instanceof re && (r = this.iy * (a + (n - a) * t.value)), this.get("arc") >= 360 && a == 0 && (s = 0, r = 0), { x: s, y: r };
  }
  _beforeChanged() {
    super._beforeChanged(), (this.isDirty("radius") || this.isDirty("arc") || this.isDirty("innerRadius") || this.isDirty("startAngle") || this.isDirty("dRadius") || this.isDirty("dInnerRadius") || this.isDirty("cornerRadius")) && (this._clear = !0);
  }
  _changed() {
    if (super._changed(), this._clear) {
      let e = this.get("startAngle", 0), t = this.get("arc", 0);
      const s = this._generator;
      t < 0 && (e = e + t, t = t * -1), t > 0.1 && s.cornerRadius(this.get("cornerRadius", 0)), s.context(this._display);
      let r = this.get("radius", 0), n = this.get("innerRadius", 0), a = this.get("dRadius", 0), o = this.get("dInnerRadius", 0);
      r += a, n += o, n < 0 && (n = r + n), s({ innerRadius: n, outerRadius: r, startAngle: (e + 90) * ps, endAngle: (e + t + 90) * ps });
      let l = e + t / 2;
      this.ix = jt(l), this.iy = Lt(l);
    }
    if (this.isDirty("shiftRadius")) {
      const e = this.get("shiftRadius", 0);
      this.setRaw("dx", this.ix * e), this.setRaw("dy", this.iy * e), this.markDirtyPosition();
    }
  }
}
Object.defineProperty(ua, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Slice"
});
Object.defineProperty(ua, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: le.classNames.concat([ua.className])
});
class Zs extends Z {
  constructor() {
    super(...arguments), Object.defineProperty(this, "chartContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.children.push(Z.new(this._root, { width: R, height: R, interactiveChildren: !1 }))
    }), Object.defineProperty(this, "bulletsContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Z.new(this._root, { interactiveChildren: !1, isMeasured: !1, position: "absolute", width: R, height: R })
    });
  }
}
Object.defineProperty(Zs, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Chart"
});
Object.defineProperty(Zs, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Z.classNames.concat([Zs.className])
});
class Ks extends Zs {
  constructor() {
    super(...arguments), Object.defineProperty(this, "seriesContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Z.new(this._root, { width: R, height: R, isMeasured: !1 })
    }), Object.defineProperty(this, "series", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new Kn()
    });
  }
  _afterNew() {
    super._afterNew(), this._disposers.push(this.series);
    const e = this.seriesContainer.children;
    this._disposers.push(this.series.events.onAll((t) => {
      if (t.type === "clear") {
        w(t.oldValues, (r) => {
          this._removeSeries(r);
        });
        const s = this.get("colors");
        s && s.reset();
      } else if (t.type === "push")
        e.moveValue(t.newValue), this._processSeries(t.newValue);
      else if (t.type === "setIndex")
        e.setIndex(t.index, t.newValue), this._processSeries(t.newValue);
      else if (t.type === "insertIndex")
        e.insertIndex(t.index, t.newValue), this._processSeries(t.newValue);
      else if (t.type === "removeIndex")
        this._removeSeries(t.oldValue);
      else if (t.type === "moveIndex")
        e.moveValue(t.value, t.newIndex), this._processSeries(t.value);
      else
        throw new Error("Unknown IListEvent type");
    }));
  }
  _processSeries(e) {
    e.chart = this, e._placeBulletsContainer(this);
  }
  _removeSeries(e) {
    e.isDisposed() || (this.seriesContainer.children.removeValue(e), e._removeBulletsContainer());
  }
}
Object.defineProperty(Ks, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "SerialChart"
});
Object.defineProperty(Ks, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Zs.classNames.concat([Ks.className])
});
class Qs extends Ws {
}
Object.defineProperty(Qs, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Tick"
});
Object.defineProperty(Qs, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Ws.classNames.concat([Qs.className])
});
class ha extends $i {
  /**
   * @ignore
   */
  getFill(e) {
    const t = this.getBounds(e);
    let s = 0, r = 0, n = t.left || 0, a = t.right || 0, o = t.top || 0, l = t.bottom || 0;
    const u = a - n, c = l - o;
    let h = e.get("radius");
    S(h) ? (s = 0, r = 0) : (h = Math.min(u, c) / 2, s = u / 2, r = c / 2);
    let d = this.get("x"), f = this.get("y");
    d != null && (s = Re(d, u)), f != null && (r = Re(f, c));
    const g = this._root._renderer.createRadialGradient(s, r, 0, s, r, h), p = this.get("stops");
    if (p) {
      let _ = 0;
      w(p, (m) => {
        let v = m.offset;
        S(v) || (v = _ / (p.length - 1));
        let b = m.opacity;
        S(b) || (b = 1);
        let y = m.color;
        if (y) {
          const x = m.lighten;
          x && (y = X.lighten(y, x));
          const D = m.brighten;
          D && (y = X.brighten(y, D)), g.addColorStop(v, "rgba(" + y.r + "," + y.g + "," + y.b + "," + b + ")");
        }
        _++;
      });
    }
    return g;
  }
}
Object.defineProperty(ha, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "RadialGradient"
});
Object.defineProperty(ha, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: $i.classNames.concat([ha.className])
});
class ca extends xt {
  _beforeChanged() {
    super._beforeChanged(), this.isDirty("gap") && (this._clear = !0);
  }
  _draw() {
    super._draw();
    const e = this.get("checkered", !1), t = this.get("centered", !0), s = this.get("gap", 0), r = this.get("rotation", 0);
    let n = this.get("width", 100), a = this.get("height", 100), o = this.get("radius", 3), l = o * 2 + s, u = o * 2 + s, c = Math.round(n / l), h = Math.round(a / u);
    l = n / c, u = a / h, r != 0 && (this._display.x = l * jt(r), this._display.y = u * Lt(r));
    const d = this.get("color"), f = this.get("colorOpacity");
    (d || f) && this._display.beginFill(d, f);
    for (let g = r == 0 ? 0 : -h * 2; g < h * 2; g++)
      for (let p = r == 0 ? 0 : -c * 2; p < c * 2; p++)
        if (!e || (g & 1) != 1 && (p & 1) != 1 || (g & 1) == 1 && (p & 1) == 1) {
          let _ = p * l, m = g * u;
          t && (_ += l + s / 2, m += u + s / 2), this._display.drawCircle(_ - o, m - o, o);
        }
    e ? (n = n / 2 - s * 2, a = a / 2 - s * 2) : (n -= s, a -= s), (d || f) && this._display.endFill();
  }
}
Object.defineProperty(ca, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "CirclePattern"
});
Object.defineProperty(ca, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: xt.classNames.concat([ca.className])
});
class da extends xt {
  _beforeChanged() {
    super._beforeChanged(), this.isDirty("gap") && (this._clear = !0);
  }
  _draw() {
    super._draw();
    const e = this.get("width", 100), t = this.get("height", 100), s = this.get("gap", 0), r = this.get("strokeWidth", 1);
    if (!s)
      this._display.moveTo(0, 0), this._display.lineTo(e, 0);
    else {
      let o = s + r, l = t / o;
      for (let u = -l; u < l * 2; u++) {
        const c = Math.round(u * o - o / 2) + 0.5;
        this._display.moveTo(-e, c), this._display.lineTo(e * 2, c);
      }
    }
    this._display.lineStyle(r, this.get("color"), this.get("colorOpacity"));
    let n = this.get("strokeDasharray");
    S(n) && (n < 0.5 ? n = [0] : n = [n]), this._display.setLineDash(n);
    const a = this.get("strokeDashoffset");
    a && this._display.setLineDashOffset(a), this._display.endStroke();
  }
}
Object.defineProperty(da, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "LinePattern"
});
Object.defineProperty(da, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: xt.classNames.concat([da.className])
});
class fa extends xt {
  _beforeChanged() {
    super._beforeChanged(), this.isDirty("gap") && (this._clear = !0);
  }
  _draw() {
    super._draw();
    const e = this.get("checkered", !1), t = this.get("centered", !0), s = this.get("gap", 0), r = this.get("rotation", 0);
    let n = this.get("width", 100), a = this.get("height", 100), o = this.get("maxWidth", 5), l = this.get("maxHeight", 5), u = o + s, c = l + s, h = Math.round(n / u), d = Math.round(a / c);
    u = n / h, c = a / d, r != 0 && (this._display.x = u / 2 * jt(r), this._display.y = -c / 2 * Lt(r));
    for (let p = r == 0 ? 0 : -d * 2; p < d * 2; p++)
      for (let _ = r == 0 ? 0 : -h * 2; _ < h * 2; _++)
        if (!e || (p & 1) != 1 && (_ & 1) != 1 || (p & 1) == 1 && (_ & 1) == 1) {
          let m = _ * u, v = p * c;
          t && (m += (u - o) / 2, v += (c - l) / 2), this._display.drawRect(m, v, o, l);
        }
    e ? (n = n / 2 - s * 2, a = a / 2 - s * 2) : (n -= s, a -= s);
    const f = this.get("color"), g = this.get("colorOpacity");
    (f || g) && (this._display.beginFill(f, g), this._display.endFill());
  }
}
Object.defineProperty(fa, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "RectanglePattern"
});
Object.defineProperty(fa, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: xt.classNames.concat([fa.className])
});
class pa extends xt {
  _beforeChanged() {
    super._beforeChanged(), this.isDirty("svgPath") && (this._clear = !0);
  }
  _draw() {
    super._draw();
    const e = this.get("svgPath");
    e != null && this._display.svgPath(e);
    const t = this.get("color"), s = this.get("colorOpacity");
    (t || s) && (this._display.beginFill(t, s), this._display.endFill());
  }
}
Object.defineProperty(pa, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "PathPattern"
});
Object.defineProperty(pa, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: xt.classNames.concat([pa.className])
});
class qs extends Se {
  //protected _currentPass: number = 0;
  _afterNew() {
    super._afterNewApplyThemes(), this._dirty.colors = !1;
  }
  _beforeChanged() {
    this.isDirty("colors") && this.reset();
  }
  /**
   * @ignore
   */
  generateColors() {
    this.setPrivate("currentPass", this.getPrivate("currentPass", 0) + 1);
    const e = this.getPrivate("currentPass"), t = this.get("colors", [this.get("baseColor", X.fromHex(16711680))]);
    this.getPrivate("numColors") || this.setPrivate("numColors", t.length);
    const s = this.getPrivate("numColors"), r = 0, n = this.get("passOptions"), a = this.get("reuse");
    for (let o = r; o < s; o++)
      if (a)
        t.push(t[o]);
      else {
        const l = t[o].toHSL();
        let u = l.h + (n.hue || 0) * e;
        for (; u > 1; )
          u -= 1;
        let c = l.s + (n.saturation || 0) * e;
        c > 1 && (c = 1), c < 0 && (c = 0);
        let h = l.l + (n.lightness || 0) * e;
        for (; h > 1; )
          h -= 1;
        t.push(X.fromHSL(u, c, h));
      }
  }
  /**
   * Returns a [[Color]] at specific index.
   *
   * If there's no color at this index, a new color is generated.
   *
   * @param   index  Index
   * @return         Color
   */
  getIndex(e) {
    const t = this.get("colors", []), s = this.get("saturation");
    return e >= t.length ? (this.generateColors(), this.getIndex(e)) : s != null ? X.saturate(t[e], s) : t[e];
  }
  /**
   * Returns next [[Color]] in the list.
   *
   * If the list is out of colors, new ones are generated dynamically.
   */
  next() {
    let e = this.getPrivate("currentStep", this.get("startIndex", 0));
    return this.setPrivate("currentStep", e + this.get("step", 1)), this.getIndex(e);
  }
  /**
   * Resets counter to the start of the list, so the next call for `next()` will
   * return the first color.
   */
  reset() {
    this.setPrivate("currentStep", this.get("startIndex", 0)), this.setPrivate("currentPass", 0);
  }
}
Object.defineProperty(qs, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "ColorSet"
});
Object.defineProperty(qs, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Se.classNames.concat([qs.className])
});
class Zw {
  /**
   * Parses JSON string.
   *
   * @param   input    JSON
   * @param   options  Options
   * @return           Data
   */
  static parse(e, t) {
    t = this._applyDefaults(t);
    try {
      if (Ii(e)) {
        let s = JSON.parse(e);
        return t.reverse && Un(s) && s.reverse(), s;
      } else {
        if (Un(e) || ys(e))
          return e;
        throw "Unable to parse JSON data";
      }
    } catch {
      return;
    }
  }
  static _applyDefaults(e) {
    const t = {}, s = {
      reverse: !1
    };
    return e || (e = {}), _e(s, (r, n) => {
      t[r] = e[r] || n;
    }), t;
  }
}
class Kw {
  /**
   * Parses CSV string.
   *
   * @param   input    CSV
   * @param   options  Options
   * @return           Data
   */
  static parse(e, t) {
    t = this._applyDefaults(t);
    let s = this.CSVToArray(e, t.delimiter), r = [], n = [], a, o;
    for (o = 0; o < t.skipRows; o++)
      s.shift();
    if (t.useColumnNames) {
      n = s.shift();
      for (let u = 0; u < n.length; u++)
        a = n[u] != null ? n[u].replace(/^\s+|\s+$/gm, "") : "", a === "" && (a = "col" + u), n[u] = a;
    }
    let l;
    for (; l = t.reverse ? s.pop() : s.shift(), !!l; ) {
      if (t.skipEmpty && l.length === 1 && l[0] === "")
        continue;
      let u = {};
      for (o = 0; o < l.length; o++)
        a = n[o] === void 0 ? "col" + o : n[o], u[a] = l[o];
      r.push(u);
    }
    return r;
  }
  /**
   * @ignore
   */
  static CSVToArray(e, t) {
    t = t || ",";
    let s = new RegExp(
      // Delimiters.
      "(\\" + t + '|\\r?\\n|\\r|^)(?:"([^"]*(?:""[^"]*)*)"|([^"\\' + t + "\\r\\n]*))",
      "gi"
    ), r = [
      []
    ], n = null;
    for (; n = s.exec(e), !!n; ) {
      let a = n[1];
      a.length && a !== t && r.push([]);
      let o;
      n[2] ? o = n[2].replace(new RegExp('""', "g"), '"') : o = n[3], r[r.length - 1].push(o);
    }
    return r;
  }
  static _applyDefaults(e) {
    const t = {}, s = {
      delimiter: ",",
      reverse: !1,
      skipRows: 0,
      skipEmpty: !0,
      useColumnNames: !1
    };
    return e || (e = {}), _e(s, (r, n) => {
      t[r] = e[r] || n;
    }), t;
  }
}
class Qw extends Se {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_checkDates", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_checkNumbers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_checkColors", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_checkEmpty", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_checkDeep", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    });
  }
  _afterNew() {
    super._afterNew(), this._checkFeatures(), this.on("dateFields", () => this._checkFeatures()), this.on("dateFormat", () => this._checkFeatures()), this.on("numericFields", () => this._checkFeatures()), this.on("colorFields", () => this._checkFeatures()), this.on("emptyAs", () => this._checkFeatures());
  }
  _checkFeatures() {
    (this.isDirty("dateFields") || this.isDirty("dateFormat")) && (this._checkDates = this.get("dateFields") && this.get("dateFields").length > 0), this.isDirty("numericFields") && (this._checkNumbers = this.get("numericFields") && this.get("numericFields").length > 0), this.isDirty("colorFields") && (this._checkColors = this.get("colorFields") && this.get("colorFields").length > 0), this.isDirty("emptyAs") && (this._checkEmpty = this.get("emptyAs") != null), this._checkDeepFeatures();
  }
  _checkDeepFeatures() {
    const e = [];
    w(["dateFields", "numericFields", "colorFields"], (t) => {
      w(this.get(t, []), (s) => {
        const r = s.split(".");
        for (r.pop(); r.length > 0; )
          e.push(r.join(".")), r.pop();
      });
    }), this._checkDeep = e.length > 0, this.setPrivate("deepFields", e);
  }
  /**
   * Processess entire array of data.
   *
   * NOTE: calling this will modify original array!
   */
  processMany(e) {
    Un(e) && (this._checkDates || this._checkNumbers || this._checkColors || this._checkEmpty) && w(e, (t) => {
      this.processRow(t);
    });
  }
  /**
   * Processes a row (object) of data.
   *
   * NOTE: calling this will modify values of the original object!
   */
  processRow(e, t = "") {
    _e(e, (s, r) => {
      const n = t + s;
      this._checkEmpty && (e[s] = this._maybeToEmpty(e[s])), this._checkNumbers && (e[s] = this._maybeToNumber(n, e[s])), this._checkDates && (e[s] = this._maybeToDate(n, e[s])), this._checkColors && (e[s] = this._maybeToColor(n, e[s])), this._checkDeep && this.getPrivate("deepFields", []).indexOf(n) !== -1 && ys(e[s]) && this.processRow(e[s], n + ".");
    });
  }
  _maybeToNumber(e, t) {
    return this.get("numericFields").indexOf(e) !== -1 ? dt(t) : t;
  }
  _maybeToDate(e, t) {
    return this.get("dateFields").indexOf(e) !== -1 ? this._root.dateFormatter.parse(t, this.get("dateFormat", "")).getTime() : t;
  }
  _maybeToEmpty(e) {
    return (e == null || e == "") && this.get("emptyAs") != null ? this.get("emptyAs") : e;
  }
  _maybeToColor(e, t) {
    return this.get("colorFields").indexOf(e) !== -1 ? X.fromAny(t) : t;
  }
}
class ga extends Z {
  constructor() {
    super(...arguments), Object.defineProperty(this, "rectangle", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.children.push(pt.new(this._root, { themeTags: ["rectangle"], fillOpacity: 0, fill: pe(16777215) }))
    }), Object.defineProperty(this, "gripL", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._createGrip("left")
    }), Object.defineProperty(this, "gripR", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._createGrip("right")
    }), Object.defineProperty(this, "gripT", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._createGrip("top")
    }), Object.defineProperty(this, "gripB", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this._createGrip("bottom")
    }), Object.defineProperty(this, "_is", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), Object.defineProperty(this, "_ix", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_iw", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_positionDP", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_isHover", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    });
  }
  _afterNew() {
    super._afterNew(), this.addTag("resizer"), this.set("visible", !1), this.gripL.events.on("dragged", (e) => {
      this._resize(e.target, -1);
    }), this.gripR.events.on("dragged", (e) => {
      this._resize(e.target, 1);
    }), this.gripL.events.on("dragstart", (e) => {
      this._resizeStart(e.target);
    }), this.gripR.events.on("dragstart", (e) => {
      this._resizeStart(e.target);
    }), this.gripT.events.on("dragged", (e) => {
      this._rotate(e, 90);
    }), this.gripB.events.on("dragged", (e) => {
      this._rotate(e, -90);
    }), this.gripT.events.on("dragstart", (e) => {
      this._resizeStart(e.target);
    }), this.gripB.events.on("dragstart", (e) => {
      this._resizeStart(e.target);
    });
  }
  _resizeStart(e) {
    const t = this.get("sprite");
    t && (this._is = t.get("scale", 1), this._ix = e.x(), this._iw = this.width() / 2);
  }
  _resize(e, t) {
    const s = this.get("sprite"), r = this.get("spriteTemplate");
    if (s) {
      const n = Math.max(0.01, this._is * (1 + t * (e.x() - this._ix) / this._iw));
      r ? r.set("scale", n) : s.set("scale", n), s.states.lookup("default").set("scale", n), this._updatePositions();
    }
  }
  _rotate(e, t) {
    const s = this.get("sprite"), r = this.get("spriteTemplate");
    if (s) {
      const n = this.parent;
      if (n) {
        const a = this.get("rotationStep", 10);
        let o = Math.round((gd({ x: this.x(), y: this.y() }, n.toLocal(e.point)) + t) / a) * a;
        r ? r.set("rotation", o) : s.set("rotation", o), s.states.lookup("default").set("rotation", o), this._updatePositions();
      }
    }
  }
  _createGrip(e) {
    const t = this.children.push(Z.new(this._root, {
      themeTags: ["grip", e],
      setStateOnChildren: !0,
      draggable: !0
    }));
    return t.children.push(et.new(this._root, {
      themeTags: ["outline"],
      centerX: ce,
      centerY: ce
    })), t.children.push(et.new(this._root, {
      centerX: ce,
      centerY: ce
    })), t;
  }
  _updateChildren() {
    if (super._updateChildren(), this.isDirty("sprite")) {
      const e = this.get("sprite");
      if (e) {
        this.show(0), this.setPrivate("visible", !0), this._updatePositions();
        const t = e.parent;
        t && t.children.moveValue(this, 0), this._positionDP = e.events.on("positionchanged", () => {
          this._updatePositions();
        });
      } else
        this.hide(0), this.setPrivate("visible", !1), this._positionDP && this._positionDP.dispose();
    }
    (this.isDirty("width") || this.isDirty("height") || this.isDirty("rotation")) && this._updatePositions();
  }
  _updatePositions() {
    const e = this.get("sprite");
    if (e) {
      let t = e.localBounds(), s = e.get("scale", 1), r = 20, n = (t.right - t.left) * s + r, a = (t.bottom - t.top) * s + r, o = e.get("rotation", 0);
      const l = this.rectangle;
      let u = e.get("centerX", ce), c = e.get("centerY", ce), h = 0;
      u instanceof re && (h = u.value);
      let d = 0;
      c instanceof re && (d = c.value), l.setAll({ centerX: u, centerY: c, width: n, height: a }), this.setAll({ x: e.x() + r * (h - 0.5) * jt(o) - r * (d - 0.5) * Lt(o), y: e.y() + r * (d - 0.5) * jt(o) + r * (h - 0.5) * Lt(o), width: n, height: a, rotation: o }), this.gripT.setAll({ x: (0.5 - h) * n, y: -d * a }), this.gripB.setAll({ x: (0.5 - h) * n, y: (1 - d) * a }), this.gripL.setAll({ x: -h * n, y: (0.5 - d) * a }), this.gripR.setAll({ x: (1 - h) * n, y: (0.5 - d) * a }), this.rectangle.setAll({ width: n, height: a });
    }
  }
}
Object.defineProperty(ga, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "SpriteResizer"
});
Object.defineProperty(ga, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Z.classNames.concat([ga.className])
});
function qw(i, e, t) {
  return new Promise((s, r) => {
    let n = t != null && t.responseType == "blob", a = new XMLHttpRequest();
    if (a.onload = () => {
      if (a.status === 200) {
        let o, l;
        if (n) {
          l = a.response, Fd(l).then((c) => {
            let h = {
              xhr: a,
              error: !1,
              response: c,
              blob: l,
              type: a.getResponseHeader("Content-Type"),
              target: e
            };
            s(h);
          });
          return;
        } else
          o = a.responseText || a.response;
        let u = {
          xhr: a,
          error: !1,
          response: o,
          blob: l,
          type: a.getResponseHeader("Content-Type"),
          target: e
        };
        s(u);
      } else
        r({
          xhr: a,
          error: !0,
          type: a.getResponseHeader("Content-Type"),
          target: e
        });
    }, a.onerror = () => {
      r({
        xhr: a,
        error: !0,
        type: a.getResponseHeader("Content-Type"),
        target: e
      });
    }, a.open("GET", i, !0), t && t.withCredentials && (a.withCredentials = !0), t != null) {
      if (t.requestHeaders != null)
        for (let o = 0; o < t.requestHeaders.length; o++) {
          let l = t.requestHeaders[o];
          a.setRequestHeader(l.key, l.value);
        }
      t.responseType != null && (a.responseType = t.responseType);
    }
    a.send();
  });
}
function Fd(i) {
  return new Promise((e, t) => {
    const s = new FileReader();
    s.onload = (r) => {
      e(s.result);
    }, s.onerror = (r) => {
      t(r);
    }, s.readAsText(i);
  });
}
const Jw = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  load: qw,
  readBlob: Fd
}, Symbol.toStringTag, { value: "Module" })), eS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ArrayDisposer: Fc,
  Bullet: ki,
  Button: Vs,
  CSVParser: Kw,
  Chart: Zs,
  Circle: Ci,
  CirclePattern: ca,
  Color: X,
  ColorSet: qs,
  Component: Ni,
  Container: Z,
  CounterDisposer: Ua,
  DataItem: Gt,
  DataProcessor: Qw,
  DateFormatter: Dd,
  Disposer: He,
  DurationFormatter: Pd,
  Ellipse: ia,
  Entity: Se,
  Gradient: $i,
  Graphics: le,
  GridLayout: gi,
  HeatLegend: ra,
  HorizontalLayout: gs,
  InterfaceColors: Fr,
  JSONParser: Zw,
  JsonData: Aw,
  Label: Xe,
  Layout: si,
  Legend: Hr,
  Line: Ws,
  LinePattern: da,
  LinearGradient: Br,
  ListData: Cd,
  Modal: ta,
  MultiDisposer: st,
  MutableValueDisposer: Ix,
  NumberFormatter: xd,
  PathPattern: pa,
  Pattern: xt,
  Percent: re,
  Picture: na,
  PicturePattern: Xs,
  PointedRectangle: ds,
  RadialGradient: ha,
  RadialLabel: Gs,
  RadialText: zr,
  Rectangle: pt,
  RectanglePattern: fa,
  Root: Ja,
  RoundedRectangle: et,
  Scrollbar: _i,
  SerialChart: Ks,
  Series: Fi,
  Slice: ua,
  Slider: oa,
  Sprite: vt,
  SpriteResizer: ga,
  Star: sa,
  Template: me,
  Text: Ri,
  TextFormatter: Nt,
  Theme: rn,
  Tick: Qs,
  Timezone: Sd,
  Tooltip: Mt,
  Triangle: aa,
  VerticalLayout: _s,
  addLicense: I0,
  array: Ex,
  color: pe,
  disposeAllRootElements: Y0,
  ease: A0,
  math: h0,
  net: Jw,
  object: Fx,
  p0: Rx,
  p100: R,
  p50: ce,
  percent: Ke,
  ready: zc,
  registry: Ot,
  time: Ew,
  type: xx,
  utils: Kx
}, Symbol.toStringTag, { value: "Module" }));
class Bd extends rn {
  setupDefaultRules() {
    super.setupDefaultRules();
    const e = this._root.interfaceColors, t = this._root.language, s = this.rule.bind(this);
    s("XYChart").setAll({
      colors: qs.new(this._root, {}),
      paddingLeft: 20,
      paddingRight: 20,
      paddingTop: 16,
      paddingBottom: 16,
      panX: !1,
      panY: !1,
      wheelStep: 0.25,
      arrangeTooltips: !0,
      pinchZoomX: !1,
      pinchZoomY: !1
    }), s("XYSeries").setAll({
      legendLabelText: "{name}"
    }), s("XYChart", ["scrollbar", "chart"]).setAll({
      paddingBottom: 0,
      paddingLeft: 0,
      paddingTop: 0,
      paddingRight: 0,
      colors: qs.new(this._root, {
        saturation: 0
      })
    });
    {
      const l = s("Graphics", ["scrollbar", "overlay"]);
      l.setAll({
        fillOpacity: 0.5
      }), K(l, "fill", e, "background");
    }
    s("RoundedRectangle", ["xy", "scrollbar", "thumb"]).setAll({
      cornerRadiusTR: 0,
      cornerRadiusTL: 0,
      cornerRadiusBR: 0,
      cornerRadiusBL: 0,
      fillOpacity: 0,
      focusable: !0
    }), s("RoundedRectangle", ["xy", "scrollbar", "thumb"]).states.create("hover", { fillOpacity: 0.4 }), s("RoundedRectangle", ["xy", "scrollbar", "chart", "background"]).setAll({
      cornerRadiusTL: 0,
      cornerRadiusBL: 0,
      cornerRadiusTR: 0,
      cornerRadiusBR: 0
    }), s("RoundedRectangle", ["xy", "scrollbar", "chart", "background", "resize", "button"]).setAll({
      cornerRadiusBL: 40,
      cornerRadiusBR: 40,
      cornerRadiusTL: 40,
      cornerRadiusTR: 40
    }), s("AxisRendererX", ["xy", "chart", "scrollbar"]).setAll({
      strokeOpacity: 0,
      inside: !0
    }), s("AxisRendererY", ["xy", "chart", "scrollbar"]).setAll({
      strokeOpacity: 0,
      inside: !0,
      minGridDistance: 5
    }), s("AxisLabel", ["xy", "scrollbar", "x"]).setAll({
      opacity: 0.5,
      centerY: R,
      minPosition: 0.01,
      maxPosition: 0.99,
      fontSize: "0.8em"
    }), s("AxisLabel", ["category"]).setAll({
      text: "{category}",
      populateText: !0
    }), s("AxisLabel", ["x"]).setAll({
      centerY: 0
    }), s("AxisLabel", ["x", "inside"]).setAll({
      centerY: R
    }), s("AxisLabel", ["x", "inside", "opposite"]).setAll({
      centerY: 0
    }), s("AxisLabel", ["x", "opposite"]).setAll({
      centerY: R
    }), s("AxisLabel", ["y"]).setAll({
      centerX: R
    }), s("AxisLabel", ["y", "inside"]).setAll({
      centerX: 0
    }), s("AxisLabel", ["y", "inside", "opposite"]).setAll({
      centerX: R
    }), s("AxisLabel", ["y", "opposite"]).setAll({
      centerX: 0
    }), s("AxisLabel", ["xy", "scrollbar", "y"]).setAll({
      visible: !1
    }), s("Grid", ["xy", "scrollbar", "y"]).setAll({
      visible: !1
    }), s("Grid", ["xy", "scrollbar", "x"]).setAll({
      opacity: 0.5
    }), s("XYCursor").setAll({
      behavior: "none",
      layer: 30,
      exportable: !1,
      snapToSeriesBy: "xy",
      moveThreshold: 1
    });
    {
      const l = s("Grid", ["cursor", "x"]);
      l.setAll({
        strokeOpacity: 0.8,
        strokeDasharray: [2, 2],
        ariaLabel: t.translate("Use left and right arrows to move selection")
      }), K(l, "stroke", e, "alternativeBackground");
    }
    {
      const l = s("Grid", ["cursor", "y"]);
      l.setAll({
        strokeOpacity: 0.8,
        strokeDasharray: [2, 2],
        ariaLabel: t.translate("Use up and down arrows to move selection")
      }), K(l, "stroke", e, "alternativeBackground");
    }
    {
      const l = s("Graphics", ["cursor", "selection"]);
      l.setAll({
        fillOpacity: 0.15
      }), K(l, "fill", e, "alternativeBackground");
    }
    s("Axis").setAll({
      start: 0,
      end: 1,
      minZoomCount: 1,
      maxZoomCount: 1 / 0,
      maxZoomFactor: 1e3,
      maxDeviation: 0.1,
      snapTooltip: !0,
      tooltipLocation: 0.5,
      panX: !0,
      panY: !0,
      zoomX: !0,
      zoomY: !0,
      fixAxisSize: !0
    }), s("AxisLabel").setAll({
      location: 0.5,
      multiLocation: 0,
      centerX: ce,
      centerY: ce,
      paddingTop: 3,
      paddingBottom: 3,
      paddingLeft: 5,
      paddingRight: 5
    }), s("Container", ["axis", "header"]).setAll({
      layer: 30
    }), s("Rectangle", ["axis", "header", "background"]).setAll({
      crisp: !0
    });
    {
      const l = s("AxisRenderer");
      l.setAll({
        crisp: !0,
        strokeOpacity: 0
      }), K(l, "stroke", e, "grid");
    }
    s("AxisRendererX").setAll({
      minGridDistance: 120,
      opposite: !1,
      inversed: !1,
      cellStartLocation: 0,
      cellEndLocation: 1,
      width: R
    }), s("AxisRendererY").setAll({
      minGridDistance: 40,
      opposite: !1,
      inversed: !1,
      cellStartLocation: 0,
      cellEndLocation: 1,
      height: R
    });
    {
      const l = s("Rectangle", ["axis", "thumb"]);
      l.setAll({
        fillOpacity: 0
      }), K(l, "fill", e, "alternativeBackground"), l.states.create("hover", { fillOpacity: 0.1 });
    }
    s("Rectangle", ["axis", "thumb", "x"]).setAll({
      cursorOverStyle: "ew-resize"
    }), s("Rectangle", ["axis", "thumb", "y"]).setAll({
      cursorOverStyle: "ns-resize"
    });
    {
      const l = s("Grid");
      l.setAll({
        location: 0,
        strokeOpacity: 0.15,
        crisp: !0
      }), K(l, "stroke", e, "grid");
    }
    s("Grid", ["base"]).setAll({
      strokeOpacity: 0.3
    });
    {
      const l = s("Graphics", ["axis", "fill"]);
      l.setAll({
        visible: !1,
        isMeasured: !1,
        position: "absolute",
        fillOpacity: 0.05
      }), K(l, "fill", e, "alternativeBackground");
    }
    s("Graphics", ["axis", "fill", "range"]).setAll({
      isMeasured: !0
    }), s("Graphics", ["series", "fill", "range"]).setAll({
      visible: !1,
      isMeasured: !0
    }), s("Grid", ["series", "range"]).setAll({
      visible: !1
    }), s("AxisTick", ["series", "range"]).setAll({
      visible: !1
    }), s("AxisLabel", ["series", "range"]).setAll({
      visible: !1
    });
    {
      const l = s("AxisTick");
      l.setAll({
        location: 0.5,
        multiLocation: 0,
        strokeOpacity: 1,
        isMeasured: !1,
        position: "absolute",
        visible: !1
      }), K(l, "stroke", e, "grid");
    }
    s("CategoryAxis").setAll({
      startLocation: 0,
      endLocation: 1,
      fillRule: (l, u) => {
        const c = l.get("axisFill");
        c && (!S(u) || u % 2 == 0 ? c.setPrivate("visible", !0) : c.setPrivate("visible", !1));
      }
    });
    const r = [
      { timeUnit: "millisecond", count: 1 },
      { timeUnit: "millisecond", count: 5 },
      { timeUnit: "millisecond", count: 10 },
      { timeUnit: "millisecond", count: 50 },
      { timeUnit: "millisecond", count: 100 },
      { timeUnit: "millisecond", count: 500 },
      { timeUnit: "second", count: 1 },
      { timeUnit: "second", count: 5 },
      { timeUnit: "second", count: 10 },
      { timeUnit: "second", count: 30 },
      { timeUnit: "minute", count: 1 },
      { timeUnit: "minute", count: 5 },
      { timeUnit: "minute", count: 10 },
      { timeUnit: "minute", count: 15 },
      { timeUnit: "minute", count: 30 },
      { timeUnit: "hour", count: 1 },
      { timeUnit: "hour", count: 3 },
      { timeUnit: "hour", count: 6 },
      { timeUnit: "hour", count: 12 },
      { timeUnit: "day", count: 1 },
      { timeUnit: "day", count: 2 },
      { timeUnit: "day", count: 3 },
      { timeUnit: "day", count: 4 },
      { timeUnit: "day", count: 5 },
      { timeUnit: "week", count: 1 },
      { timeUnit: "month", count: 1 },
      { timeUnit: "month", count: 2 },
      { timeUnit: "month", count: 3 },
      { timeUnit: "month", count: 6 },
      { timeUnit: "year", count: 1 },
      { timeUnit: "year", count: 2 },
      { timeUnit: "year", count: 5 },
      { timeUnit: "year", count: 10 },
      { timeUnit: "year", count: 50 },
      { timeUnit: "year", count: 100 },
      { timeUnit: "year", count: 200 },
      { timeUnit: "year", count: 500 },
      { timeUnit: "year", count: 1e3 },
      { timeUnit: "year", count: 2e3 },
      { timeUnit: "year", count: 5e3 },
      { timeUnit: "year", count: 1e4 },
      { timeUnit: "year", count: 1e5 }
    ], n = {
      millisecond: t.translate("_date_millisecond"),
      second: t.translate("_date_second"),
      minute: t.translate("_date_minute"),
      hour: t.translate("_date_hour"),
      day: t.translate("_date_day"),
      week: t.translate("_date_day"),
      month: t.translate("_date_month"),
      year: t.translate("_date_year")
    }, a = {
      millisecond: t.translate("_date_millisecond"),
      second: t.translate("_date_second"),
      minute: t.translate("_date_minute"),
      hour: t.translate("_date_day"),
      day: t.translate("_date_day"),
      week: t.translate("_date_day"),
      month: t.translate("_date_month") + " " + t.translate("_date_year"),
      year: t.translate("_date_year")
    }, o = {
      millisecond: t.translate("_date_millisecond_full"),
      second: t.translate("_date_second_full"),
      minute: t.translate("_date_minute_full"),
      hour: t.translate("_date_hour_full"),
      day: t.translate("_date_day_full"),
      week: t.translate("_date_week_full"),
      month: t.translate("_date_month_full"),
      year: t.translate("_date_year")
    };
    s("CategoryDateAxis").setAll({
      markUnitChange: !0,
      gridIntervals: Gn(r),
      dateFormats: Ti(n),
      periodChangeDateFormats: Ti(a)
    }), s("DateAxis").setAll({
      maxZoomFactor: null,
      strictMinMax: !0,
      startLocation: 0,
      endLocation: 1,
      markUnitChange: !0,
      groupData: !1,
      groupCount: 500,
      gridIntervals: Gn(r),
      dateFormats: Ti(n),
      periodChangeDateFormats: Ti(a),
      tooltipDateFormats: o,
      groupIntervals: [
        { timeUnit: "millisecond", count: 1 },
        { timeUnit: "millisecond", count: 10 },
        { timeUnit: "millisecond", count: 100 },
        { timeUnit: "second", count: 1 },
        { timeUnit: "second", count: 10 },
        { timeUnit: "minute", count: 1 },
        { timeUnit: "minute", count: 10 },
        { timeUnit: "hour", count: 1 },
        { timeUnit: "day", count: 1 },
        { timeUnit: "week", count: 1 },
        { timeUnit: "month", count: 1 },
        { timeUnit: "year", count: 1 }
      ],
      fillRule: (l) => {
        const u = l.get("axisFill");
        if (u) {
          const c = l.component, h = l.get("value"), d = l.get("endValue"), f = c.intervalDuration(), g = c.getPrivate("baseInterval"), p = c.getPrivate("gridInterval", g);
          let _ = c.getPrivate("min", 0);
          if (_ = Ve(new Date(_), p.timeUnit, p.count, this._root.locale.firstDayOfWeek, this._root.utc, void 0, this._root.timezone).getTime(), h != null && d != null) {
            const m = Math.round(Math.round((h - _) / f)) / 2;
            m == Math.round(m) ? u.setPrivate("visible", !0) : u.setPrivate("visible", !1);
          }
        }
      }
    }), s("GaplessDateAxis").setAll({
      fillRule: (l) => {
        const u = l.get("axisFill");
        if (u) {
          const c = l.get("index");
          let h = !1;
          (!S(c) || c % 2 == 0) && (h = !0), u.setPrivate("visible", h);
        }
      }
    }), s("ValueAxis").setAll({
      baseValue: 0,
      logarithmic: !1,
      strictMinMax: !1,
      autoZoom: !0,
      fillRule: (l) => {
        const u = l.get("axisFill");
        if (u) {
          const c = l.component, h = l.get("value"), d = c.getPrivate("step");
          S(h) && S(d) && (qe(h / d / 2, 5) == Math.round(h / d / 2) ? u.setPrivate("visible", !1) : u.setPrivate("visible", !0));
        }
      }
    }), s("DurationAxis").setAll({
      baseUnit: "second"
    }), s("XYSeries").setAll({
      maskBullets: !0,
      stackToNegative: !0,
      locationX: 0.5,
      locationY: 0.5,
      snapTooltip: !1,
      openValueXGrouped: "open",
      openValueYGrouped: "open",
      valueXGrouped: "close",
      valueYGrouped: "close",
      seriesTooltipTarget: "series"
    }), s("BaseColumnSeries").setAll({
      adjustBulletPosition: !0
    }), s("ColumnSeries").setAll({
      clustered: !0
    }), s("RoundedRectangle", ["series", "column"]).setAll({
      position: "absolute",
      isMeasured: !1,
      width: Ke(70),
      height: Ke(70),
      strokeWidth: 1,
      strokeOpacity: 1,
      cornerRadiusBL: 0,
      cornerRadiusTL: 0,
      cornerRadiusBR: 0,
      cornerRadiusTR: 0,
      fillOpacity: 1,
      role: "figure"
    }), s("LineSeries").setAll({
      connect: !0,
      autoGapCount: 1.1,
      stackToNegative: !1
    }), s("Graphics", ["series", "stroke"]).setAll({
      position: "absolute",
      strokeWidth: 1,
      strokeOpacity: 1,
      isMeasured: !1
    }), s("Graphics", ["series", "fill"]).setAll({
      visible: !1,
      fillOpacity: 0,
      position: "absolute",
      strokeWidth: 0,
      strokeOpacity: 0,
      isMeasured: !1
    }), s("Graphics", ["line", "series", "legend", "marker", "stroke"]).setAll({
      draw: (l, u) => {
        const c = u.parent;
        if (c) {
          const h = c.height(), d = c.width();
          l.moveTo(0, h / 2), l.lineTo(d, h / 2);
        }
      }
    });
    {
      const l = s("Graphics", ["line", "series", "legend", "marker", "stroke"]).states.create("disabled", {});
      K(l, "stroke", e, "disabled");
    }
    s("Graphics", ["line", "series", "legend", "marker", "fill"]).setAll({
      draw: (l, u) => {
        const c = u.parent;
        if (c) {
          const h = c.height(), d = c.width();
          l.moveTo(0, 0), l.lineTo(d, 0), l.lineTo(d, h), l.lineTo(0, h), l.lineTo(0, 0);
        }
      }
    });
    {
      const l = s("Graphics", ["line", "series", "legend", "marker", "fill"]).states.create("disabled", {});
      K(l, "stroke", e, "disabled");
    }
    s("SmoothedXYLineSeries").setAll({
      tension: 0.5
    }), s("SmoothedXLineSeries").setAll({
      tension: 0.5
    }), s("SmoothedYLineSeries").setAll({
      tension: 0.5
    }), s("Candlestick").setAll({
      position: "absolute",
      isMeasured: !1,
      width: Ke(50),
      height: Ke(50),
      strokeWidth: 1,
      strokeOpacity: 1,
      cornerRadiusBL: 0,
      cornerRadiusTL: 0,
      cornerRadiusBR: 0,
      cornerRadiusTR: 0,
      fillOpacity: 1,
      role: "figure"
    }), s("OHLC").setAll({
      width: Ke(80),
      height: Ke(80)
    }), s("CandlestickSeries").setAll({
      lowValueXGrouped: "low",
      lowValueYGrouped: "low",
      highValueXGrouped: "high",
      highValueYGrouped: "high",
      openValueXGrouped: "open",
      openValueYGrouped: "open",
      valueXGrouped: "close",
      valueYGrouped: "close"
    });
    {
      const l = s("Rectangle", ["column", "autocolor"]).states.create("riseFromOpen", {});
      K(l, "fill", e, "positive"), K(l, "stroke", e, "positive");
    }
    {
      const l = s("Rectangle", ["column", "autocolor"]).states.create("dropFromOpen", {});
      K(l, "fill", e, "negative"), K(l, "stroke", e, "negative");
    }
    s("Rectangle", ["column", "autocolor", "pro"]).states.create("riseFromOpen", { fillOpacity: 0 }), s("Rectangle", ["column", "autocolor", "pro"]).states.create("dropFromOpen", { fillOpacity: 1 });
    {
      const l = s("Rectangle", ["column", "autocolor", "pro"]).states.create("riseFromPrevious", {});
      K(l, "fill", e, "positive"), K(l, "stroke", e, "positive");
    }
    {
      const l = s("Rectangle", ["column", "autocolor", "pro"]).states.create("dropFromPrevious", {});
      K(l, "fill", e, "negative"), K(l, "stroke", e, "negative");
    }
  }
}
let Js = class extends Ks {
  constructor() {
    super(...arguments), Object.defineProperty(this, "xAxes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new Kn()
    }), Object.defineProperty(this, "yAxes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new Kn()
    }), Object.defineProperty(this, "topAxesContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.chartContainer.children.push(Z.new(this._root, { width: R, layout: this._root.verticalLayout }))
    }), Object.defineProperty(this, "yAxesAndPlotContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.chartContainer.children.push(Z.new(this._root, { width: R, height: R, layout: this._root.horizontalLayout }))
    }), Object.defineProperty(this, "bottomAxesContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.chartContainer.children.push(Z.new(this._root, { width: R, layout: this._root.verticalLayout }))
    }), Object.defineProperty(this, "leftAxesContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.yAxesAndPlotContainer.children.push(Z.new(this._root, { height: R, layout: this._root.horizontalLayout }))
    }), Object.defineProperty(this, "plotsContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.yAxesAndPlotContainer.children.push(Z.new(this._root, { width: R, height: R, maskContent: !1 }))
    }), Object.defineProperty(this, "plotContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.plotsContainer.children.push(Z.new(this._root, { width: R, height: R }))
    }), Object.defineProperty(this, "topPlotContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.plotsContainer.children.push(Z.new(this._root, { width: R, height: R }))
    }), Object.defineProperty(this, "gridContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.plotContainer.children.push(Z.new(this._root, { width: R, height: R, isMeasured: !1 }))
    }), Object.defineProperty(this, "topGridContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Z.new(this._root, { width: R, height: R, isMeasured: !1 })
    }), Object.defineProperty(this, "rightAxesContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.yAxesAndPlotContainer.children.push(Z.new(this._root, { height: R, layout: this._root.horizontalLayout }))
    }), Object.defineProperty(this, "axisHeadersContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.plotContainer.children.push(Z.new(this._root, {}))
    }), Object.defineProperty(this, "zoomOutButton", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.topPlotContainer.children.push(Vs.new(this._root, {
        themeTags: ["zoom"],
        icon: le.new(this._root, {
          themeTags: ["button", "icon"]
        })
      }))
    }), Object.defineProperty(this, "_movePoint", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: { x: 0, y: 0 }
    }), Object.defineProperty(this, "_wheelDp", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_otherCharts", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_movePoints", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_downStartX", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_downEndX", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_downStartY", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_downEndY", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  _afterNew() {
    this._defaultThemes.push(Bd.new(this._root)), super._afterNew(), this._disposers.push(this.xAxes), this._disposers.push(this.yAxes);
    const e = this._root;
    let t = this._root.verticalLayout;
    const s = this.zoomOutButton;
    s.events.on("click", () => {
      this.zoomOut();
    }), s.set("opacity", 0), s.states.lookup("default").set("opacity", 1), this.chartContainer.set("layout", t);
    const r = this.plotContainer;
    r.children.push(this.seriesContainer), this._disposers.push(this._processAxis(this.xAxes, this.bottomAxesContainer)), this._disposers.push(this._processAxis(this.yAxes, this.leftAxesContainer)), r.children.push(this.topGridContainer), r.children.push(this.bulletsContainer), r.set("interactive", !0), r.set("interactiveChildren", !1), r.set("background", pt.new(e, {
      themeTags: ["xy", "background"],
      fill: X.fromHex(0),
      fillOpacity: 0
    })), this._disposers.push(r.events.on("pointerdown", (n) => {
      this._handlePlotDown(n.originalEvent);
    })), this._disposers.push(r.events.on("globalpointerup", (n) => {
      this._handlePlotUp(n.originalEvent);
    })), this._disposers.push(r.events.on("globalpointermove", (n) => {
      this._handlePlotMove(n.originalEvent);
    })), this._maskGrid(), this._setUpTouch();
  }
  _beforeChanged() {
    super._beforeChanged(), (this.isDirty("pinchZoomX") || this.isDirty("pinchZoomY") || this.get("panX") || this.get("panY")) && this._setUpTouch();
  }
  _setUpTouch() {
    this.plotContainer._display.cancelTouch || (this.plotContainer._display.cancelTouch = !!(this.get("pinchZoomX") || this.get("pinchZoomY") || this.get("panX") || this.get("panY")));
  }
  _maskGrid() {
    this.gridContainer.set("maskContent", !0), this.topGridContainer.set("maskContent", !0);
  }
  _removeSeries(e) {
    const t = e.get("xAxis");
    t && (bt(t.series, e), t.markDirtyExtremes());
    const s = e.get("yAxis");
    s && (bt(s.series, e), s.markDirtyExtremes());
    const r = this.get("cursor");
    if (r) {
      const n = r.get("snapToSeries");
      n && bt(n, e);
    }
    super._removeSeries(e);
  }
  /**
   * This method is invoked when mouse wheel is used over chart's plot
   * container, and handles zooming/pan.
   *
   * You can invoke this method manually, if you need to mimic chart's wheel
   * behavior over other elements of the chart.
   */
  handleWheel(e) {
    const t = this.get("wheelX"), s = this.get("wheelY"), r = this.plotContainer, n = e.originalEvent;
    if (Wa(n, this))
      n.preventDefault();
    else
      return;
    const a = r.toLocal(this._root.documentPointToRoot({ x: n.clientX, y: n.clientY })), o = this.get("wheelStep", 0.2), l = n.deltaY / 100, u = n.deltaX / 100, c = this.get("wheelZoomPositionX"), h = this.get("wheelZoomPositionY");
    (t === "zoomX" || t === "zoomXY") && u != 0 && this.xAxes.each((d) => {
      if (d.get("zoomX")) {
        let f = d.get("start"), g = d.get("end"), p = d.fixPosition(a.x / r.width());
        c != null && (p = c);
        let _ = f - o * (g - f) * u * p, m = g + o * (g - f) * u * (1 - p);
        1 / (m - _) < d.getPrivate("maxZoomFactor", 1 / 0) / d.get("minZoomCount", 1) && this._handleWheelAnimation(d.zoom(_, m));
      }
    }), (s === "zoomX" || s === "zoomXY") && l != 0 && this.xAxes.each((d) => {
      if (d.get("zoomX")) {
        let f = d.get("start"), g = d.get("end"), p = d.fixPosition(a.x / r.width());
        c != null && (p = c);
        let _ = f - o * (g - f) * l * p, m = g + o * (g - f) * l * (1 - p);
        1 / (m - _) < d.getPrivate("maxZoomFactor", 1 / 0) / d.get("minZoomCount", 1) && this._handleWheelAnimation(d.zoom(_, m));
      }
    }), (t === "zoomY" || t === "zoomXY") && u != 0 && this.yAxes.each((d) => {
      if (d.get("zoomY")) {
        let f = d.get("start"), g = d.get("end"), p = d.fixPosition(a.y / r.height());
        h != null && (p = h);
        let _ = f - o * (g - f) * u * p, m = g + o * (g - f) * u * (1 - p);
        1 / (m - _) < d.getPrivate("maxZoomFactor", 1 / 0) / d.get("minZoomCount", 1) && this._handleWheelAnimation(d.zoom(_, m));
      }
    }), (s === "zoomY" || s === "zoomXY") && l != 0 && this.yAxes.each((d) => {
      if (d.get("zoomY")) {
        let f = d.get("start"), g = d.get("end"), p = d.fixPosition(a.y / r.height());
        h != null && (p = h);
        let _ = f - o * (g - f) * l * p, m = g + o * (g - f) * l * (1 - p);
        1 / (m - _) < d.getPrivate("maxZoomFactor", 1 / 0) / d.get("minZoomCount", 1) && this._handleWheelAnimation(d.zoom(_, m));
      }
    }), (t === "panX" || t === "panXY") && u != 0 && this.xAxes.each((d) => {
      if (d.get("panX")) {
        let f = d.get("start"), g = d.get("end"), p = this._getWheelSign(d) * o * (g - f) * u, _ = f + p, m = g + p, v = this._fixWheel(_, m);
        _ = v[0], m = v[1], this._handleWheelAnimation(d.zoom(_, m));
      }
    }), (s === "panX" || s === "panXY") && l != 0 && this.xAxes.each((d) => {
      if (d.get("panX")) {
        let f = d.get("start"), g = d.get("end"), p = this._getWheelSign(d) * o * (g - f) * l, _ = f + p, m = g + p, v = this._fixWheel(_, m);
        _ = v[0], m = v[1], this._handleWheelAnimation(d.zoom(_, m));
      }
    }), (t === "panY" || t === "panXY") && u != 0 && this.yAxes.each((d) => {
      if (d.get("panY")) {
        let f = d.get("start"), g = d.get("end"), p = this._getWheelSign(d) * o * (g - f) * u, _ = f + p, m = g + p, v = this._fixWheel(_, m);
        _ = v[0], m = v[1], this._handleWheelAnimation(d.zoom(_, m));
      }
    }), (s === "panY" || s === "panXY") && l != 0 && this.yAxes.each((d) => {
      if (d.get("panY")) {
        let f = d.get("start"), g = d.get("end"), p = this._getWheelSign(d) * o * (g - f) * l, _ = f - p, m = g - p, v = this._fixWheel(_, m);
        _ = v[0], m = v[1], this._handleWheelAnimation(d.zoom(_, m));
      }
    });
  }
  _handleSetWheel() {
    const e = this.get("wheelX"), t = this.get("wheelY"), s = this.plotContainer;
    e !== "none" || t !== "none" ? (this._wheelDp = s.events.on("wheel", (r) => {
      this.handleWheel(r);
    }), this._disposers.push(this._wheelDp)) : this._wheelDp && this._wheelDp.dispose();
  }
  _getWheelSign(e) {
    let t = 1;
    return e.get("renderer").get("inversed") && (t = -1), t;
  }
  _fixWheel(e, t) {
    const s = t - e;
    return e < 0 && (e = 0, t = e + s), t > 1 && (t = 1, e = t - s), [e, t];
  }
  _handlePlotDown(e) {
    if (e.button == 2)
      return;
    const t = this.plotContainer;
    let s = t.toLocal(this._root.documentPointToRoot({ x: e.clientX, y: e.clientY }));
    if ((this.get("pinchZoomX") || this.get("pinchZoomY")) && e.pointerId && Ne(t._downPoints).length > 0) {
      const a = this.xAxes.getIndex(0), o = this.yAxes.getIndex(0);
      a && (this._downStartX = a.get("start", 0), this._downEndX = a.get("end", 1)), o && (this._downStartY = o.get("start", 0), this._downEndY = o.get("end", 1));
    }
    if ((this.get("panX") || this.get("panY")) && s.x >= 0 && s.y >= 0 && s.x <= t.width() && s.y <= this.height()) {
      this._downPoint = { x: e.clientX, y: e.clientY };
      const r = this.get("panX"), n = this.get("panY");
      r && this.xAxes.each((o) => {
        o._panStart = o.get("start"), o._panEnd = o.get("end");
      }), n && this.yAxes.each((o) => {
        o._panStart = o.get("start"), o._panEnd = o.get("end");
      });
      const a = "panstarted";
      this.events.isEnabled(a) && this.events.dispatch(a, { type: a, target: this, originalEvent: e });
    }
  }
  _handleWheelAnimation(e) {
    e ? e.events.on("stopped", () => {
      this._dispatchWheelAnimation();
    }) : this._dispatchWheelAnimation();
  }
  _dispatchWheelAnimation() {
    const e = "wheelended";
    this.events.isEnabled(e) && this.events.dispatch(e, { type: e, target: this });
  }
  _handlePlotUp(e) {
    const t = this._downPoint;
    if (t && (this.get("panX") || this.get("panY"))) {
      let s = this.plotContainer.toLocal(this._root.documentPointToRoot({ x: e.clientX, y: e.clientY }));
      if (s.x == t.x && s.y == t.y) {
        const n = "pancancelled";
        this.events.isEnabled(n) && this.events.dispatch(n, { type: n, target: this, originalEvent: e });
      }
      const r = "panended";
      this.events.isEnabled(r) && this.events.dispatch(r, { type: r, target: this, originalEvent: e });
    }
    this._downPoint = void 0, this.xAxes.each((s) => {
      s._isPanning = !1;
    }), this.yAxes.each((s) => {
      s._isPanning = !1;
    });
  }
  _handlePlotMove(e) {
    const t = this.plotContainer;
    if (this.get("pinchZoomX") || this.get("pinchZoomY")) {
      const n = e.pointerId;
      if (n && (this._movePoints[n] = this._root.documentPointToRoot({ x: e.clientX, y: e.clientY }), Ne(t._downPoints).length > 1)) {
        this._handlePinch();
        return;
      }
    }
    let s = this._downPoint;
    if (s) {
      s = t.toLocal(this._root.documentPointToRoot(s));
      let r = t.toLocal(this._root.documentPointToRoot({ x: e.clientX, y: e.clientY }));
      const n = this.get("panX"), a = this.get("panY");
      if (n) {
        let o = this.get("scrollbarX");
        o && o.events.disableType("rangechanged"), this.xAxes.each((l) => {
          if (l.get("panX")) {
            l._isPanning = !0;
            let u = l._panStart, c = l._panEnd, d = (c - u) * (s.x - r.x) / t.width();
            l.get("renderer").get("inversed") && (d *= -1);
            let f = u + d, g = c + d;
            g - f < 1 + l.get("maxDeviation", 1) * 2 && (l.set("start", f), l.set("end", g));
          }
        }), o && o.events.enableType("rangechanged");
      }
      if (a) {
        let o = this.get("scrollbarY");
        o && o.events.disableType("rangechanged"), this.yAxes.each((l) => {
          if (l.get("panY")) {
            l._isPanning = !0;
            let u = l._panStart, c = l._panEnd, d = (c - u) * (s.y - r.y) / t.height();
            l.get("renderer").get("inversed") && (d *= -1);
            let f = u - d, g = c - d;
            g - f < 1 + l.get("maxDeviation", 1) * 2 && (l.set("start", f), l.set("end", g));
          }
        }), o && o.events.enableType("rangechanged");
      }
    }
  }
  _handlePinch() {
    const e = this.plotContainer;
    let t = 0, s = [], r = [];
    if (_e(e._downPoints, (n, a) => {
      s[t] = a;
      let o = this._movePoints[n];
      o && (r[t] = o), t++;
    }), s.length > 1 && r.length > 1) {
      const n = e.width(), a = e.height();
      let o = s[0], l = s[1], u = r[0], c = r[1];
      if (o && l && u && c) {
        if (u = e.toLocal(u), c = e.toLocal(c), o = e.toLocal(o), l = e.toLocal(l), this.get("pinchZoomX")) {
          const h = this._downStartX, d = this._downEndX;
          if (h != null && d != null) {
            o.x > l.x && ([o, l] = [l, o], [u, c] = [c, u]);
            let f = h + o.x / n * (d - h), g = h + l.x / n * (d - h), p = h + u.x / n * (d - h), _ = h + c.x / n * (d - h), m = Math.max(1e-3, g - f), v = Math.max(1e-3, _ - p), b = m / v, y = h * b + f - p * b, x = d * b + g - _ * b;
            this.xAxes.each((D) => {
              let A = D.fixPosition(y), T = D.fixPosition(x);
              D.zoom(A, T, 0);
            });
          }
        }
        if (this.get("pinchZoomY")) {
          const h = this._downStartY, d = this._downEndY;
          if (h != null && d != null) {
            o.y < l.y && ([o, l] = [l, o], [u, c] = [c, u]);
            let f = h + (1 - o.y / a) * (d - h), g = h + (1 - l.y / a) * (d - h), p = h + (1 - u.y / a) * (d - h), _ = h + (1 - c.y / a) * (d - h), m = Math.max(1e-3, g - f), v = Math.max(1e-3, _ - p), b = m / v, y = h * b + f - p * b, x = d * b + g - _ * b;
            this.yAxes.each((D) => {
              let A = D.fixPosition(y), T = D.fixPosition(x);
              D.zoom(A, T, 0);
            });
          }
        }
      }
    }
  }
  _handleCursorPosition() {
    const e = this.get("cursor");
    if (e) {
      const t = e.getPrivate("point");
      let s = e.get("snapToSeries");
      if (e._downPoint && (s = void 0), s && t) {
        const r = e.get("snapToSeriesBy"), n = [];
        w(s, (l) => {
          if (!l.isHidden() && !l.isHiding())
            if (r != "x!" && r != "y!") {
              const u = l.startIndex(), c = l.endIndex();
              for (let h = u; h < c; h++) {
                const d = l.dataItems[h];
                d && !d.isHidden() && n.push(d);
              }
            } else {
              const u = l.get("tooltipDataItem");
              u && n.push(u);
            }
        });
        let a = 1 / 0, o;
        if (w(n, (l) => {
          const u = l.get("point");
          if (u) {
            let c = 0;
            r == "x" || r == "x!" ? c = Math.abs(t.x - u.x) : r == "y" || r == "y!" ? c = Math.abs(t.y - u.y) : c = Math.hypot(t.x - u.x, t.y - u.y), c < a && (a = c, o = l);
          }
        }), w(s, (l) => {
          const u = l.get("tooltip");
          u && u._setDataItem(void 0);
        }), o) {
          let l = o.component;
          l.showDataItemTooltip(o);
          const u = o.get("point");
          u && e.handleMove(l.toGlobal({ x: u.x - l.x(), y: u.y - l.y() }), !0);
        }
      }
    }
  }
  _updateCursor() {
    let e = this.get("cursor");
    e && e.handleMove();
  }
  _addCursor(e) {
    this.plotContainer.children.push(e);
  }
  _prepareChildren() {
    if (super._prepareChildren(), this.series.each((e) => {
      this._colorize(e);
    }), (this.isDirty("wheelX") || this.isDirty("wheelY")) && this._handleSetWheel(), this.isDirty("cursor")) {
      const e = this._prevSettings.cursor, t = this.get("cursor");
      t !== e && (this._disposeProperty("cursor"), e && e.dispose(), t && (t._setChart(this), this._addCursor(t), this._pushPropertyDisposer("cursor", t.events.on("selectended", () => {
        this._handleCursorSelectEnd();
      }))), this._prevSettings.cursor = t);
    }
    if (this.isDirty("scrollbarX")) {
      const e = this._prevSettings.scrollbarX, t = this.get("scrollbarX");
      t !== e && (this._disposeProperty("scrollbarX"), e && e.dispose(), t && (t.parent || this.topAxesContainer.children.push(t), this._pushPropertyDisposer("scrollbarX", t.events.on("rangechanged", (s) => {
        this._handleScrollbar(this.xAxes, s.start, s.end, s.grip);
      })), t.setPrivate("positionTextFunction", (s) => {
        const r = this.xAxes.getIndex(0);
        return r && r.getTooltipText(s) || "";
      })), this._prevSettings.scrollbarX = t);
    }
    if (this.isDirty("scrollbarY")) {
      const e = this._prevSettings.scrollbarY, t = this.get("scrollbarY");
      t !== e && (this._disposeProperty("scrollbarY"), e && e.dispose(), t && (t.parent || this.rightAxesContainer.children.push(t), this._pushPropertyDisposer("scrollbarY", t.events.on("rangechanged", (s) => {
        this._handleScrollbar(this.yAxes, s.start, s.end, s.grip);
      })), t.setPrivate("positionTextFunction", (s) => {
        const r = this.yAxes.getIndex(0);
        return r && r.getTooltipText(s) || "";
      })), this._prevSettings.scrollbarY = t);
    }
    this._handleZoomOut();
  }
  _processSeries(e) {
    super._processSeries(e), this._colorize(e);
  }
  _colorize(e) {
    const t = this.get("colors");
    if (t && e.get("fill") == null) {
      const s = t.next();
      e._setSoft("stroke", s), e._setSoft("fill", s);
    }
  }
  _handleCursorSelectEnd() {
    const e = this.get("cursor"), t = e.get("behavior"), s = e.getPrivate("downPositionX", 0), r = e.getPrivate("downPositionY", 0), n = e.getPrivate("positionX", 0.5), a = e.getPrivate("positionY", 0.5);
    this.xAxes.each((o) => {
      if (t === "zoomX" || t === "zoomXY") {
        let l = o.toAxisPosition(s), u = o.toAxisPosition(n);
        o.zoom(l, u);
      }
      o.setPrivate("updateScrollbar", !0);
    }), this.yAxes.each((o) => {
      if (t === "zoomY" || t === "zoomXY") {
        let l = o.toAxisPosition(r), u = o.toAxisPosition(a);
        o.zoom(l, u);
      }
      o.setPrivate("updateScrollbar", !0);
    });
  }
  _handleScrollbar(e, t, s, r) {
    e.each((n) => {
      let a = n.fixPosition(t), o = n.fixPosition(s), l = n.zoom(a, o, void 0, r);
      const u = "updateScrollbar";
      n.setPrivateRaw(u, !1), l ? l.events.on("stopped", () => {
        n.setPrivateRaw(u, !0);
      }) : n.setPrivateRaw(u, !0);
    });
  }
  _processAxis(e, t) {
    return e.events.onAll((s) => {
      if (s.type === "clear")
        w(s.oldValues, (r) => {
          this._removeAxis(r);
        });
      else if (s.type === "push")
        t.children.push(s.newValue), s.newValue.processChart(this);
      else if (s.type === "setIndex")
        t.children.setIndex(s.index, s.newValue), s.newValue.processChart(this);
      else if (s.type === "insertIndex")
        t.children.insertIndex(s.index, s.newValue), s.newValue.processChart(this);
      else if (s.type === "removeIndex")
        this._removeAxis(s.oldValue);
      else if (s.type === "moveIndex")
        t.children.moveValue(s.value, s.newIndex), s.value.processChart(this);
      else
        throw new Error("Unknown IListEvent type");
    });
  }
  _removeAxis(e) {
    if (!e.isDisposed()) {
      const t = e.parent;
      t && t.children.removeValue(e);
      const s = e.gridContainer, r = s.parent;
      r && r.children.removeValue(s);
      const n = e.topGridContainer, a = n.parent;
      a && a.children.removeValue(n);
    }
  }
  _updateChartLayout() {
    const e = this.leftAxesContainer.width(), t = this.rightAxesContainer.width(), s = this.bottomAxesContainer;
    s.set("paddingLeft", e), s.set("paddingRight", t);
    const r = this.topAxesContainer;
    r.set("paddingLeft", e), r.set("paddingRight", t);
  }
  /**
   * @ignore
   */
  processAxis(e) {
  }
  _handleAxisSelection(e, t) {
    let s = e.fixPosition(e.get("start", 0)), r = e.fixPosition(e.get("end", 1));
    if (s > r && ([s, r] = [r, s]), this.xAxes.indexOf(e) != -1) {
      if (t || e.getPrivate("updateScrollbar")) {
        let n = this.get("scrollbarX");
        n && (!n.getPrivate("isBusy") || t) && (n.setRaw("start", s), n.setRaw("end", r), n.updateGrips());
      }
    } else if (this.yAxes.indexOf(e) != -1 && (t || e.getPrivate("updateScrollbar"))) {
      let n = this.get("scrollbarY");
      n && (!n.getPrivate("isBusy") || t) && (n.setRaw("start", s), n.setRaw("end", r), n.updateGrips());
    }
    this._handleZoomOut();
  }
  _handleZoomOut() {
    let e = this.zoomOutButton;
    if (e && e.parent) {
      let t = !1;
      this.xAxes.each((s) => {
        (s.get("start") != 0 || s.get("end") != 1) && (t = !0);
      }), this.yAxes.each((s) => {
        (s.get("start") != 0 || s.get("end") != 1) && (t = !0);
      }), t ? e.isHidden() && e.show() : e.hide();
    }
  }
  /**
   * Checks if point is within plot area.
   *
   * @param   point  Reference point
   * @return         Is within plot area?
   */
  inPlot(e) {
    const t = this.plotContainer, s = this.getPrivate("otherCharts", this._otherCharts), r = t.toGlobal(e);
    if (e.x >= -0.5 && e.y >= -0.5 && e.x <= t.width() + 0.5 && e.y <= t.height() + 0.5)
      return !0;
    if (s)
      for (let n = s.length - 1; n >= 0; n--) {
        const a = s[n];
        if (a != this) {
          const o = a.plotContainer, l = this._root.rootPointToDocument(r), u = a._root.documentPointToRoot(l), c = o.toLocal(u);
          if (c.x >= -0.1 && c.y >= -0.1 && c.x <= o.width() + 0.1 && c.y <= o.height() + 0.1)
            return !0;
        }
      }
    return !1;
  }
  /**
   * @ignore
   */
  arrangeTooltips() {
    const e = this.plotContainer, t = e.width(), s = e.height(), r = this.height();
    let n = e._display.toGlobal({ x: 0, y: 0 }), a = e._display.toGlobal({ x: t, y: s });
    const o = [];
    let l = 0, u = 1 / 0, c = this._movePoint, h = this.get("maxTooltipDistance"), d = this.get("maxTooltipDistanceBy", "xy"), f, g;
    S(h) && this.series.each((_) => {
      if (!_.isHidden()) {
        const m = _.get("tooltip");
        if (m) {
          let v = m.get("pointTo");
          if (v) {
            let b = Math.hypot(c.x - v.x, c.y - v.y);
            d == "x" ? b = Math.abs(c.x - v.x) : d == "y" && (b = Math.abs(c.y - v.y)), b < u && (u = b, f = _, g = v);
          }
        }
      }
    });
    const p = [];
    if (this.series.each((_) => {
      const m = _.get("tooltip");
      if (m) {
        let v = !1, b = m.get("pointTo");
        if (b) {
          if (h >= 0) {
            let y = m.get("pointTo");
            if (y && _ != f) {
              let x = Math.hypot(g.x - y.x, g.y - y.y);
              d == "x" ? x = Math.abs(g.x - y.x) : d == "y" && (x = Math.abs(g.y - y.y)), x > h && (v = !0);
            }
          } else
            h == -1 && _ != f && (v = !0);
          !this.inPlot(this._tooltipToLocal(b)) || !m.dataItem ? v = !0 : v || (l += b.y), v || _.isHidden() || _.isHiding() ? m.hide(0) : (m.show(), o.push(m), p.push(_));
        }
      }
    }), this.setPrivate("tooltipSeries", p), this.get("arrangeTooltips")) {
      const _ = this._root.tooltipContainer, m = o.length;
      if (l / m > s / 2 + n.y) {
        o.sort((y, x) => Xu(x.get("pointTo").y, y.get("pointTo").y));
        let b = a.y;
        if (w(o, (y) => {
          let x = y.height(), D = y.get("centerY");
          D instanceof re && (x *= D.value), x += y.get("marginBottom", 0), y.set("bounds", { left: n.x, top: n.y, right: a.x, bottom: b }), y.setPrivate("customData", { left: n.x, top: n.y, right: a.x, bottom: b }), b = Math.min(b - x, y._fy - x), y.parent == _ && _.children.moveValue(y, 0);
        }), b < 0) {
          o.reverse();
          let y = b;
          w(o, (x) => {
            let D = x.get("bounds");
            if (D) {
              let A = D.top - b, T = D.bottom - b;
              A < y && (A = y, T = A + x.height()), x.set("bounds", { left: D.left, top: A, right: D.right, bottom: T }), y = D.bottom - b + x.get("marginBottom", 0);
            }
          });
        }
      } else {
        o.reverse(), o.sort((y, x) => Xu(y.get("pointTo").y, x.get("pointTo").y));
        let b = 0;
        if (w(o, (y) => {
          let x = y.height(), D = y.get("centerY");
          D instanceof re && (x *= D.value), x += y.get("marginBottom", 0), y.set("bounds", { left: n.x, top: b, right: a.x, bottom: Math.max(n.y + r, b + x) }), y.parent == _ && _.children.moveValue(y, 0), b = Math.max(b + x, y._fy + x);
        }), b > r) {
          o.reverse();
          let y = r;
          w(o, (x) => {
            let D = x.get("bounds");
            if (D) {
              let A = D.top - (r - b), T = D.bottom - (r - b);
              T > y && (T = y, A = T - x.height()), x.set("bounds", { left: D.left, top: A, right: D.right, bottom: T }), y = T - x.height() - x.get("marginBottom", 0);
            }
          });
        }
      }
    }
  }
  _tooltipToLocal(e) {
    return this.plotContainer.toLocal(e);
  }
  /**
   * Fully zooms out the chart.
   */
  zoomOut() {
    this.xAxes.each((e) => {
      e.setPrivate("updateScrollbar", !0), e.zoom(0, 1);
    }), this.yAxes.each((e) => {
      e.setPrivate("updateScrollbar", !0), e.zoom(0, 1);
    });
  }
};
Object.defineProperty(Js, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "XYChart"
});
Object.defineProperty(Js, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Ks.classNames.concat([Js.className])
});
class Vr extends _i {
  constructor() {
    super(...arguments), Object.defineProperty(this, "chart", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.children.push(Js.new(this._root, {
        themeTags: ["chart"],
        interactive: !1,
        interactiveChildren: !1,
        panX: !1,
        panY: !1,
        wheelX: "none",
        wheelY: "none"
      }))
    }), Object.defineProperty(this, "overlay", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.children.push(le.new(this._root, {
        themeTags: ["overlay"],
        interactive: !1
      }))
    });
  }
  _afterNew() {
    this._addOrientationClass(), this._settings.themeTags = ie(this._settings.themeTags, ["scrollbar", "xy", "chart", this._settings.orientation]);
    const e = this.children;
    e.moveValue(this.thumb), e.moveValue(this.startGrip), e.moveValue(this.endGrip), this.thumb.set("opacity", 0), this.thumb.states.create("hover", { opacity: 0.2 });
    const t = this.chart.plotContainer;
    t.set("interactive", !1), t.remove("background"), t.children.removeValue(this.chart.zoomOutButton), super._afterNew();
  }
  _updateThumb() {
    super._updateThumb(), this.overlay.set("draw", (e) => {
      const t = this.startGrip, s = this.endGrip;
      let r = t.x(), n = t.y(), a = s.x(), o = s.y();
      const l = this.height(), u = this.width();
      r > a && ([r, a] = [a, r]), n > o && ([n, o] = [o, n]), this.get("orientation") === "horizontal" ? (e.moveTo(0, 0), e.lineTo(r, 0), e.lineTo(r, l), e.lineTo(0, l), e.lineTo(0, 0), e.moveTo(a, 0), e.lineTo(u, 0), e.lineTo(u, l), e.lineTo(a, l), e.lineTo(a, 0)) : (e.moveTo(0, 0), e.lineTo(0, n), e.lineTo(u, n), e.lineTo(u, 0), e.lineTo(0, 0), e.moveTo(0, o), e.lineTo(0, l), e.lineTo(u, l), e.lineTo(u, o), e.lineTo(0, o));
    });
  }
}
Object.defineProperty(Vr, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "XYChartScrollbar"
});
Object.defineProperty(Vr, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: _i.classNames.concat([Vr.className])
});
class ms extends le {
  _beforeChanged() {
    super._beforeChanged(), (this.isPrivateDirty("width") || this.isPrivateDirty("height")) && (this._clear = !0);
  }
}
Object.defineProperty(ms, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Grid"
});
Object.defineProperty(ms, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: le.classNames.concat([ms.className])
});
class Ur extends Z {
  constructor() {
    super(...arguments), Object.defineProperty(this, "lineX", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.children.push(ms.new(this._root, {
        themeTags: ["x"]
      }))
    }), Object.defineProperty(this, "lineY", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.children.push(ms.new(this._root, {
        themeTags: ["y"]
      }))
    }), Object.defineProperty(this, "selection", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.children.push(le.new(this._root, {
        themeTags: ["selection", "cursor"],
        layer: 30
      }))
    }), Object.defineProperty(this, "_movePoint", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_lastPoint", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: { x: 0, y: 0 }
    }), Object.defineProperty(this, "_tooltipX", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_tooltipY", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "chart", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_toX", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_toY", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  _afterNew() {
    this._settings.themeTags = ie(this._settings.themeTags, ["xy", "cursor"]), super._afterNew(), this.setAll({ width: R, height: R, isMeasured: !0, position: "absolute" }), this.states.create("hidden", { visible: !0, opacity: 0 }), this._drawLines(), this.setPrivateRaw("visible", !1), this._disposers.push(this.setTimeout(() => {
      this.setPrivate("visible", !0);
    }, 500)), this._disposers.push(this.lineX.events.on("positionchanged", () => {
      this._handleXLine();
    })), this._disposers.push(this.lineY.events.on("positionchanged", () => {
      this._handleYLine();
    })), this._disposers.push(this.lineX.events.on("focus", (e) => this._handleLineFocus(e.target))), this._disposers.push(this.lineX.events.on("blur", (e) => this._handleLineBlur(e.target))), this._disposers.push(this.lineY.events.on("focus", (e) => this._handleLineFocus(e.target))), this._disposers.push(this.lineY.events.on("blur", (e) => this._handleLineBlur(e.target))), Wt("keyboardevents") && this._disposers.push(Le(document, "keydown", (e) => {
      this._handleLineMove(e.keyCode);
    }));
  }
  _setUpTouch() {
    const e = this.chart;
    e && (e.plotContainer._display.cancelTouch = this.get("behavior") != "none");
  }
  _handleXLine() {
    let e = this.lineX.x(), t = !0;
    (e < 0 || e > this.width()) && (t = !1), this.lineX.setPrivate("visible", t);
  }
  _handleYLine() {
    let e = this.lineY.y(), t = !0;
    (e < 0 || e > this.height()) && (t = !1), this.lineY.setPrivate("visible", t);
  }
  _handleLineMove(e) {
    let t = "", s = 0, r = 0.1;
    const n = this.chart;
    this._root.focused(this.lineX) ? (n && n.xAxes.length && (r = n.xAxes.getIndex(0).getCellWidthPosition()), s = this.getPrivate("positionX", 0), t = "positionX", e == 37 ? s -= r : e == 39 && (s += r)) : this._root.focused(this.lineY) && (n && n.yAxes.length && (r = n.yAxes.getIndex(0).getCellWidthPosition()), s = this.getPrivate("positionY", 0), t = "positionY", e == 38 ? s -= r : e == 40 && (s += r)), s < 0 ? s = 0 : s > 1 && (s = 1), t != "" && this.set(t, s);
  }
  _handleLineFocus(e) {
    this.setAll({
      positionX: this.getPrivate("positionX"),
      positionY: this.getPrivate("positionY"),
      alwaysShow: !0
    });
  }
  _handleLineBlur(e) {
    this.setAll({
      positionX: void 0,
      positionY: void 0,
      alwaysShow: !1
    });
  }
  _prepareChildren() {
    if (super._prepareChildren(), this.isDirty("xAxis")) {
      this._tooltipX = !1;
      const e = this.get("xAxis");
      if (e) {
        const t = e.get("tooltip");
        t && (this._tooltipX = !0, this._disposers.push(t.on("pointTo", () => {
          this._updateXLine(t);
        })));
      }
    }
    if (this.isDirty("yAxis")) {
      this._tooltipY = !1;
      const e = this.get("yAxis");
      if (e) {
        const t = e.get("tooltip");
        t && (this._tooltipY = !0, this._disposers.push(t.on("pointTo", () => {
          this._updateYLine(t);
        })));
      }
    }
  }
  _handleSyncWith() {
    const e = this.chart;
    if (e) {
      const t = this.get("syncWith"), s = [];
      t && w(t, (r) => {
        const n = r.chart;
        n && s.push(n);
      }), e._otherCharts = s;
    }
  }
  _updateChildren() {
    if (super._updateChildren(), this._handleSyncWith(), this.isDirty("positionX") || this.isDirty("positionY")) {
      const e = this.get("positionX"), t = this.get("positionY");
      e == null && t == null ? this.hide(0) : (this._movePoint = this.toGlobal(this._getPoint(this.get("positionX", 0), this.get("positionY", 0))), this.handleMove());
    }
  }
  _updateXLine(e) {
    let t = qe(this._display.toLocal(e.get("pointTo", { x: 0, y: 0 })).x, 2);
    this._toX != t && (this.lineX.animate({ key: "x", to: t, duration: e.get("animationDuration", 0), easing: e.get("animationEasing") }), this._toX = t);
  }
  _updateYLine(e) {
    let t = qe(this._display.toLocal(e.get("pointTo", { x: 0, y: 0 })).y, 2);
    this._toY != t && (this.lineY.animate({ key: "y", to: t, duration: e.get("animationDuration", 0), easing: e.get("animationEasing") }), this._toY = t);
  }
  _drawLines() {
    this.lineX.set("draw", (e) => {
      e.moveTo(0, 0), e.lineTo(0, this.height());
    }), this.lineY.set("draw", (e) => {
      e.moveTo(0, 0), e.lineTo(this.width(), 0);
    });
  }
  _setChart(e) {
    this.chart = e, this._handleSyncWith();
    const t = e.plotContainer;
    this.events.on("boundschanged", () => {
      this._disposers.push(this.setTimeout(() => {
        this.get("alwaysShow") && (this._movePoint = this.toGlobal(this._getPoint(this.get("positionX", 0), this.get("positionY", 0))), this.handleMove());
      }, 50));
    }), Wt("touchevents") && (this._disposers.push(t.events.on("click", (r) => {
      qn(r.originalEvent) && this._handleMove(r.originalEvent);
    })), this._setUpTouch()), this._disposers.push(t.events.on("pointerdown", (r) => {
      this._handleCursorDown(r.originalEvent);
    })), this._disposers.push(t.events.on("globalpointerup", (r) => {
      this._handleCursorUp(r.originalEvent), !r.native && !this.isHidden() && this._handleMove(r.originalEvent);
    })), this._disposers.push(t.events.on("globalpointermove", (r) => {
      !this.get("syncWith") && Ne(t._downPoints).length == 0 && !r.native && this.isHidden() || this._handleMove(r.originalEvent);
    }));
    const s = this.parent;
    s && s.children.moveValue(this.selection);
  }
  _inPlot(e) {
    const t = this.chart;
    return t ? t.inPlot(e) : !1;
  }
  _handleCursorDown(e) {
    if (e.button == 2)
      return;
    const t = this._root.documentPointToRoot({ x: e.clientX, y: e.clientY });
    let s = this._display.toLocal(t);
    const r = this.chart;
    if (this.selection.set("draw", () => {
    }), r && this._inPlot(s)) {
      if (this._downPoint = s, this.get("behavior") != "none") {
        this.selection.show();
        const o = "selectstarted";
        this.events.isEnabled(o) && this.events.dispatch(o, { type: o, target: this });
      }
      let n = this._getPosition(s).x, a = this._getPosition(s).y;
      this.setPrivate("downPositionX", n), this.setPrivate("downPositionY", a);
    }
  }
  _handleCursorUp(e) {
    if (this._downPoint) {
      const t = this.get("behavior", "none");
      if (t != "none") {
        t.charAt(0) === "z" && this.selection.hide();
        const s = this._root.documentPointToRoot({ x: e.clientX, y: e.clientY });
        let r = this._display.toLocal(s);
        const n = this._downPoint, a = this.get("moveThreshold", 1);
        if (r && n) {
          let o = !1;
          if ((t === "zoomX" || t === "zoomXY" || t === "selectX" || t === "selectXY") && Math.abs(r.x - n.x) > a && (o = !0), (t === "zoomY" || t === "zoomXY" || t === "selectY" || t === "selectXY") && Math.abs(r.y - n.y) > a && (o = !0), o) {
            const l = "selectended";
            this.events.isEnabled(l) && this.events.dispatch(l, { type: l, target: this });
          }
        }
      }
    }
    this._downPoint = void 0;
  }
  _handleMove(e) {
    if (this.getPrivate("visible")) {
      const t = this.chart;
      if (t && Ne(t.plotContainer._downPoints).length > 1) {
        this.set("forceHidden", !0);
        return;
      } else
        this.set("forceHidden", !1);
      const s = this._root.documentPointToRoot({ x: e.clientX, y: e.clientY }), r = this._lastPoint;
      if (Math.round(r.x) === Math.round(s.x) && Math.round(r.y) === Math.round(s.y))
        return;
      this._lastPoint = s, this.setPrivate("lastPoint", s), this.handleMove({ x: s.x, y: s.y });
    }
  }
  _getPosition(e) {
    return { x: e.x / this.width(), y: e.y / this.height() };
  }
  /**
   * Moves the cursor to X/Y coordinates within chart container (`point`).
   *
   * If `skipEvent` parameter is set to `true`, the move will not invoke
   * the `"cursormoved"` event.
   *
   * @param  point      X/Y to move cursor to
   * @param  skipEvent  Do not fire "cursormoved" event
   */
  handleMove(e, t) {
    e || (e = this._movePoint);
    const s = this.get("alwaysShow");
    if (!e) {
      this.hide(0);
      return;
    }
    this._movePoint = e;
    let r = this._display.toLocal(e), n = this.chart;
    if (n && this._inPlot(r)) {
      n._movePoint = e, this.isHidden() && (this.show(), this.get("behavior", "").charAt(0) == "z" && this.selection.set("draw", () => {
      }));
      let a = r.x, o = r.y, l = this._getPosition(r);
      this.setPrivate("point", r);
      let u = this.get("snapToSeries");
      this._downPoint && (u = void 0);
      let c = this.get("positionX"), h = l.x;
      S(c) && (h = c);
      let d = this.get("positionY"), f = l.y;
      S(d) && (f = d), this.setPrivate("positionX", h), this.setPrivate("positionY", f);
      const g = this._getPoint(h, f);
      if (a = g.x, o = g.y, n.xAxes.each((p) => {
        p._handleCursorPosition(h, u), s && p.handleCursorShow();
      }), n.yAxes.each((p) => {
        p._handleCursorPosition(f, u), s && p.handleCursorShow();
      }), !t) {
        n._handleCursorPosition();
        const p = "cursormoved";
        this.events.isEnabled(p) && this.events.dispatch(p, { type: p, target: this });
      }
      this._updateLines(a, o), n.arrangeTooltips();
    } else if (!this._downPoint && !s) {
      this.hide(0);
      const a = "cursorhidden";
      this.events.isEnabled(a) && this.events.dispatch(a, { type: a, target: this });
    }
    this._downPoint && this.get("behavior") != "none" && this._updateSelection(r);
  }
  _getPoint(e, t) {
    return { x: this.width() * e, y: this.height() * t };
  }
  _updateLines(e, t) {
    this._tooltipX || this.lineX.set("x", e), this._tooltipY || this.lineY.set("y", t), this._drawLines();
  }
  _updateSelection(e) {
    const t = this.selection, s = this.get("behavior"), r = this.width(), n = this.height();
    e.x < 0 && (e.x = 0), e.x > r && (e.x = r), e.y < 0 && (e.y = 0), e.y > n && (e.y = n), t.set("draw", (a) => {
      const o = this._downPoint;
      o && (s === "zoomXY" || s === "selectXY" ? (a.moveTo(o.x, o.y), a.lineTo(o.x, e.y), a.lineTo(e.x, e.y), a.lineTo(e.x, o.y), a.lineTo(o.x, o.y)) : s === "zoomX" || s === "selectX" ? (a.moveTo(o.x, 0), a.lineTo(o.x, n), a.lineTo(e.x, n), a.lineTo(e.x, 0), a.lineTo(o.x, 0)) : (s === "zoomY" || s === "selectY") && (a.moveTo(0, o.y), a.lineTo(r, o.y), a.lineTo(r, e.y), a.lineTo(0, e.y), a.lineTo(0, o.y)));
    });
  }
  _onHide() {
    if (this.isHidden()) {
      let e = this.chart;
      e && (e.xAxes.each((t) => {
        t.handleCursorHide();
      }), e.yAxes.each((t) => {
        t.handleCursorHide();
      }), e.series.each((t) => {
        t.handleCursorHide();
      }));
    }
    super._onHide();
  }
  _onShow() {
    if (!this.isHidden()) {
      let e = this.chart;
      e && (e.xAxes.each((t) => {
        t.handleCursorShow();
      }), e.yAxes.each((t) => {
        t.handleCursorShow();
      }));
    }
    super._onShow();
  }
  _dispose() {
    super._dispose(), this.selection.dispose();
  }
}
Object.defineProperty(Ur, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "XYCursor"
});
Object.defineProperty(Ur, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Z.classNames.concat([Ur.className])
});
function tS(i, e) {
  return i == null ? e : e == null ? i : e < i ? e : i;
}
function iS(i, e) {
  return i == null ? e : e == null ? i : e > i ? e : i;
}
class Bi extends Fi {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_xField", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_yField", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_xOpenField", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_yOpenField", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_xLowField", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_xHighField", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_yLowField", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_yHighField", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_axesDirty", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_stackDirty", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_selectionProcessed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_dataSets", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_mainContainerMask", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_x", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_y", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "mainContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.children.push(Z.new(this._root, {}))
    }), Object.defineProperty(this, "axisRanges", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new lr()
    }), Object.defineProperty(this, "_skipped", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_couldStackTo", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_reallyStackedTo", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_stackedSeries", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_aLocationX0", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_aLocationX1", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), Object.defineProperty(this, "_aLocationY0", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_aLocationY1", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), Object.defineProperty(this, "_showBullets", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !0
    }), Object.defineProperty(this, "valueXFields", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: [
        "valueX",
        "openValueX",
        "lowValueX",
        "highValueX"
      ]
    }), Object.defineProperty(this, "valueYFields", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: [
        "valueY",
        "openValueY",
        "lowValueY",
        "highValueY"
      ]
    }), Object.defineProperty(this, "_valueXFields", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_valueYFields", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_valueXShowFields", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_valueYShowFields", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "__valueXShowFields", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "__valueYShowFields", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_emptyDataItem", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new Gt(this, void 0, {})
    }), Object.defineProperty(this, "_dataSetId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_tooltipFieldX", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_tooltipFieldY", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  _afterNew() {
    this.fields.push("categoryX", "categoryY", "openCategoryX", "openCategoryY"), this.valueFields.push("valueX", "valueY", "openValueX", "openValueY", "lowValueX", "lowValueY", "highValueX", "highValueY"), this._setRawDefault("vcx", 1), this._setRawDefault("vcy", 1), this._setRawDefault("valueXShow", "valueXWorking"), this._setRawDefault("valueYShow", "valueYWorking"), this._setRawDefault("openValueXShow", "openValueXWorking"), this._setRawDefault("openValueYShow", "openValueYWorking"), this._setRawDefault("lowValueXShow", "lowValueXWorking"), this._setRawDefault("lowValueYShow", "lowValueYWorking"), this._setRawDefault("highValueXShow", "highValueXWorking"), this._setRawDefault("highValueYShow", "highValueYWorking"), this._setRawDefault("lowValueXGrouped", "low"), this._setRawDefault("lowValueYGrouped", "low"), this._setRawDefault("highValueXGrouped", "high"), this._setRawDefault("highValueYGrouped", "high"), super._afterNew(), this._settings.xAxis.series.push(this), this._settings.yAxis.series.push(this), this.set("maskContent", !0), this._disposers.push(this.axisRanges.events.onAll((s) => {
      if (s.type === "clear")
        w(s.oldValues, (r) => {
          this._removeAxisRange(r);
        });
      else if (s.type === "push")
        this._processAxisRange(s.newValue);
      else if (s.type === "setIndex")
        this._processAxisRange(s.newValue);
      else if (s.type === "insertIndex")
        this._processAxisRange(s.newValue);
      else if (s.type === "removeIndex")
        this._removeAxisRange(s.oldValue);
      else if (s.type === "moveIndex")
        this._processAxisRange(s.value);
      else
        throw new Error("Unknown IStreamEvent type");
    }));
    const e = this.get("xAxis"), t = this.get("yAxis");
    this._disposers.push(e.events.on("positionchanged", () => {
      this._fixPosition();
    })), this._disposers.push(t.events.on("positionchanged", () => {
      this._fixPosition();
    })), this.get("baseAxis") || (t.isType("CategoryAxis") || t.isType("DateAxis") ? this.set("baseAxis", t) : this.set("baseAxis", e)), this.states.create("hidden", { opacity: 1, visible: !1 }), this._makeFieldNames();
  }
  _processAxisRange(e) {
    const t = Z.new(this._root, {});
    e.container = t, this.children.push(t), e.series = this;
    const s = e.axisDataItem;
    s.setRaw("isRange", !0);
    const r = s.component;
    if (r) {
      r._processAxisRange(s, ["range", "series"]);
      const n = s.get("bullet");
      if (n) {
        const o = n.get("sprite");
        o && o.setPrivate("visible", !1);
      }
      const a = s.get("axisFill");
      a && t.set("mask", a), r._seriesAxisRanges.push(s);
    }
  }
  _removeAxisRange(e) {
    const t = e.axisDataItem, s = t.component;
    s.disposeDataItem(t), bt(s._seriesAxisRanges, t);
    const r = e.container;
    r && r.dispose();
  }
  _updateFields() {
    super._updateFields(), this._valueXFields = [], this._valueYFields = [], this._valueXShowFields = [], this._valueYShowFields = [], this.__valueXShowFields = [], this.__valueYShowFields = [], this.valueXFields && w(this.valueXFields, (e) => {
      if (this.get(e + "Field")) {
        this._valueXFields.push(e);
        let s = this.get(e + "Show");
        this.__valueXShowFields.push(s), s.indexOf("Working") != -1 ? this._valueXShowFields.push(s.split("Working")[0]) : this._valueXShowFields.push(s);
      }
    }), this.valueYFields && w(this.valueYFields, (e) => {
      if (this.get(e + "Field")) {
        this._valueYFields.push(e);
        let s = this.get(e + "Show");
        this.__valueYShowFields.push(s), s.indexOf("Working") != -1 ? this._valueYShowFields.push(s.split("Working")[0]) : this._valueYShowFields.push(s);
      }
    });
  }
  _dispose() {
    super._dispose();
    const e = this.chart;
    e && e.series.removeValue(this), nt(this.get("xAxis").series, this), nt(this.get("yAxis").series, this);
  }
  // TODO use  SelectKeys<this["_privateSettings"], number | undefined>
  _min(e, t) {
    let s = tS(this.getPrivate(e), t);
    this.setPrivate(e, s);
  }
  // TODO use  SelectKeys<this["_privateSettings"], number | undefined>
  _max(e, t) {
    let s = iS(this.getPrivate(e), t);
    this.setPrivate(e, s);
  }
  _shouldMakeBullet(e) {
    const t = this.get("xAxis"), s = this.get("yAxis"), r = this.get("baseAxis");
    if (!t.inited || !s.inited)
      return !1;
    const n = this.get("minBulletDistance", 0);
    if (n > 0) {
      let a = this.startIndex(), l = this.endIndex() - a;
      if (t == r) {
        if (t.get("renderer").axisLength() / l < n / 5)
          return !1;
      } else if (s == r && s.get("renderer").axisLength() / l < n / 5)
        return !1;
    }
    return e.get(this._xField) != null && e.get(this._yField) != null;
  }
  _makeFieldNames() {
    const e = this.get("xAxis"), t = this.get("yAxis"), s = e.getPrivate("name"), r = tl(s), n = t.getPrivate("name"), a = tl(n), o = e.get("renderer").getPrivate("letter"), l = t.get("renderer").getPrivate("letter"), u = "open", c = "low", h = "high", d = "Show";
    e.className === "ValueAxis" ? (this._xField = this.get(s + o + d), this._xOpenField = this.get(u + r + o + d), this._xLowField = this.get(c + r + o + d), this._xHighField = this.get(h + r + o + d)) : (this._xField = s + o, this._xOpenField = u + r + o, this._xLowField = c + r + o, this._xHighField = h + r + o), t.className === "ValueAxis" ? (this._yField = this.get(n + l + d), this._yOpenField = this.get(u + a + l + d), this._yLowField = this.get(c + a + l + d), this._yHighField = this.get(h + a + l + d)) : (this._yField = n + l, this._yOpenField = u + a + l, this._yLowField = c + a + l, this._yHighField = h + a + l);
  }
  _fixVC() {
    const e = this.get("xAxis"), t = this.get("yAxis"), s = this.get("baseAxis"), r = this.states.lookup("hidden"), n = this.get("sequencedInterpolation");
    if (r) {
      let a = 0;
      n && (a = 0.999999999999), e === s ? r.set("vcy", a) : (t === s || r.set("vcy", a), r.set("vcx", a));
    }
  }
  _handleMaskBullets() {
    this.isDirty("maskBullets") && this.bulletsContainer.set("maskContent", this.get("maskBullets"));
  }
  _fixPosition() {
    const e = this.get("xAxis"), t = this.get("yAxis");
    this.set("x", e.x() - Re(e.get("centerX", 0), e.width()) - e.parent.get("paddingLeft", 0)), this.set("y", t.y() - Re(t.get("centerY", 0), t.height()) - t.parent.get("paddingTop", 0)), this.bulletsContainer.set("y", this.y()), this.bulletsContainer.set("x", this.x());
  }
  _prepareChildren() {
    super._prepareChildren(), (this.isDirty("valueYShow") || this.isDirty("valueXShow")) && (this._updateFields(), this._makeFieldNames(), this._valuesDirty = !0), this.set("width", this.get("xAxis").width()), this.set("height", this.get("yAxis").height()), this._handleMaskBullets();
    const e = this.get("xAxis"), t = this.get("yAxis"), s = this.get("baseAxis"), r = this.get("tooltipPositionX");
    let n;
    switch (r) {
      case "open":
        n = this._xOpenField;
        break;
      case "low":
        n = this._xLowField;
        break;
      case "high":
        n = this._xHighField;
        break;
      default:
        n = this._xField;
    }
    this._tooltipFieldX = n;
    const a = this.get("tooltipPositionY");
    let o;
    switch (a) {
      case "open":
        o = this._yOpenField;
        break;
      case "low":
        o = this._yLowField;
        break;
      case "high":
        o = this._yHighField;
        break;
      default:
        o = this._yField;
    }
    this._tooltipFieldY = o, this.isDirty("baseAxis") && this._fixVC(), this._fixPosition();
    const l = this.get("stacked");
    if (this.isDirty("stacked") && (l ? this._valuesDirty && !this._dataProcessed || this._stack() : this._unstack()), this._valuesDirty && !this._dataProcessed && (this._dataProcessed = !0, l && this._stack(), w(this.dataItems, (u) => {
      w(this._valueXShowFields, (c) => {
        let h = u.get(c);
        h != null && (l && (h += this.getStackedXValue(u, c)), this._min("minX", h), this._max("maxX", h));
      }), w(this._valueYShowFields, (c) => {
        let h = u.get(c);
        h != null && (l && (h += this.getStackedYValue(u, c)), this._min("minY", h), this._max("maxY", h));
      }), e.processSeriesDataItem(u, this._valueXFields), t.processSeriesDataItem(u, this._valueYFields);
    }), e._seriesValuesDirty = !0, t._seriesValuesDirty = !0, this.get("ignoreMinMax") || ((this.isPrivateDirty("minX") || this.isPrivateDirty("maxX")) && e.markDirtyExtremes(), (this.isPrivateDirty("minY") || this.isPrivateDirty("maxY")) && t.markDirtyExtremes()), this._markStakedDirtyStack(), this.get("tooltipDataItem") || this.updateLegendValue(void 0)), (this.isDirty("vcx") || this.isDirty("vcy")) && this._markStakedDirtyStack(), this._dataGrouped || (e._groupSeriesData(this), t._groupSeriesData(this), this._dataGrouped = !0), this._valuesDirty || this.isPrivateDirty("startIndex") || this.isPrivateDirty("endIndex") || this.isDirty("vcx") || this.isDirty("vcy") || this._stackDirty) {
      let u = this.startIndex(), c = this.endIndex(), h = this.get("minBulletDistance", 0);
      if (h > 0 && s && (s.get("renderer").axisLength() / (c - u) > h ? this._showBullets = !0 : this._showBullets = !1), (this._psi != u || this._pei != c || this.isDirty("vcx") || this.isDirty("vcy") || this._stackDirty || this._valuesDirty) && !this._selectionProcessed) {
        this._selectionProcessed = !0;
        const d = this.get("vcx", 1), f = this.get("vcy", 1), g = this.get("stacked", !1), p = this.getPrivate("outOfSelection");
        if (s === e)
          if (t._calculateTotals(), this.setPrivateRaw("selectionMinY", void 0), this.setPrivateRaw("selectionMaxY", void 0), p)
            t.markDirtySelectionExtremes();
          else
            for (let _ = u; _ < c; _++)
              this.processYSelectionDataItem(this.dataItems[_], f, g);
        else if (s === t)
          if (e._calculateTotals(), this.setPrivateRaw("selectionMinX", void 0), this.setPrivateRaw("selectionMaxX", void 0), p)
            t.markDirtySelectionExtremes();
          else
            for (let _ = u; _ < c; _++)
              this.processXSelectionDataItem(this.dataItems[_], d, g);
        if (s === e) {
          if (this.get("valueYShow") !== "valueYWorking") {
            const _ = this.getPrivate("selectionMinY");
            _ != null && (this.setPrivateRaw("minY", _), t.markDirtyExtremes());
            const m = this.getPrivate("selectionMaxY");
            m != null && (this.setPrivateRaw("maxY", m), t.markDirtyExtremes());
          }
        } else if (s === t && this.get("valueXShow") !== "valueXWorking") {
          const _ = this.getPrivate("selectionMinX");
          _ != null && (this.setPrivateRaw("minX", _), t.markDirtyExtremes());
          const m = this.getPrivate("selectionMaxX");
          m != null && (this.setPrivateRaw("maxX", m), e.markDirtyExtremes());
        }
        (this.isPrivateDirty("selectionMinX") || this.isPrivateDirty("selectionMaxX")) && e.markDirtySelectionExtremes(), (this.isPrivateDirty("selectionMinY") || this.isPrivateDirty("selectionMaxY")) && t.markDirtySelectionExtremes();
      }
    }
  }
  _makeRangeMask() {
    if (this.axisRanges.length > 0) {
      let e = this._mainContainerMask;
      e == null && (e = this.children.push(le.new(this._root, {})), this._mainContainerMask = e, e.set("draw", (t, s) => {
        const r = this.parent;
        if (r) {
          const n = this._root.container.width(), a = this._root.container.height();
          t.moveTo(-n, -a), t.lineTo(-n, a * 2), t.lineTo(n * 2, a * 2), t.lineTo(n * 2, -a), t.lineTo(-n, -a), this.axisRanges.each((o) => {
            const l = o.axisDataItem.get("axisFill");
            if (r && l) {
              let u = l.get("draw");
              u && u(t, s);
            }
          });
        }
        this.mainContainer._display.mask = e._display;
      })), e.markDirty(), e._markDirtyKey("fill");
    } else
      this.mainContainer._display.mask = null;
  }
  _updateChildren() {
    super._updateChildren(), this._x = this.x(), this._y = this.y(), this._makeRangeMask();
  }
  _stack() {
    const e = this.chart;
    if (e) {
      const t = e.series.indexOf(this);
      if (this._couldStackTo = [], t > 0) {
        let s;
        for (let r = t - 1; r >= 0 && (s = e.series.getIndex(r), !(s.get("xAxis") === this.get("xAxis") && s.get("yAxis") === this.get("yAxis") && s.className === this.className && (this._couldStackTo.push(s), !s.get("stacked")))); r--)
          ;
      }
      this._stackDataItems();
    }
  }
  _unstack() {
    _e(this._reallyStackedTo, (e, t) => {
      delete t._stackedSeries[this.uid];
    }), this._reallyStackedTo = {}, w(this.dataItems, (e) => {
      e.setRaw("stackToItemY", void 0), e.setRaw("stackToItemX", void 0);
    });
  }
  _stackDataItems() {
    const e = this.get("baseAxis"), t = this.get("xAxis"), s = this.get("yAxis");
    let r, n;
    e === t ? (r = "valueY", n = "stackToItemY") : e === s && (r = "valueX", n = "stackToItemX");
    let a = this._couldStackTo.length, o = 0;
    const l = this.get("stackToNegative");
    this._reallyStackedTo = {}, w(this.dataItems, (u) => {
      for (let c = 0; c < a; c++) {
        let h = this._couldStackTo[c], d = h.dataItems[o], f = u.get(r);
        if (d) {
          let g = d.get(r);
          if (l)
            if (S(f)) {
              if (S(g)) {
                if (f >= 0 && g >= 0) {
                  u.setRaw(n, d), this._reallyStackedTo[h.uid] = h, h._stackedSeries[this.uid] = this;
                  break;
                }
                if (f < 0 && g < 0) {
                  u.setRaw(n, d), this._reallyStackedTo[h.uid] = h, h._stackedSeries[this.uid] = this;
                  break;
                }
              }
            } else
              break;
          else if (S(f) && S(g)) {
            u.setRaw(n, d), this._reallyStackedTo[h.uid] = h, h._stackedSeries[this.uid] = this;
            break;
          }
        }
      }
      o++;
    });
  }
  processXSelectionDataItem(e, t, s) {
    w(this.__valueXShowFields, (r) => {
      let n = e.get(r);
      n != null && (s && (n += this.getStackedXValueWorking(e, r)), this._min("selectionMinX", n), this._max("selectionMaxX", n * t));
    });
  }
  processYSelectionDataItem(e, t, s) {
    w(this.__valueYShowFields, (r) => {
      let n = e.get(r);
      n != null && (s && (n += this.getStackedYValueWorking(e, r)), this._min("selectionMinY", n), this._max("selectionMaxY", n * t));
    });
  }
  /**
   * @ignore
   */
  getStackedYValueWorking(e, t) {
    const s = e.get("stackToItemY");
    if (s) {
      const r = s.component;
      return s.get(t, 0) * r.get("vcy", 1) + this.getStackedYValueWorking(s, t);
    }
    return 0;
  }
  /**
   * @ignore
   */
  getStackedXValueWorking(e, t) {
    const s = e.get("stackToItemX");
    if (s) {
      const r = s.component;
      return s.get(t, 0) * r.get("vcx", 1) + this.getStackedXValueWorking(s, t);
    }
    return 0;
  }
  /**
   * @ignore
   */
  getStackedYValue(e, t) {
    const s = e.get("stackToItemY");
    return s ? s.get(t, 0) + this.getStackedYValue(s, t) : 0;
  }
  /**
   * @ignore
   */
  getStackedXValue(e, t) {
    const s = e.get("stackToItemX");
    return s ? s.get(t, 0) + this.getStackedXValue(s, t) : 0;
  }
  /**
   * @ignore
   */
  createLegendMarker(e) {
    this.updateLegendMarker();
  }
  _markDirtyAxes() {
    this._axesDirty = !0, this.markDirty();
  }
  _markDataSetDirty() {
    this._afterDataChange(), this._valuesDirty = !0, this._dataProcessed = !1, this._aggregatesCalculated = !1, this.markDirty();
  }
  _clearDirty() {
    super._clearDirty(), this._axesDirty = !1, this._selectionProcessed = !1, this._stackDirty = !1, this._dataProcessed = !1;
  }
  _positionBullet(e) {
    let t = e.get("sprite");
    if (t) {
      let s = t.dataItem, r = e.get("locationX", s.get("locationX", 0.5)), n = e.get("locationY", s.get("locationY", 0.5)), a = this.get("xAxis"), o = this.get("yAxis");
      const l = a.getDataItemPositionX(s, this._xField, r, this.get("vcx", 1)), u = o.getDataItemPositionY(s, this._yField, n, this.get("vcy", 1));
      let c = this.getPoint(l, u), h = s.get("left", c.x), d = s.get("right", c.x), f = s.get("top", c.y), g = s.get("bottom", c.y);
      if (this._shouldShowBullet(l, u)) {
        e.getPrivate("hidden") ? t.setPrivate("visible", !1) : t.setPrivate("visible", !0);
        let p = d - h, _ = g - f;
        t.isType("Label") && (t.setPrivate("maxWidth", Math.abs(p)), t.setPrivate("maxHeight", Math.abs(_)));
        let m = h + p * r, v = g - _ * n;
        t.set("x", m), t.set("y", v);
      } else
        t.setPrivate("visible", !1);
    }
  }
  _shouldShowBullet(e, t) {
    return this._showBullets;
  }
  /**
   * @ignore
   */
  setDataSet(e) {
    if (this._dataSets[e]) {
      this._handleDataSetChange(), this._dataItems = this._dataSets[e], this._markDataSetDirty(), this._dataSetId = e;
      const t = "datasetchanged";
      this.events.isEnabled(t) && this.events.dispatch(t, { type: t, target: this, id: e });
    }
  }
  _handleDataSetChange() {
    this.bullets.length > 0 && w(this._dataItems, (e) => {
      let t = e.bullets;
      t && w(t, (s) => {
        if (s) {
          let r = s.get("sprite");
          r && r.setPrivate("visible", !1);
        }
      });
    }), this._selectionProcessed = !1;
  }
  /**
   * Shows hidden series.
   *
   * @param   duration  Duration of animation in milliseconds
   * @return            Animation promise
   */
  show(e) {
    const t = Object.create(null, {
      show: { get: () => super.show }
    });
    return at(this, void 0, void 0, function* () {
      this._fixVC();
      let s = [];
      s.push(t.show.call(this, e).then(() => {
        this._isShowing = !1;
        let r = this.get("xAxis"), n = this.get("yAxis"), a = this.get("baseAxis");
        n !== a && n.markDirtySelectionExtremes(), r !== a && r.markDirtySelectionExtremes();
      })), s.push(this.bulletsContainer.show(e)), s.push(this._sequencedShowHide(!0, e)), yield Promise.all(s);
    });
  }
  /**
   * Hides series.
   *
   * @param   duration  Duration of animation in milliseconds
   * @return            Animation promise
   */
  hide(e) {
    const t = Object.create(null, {
      hide: { get: () => super.hide }
    });
    return at(this, void 0, void 0, function* () {
      this._fixVC();
      let s = [];
      s.push(t.hide.call(this, e).then(() => {
        this._isHiding = !1;
      })), s.push(this.bulletsContainer.hide(e)), s.push(this._sequencedShowHide(!1, e)), yield Promise.all(s);
    });
  }
  /**
   * Shows series's data item.
   *
   * @param   dataItem  Data item
   * @param   duration  Animation duration in milliseconds
   * @return            Promise
   */
  showDataItem(e, t) {
    const s = Object.create(null, {
      showDataItem: { get: () => super.showDataItem }
    });
    return at(this, void 0, void 0, function* () {
      const r = [s.showDataItem.call(this, e, t)];
      S(t) || (t = this.get("stateAnimationDuration", 0));
      const n = this.get("stateAnimationEasing");
      w(this._valueFields, (a) => {
        r.push(e.animate({ key: a + "Working", to: e.get(a), duration: t, easing: n }).waitForStop());
      }), yield Promise.all(r);
    });
  }
  /**
   * Hides series's data item.
   *
   * @param   dataItem  Data item
   * @param   duration  Animation duration in milliseconds
   * @return            Promise
   */
  hideDataItem(e, t) {
    const s = Object.create(null, {
      hideDataItem: { get: () => super.hideDataItem }
    });
    return at(this, void 0, void 0, function* () {
      const r = [s.hideDataItem.call(this, e, t)], n = this.states.create("hidden", {});
      S(t) || (t = n.get("stateAnimationDuration", this.get("stateAnimationDuration", 0)));
      const a = n.get("stateAnimationEasing", this.get("stateAnimationEasing")), o = this.get("xAxis"), l = this.get("yAxis"), u = this.get("baseAxis"), c = this.get("stacked");
      if ((u === o || !u) && w(this._valueYFields, (h) => {
        let d = l.getPrivate("min"), f = l.baseValue();
        S(d) && d > f && (f = d), c && (f = 0), e.get(h) != null && r.push(e.animate({ key: h + "Working", to: f, duration: t, easing: a }).waitForStop());
      }), u === l || !u) {
        let h = o.getPrivate("min"), d = o.baseValue();
        S(h) && h > d && (d = h), c && (d = 0), w(this._valueXFields, (f) => {
          e.get(f) != null && r.push(e.animate({ key: f + "Working", to: d, duration: t, easing: a }).waitForStop());
        });
      }
      yield Promise.all(r);
    });
  }
  _markDirtyStack() {
    this._stackDirty = !0, this.markDirty(), this._markStakedDirtyStack();
  }
  _markStakedDirtyStack() {
    const e = this._stackedSeries;
    e && _e(e, (t, s) => {
      s._stackDirty || s._markDirtyStack();
    });
  }
  _afterChanged() {
    super._afterChanged(), this._skipped && (this._markDirtyAxes(), this._skipped = !1);
  }
  /**
   * Shows a tooltip for specific data item.
   *
   * @param  dataItem  Data item
   */
  showDataItemTooltip(e) {
    this.updateLegendMarker(e), this.updateLegendValue(e);
    const t = this.get("tooltip");
    if (t) {
      if (this.isHidden())
        this.hideTooltip();
      else if (t._setDataItem(e), e) {
        let s = this.get("locationX", 0), r = this.get("locationY", 1), n = e.get("locationX", s), a = e.get("locationY", r);
        const o = this.get("xAxis"), l = this.get("yAxis"), u = this.get("vcx", 1), c = this.get("vcy", 1), h = o.getDataItemPositionX(e, this._tooltipFieldX, this._aLocationX0 + (this._aLocationX1 - this._aLocationX0) * n, u), d = l.getDataItemPositionY(e, this._tooltipFieldY, this._aLocationY0 + (this._aLocationY1 - this._aLocationY0) * a, c), f = this.getPoint(h, d);
        let g = !0;
        if (w(this._valueFields, (p) => {
          e.get(p) == null && (g = !1);
        }), g) {
          const p = this.chart;
          p && p.inPlot(f) ? (t.label.text.markDirtyText(), t.set("tooltipTarget", this._getTooltipTarget(e)), t.set("pointTo", this._display.toGlobal({ x: f.x, y: f.y }))) : t._setDataItem(void 0);
        } else
          t._setDataItem(void 0);
      }
    }
  }
  hideTooltip() {
    const e = this.get("tooltip");
    return e && e.set("tooltipTarget", this), super.hideTooltip();
  }
  _getTooltipTarget(e) {
    if (this.get("seriesTooltipTarget") == "bullet") {
      const t = e.bullets;
      if (t && t.length > 0) {
        const r = t[0].get("sprite");
        if (r)
          return r;
      }
    }
    return this;
  }
  /**
   * @ignore
   */
  updateLegendValue(e) {
    const t = this.get("legendDataItem");
    if (t) {
      const s = t.get("label");
      if (s) {
        let n = "";
        e ? (s._setDataItem(e), n = this.get("legendLabelText", s.get("text", this.get("name", "")))) : (s._setDataItem(this._emptyDataItem), n = this.get("legendRangeLabelText", this.get("legendLabelText", s.get("text", this.get("name", ""))))), s.set("text", n);
      }
      const r = t.get("valueLabel");
      if (r) {
        let n = "";
        e ? (r._setDataItem(e), n = this.get("legendValueText", r.get("text", ""))) : (r._setDataItem(this._emptyDataItem), n = this.get("legendRangeValueText", r.get("text", ""))), r.set("text", n);
      }
    }
  }
  _getItemReaderLabel() {
    let e = "X: {" + this._xField;
    return this.get("xAxis").isType("DateAxis") && (e += ".formatDate()"), e += "}; Y: {" + this._yField, this.get("yAxis").isType("DateAxis") && (e += ".formatDate()"), e += "}", e;
  }
  /**
   * @ignore
   */
  getPoint(e, t) {
    let s = this.get("xAxis").get("renderer").positionToCoordinate(e), r = this.get("yAxis").get("renderer").positionToCoordinate(t), n = 999999999;
    return r < -n && (r = -n), r > n && (r = n), s < -n && (s = -n), s > n && (s = n), { x: s, y: r };
  }
  _shouldInclude(e) {
    return !0;
  }
  /**
   * @ignore
   */
  handleCursorHide() {
    this.hideTooltip(), this.updateLegendValue(void 0), this.updateLegendMarker(void 0);
  }
  _afterDataChange() {
    super._afterDataChange(), this.get("xAxis")._markDirtyKey("start"), this.get("yAxis")._markDirtyKey("start"), this.resetExtremes();
  }
  // todo description
  resetExtremes() {
    this.setPrivate("selectionMinX", void 0), this.setPrivate("selectionMaxX", void 0), this.setPrivate("selectionMinY", void 0), this.setPrivate("selectionMaxY", void 0), this.setPrivate("minX", void 0), this.setPrivate("minY", void 0), this.setPrivate("maxX", void 0), this.setPrivate("maxY", void 0);
  }
  /**
   * Creates and returns an axis range object.
   *
   * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/axis-ranges/} for more info
   * @param   axisDataItem  Axis data item
   * @return                Axis range
   */
  createAxisRange(e) {
    return this.axisRanges.push({
      axisDataItem: e
    });
  }
  /**
   * A list of series's main (ungrouped) data items.
   *
   * @return  Data items
   */
  get mainDataItems() {
    return this._mainDataItems;
  }
}
Object.defineProperty(Bi, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "XYSeries"
});
Object.defineProperty(Bi, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Fi.classNames.concat([Bi.className])
});
class Hi extends Bi {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_ph", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_pw", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    });
  }
  _makeGraphics(e, t) {
    return this.makeColumn(t, e);
  }
  _makeFieldNames() {
    super._makeFieldNames();
    const e = this.get("xAxis"), t = this.get("yAxis"), s = "CategoryAxis", r = "ValueAxis";
    e.isType(s) && (this.get("openCategoryXField") || (this._xOpenField = this._xField)), e.isType(r) && (this.get("openValueXField") || (this._xOpenField = this._xField)), t.isType(s) && (this.get("openCategoryYField") || (this._yOpenField = this._yField)), t.isType(r) && (this.get("openValueYField") || (this._yOpenField = this._yField));
  }
  _prepareChildren() {
    super._prepareChildren();
    const e = this.get("xAxis"), t = this.get("yAxis"), s = this.dataItems.length, r = Math.max(0, this.startIndex() - 2), n = Math.min(this.endIndex() + 2, s - 1);
    if (e.inited && t.inited)
      for (let a = r; a <= n; a++) {
        let o = this.dataItems[a];
        this._createGraphics(o);
      }
  }
  _updateChildren() {
    const e = this.chart;
    e && (this._ph = e.plotContainer.height(), this._pw = e.plotContainer.width());
    const t = this.get("xAxis"), s = this.get("yAxis"), r = this.get("baseAxis"), n = this.columns.template;
    this.isDirty("fill") && n.get("fill") == null && n.set("fill", this.get("fill")), this.isDirty("stroke") && n.get("stroke") == null && n.set("stroke", this.get("stroke"));
    let a = 0, o = 0, l = 0;
    w(r.series, (m) => {
      if (m instanceof Hi) {
        const v = m.get("stacked");
        v && l == 0 && o++, !v && m.get("clustered") && o++;
      }
      m === this && (a = o - 1), l++;
    }), this.get("clustered") || (a = 0, o = 1), o === 0 && (o = 1, a = 0);
    const u = t.get("renderer"), c = s.get("renderer"), h = "cellStartLocation", d = "cellEndLocation", f = u.get(h, 0), g = u.get(d, 1), p = c.get(h, 0), _ = c.get(d, 1);
    if (this._aLocationX0 = f + a / o * (g - f), this._aLocationX1 = f + (a + 1) / o * (g - f), this._aLocationY0 = p + a / o * (_ - p), this._aLocationY1 = p + (a + 1) / o * (_ - p), t.inited && s.inited) {
      if (this._axesDirty || this._valuesDirty || this._stackDirty || this.isDirty("vcx") || this.isDirty("vcy") || this._sizeDirty) {
        const m = this.dataItems.length;
        let v = Math.max(0, this.startIndex() - 2), b = Math.min(this.endIndex() + 2, m - 1);
        for (let x = 0; x < v; x++)
          this._toggleColumn(this.dataItems[x], !1);
        let y = this.dataItems[v];
        for (let x = v; x <= b; x++) {
          let D = this.dataItems[x];
          if (D.get("valueX") != null && D.get("valueY") != null) {
            if (y = D, x > 0 && v > 0)
              for (let A = x - 1; A >= 0; A--) {
                let T = this.dataItems[A];
                if (T.get("valueX") != null && T.get("valueY") != null) {
                  y = T;
                  break;
                }
              }
            break;
          } else
            this._toggleColumn(D, !1);
        }
        for (let x = v; x <= b; x++) {
          let D = this.dataItems[x];
          this._updateGraphics(D, y), D.get("valueX") != null && D.get("valueY") != null && (y = D);
        }
        for (let x = b + 1; x < m; x++)
          this._toggleColumn(this.dataItems[x], !1);
      }
    } else
      this._skipped = !0;
    this.updateLegendMarker(this.get("tooltipDataItem")), super._updateChildren();
  }
  _createGraphics(e) {
    let t = e.get("graphics");
    if (!t) {
      t = this._makeGraphics(this.columns, e), e.set("graphics", t), t._setDataItem(e);
      const s = e.get("legendDataItem");
      if (s) {
        const r = s.get("markerRectangle");
        r && r.setAll({ fill: t.get("fill"), stroke: t.get("stroke") });
      }
      this.axisRanges.each((r) => {
        const n = r.container, a = e.get("rangeGraphics", []);
        e.set("rangeGraphics", a);
        const o = this._makeGraphics(r.columns, e);
        a.push(o), o.setPrivate("list", r.columns), n.children.push(o);
      });
    }
  }
  _updateGraphics(e, t) {
    let s = e.get("graphics");
    const r = this._xField, n = this._yField, a = e.get(r), o = e.get(n);
    if (a != null && o != null) {
      const l = this._xOpenField, u = this._yOpenField, c = this.get("locationX", e.get("locationX", 0.5)), h = this.get("locationY", e.get("locationY", 0.5)), d = this.get("openLocationX", e.get("openLocationX", c)), f = this.get("openLocationY", e.get("openLocationY", h)), g = s.get("width"), p = s.get("height"), _ = this.get("stacked"), m = this.get("xAxis"), v = this.get("yAxis"), b = this.get("baseAxis"), y = m.get("start"), x = m.get("end"), D = v.get("start"), A = v.get("end");
      let T, j, C, L, E = this.get("vcy", 1), N = this.get("vcx", 1), q = !1, z = !1;
      if (v.isType("CategoryAxis") && m.isType("CategoryAxis")) {
        let Y = this._aLocationX0 + d - 0.5, W = this._aLocationX1 + c - 0.5;
        if (g instanceof re) {
          let B = (W - Y) * (1 - g.value) / 2;
          Y += B, W -= B;
        }
        if (T = m.getDataItemPositionX(e, l, Y, N), j = m.getDataItemPositionX(e, r, W, N), Y = this._aLocationY0 + f - 0.5, W = this._aLocationY1 + h - 0.5, p instanceof re) {
          let B = (W - Y) * (1 - p.value) / 2;
          Y += B, W -= B;
        }
        C = v.getDataItemPositionY(e, u, Y, E), L = v.getDataItemPositionY(e, n, W, E), e.setRaw("point", { x: T + (j - T) / 2, y: C + (L - C) / 2 });
      } else if (m === b) {
        let Y = this._aLocationX0 + d - 0.5, W = this._aLocationX1 + c - 0.5;
        if (g instanceof re) {
          let B = (W - Y) * (1 - g.value) / 2;
          Y += B, W -= B;
        }
        if (T = m.getDataItemPositionX(e, l, Y, N), j = m.getDataItemPositionX(e, r, W, N), C = v.getDataItemPositionY(e, n, h, E), this._yOpenField !== this._yField)
          L = v.getDataItemPositionY(e, u, f, E);
        else if (_) {
          let B = e.get("stackToItemY");
          B ? L = v.getDataItemPositionY(B, n, f, B.component.get("vcy")) : L = v.basePosition();
        } else
          L = v.basePosition();
        e.setRaw("point", { x: T + (j - T) / 2, y: C }), z = !0;
      } else if (v === b) {
        let Y = this._aLocationY0 + f - 0.5, W = this._aLocationY1 + h - 0.5;
        if (p instanceof re) {
          let B = (W - Y) * (1 - p.value) / 2;
          Y += B, W -= B;
        }
        if (C = v.getDataItemPositionY(e, u, Y, E), L = v.getDataItemPositionY(e, n, W, E), j = m.getDataItemPositionX(e, r, c, N), this._xOpenField !== this._xField)
          T = m.getDataItemPositionX(e, l, d, N);
        else if (_) {
          let B = e.get("stackToItemX");
          B ? T = m.getDataItemPositionX(B, r, d, B.component.get("vcx")) : T = m.basePosition();
        } else
          T = m.basePosition();
        q = !0, e.setRaw("point", { x: j, y: C + (L - C) / 2 });
      }
      this._updateSeriesGraphics(e, s, T, j, C, L, q, z), T < y && j < y || T > x && j > x || C < D && L <= D || C >= A && L > A || $t(T) || $t(C) ? this._toggleColumn(e, !1) : this._toggleColumn(e, !0);
      let H = e.get("rangeGraphics");
      H && w(H, (Y) => {
        this._updateSeriesGraphics(e, Y, T, j, C, L, q, z);
      }), this._applyGraphicsStates(e, t);
    }
  }
  _updateSeriesGraphics(e, t, s, r, n, a, o, l) {
    const u = t.get("width"), c = t.get("height"), h = t.get("maxWidth"), d = t.get("maxHeight"), f = this.getPoint(s, n), g = this.getPoint(r, a), p = e.get("point");
    if (p) {
      const _ = this.getPoint(p.x, p.y);
      p.x = _.x + this._x, p.y = _.y + this._y;
    }
    if (s = f.x, r = g.x, n = f.y, a = g.y, S(u)) {
      const _ = (r - s - u) / 2;
      s += _, r -= _;
    }
    if (S(h) && h < Math.abs(r - s)) {
      const _ = (r - s - h) / 2;
      s += _, r -= _;
    }
    if (S(c)) {
      const _ = (a - n - c) / 2;
      n += _, a -= _;
    }
    if (S(d) && d < Math.abs(a - n)) {
      const _ = (a - n - d) / 2;
      n += _, a -= _;
    }
    this.get("adjustBulletPosition") && (o && (r = Math.min(Math.max(0, r), this._pw), s = Math.min(Math.max(0, s), this._pw)), l && (n = Math.min(Math.max(0, n), this._ph), a = Math.min(Math.max(0, a), this._ph))), e.setRaw("left", s), e.setRaw("right", r), e.setRaw("top", n), e.setRaw("bottom", a), t.setPrivate("width", r - s), t.setPrivate("height", a - n), t.set("x", s), t.set("y", a - (a - n));
  }
  _handleDataSetChange() {
    super._handleDataSetChange(), w(this._dataItems, (e) => {
      this._toggleColumn(e, !1);
    });
  }
  _applyGraphicsStates(e, t) {
    const s = e.get("graphics"), r = s.states.lookup("dropFromOpen"), n = s.states.lookup("riseFromOpen"), a = s.states.lookup("dropFromPrevious"), o = s.states.lookup("riseFromPrevious");
    if (r || a || n || o) {
      const l = this.get("xAxis"), u = this.get("yAxis"), c = this.get("baseAxis");
      let h, d, f;
      c === l && u.isType("ValueAxis") ? (h = e.get(this._yOpenField), d = e.get(this._yField), f = t.get(this._yField)) : c === u && l.isType("ValueAxis") && (h = e.get(this._xOpenField), d = e.get(this._xField), f = t.get(this._xField)), S(h) && S(d) && (d < h ? r && r.apply() : n && n.apply(), S(f) && (d < f ? a && a.apply() : o && o.apply()));
    }
  }
  /**
   * @ignore
   */
  disposeDataItem(e) {
    super.disposeDataItem(e);
    const t = e.get("graphics");
    t && (this.columns.removeValue(t), t.dispose());
    const s = e.get("rangeGraphics");
    s && w(s, (r) => {
      const n = r.getPrivate("list");
      n && n.removeValue(r), r.dispose();
    });
  }
  /**
   * Hides series's data item.
   *
   * @param   dataItem  Data item
   * @param   duration  Animation duration in milliseconds
   * @return            Promise
   */
  hideDataItem(e, t) {
    const s = Object.create(null, {
      hideDataItem: { get: () => super.hideDataItem }
    });
    return at(this, void 0, void 0, function* () {
      const r = [s.hideDataItem.call(this, e, t)], n = e.get("graphics");
      n && r.push(n.hide(t));
      const a = e.get("rangeGraphics");
      a && w(a, (o) => {
        r.push(o.hide(t));
      }), yield Promise.all(r);
    });
  }
  _toggleColumn(e, t) {
    const s = e.get("graphics");
    s && s.setPrivate("visible", t);
    const r = e.get("rangeGraphics");
    r && w(r, (a) => {
      a.setPrivate("visible", t);
    });
    const n = e.bullets;
    n && w(n, (a) => {
      a.setPrivate("hidden", !t);
    });
  }
  /**
   * Shows series's data item.
   *
   * @param   dataItem  Data item
   * @param   duration  Animation duration in milliseconds
   * @return            Promise
   */
  showDataItem(e, t) {
    const s = Object.create(null, {
      showDataItem: { get: () => super.showDataItem }
    });
    return at(this, void 0, void 0, function* () {
      const r = [s.showDataItem.call(this, e, t)], n = e.get("graphics");
      n && r.push(n.show(t));
      const a = e.get("rangeGraphics");
      a && w(a, (o) => {
        r.push(o.show(t));
      }), yield Promise.all(r);
    });
  }
  /**
   * @ignore
   */
  updateLegendMarker(e) {
    let t = this.get("legendDataItem");
    if (this.get("useLastColorForLegendMarker") && !e) {
      const s = this.dataItems[this.endIndex() - 1];
      s && (e = s);
    }
    if (t) {
      let s = this.columns.template;
      if (e) {
        let n = e.get("graphics");
        n && (s = n);
      }
      const r = t.get("markerRectangle");
      r && (t.get("itemContainer").get("disabled") || w(H0, (n) => {
        r.set(n, s.get(n, this.get(n)));
      }));
    }
  }
  _getTooltipTarget(e) {
    if (this.get("seriesTooltipTarget") == "bullet")
      return super._getTooltipTarget(e);
    let t = e.get("graphics");
    return t || this;
  }
}
Object.defineProperty(Hi, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "BaseColumnSeries"
});
Object.defineProperty(Hi, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Bi.classNames.concat([Hi.className])
});
class zi extends Ni {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_series", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "_isPanning", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "labelsContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.children.push(Z.new(this._root, {}))
    }), Object.defineProperty(this, "gridContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Z.new(this._root, { width: R, height: R })
    }), Object.defineProperty(this, "topGridContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Z.new(this._root, { width: R, height: R })
    }), Object.defineProperty(this, "bulletsContainer", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.children.push(Z.new(this._root, { isMeasured: !1, width: R, height: R, position: "absolute" }))
    }), Object.defineProperty(this, "chart", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_rangesDirty", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_panStart", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_panEnd", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), Object.defineProperty(this, "_sAnimation", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_eAnimation", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_skipSync", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "axisRanges", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new lr()
    }), Object.defineProperty(this, "_seriesAxisRanges", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    }), Object.defineProperty(this, "ghostLabel", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_cursorPosition", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: -1
    }), Object.defineProperty(this, "_snapToSeries", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_seriesValuesDirty", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "axisHeader", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.children.push(Z.new(this._root, {
        themeTags: ["axis", "header"],
        position: "absolute",
        background: pt.new(this._root, {
          themeTags: ["header", "background"],
          fill: this._root.interfaceColors.get("background")
        })
      }))
    }), Object.defineProperty(this, "_bullets", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    });
  }
  _dispose() {
    this.gridContainer.dispose(), this.topGridContainer.dispose(), this.bulletsContainer.dispose(), this.labelsContainer.dispose(), this.axisHeader.dispose(), super._dispose();
  }
  _afterNew() {
    super._afterNew(), this.setPrivate("updateScrollbar", !0), this._disposers.push(this.axisRanges.events.onAll((t) => {
      if (t.type === "clear")
        w(t.oldValues, (s) => {
          this.disposeDataItem(s);
        });
      else if (t.type === "push")
        this._processAxisRange(t.newValue, ["range"]);
      else if (t.type === "setIndex")
        this._processAxisRange(t.newValue, ["range"]);
      else if (t.type === "insertIndex")
        this._processAxisRange(t.newValue, ["range"]);
      else if (t.type === "removeIndex")
        this.disposeDataItem(t.oldValue);
      else if (t.type === "moveIndex")
        this._processAxisRange(t.value, ["range"]);
      else
        throw new Error("Unknown IStreamEvent type");
    }));
    const e = this.get("renderer");
    e && (e.axis = this, e.processAxis()), this.children.push(e), this.ghostLabel = e.makeLabel(new Gt(this, void 0, {}), []), this.ghostLabel.adapters.disable("text"), this.ghostLabel.setAll({ opacity: 0, tooltipText: void 0, tooltipHTML: void 0, interactive: !1 }), this.ghostLabel.events.disable();
  }
  _updateFinals(e, t) {
  }
  /**
   * Zooms the axis to relative locations.
   *
   * Both `start` and `end` are relative: 0 means start of the axis, 1 - end.
   *
   * @param   start     Relative start
   * @param   end       Relative end
   * @param   duration  Duration of the zoom animation in milliseconds
   * @return            Zoom animation
   */
  zoom(e, t, s, r) {
    if (this._updateFinals(e, t), this.get("start") !== e || this.get("end") != t) {
      let n = this._sAnimation, a = this._eAnimation, o = this.get("maxDeviation", 0.5) * Math.min(1, t - e);
      e < -o && (e = -o), t > 1 + o && (t = 1 + o), e > t && ([e, t] = [t, e]), S(s) || (s = this.get("interpolationDuration", 0)), r || (r = "end");
      let l = this.getPrivate("maxZoomFactor", this.get("maxZoomFactor", 100)), u = l;
      t === 1 && e !== 0 && (e < this.get("start") ? r = "start" : r = "end"), e === 0 && t !== 1 && (t > this.get("end") ? r = "end" : r = "start");
      let c = this.get("minZoomCount"), h = this.get("maxZoomCount");
      S(c) && (l = u / c);
      let d = 1;
      if (S(h) && (d = u / h), r === "start" ? (h > 0 && 1 / (t - e) < d && (t = e + 1 / d), 1 / (t - e) > l && (t = e + 1 / l), t > 1 && t - e < 1 / l && (e = t - 1 / l)) : (h > 0 && 1 / (t - e) < d && (e = t - 1 / d), 1 / (t - e) > l && (e = t - 1 / l), e < 0 && t - e < 1 / l && (t = e + 1 / l)), 1 / (t - e) > l && (t = e + 1 / l), 1 / (t - e) > l && (e = t - 1 / l), h != null && c != null && e == this.get("start") && t == this.get("end")) {
        const f = this.chart;
        f && f._handleAxisSelection(this, !0);
      }
      if ((n && n.playing && n.to == e || this.get("start") == e) && (a && a.playing && a.to == t || this.get("end") == t))
        return;
      if (s > 0) {
        let f = this.get("interpolationEasing"), g, p;
        if (this.get("start") != e && (g = this.animate({ key: "start", to: e, duration: s, easing: f })), this.get("end") != t && (p = this.animate({ key: "end", to: t, duration: s, easing: f })), this._sAnimation = g, this._eAnimation = p, g)
          return g;
        if (p)
          return p;
      } else
        this.set("start", e), this.set("end", t), this._root.events.once("frameended", () => {
          this._markDirtyKey("start"), this._root._markDirty();
        });
    } else
      this._sAnimation && this._sAnimation.stop(), this._eAnimation && this._eAnimation.stop();
  }
  /**
   * A list of series using this axis.
   *
   * @return Series
   */
  get series() {
    return this._series;
  }
  _processAxisRange(e, t) {
    e.setRaw("isRange", !0), this._createAssets(e, t), this._rangesDirty = !0, this._prepareDataItem(e);
    const s = e.get("above"), r = this.topGridContainer, n = e.get("grid");
    s && n && r.children.moveValue(n);
    const a = e.get("axisFill");
    s && a && r.children.moveValue(a);
  }
  _prepareDataItem(e, t) {
  }
  /**
   * @ignore
   */
  markDirtyExtremes() {
  }
  /**
   * @ignore
   */
  markDirtySelectionExtremes() {
  }
  _calculateTotals() {
  }
  _updateAxisRanges() {
    this._bullets = {}, this.axisRanges.each((e) => {
      this._prepareDataItem(e);
    }), w(this._seriesAxisRanges, (e) => {
      this._prepareDataItem(e);
    });
  }
  _prepareChildren() {
    if (super._prepareChildren(), this.get("fixAxisSize") ? this.ghostLabel.set("visible", !0) : this.ghostLabel.set("visible", !1), this.isDirty("start") || this.isDirty("end")) {
      this.chart._updateCursor();
      let t = this.get("start", 0), s = this.get("end", 1), r = this.get("maxDeviation", 0.5) * Math.min(1, s - t);
      if (t < -r) {
        let n = t + r;
        t = -r, this.setRaw("start", t), this.isDirty("end") && this.setRaw("end", s - n);
      }
      if (s > 1 + r) {
        let n = s - 1 - r;
        s = 1 + r, this.setRaw("end", s), this.isDirty("start") && this.setRaw("start", t - n);
      }
    }
    const e = this.get("renderer");
    if (e._start = this.get("start"), e._end = this.get("end"), e._inversed = e.get("inversed", !1), e._axisLength = e.axisLength() / (e._end - e._start), e._updateLC(), this.isDirty("tooltip")) {
      const t = this.get("tooltip");
      if (t) {
        const s = e.get("themeTags");
        t.addTag("axis"), t.addTag(this.className.toLowerCase()), t._applyThemes(), s && (t.set("themeTags", ie(t.get("themeTags"), s)), t.label._applyThemes());
      }
    }
  }
  _updateTooltipBounds() {
    const e = this.get("tooltip");
    e && this.get("renderer").updateTooltipBounds(e);
  }
  _updateBounds() {
    super._updateBounds(), this._updateTooltipBounds();
  }
  /**
   * @ignore
   */
  processChart(e) {
    this.chart = e;
    const t = this.get("renderer");
    t.chart = e, e.gridContainer.children.push(this.gridContainer), e.topGridContainer.children.push(this.topGridContainer), e.axisHeadersContainer.children.push(this.axisHeader), this.on("start", () => {
      e._handleAxisSelection(this);
    }), this.on("end", () => {
      e._handleAxisSelection(this);
    }), e.plotContainer.onPrivate("width", () => {
      this.markDirtySize();
    }), e.plotContainer.onPrivate("height", () => {
      this.markDirtySize();
    }), e.processAxis(this);
  }
  /**
   * @ignore
   */
  hideDataItem(e) {
    return this._toggleDataItem(e, !1), super.hideDataItem(e);
  }
  /**
   * @ignore
   */
  showDataItem(e) {
    return this._toggleDataItem(e, !0), super.showDataItem(e);
  }
  _toggleDataItem(e, t) {
    const s = e.get("label");
    s && s.setPrivate("visible", t);
    const r = e.get("grid");
    r && r.setPrivate("visible", t);
    const n = e.get("tick");
    n && n.setPrivate("visible", t);
    const a = e.get("axisFill");
    a && a.setPrivate("visible", t);
    const o = e.get("bullet");
    if (o) {
      const l = o.get("sprite");
      l && l.setPrivate("visible", t);
    }
  }
  _createAssets(e, t) {
    const s = this.get("renderer");
    e.get("label") || s.makeLabel(e, t), e.get("grid") || s.makeGrid(e, t), e.get("tick") || s.makeTick(e, t), e.get("axisFill") || s.makeAxisFill(e, t), this._processBullet(e);
  }
  _processBullet(e) {
    let t = e.get("bullet"), s = this.get("bullet");
    if (!t && s && !e.get("isRange") && (t = s(this._root, this, e)), t) {
      t.axis = this;
      const r = t.get("sprite");
      r && (r._setDataItem(e), e.setRaw("bullet", t), r.parent || this.bulletsContainer.children.push(r));
    }
  }
  _afterChanged() {
    super._afterChanged();
    const e = this.chart;
    e && (e._updateChartLayout(), e.axisHeadersContainer.markDirtySize()), this.get("renderer")._updatePositions();
  }
  /**
   * @ignore
   */
  disposeDataItem(e) {
    super.disposeDataItem(e);
    const t = this.get("renderer"), s = e.get("label");
    s && (t.labels.removeValue(s), s.dispose());
    const r = e.get("tick");
    r && (t.ticks.removeValue(r), r.dispose());
    const n = e.get("grid");
    n && (t.grid.removeValue(n), n.dispose());
    const a = e.get("axisFill");
    a && (t.axisFills.removeValue(a), a.dispose());
    const o = e.get("bullet");
    o && o.dispose();
  }
  _updateGhost() {
    this.setPrivate("cellWidth", this.getCellWidthPosition() * this.get("renderer").axisLength());
    const e = this.ghostLabel;
    if (!e.isHidden()) {
      const r = e.localBounds(), n = r.right - r.left;
      let a = e.get("text");
      w(this.dataItems, (o) => {
        const l = o.get("label");
        if (l && !l.isHidden()) {
          const u = l.localBounds();
          u.right - u.left > n && (a = l.text._getText());
        }
      }), e.set("text", a);
    }
    let t = this.get("start", 0), s = this.get("end", 1);
    this.get("renderer").updateLabel(e, t + (s - t) * 0.5);
  }
  _handleCursorPosition(e, t) {
    e = this.get("renderer").toAxisPosition(e), this._cursorPosition = e, this._snapToSeries = t, this.updateTooltip();
  }
  /**
   * Can be called when axis zoom changes and you need to update tooltip
   * position.
   */
  updateTooltip() {
    const e = this._snapToSeries;
    let t = this._cursorPosition;
    const s = this.get("tooltip"), r = this.get("renderer");
    S(t) && (w(this.series, (n) => {
      if (n.get("baseAxis") === this) {
        const a = this.getSeriesItem(n, t, this.get("tooltipLocation"));
        n.setRaw("tooltipDataItem", a), e && e.indexOf(n) != -1 ? (n.updateLegendMarker(a), n.updateLegendValue(a)) : n.showDataItemTooltip(a);
      }
    }), s && (r.updateTooltipBounds(s), this.get("snapTooltip") && (t = this.roundAxisPosition(t, this.get("tooltipLocation", 0.5))), $t(t) ? s.hide(0) : (this.setPrivateRaw("tooltipPosition", t), this._updateTooltipText(s, t), r.positionTooltip(s, t), t < this.get("start") || t > this.get("end") ? s.hide(0) : s.show(0))));
  }
  _updateTooltipText(e, t) {
    e.label.set("text", this.getTooltipText(t));
  }
  /**
   * @ignore
   */
  roundAxisPosition(e, t) {
    return e;
  }
  /**
   * @ignore
   */
  handleCursorShow() {
    let e = this.get("tooltip");
    e && e.show();
  }
  /**
   * @ignore
   */
  handleCursorHide() {
    let e = this.get("tooltip");
    e && e.hide();
  }
  /**
   * @ignore
   */
  processSeriesDataItem(e, t) {
  }
  _clearDirty() {
    super._clearDirty(), this._sizeDirty = !1, this._rangesDirty = !1;
  }
  /**
   * Converts pixel coordinate to a relative position on axis.
   *
   * @param   coordinate  Coordinate
   * @return              Relative position
   */
  coordinateToPosition(e) {
    const t = this.get("renderer");
    return t.toAxisPosition(e / t.axisLength());
  }
  /**
   * Converts relative position of the plot area to relative position of the
   * axis with zoom taken into account.
   *
   * @param position Position
   * @return Relative position
   */
  toAxisPosition(e) {
    return this.get("renderer").toAxisPosition(e);
  }
  /**
   * Adjusts position with inversed taken into account.
   *
   * @ignore
   */
  fixPosition(e) {
    return this.get("renderer").fixPosition(e);
  }
  /**
   * @ignore
   */
  shouldGap(e, t, s, r) {
    return !1;
  }
  /**
   * Creates and returns an axis range object.
   *
   * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/axis-ranges/} for more info
   * @param   axisDataItem  Axis data item
   * @return                Axis range
   */
  createAxisRange(e) {
    return this.axisRanges.push(e);
  }
  /**
   * @ignore
   */
  _groupSeriesData(e) {
  }
  /**
   * Returns relative position between two grid lines of the axis.
   *
   * @return Position
   */
  getCellWidthPosition() {
    return 0.05;
  }
}
Object.defineProperty(zi, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Axis"
});
Object.defineProperty(zi, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Ni.classNames.concat([zi.className])
});
class mi extends zi {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_frequency", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), Object.defineProperty(this, "_itemMap", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    });
  }
  _afterNew() {
    this._settings.themeTags = ie(this._settings.themeTags, ["axis"]), this.fields.push("category"), this.setPrivateRaw("name", "category"), this.addTag("category"), super._afterNew();
  }
  _prepareChildren() {
    super._prepareChildren();
    const e = this.dataItems.length;
    let t = 0;
    this._valuesDirty && (this._itemMap = {}, w(this.dataItems, (s) => {
      s.setRaw("index", t), this._itemMap[s.get("category")] = s, t++;
    }), this.setPrivateRaw("maxZoomFactor", e)), this.setPrivateRaw("startIndex", Math.max(Math.round(this.get("start", 0) * e), 0)), this.setPrivateRaw("endIndex", Math.min(Math.round(this.get("end", 1) * e), e)), (this._sizeDirty || this._valuesDirty || this.isDirty("start") || this.isDirty("end") || this.isPrivateDirty("endIndex") || this.isPrivateDirty("startIndex") || this.isPrivateDirty("width") || this.isPrivateDirty("height")) && this.dataItems.length > 0 && (this._handleRangeChange(), this._prepareAxisItems(), this._updateAxisRanges());
  }
  _handleRangeChange() {
    w(this.series, (e) => {
      let t = this.dataItems[this.startIndex()].get("category"), s = this.dataItems[this.endIndex() - 1].get("category"), r = e.get("baseAxis"), n = e.get("xAxis"), a = e.get("yAxis");
      if (n instanceof mi && a instanceof mi)
        e._markDirtyAxes();
      else if (r === this) {
        let o, l, u = a;
        if (n === r ? (e.get("categoryXField") && (o = "categoryX"), e.get("openCategoryXField") && (l = "openCategoryX")) : a === r && (e.get("categoryYField") && (o = "categoryY"), e.get("openCategoryYField") && (l = "openCategoryY"), u = n), u.className == "ValueAxis" && (o || l)) {
          let c, h;
          for (let p = 0, _ = e.dataItems.length; p < _; p++) {
            let m = e.dataItems[p];
            if (o && m.get(o) === t) {
              c = m;
              break;
            }
            if (l && m.get(l) === t) {
              c = m;
              break;
            }
          }
          for (let p = e.dataItems.length - 1; p >= 0; p--) {
            let _ = e.dataItems[p];
            if (o && _.get(o) === s) {
              h = _;
              break;
            }
            if (l && _.get(l) === s) {
              h = _;
              break;
            }
          }
          let d = 0, f = e.dataItems.length;
          c && (d = e.dataItems.indexOf(c)), h && (f = e.dataItems.indexOf(h) + 1), e.setPrivate("startIndex", d), e.setPrivate("endIndex", f);
          let g = !1;
          for (let p = d; p < f; p++) {
            const _ = e.dataItems[p];
            if (w(e.__valueXShowFields, (m) => {
              _.get(m) != null && (g = !0);
            }), w(e.__valueYShowFields, (m) => {
              _.get(m) != null && (g = !0);
            }), g)
              break;
          }
          e.setPrivate("outOfSelection", !g);
        }
        e._markDirtyAxes();
      }
    });
  }
  _prepareAxisItems() {
    const e = this.get("renderer"), t = this.dataItems.length;
    let s = this.startIndex();
    s > 0 && s--;
    let r = this.endIndex();
    r < t && r++;
    let n = e.axisLength() / Math.max(e.get("minGridDistance"), 1 / Number.MAX_SAFE_INTEGER), a = Math.max(1, Math.min(t, Math.ceil((r - s) / n)));
    s = Math.floor(s / a) * a, this._frequency = a;
    for (let l = 0; l < t; l++)
      this.dataItems[l].hide();
    let o = this.dataItems[s].get("index", 0);
    for (let l = s; l < r; l = l + a) {
      let u = this.dataItems[l];
      this._createAssets(u, []), u.isHidden() && u.show(), this._prepareDataItem(u, o, a), o++;
    }
    this._updateGhost();
  }
  _prepareDataItem(e, t, s) {
    let r = this.get("renderer"), n = e.get("categoryLocation", 0), a = e.get("endCategoryLocation", 1), o = e.get("index");
    S(o) || (o = this.categoryToIndex(e.get("category")));
    let l = this.indexToPosition(o, n), u = e.get("endCategory"), c;
    u ? (c = this.categoryToIndex(u), S(c) || (c = o)) : c = o;
    let h = this.indexToPosition(c, a), d, f;
    e.get("isRange") ? d = c : d = o + this._frequency - 1, f = this.indexToPosition(d, a), r.updateLabel(e.get("label"), l, h, s), r.updateGrid(e.get("grid"), l, h), r.updateTick(e.get("tick"), l, h, s), r.updateFill(e.get("axisFill"), l, f), this._processBullet(e), r.updateBullet(e.get("bullet"), l, h);
    const g = this.get("fillRule");
    g && g(e, t);
  }
  startIndex() {
    let e = this.dataItems.length;
    return Math.min(Math.max(this.getPrivate("startIndex", 0), 0), e - 1);
  }
  endIndex() {
    let e = this.dataItems.length;
    return Math.max(1, Math.min(this.getPrivate("endIndex", e), e));
  }
  /**
   * @ignore
   */
  baseValue() {
  }
  /**
   * @ignore
   */
  basePosition() {
    return 0;
  }
  /**
   * Returns X coordinate in pixels corresponding to specific category index.
   *
   * @param   value  Index
   * @return         X coordinate
   */
  getX(e) {
    let t = this._itemMap[e];
    return t ? this._settings.renderer.positionToCoordinate(this.indexToPosition(t.get("index", 0))) : NaN;
  }
  /**
   * Returns Y coordinate in pixels corresponding to specific category index.
   *
   * @param   value  Index
   * @return         Y coordinate
   */
  getY(e) {
    let t = this._itemMap[e];
    return t ? this._settings.renderer.positionToCoordinate(this.indexToPosition(t.get("index", 0))) : NaN;
  }
  /**
   * @ignore
   */
  getDataItemPositionX(e, t, s, r) {
    const n = e.get(t), a = this._itemMap[n];
    return a ? this.indexToPosition(a.get("index", 0), s) : NaN;
  }
  /**
   * @ignore
   */
  getDataItemCoordinateX(e, t, s, r) {
    return this._settings.renderer.positionToCoordinate(this.getDataItemPositionX(e, t, s, r));
  }
  /**
   * @ignore
   */
  getDataItemPositionY(e, t, s, r) {
    const n = e.get(t), a = this._itemMap[n];
    return a ? this.indexToPosition(a.get("index", 0), s) : NaN;
  }
  /**
   * @ignore
   */
  getDataItemCoordinateY(e, t, s, r) {
    return this._settings.renderer.positionToCoordinate(this.getDataItemPositionY(e, t, s, r));
  }
  /**
   * Converts category index to a relative position.
   *
   * `location` indicates relative position within category: 0 - start, 1 - end.
   *
   * If not set, will use middle (0.5) of the category.
   *
   * @param   index     Index
   * @param   location  Location
   * @return            Index
   */
  indexToPosition(e, t) {
    S(t) || (t = 0.5);
    let s = this.dataItems.length, r = this.get("startLocation", 0), n = this.get("endLocation", 1);
    s -= r, s -= 1 - n;
    let a = (e + t - r) / s, o = this.dataItems[e];
    return o && (a += o.get("deltaPosition", 0)), a;
  }
  /**
   * Returns an index of a category.
   *
   * @param   category  Category to look up
   * @return            Index
   */
  categoryToIndex(e) {
    let t = this._itemMap[e];
    return t ? t.get("index") : NaN;
  }
  /**
   * @ignore
   */
  dataItemToPosition(e) {
    return this.indexToPosition(e.get("index"));
  }
  /**
   * @ignore
   */
  roundAxisPosition(e, t) {
    return e += (0.5 - t) / this.dataItems.length, this.indexToPosition(this.axisPositionToIndex(e), t);
  }
  /**
   * Returns an index of the category that corresponds to specific pixel
   * position within axis.
   *
   * @param position  Position (px)
   * @return Category index
   */
  axisPositionToIndex(e) {
    let t = this.dataItems.length;
    return Ie(Math.floor(e * t), 0, t - 1);
  }
  /**
   * Returns text to be used in an axis tooltip for specific relative position.
   *
   * @param   position  Position
   * @return            Tooltip text
   */
  getTooltipText(e) {
    const t = this.dataItems[this.axisPositionToIndex(e)];
    if (t) {
      const s = t.get("label");
      if (s)
        return $r(s, this.get("tooltipText", ""));
    }
  }
  _updateTooltipText(e, t) {
    e._setDataItem(this.dataItems[this.axisPositionToIndex(t)]), e.label.text.markDirtyText();
  }
  /**
   * Returns a data item from series that is closest to the `position`.
   *
   * @param   series    Series
   * @param   position  Relative position
   * @return            Data item
   */
  getSeriesItem(e, t) {
    if (this.dataItems.length > 0) {
      let s = this.getPrivate("name") + this.get("renderer").getPrivate("letter"), r = this.axisPositionToIndex(t), n = e.dataItems[r], a = this.dataItems[r], o = a.get("category");
      if (n && a && n.get(s) === o)
        return n;
      for (let l = 0, u = e.dataItems.length; l < u; l++) {
        let c = e.dataItems[l];
        if (c.get(s) === o)
          return c;
      }
    }
  }
  /**
   * Zooms the axis to specific `start` and `end` indexes.
   *
   * Optional `duration` specifies duration of zoom animation in milliseconds.
   *
   * @param  start     Start index
   * @param  end       End index
   * @param  duration  Duration in milliseconds
   */
  zoomToIndexes(e, t, s) {
    let r = this.dataItems.length;
    this.zoom(e / r, t / r, s);
  }
  zoomToCategories(e, t, s) {
    this.zoomToIndexes(this.categoryToIndex(e), this.categoryToIndex(t) + 1, s);
  }
  /**
   * Returns position span between start and end of a single cell in axis.
   *
   * @since 5.2.30
   * @return Position
   */
  getCellWidthPosition() {
    return this._frequency / this.dataItems.length / (this.get("end", 1) - this.get("start", 0));
  }
}
Object.defineProperty(mi, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "CategoryAxis"
});
Object.defineProperty(mi, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: zi.classNames.concat([mi.className])
});
class _a extends mi {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_frequency", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), Object.defineProperty(this, "_itemMap", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    });
  }
  _afterNew() {
    this._settings.themeTags = ie(this._settings.themeTags, ["axis"]), this.fields.push("category"), super._afterNew();
  }
  _prepareAxisItems() {
    this.setPrivateRaw("baseInterval", this.get("baseInterval"));
    const e = this.get("renderer"), t = this.dataItems.length;
    let s = this.startIndex();
    s > 0 && s--;
    let r = this.endIndex();
    r < t && r++;
    let n = e.axisLength() / Math.max(e.get("minGridDistance"), 1 / Number.MAX_SAFE_INTEGER), a = Math.min(t, Math.ceil((r - s) / n));
    s = Math.floor(s / a) * a, this._frequency = a;
    for (let y = 0; y < t; y++)
      this.dataItems[y].hide();
    let o = Number(this.dataItems[s].get("category")), l = Number(this.dataItems[r - 1].get("category")), u = l - o;
    r - s < n && (u = l - o - ((l - o) / this.baseDuration() - (r - s)) * this.baseDuration());
    let c = Us(0, u, n, this.get("gridIntervals"));
    const h = nn(c.timeUnit), d = this.getPrivate("baseInterval");
    kt(c) < this.baseDuration() && (c = Object.assign({}, d));
    const f = this.get("dateFormats");
    let g = -1 / 0, p = -1 / 0, _ = -1 / 0, m, v = [], b = !1;
    for (let y = s; y < r; y++) {
      let x = this.dataItems[y], D = x.get("index"), A = !1, T = Number(x.get("category")), j = new Date(T), C = Ld(j, c.timeUnit);
      m = f[c.timeUnit];
      let L = !1;
      c.timeUnit != "year" && c.timeUnit != "week" && h && this.get("markUnitChange") && S(g) && an(T, g, h, this._root.utc) && (m = this.get("periodChangeDateFormats")[c.timeUnit], D - a * 0.5 < p && v.pop(), v.push({ format: m, dataItem: x }), b = !0, L = !0, p = D, _ = C);
      let E = !1;
      c.timeUnit === "day" || c.timeUnit === "week" ? D - p >= a && (E = !0) : C % c.count === 0 && C != _ && (E = !0), !L && E && (D - a * 0.7 < p && b && (A = !0), A || (v.push({ format: m, dataItem: x }), p = D, _ = C), b = !1), g = T;
    }
    if (v.length > 0) {
      let y = v[0].dataItem.get("index", 0);
      w(v, (x) => {
        const D = x.dataItem, A = x.format;
        this._createAssets(D, []), D.isHidden() && D.show();
        let T = Number(D.get("category")), j = new Date(T);
        const C = D.get("label");
        C && C.set("text", this._root.dateFormatter.format(j, A)), y++, this._prepareDataItem(D, y, a);
      });
    }
  }
  /**
   * Returns a duration of currently active `baseInterval` in milliseconds.
   *
   * @return Duration
   */
  baseDuration() {
    return kt(this.getPrivate("baseInterval"));
  }
  /**
   * Returns text to be used in an axis tooltip for specific relative position.
   *
   * @param   position  Position
   * @return            Tooltip text
   */
  getTooltipText(e) {
    let t = this.dataItems[this.axisPositionToIndex(e)];
    if (t) {
      let s = this.get("dateFormats")[this.getPrivate("baseInterval").timeUnit];
      return this._root.dateFormatter.format(new Date(t.get("category", 0)), this.get("tooltipDateFormat", s));
    }
  }
  _updateTooltipText(e, t) {
    e.label.set("text", this.getTooltipText(t));
  }
}
Object.defineProperty(_a, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "CategoryDateAxis"
});
Object.defineProperty(_a, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: mi.classNames.concat([_a.className])
});
class Xi extends zi {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_dirtyExtremes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_dirtySelectionExtremes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_deltaMinMax", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), Object.defineProperty(this, "_minReal", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_maxReal", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_baseValue", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_syncDp", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_minLogAdjusted", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    });
  }
  /**
   * @ignore
   */
  markDirtyExtremes() {
    this._dirtyExtremes = !0, this.markDirty();
  }
  /**
   * @ignore
   */
  markDirtySelectionExtremes() {
    this._dirtySelectionExtremes = !0, this.markDirty();
  }
  _afterNew() {
    this._settings.themeTags = ie(this._settings.themeTags, ["axis"]), this.setPrivateRaw("name", "value"), this.addTag("value"), super._afterNew();
  }
  _prepareChildren() {
    if (super._prepareChildren(), this.isDirty("syncWithAxis")) {
      this._prevSettings.syncWithAxis && this._syncDp && this._syncDp.dispose();
      let t = this.get("syncWithAxis");
      t && (this._syncDp = new st([
        t.onPrivate("selectionMinFinal", () => {
          this._dirtySelectionExtremes = !0;
        }),
        t.onPrivate("selectionMaxFinal", () => {
          this._dirtySelectionExtremes = !0;
        })
      ]));
    }
    (this._sizeDirty || this._dirtyExtremes || this._valuesDirty || this.isPrivateDirty("width") || this.isPrivateDirty("height") || this.isDirty("min") || this.isDirty("max") || this.isDirty("extraMin") || this.isDirty("extraMax") || this.isDirty("logarithmic") || this.isDirty("treatZeroAs") || this.isDirty("baseValue") || this.isDirty("strictMinMax") || this.isDirty("strictMinMaxSelection") || this.isDirty("maxPrecision") || this.isDirty("numberFormat")) && (this._getMinMax(), this.ghostLabel.set("text", ""), this._dirtyExtremes = !1), this._dirtySelectionExtremes && !this._isPanning && this.get("autoZoom", !0) && (this._getSelectionMinMax(), this._dirtySelectionExtremes = !1), this._groupData(), (this._sizeDirty || this._valuesDirty || this.isDirty("start") || this.isDirty("end") || this.isPrivateDirty("min") || this.isPrivateDirty("selectionMax") || this.isPrivateDirty("selectionMin") || this.isPrivateDirty("max") || this.isPrivateDirty("step") || this.isPrivateDirty("width") || this.isPrivateDirty("height") || this.isDirty("logarithmic")) && (this._handleRangeChange(), this._prepareAxisItems(), this._updateAxisRanges()), this._baseValue = this.baseValue();
  }
  _groupData() {
  }
  _formatText(e) {
    const t = this.get("numberFormat"), s = this.getNumberFormatter();
    let r = "";
    return t ? r = s.format(e, t) : r = s.format(e, void 0, this.getPrivate("stepDecimalPlaces")), r;
  }
  _prepareAxisItems() {
    const e = this.getPrivate("min"), t = this.getPrivate("max");
    if (S(e) && S(t)) {
      const s = this.get("logarithmic"), r = this.getPrivate("step"), n = this.getPrivate("selectionMin"), a = this.getPrivate("selectionMax") + r;
      let o = n - r, l = 0, u = 1, c = e;
      if (s) {
        if (o = this._minLogAdjusted, o < n)
          for (; o < n; )
            o += r;
        c = o, c <= 0 && (c = 1, r < 1 && (c = r)), u = Math.log(a - r) * Math.LOG10E - Math.log(c) * Math.LOG10E, u > 2 && (o = Math.pow(10, Math.log(c) * Math.LOG10E - 5));
      }
      let h = -1 / 0;
      for (; o < a; ) {
        let d;
        this.dataItems.length < l + 1 ? (d = new Gt(this, void 0, {}), this._dataItems.push(d), this.processDataItem(d)) : d = this.dataItems[l], this._createAssets(d, []), d.isHidden() && d.show(), d.setRaw("value", o);
        const f = d.get("label");
        if (f && f.set("text", this._formatText(o)), this._prepareDataItem(d), s && u > 2 ? o = Math.pow(10, Math.log(c) * Math.LOG10E + l - 5) : o += r, h == o)
          break;
        let g = Math.pow(10, Math.floor(Math.log(Math.abs(r)) * Math.LOG10E));
        if (g < 1) {
          let p = Math.round(Math.abs(Math.log(Math.abs(g)) * Math.LOG10E)) + 2;
          o = qe(o, p);
        }
        l++, h = o;
      }
      for (let d = l; d < this.dataItems.length; d++)
        this.dataItems[d].hide();
      w(this.series, (d) => {
        d.inited && d._markDirtyAxes();
      }), this._updateGhost();
    }
  }
  _prepareDataItem(e, t) {
    let s = this.get("renderer"), r = e.get("value"), n = e.get("endValue"), a = this.valueToPosition(r), o = a, l = this.valueToPosition(r + this.getPrivate("step"));
    S(n) && (o = this.valueToPosition(n), l = o), e.get("isRange") && n == null && (l = a), s.updateLabel(e.get("label"), a, o, t);
    const u = e.get("grid");
    if (s.updateGrid(u, a, o), u && (r == this.get("baseValue", 0) ? (u.addTag("base"), u._applyThemes()) : u.hasTag("base") && (u.removeTag("base"), u._applyThemes())), s.updateTick(e.get("tick"), a, o, t), s.updateFill(e.get("axisFill"), a, l), this._processBullet(e), s.updateBullet(e.get("bullet"), a, o), !e.get("isRange")) {
      const c = this.get("fillRule");
      c && c(e);
    }
  }
  _handleRangeChange() {
    let e = this.positionToValue(this.get("start", 0)), t = this.positionToValue(this.get("end", 1));
    const s = this.get("renderer").gridCount();
    let r = this._adjustMinMax(e, t, s, !0), n = qc(r.step);
    this.setPrivateRaw("stepDecimalPlaces", n), e = qe(e, n), t = qe(t, n), r = this._adjustMinMax(e, t, s, !0);
    let a = r.step;
    e = r.min, t = r.max, (this.getPrivate("selectionMin") !== e || this.getPrivate("selectionMax") !== t || this.getPrivate("step") !== a) && (this.setPrivateRaw("selectionMin", e), this.setPrivateRaw("selectionMax", t), this.setPrivateRaw("step", a));
  }
  /**
   * Converts a relative position to a corresponding numeric value from axis
   * scale.
   *
   * @param   position  Relative position
   * @return            Value
   */
  positionToValue(e) {
    const t = this.getPrivate("min"), s = this.getPrivate("max");
    return this.get("logarithmic") ? Math.pow(Math.E, (e * (Math.log(s) * Math.LOG10E - Math.log(t) * Math.LOG10E) + Math.log(t) * Math.LOG10E) / Math.LOG10E) : e * (s - t) + t;
  }
  /**
   * Convers value to a relative position on axis.
   *
   * @param   value  Value
   * @return         Relative position
   */
  valueToPosition(e) {
    const t = this.getPrivate("min"), s = this.getPrivate("max");
    if (this.get("logarithmic")) {
      if (e <= 0) {
        let r = this.get("treatZeroAs");
        S(r) && (e = r);
      }
      return (Math.log(e) * Math.LOG10E - Math.log(t) * Math.LOG10E) / (Math.log(s) * Math.LOG10E - Math.log(t) * Math.LOG10E);
    } else
      return (e - t) / (s - t);
  }
  /**
   * @ignore
   */
  valueToFinalPosition(e) {
    const t = this.getPrivate("minFinal"), s = this.getPrivate("maxFinal");
    if (this.get("logarithmic")) {
      if (e <= 0) {
        let r = this.get("treatZeroAs");
        S(r) && (e = r);
      }
      return (Math.log(e) * Math.LOG10E - Math.log(t) * Math.LOG10E) / (Math.log(s) * Math.LOG10E - Math.log(t) * Math.LOG10E);
    } else
      return (e - t) / (s - t);
  }
  /**
   * Returns X coordinate in pixels corresponding to specific value.
   *
   * @param   value     Numeric value
   * @param   location  Location
   * @param   baseValue Base value
   * @return            X coordinate
   */
  getX(e, t, s) {
    e = s + (e - s) * t;
    const r = this.valueToPosition(e);
    return this._settings.renderer.positionToCoordinate(r);
  }
  /**
   * Returns X coordinate in pixels corresponding to specific value.
   *
   * @param   value     Numeric value
   * @param   location  Location
   * @param   baseValue Base value
   * @return            X coordinate
   */
  getY(e, t, s) {
    e = s + (e - s) * t;
    const r = this.valueToPosition(e);
    return this._settings.renderer.positionToCoordinate(r);
  }
  /**
   * @ignore
   */
  getDataItemCoordinateX(e, t, s, r) {
    return this._settings.renderer.positionToCoordinate(this.getDataItemPositionX(e, t, s, r));
  }
  /**
   * @ignore
   */
  getDataItemPositionX(e, t, s, r) {
    let n = e.get(t);
    if (e.get("stackToItemX")) {
      const o = e.component;
      n = n * r + o.getStackedXValueWorking(e, t);
    } else
      n = this._baseValue + (n - this._baseValue) * r;
    return this.valueToPosition(n);
  }
  /**
   * @ignore
   */
  getDataItemCoordinateY(e, t, s, r) {
    return this._settings.renderer.positionToCoordinate(this.getDataItemPositionY(e, t, s, r));
  }
  /**
   * @ignore
   */
  getDataItemPositionY(e, t, s, r) {
    let n = e.get(t);
    if (e.get("stackToItemY")) {
      const o = e.component;
      n = n * r + o.getStackedYValueWorking(e, t);
    } else
      n = this._baseValue + (n - this._baseValue) * r;
    return this.valueToPosition(n);
  }
  /**
   * Returns relative position of axis' `baseValue`.
   *
   * @return  Base value position
   */
  basePosition() {
    return this.valueToPosition(this.baseValue());
  }
  /**
   * Base value of the [[ValueAxis]], which determines positive and negative
   * values.
   *
   * @return Base value
   */
  baseValue() {
    const e = Math.min(this.getPrivate("minFinal", -1 / 0), this.getPrivate("selectionMin", -1 / 0)), t = Math.max(this.getPrivate("maxFinal", 1 / 0), this.getPrivate("selectionMax", 1 / 0));
    let s = this.get("baseValue", 0);
    return s < e && (s = e), s > t && (s = t), s;
  }
  /**
   * @ignore
   */
  cellEndValue(e) {
    return e;
  }
  fixSmallStep(e) {
    return 1 + e === 1 ? (e *= 2, this.fixSmallStep(e)) : e;
  }
  _fixMin(e) {
    return e;
  }
  _fixMax(e) {
    return e;
  }
  _calculateTotals() {
    if (this.get("calculateTotals")) {
      let e = this.series[0];
      if (e) {
        let t = e.startIndex();
        if (e.dataItems.length > 0) {
          t > 0 && t--;
          let s = e.endIndex();
          s < e.dataItems.length && s++;
          let r, n;
          e.get("yAxis") == this ? (r = "valueY", n = "vcy") : e.get("xAxis") == this && (r = "valueX", n = "vcx");
          let a = r + "Working";
          if (r)
            for (let o = t; o < s; o++) {
              let l = 0, u = 0;
              w(this.series, (c) => {
                if (!c.get("excludeFromTotal")) {
                  let h = c.dataItems[o];
                  if (h) {
                    let d = h.get(a) * c.get(n);
                    $t(d) || (l += d, u += Math.abs(d));
                  }
                }
              }), w(this.series, (c) => {
                if (!c.get("excludeFromTotal")) {
                  let h = c.dataItems[o];
                  if (h) {
                    let d = h.get(a) * c.get(n);
                    $t(d) || (h.set(r + "Total", u), h.set(r + "Sum", l), h.set(r + "TotalPercent", d / u * 100));
                  }
                }
              });
            }
        }
      }
    }
  }
  _getSelectionMinMax() {
    const e = this.getPrivate("minFinal"), t = this.getPrivate("maxFinal"), s = this.get("min"), r = this.get("max");
    let n = this.get("extraMin", 0), a = this.get("extraMax", 0);
    this.get("logarithmic") && (this.get("extraMin") == null && (n = 0.1), this.get("extraMax") == null && (a = 0.2));
    const o = this.get("renderer").gridCount(), l = this.get("strictMinMaxSelection"), u = this.get("strictMinMax");
    if (S(e) && S(t)) {
      let c = t, h = e;
      if (w(this.series, (b) => {
        if (!b.get("ignoreMinMax")) {
          let y, x;
          const D = b.getPrivate("outOfSelection");
          b.get("xAxis") === this ? D || (y = b.getPrivate("selectionMinX", b.getPrivate("minX")), x = b.getPrivate("selectionMaxX", b.getPrivate("maxX"))) : b.get("yAxis") === this && (D || (y = b.getPrivate("selectionMinY", b.getPrivate("minY")), x = b.getPrivate("selectionMaxY", b.getPrivate("maxY")))), !b.isHidden() && !b.isShowing() && (S(y) && (c = Math.min(c, y)), S(x) && (h = Math.max(h, x)));
        }
      }), this.axisRanges.each((b) => {
        if (b.get("affectsMinMax")) {
          let y = b.get("value");
          y != null && (c = Math.min(c, y), h = Math.max(h, y)), y = b.get("endValue"), y != null && (c = Math.min(c, y), h = Math.max(h, y));
        }
      }), c > h && ([c, h] = [h, c]), S(s) ? u ? c = s : c = e : u && S(this._minReal) && (c = this._minReal), S(r) ? u ? h = r : h = t : u && S(this._maxReal) && (h = this._maxReal), c === h) {
        c -= this._deltaMinMax, h += this._deltaMinMax;
        let b = this._adjustMinMax(c, h, o, u);
        c = b.min, h = b.max;
      }
      let d = c, f = h;
      c -= (h - c) * n, h += (h - c) * a;
      let g = this._adjustMinMax(c, h, o);
      c = g.min, h = g.max, c = Ie(c, e, t), h = Ie(h, e, t), g = this._adjustMinMax(c, h, o, !0), u || (c = g.min, h = g.max);
      const p = this.get("syncWithAxis");
      p && (g = this._syncAxes(c, h, g.step, p.getPrivate("selectionMinFinal", p.getPrivate("minFinal", 0)), p.getPrivate("selectionMaxFinal", p.getPrivate("maxFinal", 1)), p.getPrivate("selectionStepFinal", p.getPrivate("step", 1))), c = g.min, h = g.max), u && (S(s) && (c = Math.max(c, s)), S(r) && (h = Math.min(h, r))), l && (c = d - (h - c) * n, h = f + (h - c) * a), this.get("logarithmic") && (c <= 0 && (c = d * (1 - Math.min(n, 0.99))), c < e && (c = e), h > t && (h = t));
      let _ = Math.min(20, Math.ceil(Math.log(this.getPrivate("maxZoomFactor", 100) + 1) / Math.LN10) + 2), m = qe(this.valueToFinalPosition(c), _), v = qe(this.valueToFinalPosition(h), _);
      this.setPrivateRaw("selectionMinFinal", c), this.setPrivateRaw("selectionMaxFinal", h), this.setPrivateRaw("selectionStepFinal", g.step), this.zoom(m, v);
    }
  }
  _getMinMax() {
    let e = this.get("min"), t = this.get("max"), s = 1 / 0, r = -1 / 0, n = this.get("extraMin", 0), a = this.get("extraMax", 0);
    this.get("logarithmic") && (this.get("extraMin") == null && (n = 0.1), this.get("extraMax") == null && (a = 0.2));
    let o = 1 / 0;
    if (w(this.series, (b) => {
      if (!b.get("ignoreMinMax")) {
        let y, x;
        if (b.get("xAxis") === this ? (y = b.getPrivate("minX"), x = b.getPrivate("maxX")) : b.get("yAxis") === this && (y = b.getPrivate("minY"), x = b.getPrivate("maxY")), S(y) && S(x)) {
          s = Math.min(s, y), r = Math.max(r, x);
          let D = x - y;
          D <= 0 && (D = Math.abs(x / 100)), D < o && (o = D);
        }
      }
    }), this.axisRanges.each((b) => {
      if (b.get("affectsMinMax")) {
        let y = b.get("value");
        y != null && (s = Math.min(s, y), r = Math.max(r, y)), y = b.get("endValue"), y != null && (s = Math.min(s, y), r = Math.max(r, y));
      }
    }), this.get("logarithmic")) {
      let b = this.get("treatZeroAs");
      S(b) && s <= 0 && (s = b);
    }
    if (s === 0 && r === 0 && (r = 0.9, s = -0.9), S(e) && (s = e), S(t) && (r = t), s === 1 / 0 || r === -1 / 0) {
      this.setPrivate("minFinal", void 0), this.setPrivate("maxFinal", void 0);
      return;
    }
    const l = s, u = r;
    let c = this.adapters.fold("min", s), h = this.adapters.fold("max", r);
    S(c) && (s = c), S(h) && (r = h), s = this._fixMin(s), r = this._fixMax(r), r - s <= 1 / Math.pow(10, 15) && (r - s !== 0 ? this._deltaMinMax = (r - s) / 2 : this._getDelta(r), s -= this._deltaMinMax, r += this._deltaMinMax), s -= (r - s) * n, r += (r - s) * a, this.get("logarithmic") && (s < 0 && l >= 0 && (s = 0), r > 0 && u <= 0 && (r = 0)), this._minReal = s, this._maxReal = r;
    let d = this.get("strictMinMax"), f = this.get("strictMinMaxSelection", !1);
    f && (d = f);
    let g = d;
    S(t) && (g = !0);
    let p = this.get("renderer").gridCount(), _ = this._adjustMinMax(s, r, p, g);
    s = _.min, r = _.max, _ = this._adjustMinMax(s, r, p, !0), s = _.min, r = _.max, d && (S(e) ? s = e : s = this._minReal, S(t) ? r = t : r = this._maxReal, r - s <= 1e-8 && (s -= this._deltaMinMax, r += this._deltaMinMax), s -= (r - s) * n, r += (r - s) * a), c = this.adapters.fold("min", s), h = this.adapters.fold("max", r), S(c) && (s = c), S(h) && (r = h), o == 1 / 0 && (o = r - s);
    let m = Math.round(Math.abs(Math.log(Math.abs(r - s)) * Math.LOG10E)) + 5;
    s = qe(s, m), r = qe(r, m);
    const v = this.get("syncWithAxis");
    if (v && (_ = this._syncAxes(s, r, _.step, v.getPrivate("minFinal", v.getPrivate("min", 0)), v.getPrivate("maxFinal", v.getPrivate("max", 1)), v.getPrivate("step", 1)), s = _.min, r = _.max), this.setPrivateRaw("maxZoomFactor", Math.max(1, Math.ceil((r - s) / o * this.get("maxZoomFactor", 100)))), this._fixZoomFactor(), this.get("logarithmic") && (this._minLogAdjusted = s, s = this._minReal, r = this._maxReal, s <= 0 && (s = l * (1 - Math.min(n, 0.99)))), S(s) && S(r) && (this.getPrivate("minFinal") !== s || this.getPrivate("maxFinal") !== r)) {
      this.setPrivate("minFinal", s), this.setPrivate("maxFinal", r), this._saveMinMax(s, r);
      const b = this.get("interpolationDuration", 0), y = this.get("interpolationEasing");
      this.animatePrivate({ key: "min", to: s, duration: b, easing: y }), this.animatePrivate({ key: "max", to: r, duration: b, easing: y });
    }
  }
  _fixZoomFactor() {
  }
  _getDelta(e) {
    let t = Math.log(Math.abs(e)) * Math.LOG10E, s = Math.pow(10, Math.floor(t));
    s = s / 10, this._deltaMinMax = s;
  }
  _saveMinMax(e, t) {
  }
  _adjustMinMax(e, t, s, r) {
    s <= 1 && (s = 1), s = Math.round(s);
    let n = e, a = t, o = t - e;
    o === 0 && (o = Math.abs(t));
    let l = Math.log(Math.abs(o)) * Math.LOG10E, u = Math.pow(10, Math.floor(l));
    u = u / 10;
    let c = u;
    r && (c = 0), r ? (e = Math.floor(e / u) * u, t = Math.ceil(t / u) * u) : (e = Math.ceil(e / u) * u - c, t = Math.floor(t / u) * u + c), e < 0 && n >= 0 && (e = 0), t > 0 && a <= 0 && (t = 0), l = Math.log(Math.abs(o)) * Math.LOG10E, u = Math.pow(10, Math.floor(l)), u = u / 100;
    let h = Math.ceil(o / s / u) * u, d = Math.pow(10, Math.floor(Math.log(Math.abs(h)) * Math.LOG10E)), f = Math.ceil(h / d);
    f > 5 ? f = 10 : f <= 5 && f > 2 && (f = 5), h = Math.ceil(h / (d * f)) * d * f;
    let g = this.get("maxPrecision");
    if (S(g)) {
      let v = fd(h, g);
      g < Number.MAX_VALUE && h !== v && (h = v);
    }
    let p = 0;
    d < 1 && (p = Math.round(Math.abs(Math.log(Math.abs(d)) * Math.LOG10E)) + 1, h = qe(h, p));
    let _ = Math.floor(e / h);
    e = qe(h * _, p);
    let m;
    return r ? m = Math.floor(t / h) : m = Math.ceil(t / h), m === _ && m++, t = qe(h * m, p), t < a && (t = t + h), e > n && (e = e - h), h = this.fixSmallStep(h), { min: e, max: t, step: h };
  }
  /**
   * Returns text to be used in an axis tooltip for specific relative position.
   *
   * @param   position  Position
   * @return            Tooltip text
   */
  getTooltipText(e) {
    const t = this.get("tooltipNumberFormat", this.get("numberFormat")), s = this.getNumberFormatter(), r = this.get("extraTooltipPrecision", 0), n = this.getPrivate("stepDecimalPlaces", 0) + r, a = qe(this.positionToValue(e), n);
    return t ? s.format(a, t) : s.format(a, void 0, n);
  }
  /**
   * Returns a data item from series that is closest to the `position`.
   *
   * @param   series    Series
   * @param   position  Relative position
   * @return            Data item
   */
  getSeriesItem(e, t) {
    let s = this.getPrivate("name") + this.get("renderer").getPrivate("letter"), r = this.positionToValue(t), n, a;
    if (w(e.dataItems, (o, l) => {
      const u = Math.abs(o.get(s) - r);
      (n === void 0 || u < a) && (n = l, a = u);
    }), n != null)
      return e.dataItems[n];
  }
  /**
   * Zooms the axis to specific `start` and `end` values.
   *
   * Optional `duration` specifies duration of zoom animation in milliseconds.
   *
   * @param  start     Start value
   * @param  end       End value
   * @param  duration  Duration in milliseconds
   */
  zoomToValues(e, t, s) {
    const r = this.getPrivate("minFinal", 0), n = this.getPrivate("maxFinal", 0);
    this.getPrivate("min") != null && this.getPrivate("max") != null && this.zoom((e - r) / (n - r), (t - r) / (n - r), s);
  }
  /**
   * Syncs with a target axis.
   *
   * @param  min  Min
   * @param  max  Max
   * @param  step Step
   */
  _syncAxes(e, t, s, r, n, a) {
    if (this.get("syncWithAxis")) {
      let l = Math.round(n - r) / a, u = Math.round((t - e) / s), c = this.get("renderer").gridCount();
      if (S(l) && S(u)) {
        let h = !1, d = 0, f = (t - e) * 0.01, g = e, p = t, _ = s;
        for (; h != !0; )
          if (h = this._checkSync(g, p, _, l), d++, d > 500 && (h = !0), h)
            e = g, t = p, s = _;
          else {
            d / 3 == Math.round(d / 3) ? (g = e - f * d, e >= 0 && g < 0 && (g = 0)) : (p = t + f * d, p <= 0 && p > 0 && (p = 0));
            let m = this._adjustMinMax(g, p, c, !0);
            g = m.min, p = m.max, _ = m.step;
          }
      }
    }
    return { min: e, max: t, step: s };
  }
  /**
   * Returns `true` if axis needs to be resunced with some other axis.
   */
  _checkSync(e, t, s, r) {
    let n = (t - e) / s;
    for (let a = 1; a < r; a++)
      if (qe(n / a, 1) == r || n * a == r)
        return !0;
    return !1;
  }
  /**
   * Returns relative position between two grid lines of the axis.
   *
   * @return Position
   */
  getCellWidthPosition() {
    let e = this.getPrivate("selectionMax", this.getPrivate("max")), t = this.getPrivate("selectionMin", this.getPrivate("min"));
    return S(e) && S(t) ? this.getPrivate("step", 1) / (e - t) : 0.05;
  }
}
Object.defineProperty(Xi, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "ValueAxis"
});
Object.defineProperty(Xi, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: zi.classNames.concat([Xi.className])
});
class er extends Xi {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_dataGrouped", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_seriesDataGrouped", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_groupingCalculated", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_intervalDuration", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), Object.defineProperty(this, "_baseDuration", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), Object.defineProperty(this, "_intervalMax", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    }), Object.defineProperty(this, "_intervalMin", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {}
    });
  }
  _afterNew() {
    this._settings.themeTags = ie(this._settings.themeTags, ["axis"]), super._afterNew(), this._setBaseInterval(this.get("baseInterval")), this.on("baseInterval", () => {
      this._setBaseInterval(this.get("baseInterval"));
    });
  }
  _setBaseInterval(e) {
    this.setPrivateRaw("baseInterval", e), this._baseDuration = kt(e);
  }
  _fixZoomFactor() {
    var e = this.get("maxZoomFactor");
    e != null && e != 1 / 0 ? this.setPrivateRaw("maxZoomFactor", e) : this.setPrivateRaw("maxZoomFactor", Math.round((this.getPrivate("max", 0) - this.getPrivate("min", 0)) / this.baseMainDuration()));
  }
  _groupData() {
    const e = this.getPrivate("min"), t = this.getPrivate("max");
    if (S(e) && S(t)) {
      this._fixZoomFactor();
      const s = this.getPrivate("groupInterval");
      if (s ? this._setBaseInterval(s) : this._setBaseInterval(this.get("baseInterval")), this.isDirty("groupInterval")) {
        let r = this.get("groupInterval");
        r && this.setRaw("groupIntervals", [r]);
      }
      if (this.isDirty("groupData") && !this._dataGrouped) {
        if (this.get("groupData"))
          w(this.series, (r) => {
            this._groupSeriesData(r);
          }), this._handleRangeChange();
        else {
          let r = this.get("baseInterval"), n = r.timeUnit + r.count;
          w(this.series, (a) => {
            a.setDataSet(n);
          }), this._setBaseInterval(r), this.setPrivateRaw("groupInterval", void 0), this.markDirtyExtremes();
        }
        this._dataGrouped = !0;
      }
    }
  }
  _groupSeriesData(e) {
    if (this.get("groupData") && !e.get("groupDataDisabled")) {
      this._dataGrouped = !0, this._seriesDataGrouped = !0;
      let t = [], s = this.baseMainDuration(), r = this.get("groupIntervals");
      w(r, (_) => {
        kt(_) > s && t.push(_);
      }), e._dataSets = {};
      const n = this.getPrivate("name") + this.get("renderer").getPrivate("letter");
      let a;
      const o = e.get("baseAxis");
      e.get("xAxis") === o ? a = e._valueYFields : e.get("yAxis") === o && (a = e._valueXFields);
      let l = e._mainDataItems, u = this.get("baseInterval"), c = u.timeUnit + u.count;
      e._dataSets[c] = l;
      const h = e.get("groupDataCallback");
      let d = e.get("groupDataWithOriginals", !1);
      h && (d = !0);
      const f = this._root.locale.firstDayOfWeek, g = this._root.utc, p = this._root.timezone;
      w(t, (_) => {
        let m = -1 / 0, v = _.timeUnit + _.count;
        e._dataSets[v] = [];
        let b, y = {}, x = {}, D = {}, A = {};
        w(a, (E) => {
          y[E] = 0, x[E] = 0, D[E] = e.get(E + "Grouped"), A[E] = E + "Working";
        });
        let T = yt(_.timeUnit), j = l[0], C;
        j && (C = new Date(l[0].get(n)));
        let L;
        w(l, (E) => {
          let N = E.get(n), q = Ve(new Date(N), _.timeUnit, _.count, f, g, C, p).getTime(), z;
          m < q - T / 24 ? (z = Ti(E.dataContext), b = new Gt(e, z, e._makeDataItem(z)), b.setRaw(n, q), e._dataSets[v].push(b), w(a, (H) => {
            let Y = E.get(H);
            S(Y) ? (b.setRaw(H, Y), b.setRaw(A[H], Y), x[H] = 1, y[H] = Y) : (y[H] = 0, x[H] = 0);
          }), d && b.set("originals", [E]), h && L && h(L, _), L = b) : (w(a, (H) => {
            let Y = D[H], W = E.get(H);
            if (W !== void 0) {
              let B = b.get(H);
              switch (Y) {
                case "close":
                  b.setRaw(H, W);
                  break;
                case "sum":
                  W != null && b.setRaw(H, B + W);
                  break;
                case "open":
                  break;
                case "low":
                  W < B && b.setRaw(H, W);
                  break;
                case "high":
                  W > B && b.setRaw(H, W);
                  break;
                case "average":
                  x[H]++, y[H] += W;
                  let O = y[H] / x[H];
                  b.setRaw(H, O);
                  break;
                case "extreme":
                  Math.abs(W) > Math.abs(B) && b.setRaw(H, W);
                  break;
              }
              b.setRaw(A[H], b.get(H));
              let oe = Ti(E.dataContext);
              oe[n] = q, b.dataContext = oe;
            }
          }), d && b.get("originals").push(E)), m = q;
        }), h && L && h(L, _);
      }), e._dataSetId && e.setDataSet(e._dataSetId), this.markDirtySize();
    }
  }
  _clearDirty() {
    super._clearDirty(), this._groupingCalculated = !1, this._dataGrouped = !1;
  }
  /**
   * Returns a time interval axis would group data to for a specified duration.
   *
   * @since 5.2.1
   */
  getGroupInterval(e) {
    let t = this.get("baseInterval"), s = Us(0, e, this.get("groupCount", 1 / 0), this.get("groupIntervals"));
    return kt(s) < kt(t) && (s = Object.assign({}, t)), s;
  }
  /**
   * Return `max` of a specified time interval.
   *
   * Will work only if the axis was grouped to this interval at least once.
   *
   * @since 5.2.1
   * @param   interval  Interval
   * @return            Max
   */
  getIntervalMax(e) {
    return this._intervalMax[e.timeUnit + e.count];
  }
  /**
   * Return `min` of a specified time interval.
   *
   * Will work only if the axis was grouped to this interval at least once.
   *
   * @since 5.2.1
   * @param   interval  Interval
   * @return            Min
   */
  getIntervalMin(e) {
    return this._intervalMin[e.timeUnit + e.count];
  }
  _handleRangeChange() {
    super._handleRangeChange();
    let e = Math.round(this.getPrivate("selectionMin")), t = Math.round(this.getPrivate("selectionMax"));
    if (S(e) && S(t)) {
      if (this.get("endLocation") == 0 && (t += 1), this.get("groupData") && !this._groupingCalculated) {
        this._groupingCalculated = !0;
        let s = t - e + (this.get("startLocation", 0) + (1 - this.get("endLocation", 1)) * this.baseDuration()), r = this.get("groupInterval");
        r || (r = this.getGroupInterval(s));
        let n = this.getPrivate("groupInterval");
        if (r && (!n || n.timeUnit !== r.timeUnit || n.count !== r.count || this._seriesDataGrouped)) {
          this._seriesDataGrouped = !1, this.setPrivateRaw("groupInterval", r), this._setBaseInterval(r);
          let a = r.timeUnit + r.count;
          w(this.series, (o) => {
            o.get("baseAxis") === this && o.setDataSet(a);
          }), this.markDirtyExtremes(), this._root.events.once("frameended", () => {
            this._root.events.once("frameended", () => {
              const o = "groupintervalchanged";
              this.events.isEnabled(o) && this.events.dispatch(o, { type: o, target: this });
            });
          });
        }
      }
      w(this.series, (s) => {
        if (s.get("baseAxis") === this) {
          let r = this.getPrivate("name") + this.get("renderer").getPrivate("letter"), a = ji(s.dataItems, (p) => Et(p.get(r), e)).index;
          a > 0 && (a -= 1), t += this.baseDuration() * (1 - this.get("endLocation", 1));
          let l = ji(s.dataItems, (p) => Et(p.get(r), t)).index, u = l;
          u > 0 && u--;
          const c = s.dataItems[a], h = s.dataItems[u];
          let d, f;
          c && (f = c.get(r)), h && (d = h.get(r));
          let g = !1;
          d != null && f != null && (d < e || f > t) && (g = !0), s.setPrivate("outOfSelection", g), s.setPrivate("startIndex", a), s.setPrivate("endIndex", l);
        }
      });
    }
  }
  _adjustMinMax(e, t, s, r) {
    return { min: e, max: t, step: (t - e) / s };
  }
  /**
   * @ignore
   */
  intervalDuration() {
    return this._intervalDuration;
  }
  _saveMinMax(e, t) {
    let s = this.getPrivate("groupInterval");
    s || (s = this.get("baseInterval"));
    let r = s.timeUnit + s.count;
    this._intervalMin[r] = e, this._intervalMax[r] = t;
  }
  _getM(e) {
    return e == "month" || e == "year" || e == "day" ? 1.05 : 1.01;
  }
  _prepareAxisItems() {
    const e = this.getPrivate("min"), t = this.getPrivate("max");
    if (S(e) && S(t)) {
      const s = Math.round(this.getPrivate("selectionMin")), r = Math.round(this.getPrivate("selectionMax")), n = this.get("renderer"), a = this.getPrivate("baseInterval");
      let o = s, l = 0;
      const u = this.get("gridIntervals");
      let c = Us(0, r - s, n.gridCount(), u);
      kt(c) < this.baseDuration() && (c = Object.assign({}, a));
      const h = kt(c);
      this._intervalDuration = h;
      const d = nn(c.timeUnit), f = this._root.locale.firstDayOfWeek, g = this._root.utc, p = this._root.timezone;
      o = Ve(new Date(s - h), c.timeUnit, c.count, f, g, new Date(e), p).getTime();
      let _ = o - h, m;
      const v = this.get("dateFormats");
      for (this.setPrivateRaw("gridInterval", c); o < r + h; ) {
        let b;
        this.dataItems.length < l + 1 ? (b = new Gt(this, void 0, {}), this._dataItems.push(b), this.processDataItem(b)) : b = this.dataItems[l], this._createAssets(b, []), b.isHidden() && b.show(), b.setRaw("value", o);
        let y = o + yt(c.timeUnit, c.count * this._getM(c.timeUnit));
        y = Ve(new Date(y), c.timeUnit, 1, f, g, void 0, p).getTime(), b.setRaw("endValue", y);
        let x = new Date(o);
        m = v[c.timeUnit], d && this.get("markUnitChange") && S(_) && c.timeUnit != "year" && an(o, _, d, g, p) && (m = this.get("periodChangeDateFormats")[c.timeUnit]);
        const D = b.get("label");
        if (D && D.set("text", this._root.dateFormatter.format(x, m)), this._prepareDataItem(b, c.count), _ = o, o = y, o == _)
          break;
        l++;
      }
      for (let b = l; b < this.dataItems.length; b++)
        this.dataItems[b].hide();
      w(this.series, (b) => {
        b.inited && b._markDirtyAxes();
      });
    }
    this._updateGhost();
  }
  _updateFinals(e, t) {
    this.setPrivateRaw("selectionMinFinal", this.positionToValue(e)), this.setPrivateRaw("selectionMaxFinal", this.positionToValue(t));
  }
  _getDelta() {
    this._deltaMinMax = this.baseDuration() / 2;
  }
  _fixMin(e) {
    const t = this.getPrivate("baseInterval"), s = this._root.locale.firstDayOfWeek, r = this._root.timezone, n = this._root.utc, a = t.timeUnit;
    let o = Ve(new Date(e), a, t.count, s, n, void 0, r).getTime(), l = o + yt(a, t.count * this._getM(a));
    return l = Ve(new Date(l), a, 1, s, n, void 0, r).getTime(), o + (l - o) * this.get("startLocation", 0);
  }
  _fixMax(e) {
    const t = this.getPrivate("baseInterval"), s = this._root.locale.firstDayOfWeek, r = this._root.timezone, n = this._root.utc, a = t.timeUnit;
    let o = Ve(new Date(e), a, t.count, s, n, void 0, r).getTime(), l = o + yt(a, t.count * this._getM(a));
    return l = Ve(new Date(l), a, 1, s, n, void 0, r).getTime(), o + (l - o) * this.get("endLocation", 1);
  }
  _updateDates(e) {
  }
  /**
   * Returns a duration of currently active `baseInterval` in milliseconds.
   *
   * @return Duration
   */
  baseDuration() {
    return this._baseDuration;
  }
  /**
   * Returns a duration of user-defined `baseInterval` in milliseconds.
   *
   * @return Duration
   */
  baseMainDuration() {
    return kt(this.get("baseInterval"));
  }
  /**
   * @ignore
   */
  processSeriesDataItem(e, t) {
    const s = this.getPrivate("baseInterval");
    e.open || (e.open = {}), e.close || (e.close = {}), w(t, (r) => {
      let n = e.get(r);
      if (S(n)) {
        let a = e.open[r], o = e.close[r];
        if (!(n >= a && n <= o)) {
          const l = this._root.locale.firstDayOfWeek, u = this._root.utc, c = this._root.timezone, h = s.timeUnit, d = s.count;
          a = Ve(new Date(n), h, d, l, u, void 0, c).getTime(), o = a + yt(h, d * this._getM(h)), o = Ve(new Date(o), h, 1, l, u, void 0, c).getTime(), e.open[r] = a, e.close[r] = o;
        }
        this._updateDates(a);
      }
    });
  }
  /**
   * @ignore
   */
  getDataItemPositionX(e, t, s, r) {
    let n, a;
    e.open && e.close ? (n = e.open[t], a = e.close[t]) : (n = e.get(t), a = n);
    let o = n + (a - n) * s;
    return o = this._baseValue + (o - this._baseValue) * r, this.valueToPosition(o);
  }
  /**
   * @ignore
   */
  getDataItemCoordinateX(e, t, s, r) {
    return this._settings.renderer.positionToCoordinate(this.getDataItemPositionX(e, t, s, r));
  }
  /**
   * @ignore
   */
  getDataItemPositionY(e, t, s, r) {
    let n, a;
    e.open && e.close ? (n = e.open[t], a = e.close[t]) : (n = e.get(t), a = n);
    let o = n + (a - n) * s;
    return o = this._baseValue + (o - this._baseValue) * r, this.valueToPosition(o);
  }
  /**
   * @ignore
   */
  getDataItemCoordinateY(e, t, s, r) {
    return this._settings.renderer.positionToCoordinate(this.getDataItemPositionY(e, t, s, r));
  }
  /**
   * @ignore
   */
  roundAxisPosition(e, t) {
    let s = this.positionToValue(e);
    s = s - (t - 0.5) * this.baseDuration();
    let r = this.getPrivate("baseInterval");
    if (!$t(s)) {
      const n = this._root.locale.firstDayOfWeek, a = r.timeUnit, o = this._root.utc, l = this._root.timezone, u = r.count;
      s = Ve(new Date(s), a, u, n, o, new Date(this.getPrivate("min", 0)), l).getTime();
      let c = An(r, new Date(s), n, o, l);
      return l && (s = Ve(new Date(s + this.baseDuration() * 0.05), a, u, n, o, new Date(this.getPrivate("min", 0)), l).getTime(), c = An(r, new Date(s + c * t), n, o, l)), this.valueToPosition(s + c * t);
    }
    return NaN;
  }
  /**
   * Returns text to be used in an axis tooltip for specific relative position.
   *
   * @param   position  Position
   * @return            Tooltip text
   */
  getTooltipText(e) {
    if (this.getPrivate("min") != null) {
      let t = this.get("tooltipDateFormats")[this.getPrivate("baseInterval").timeUnit], s = this.positionToValue(e), r = new Date(s), n = this.getPrivate("baseInterval"), a = An(n, r, this._root.locale.firstDayOfWeek, this._root.utc, this._root.timezone);
      return this._root.dateFormatter.format(new Date(s + this.get("tooltipIntervalOffset", -this.get("tooltipLocation", 0.5)) * a), this.get("tooltipDateFormat", t));
    }
    return "";
  }
  /**
   * Returns a data item from series that is closest to the `position`.
   *
   * @param   series    Series
   * @param   position  Relative position
   * @return            Data item
   */
  getSeriesItem(e, t, s) {
    let r = this.getPrivate("name") + this.get("renderer").getPrivate("letter"), n = this.positionToValue(t);
    s == null && (s = 0.5), n = n - (s - 0.5) * this.baseDuration();
    const a = ji(e.dataItems, (o) => {
      var l = 0;
      return o.open && (l = o.open[r]), Et(l, n);
    });
    if (e.get("snapTooltip")) {
      let o = e.dataItems[a.index - 1], l = e.dataItems[a.index];
      if (o && l && o.open && l.close) {
        let u = o.open[r], c = l.close[r];
        if (Math.abs(n - u) > Math.abs(n - c))
          return l;
      }
      if (o)
        return o;
      if (l)
        return l;
    } else {
      const o = e.dataItems[a.index - 1];
      if (o && o.open && o.close) {
        let l = o.open[r], u = o.close[r];
        if (n >= l && n <= u)
          return o;
      }
    }
  }
  /**
   * @ignore
   */
  shouldGap(e, t, s, r) {
    const n = e.get(r);
    return t.get(r) - n > this.baseDuration() * s;
  }
  /**
   * Zooms the axis to specific `start` and `end` dates.
   *
   * Optional `duration` specifies duration of zoom animation in milliseconds.
   *
   * @param  start     Start Date
   * @param  end       End Date
   * @param  duration  Duration in milliseconds
   */
  zoomToDates(e, t, s) {
    this.zoomToValues(e.getTime(), t.getTime(), s);
  }
  /**
   * Returns a `Date` object corresponding to specific position within plot
   * area.
   *
   * @param   position  Pposition
   * @return            Date
   */
  positionToDate(e) {
    return new Date(this.positionToValue(e));
  }
  /**
   * Returns a relative position within plot area that corresponds to specific
   * date.
   *
   * @param   date  Date
   * @return        Position
   */
  dateToPosition(e) {
    return this.valueToPosition(e.getTime());
  }
  /**
   * Returns relative position between two grid lines of the axis.
   *
   * @since 5.2.30
   * @return Position
   */
  getCellWidthPosition() {
    let e = this.getPrivate("selectionMax", this.getPrivate("max")), t = this.getPrivate("selectionMin", this.getPrivate("min"));
    return S(e) && S(t) ? this._intervalDuration / (e - t) : 0.05;
  }
}
Object.defineProperty(er, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "DateAxis"
});
Object.defineProperty(er, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Xi.classNames.concat([er.className])
});
class ma extends er {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_frequency", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), Object.defineProperty(this, "_dates", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    });
  }
  _afterNew() {
    this.valueFields.push("date"), super._afterNew();
  }
  _updateDates(e) {
    const t = this._dates, s = ji(t, (r) => Et(r, e));
    s.found || Ns(t, s.index, e);
  }
  _updateAllDates() {
    this._dates.length = 0, w(this.series, (e) => {
      let t = "valueX";
      e.get("yAxis") == this && (t = "valueY"), w(e.dataItems, (s) => {
        let r = s.get(t);
        S(r) && s.open && this._updateDates(s.open[t]);
      });
    });
  }
  /**
   * Convers value to a relative position on axis.
   *
   * @param   value  Value
   * @return         Relative position
   */
  valueToPosition(e) {
    const t = this._dates, s = this.get("startLocation", 0), r = this.get("endLocation", 1), n = t.length - s - (1 - r), a = ji(t, (l) => Et(l, e));
    let o = a.index;
    if (a.found)
      return (o - s) / n;
    {
      o > 0 && (o -= 1);
      let l = t[o], u = 0;
      return l > e ? u = l - e : u = e - l, (o - s) / n + u / this.baseDuration() / n;
    }
  }
  /**
   * Converts numeric value from axis scale to index.
   *
   * @param  value  Value
   * @return        Index
   */
  valueToIndex(e) {
    const t = this._dates, s = ji(t, (n) => Et(n, e));
    let r = s.index;
    return s.found || r > 0 && (r -= 1), r;
  }
  /**
   * Converts a relative position to a corresponding numeric value from axis
   * scale.
   *
   * @param   position  Relative position
   * @return            Value
   */
  positionToValue(e) {
    const t = this.get("startLocation", 0), s = this.get("endLocation", 1);
    let r = Math.round(this._dates.length - t - (1 - s)), n = e * r, a = Math.floor(n);
    return a < 0 && (a = 0), a > r - 1 && (a = r - 1), this._dates[a] + (n - a + t) * this.baseDuration();
  }
  _fixZoomFactor() {
    this.setPrivateRaw("maxZoomFactor", this._dates.length - this.get("startLocation", 0) - (1 - this.get("endLocation", 1)));
  }
  /**
   * Zooms the axis to specific `start` and `end` values.
   *
   * Optional `duration` specifies duration of zoom animation in milliseconds.
   *
   * @param  start     Start value
   * @param  end       End value
   * @param  duration  Duration in milliseconds
   */
  zoomToValues(e, t, s) {
    this.zoom(this.valueToPosition(e), this.valueToPosition(t), s);
  }
  _prepareAxisItems() {
    let e = this.getPrivate("selectionMin", 0), t = this.getPrivate("selectionMax", 0);
    if (S(e) && S(t)) {
      this._seriesValuesDirty && (this._seriesValuesDirty = !1, this._updateAllDates());
      const s = this._dates, r = this.get("renderer"), n = s.length;
      let a = this.valueToIndex(e);
      a > 0 && a--;
      let o = this.valueToIndex(t);
      o < n - 1 && o++;
      let l = r.axisLength() / Math.max(r.get("minGridDistance"), 1 / Number.MAX_SAFE_INTEGER), u = Math.min(n, Math.ceil((o - a) / l));
      u = Math.max(1, u), a = Math.floor(a / u) * u, this._frequency = u;
      for (let D = 0, A = this.dataItems.length; D < A; D++)
        this.dataItems[D].hide();
      let c = t - e - ((t - e) / this.baseDuration() - (o - a)) * this.baseDuration(), h = Us(0, c, l, this.get("gridIntervals"));
      const d = this.getPrivate("baseInterval");
      let f = kt(h);
      f < this.baseDuration() && (h = Object.assign({}, d), f = kt(h)), this._intervalDuration = f;
      const g = this.get("dateFormats");
      let p = [], _ = new Date();
      this._dates[0] && (_ = new Date(this._dates[0]));
      let m = Ve(new Date(this.getPrivate("min", 0)), h.timeUnit, h.count, this._root.locale.firstDayOfWeek, this._root.utc, _, this._root.timezone), v = Ad(m, h.timeUnit, -1, this._root.utc, this._root.timezone).getTime(), b = this.getPrivate("selectionMax"), y = -1 / 0, x = (this.get("end", 1) - this.get("start", 0)) / l;
      for (; v <= b; ) {
        let D = this.valueToIndex(v), A = this._dates[D];
        if (A < v) {
          for (let C = D, L = this._dates.length; C < L; C++)
            if (this._dates[C] >= v) {
              D = C;
              break;
            }
        }
        let T = this.valueToPosition(A);
        T - y >= x * 0.95 && (Yc(p, D), y = T);
        let j = v;
        if (v += yt(h.timeUnit, h.count * this._getM(h.timeUnit)), v = Ve(new Date(v), h.timeUnit, h.count, this._root.locale.firstDayOfWeek, this._root.utc, void 0, this._root.timezone).getTime(), v == j)
          break;
      }
      if (p.length > 0) {
        let D = 0, A = v - f * 10;
        const T = nn(h.timeUnit);
        w(p, (j) => {
          let C;
          this.dataItems.length < D + 1 ? (C = new Gt(this, void 0, {}), this._dataItems.push(C), this.processDataItem(C)) : C = this.dataItems[D];
          let L = s[j], E = new Date(L), N = L;
          if (D < p.length - 1 ? N = s[p[D + 1]] : N += f, C.setRaw("value", L), C.setRaw("endValue", N), C.setRaw("index", D), j > a - 100 && j < o + 100) {
            let q = g[h.timeUnit];
            q = g[h.timeUnit], T && this.get("markUnitChange") && S(A) && h.timeUnit != "year" && an(L, A, T, this._root.utc, this._root.timezone) && (q = this.get("periodChangeDateFormats")[h.timeUnit]), this._createAssets(C, []);
            const z = C.get("label");
            z && z.set("text", this._root.dateFormatter.format(E, q)), C.isHidden() && C.show(), this._prepareDataItem(C, h.count);
          }
          D++, A = L;
        });
      }
      w(this.series, (D) => {
        D.inited && D._markDirtyAxes();
      });
    }
    this._updateGhost();
  }
}
Object.defineProperty(ma, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "GaplessDateAxis"
});
Object.defineProperty(ma, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: er.classNames.concat([ma.className])
});
class ba extends Xi {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_dataGrouped", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_groupingCalculated", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_intervalDuration", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    });
  }
  _afterNew() {
    this._settings.themeTags = ie(this._settings.themeTags, ["axis"]), super._afterNew();
  }
  _adjustMinMax(e, t, s, r) {
    let n;
    const a = this.getDurationFormatter(), o = this.get("baseUnit");
    if (this.setRaw("maxPrecision", 0), o == "millisecond" || o == "second" || o == "minute" || o == "hour") {
      s <= 1 && (s = 1), s = Math.round(s);
      let l = t - e;
      l === 0 && (l = Math.abs(t));
      let u = l / s, c = [60, 30, 20, 15, 10, 2, 1], h = 1;
      o == "hour" && (c = [24, 12, 6, 4, 2, 1]);
      for (let m of c)
        if (l / m > s) {
          h = m;
          break;
        }
      let d = Math.ceil((t - e) / h / s), f = Math.log(Math.abs(d)) * Math.LOG10E, g = Math.pow(10, Math.floor(f)) / 10, p = d / g;
      d = _d(c, p) * g, u = h * d, e = Math.floor(e / u) * u, t = Math.ceil(t / u) * u, n = { min: e, max: t, step: u };
    } else
      n = super._adjustMinMax(e, t, s, r);
    return this.setPrivateRaw("durationFormat", a.getFormat(n.step, n.max, o)), n;
  }
  _formatText(e) {
    return this.getDurationFormatter().format(e, this.getPrivate("durationFormat"), this.get("baseUnit"));
  }
  /**
   * Returns text to be used in an axis tooltip for specific relative position.
   *
   * @param   position  Position
   * @return            Tooltip text
   */
  getTooltipText(e) {
    const t = this.getDurationFormatter(), s = this.get("extraTooltipPrecision", 0), r = this.getPrivate("stepDecimalPlaces", 0) + s, n = qe(this.positionToValue(e), r);
    return t.format(n, this.getPrivate("durationFormat"), this.get("baseUnit"));
  }
}
Object.defineProperty(ba, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "DurationAxis"
});
Object.defineProperty(ba, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Xi.classNames.concat([ba.className])
});
class ya extends Se {
  constructor() {
    super(...arguments), Object.defineProperty(this, "axis", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  _beforeChanged() {
    super._beforeChanged();
    const e = this.get("sprite");
    if (this.isDirty("sprite") && e && (e.setAll({ position: "absolute", role: "figure" }), this._disposers.push(e)), this.isDirty("location")) {
      const t = e.dataItem;
      this.axis && e && t && this.axis._prepareDataItem(t);
    }
  }
}
Object.defineProperty(ya, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "AxisBullet"
});
Object.defineProperty(ya, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Se.classNames.concat([ya.className])
});
class Wr extends Xe {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_tickPoints", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    });
  }
}
Object.defineProperty(Wr, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "AxisLabel"
});
Object.defineProperty(Wr, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Xe.classNames.concat([Wr.className])
});
class va extends Gs {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_tickPoints", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    });
  }
}
Object.defineProperty(va, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "AxisLabelRadial"
});
Object.defineProperty(va, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Gs.classNames.concat([va.className])
});
class Gr extends Qs {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_tickPoints", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: []
    });
  }
}
Object.defineProperty(Gr, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "AxisTick"
});
Object.defineProperty(Gr, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Qs.classNames.concat([Gr.className])
});
class Vi extends le {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_axisLength", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 100
    }), Object.defineProperty(this, "_start", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_end", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), Object.defineProperty(this, "_inversed", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "_minSize", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "chart", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_lc", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 1
    }), Object.defineProperty(this, "_ls", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_thumbDownPoint", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_downStart", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_downEnd", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "ticks", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new ze(me.new({}), () => Gr._new(this._root, {
        themeTags: ie(this.ticks.template.get("themeTags", []), this.get("themeTags", []))
      }, [this.ticks.template]))
    }), Object.defineProperty(this, "grid", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new ze(me.new({}), () => ms._new(this._root, {
        themeTags: ie(this.grid.template.get("themeTags", []), this.get("themeTags", []))
      }, [this.grid.template]))
    }), Object.defineProperty(this, "axisFills", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new ze(me.new({}), () => le._new(this._root, {
        themeTags: ie(this.axisFills.template.get("themeTags", ["axis", "fill"]), this.get("themeTags", []))
      }, [this.axisFills.template]))
    }), Object.defineProperty(this, "labels", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new ze(me.new({}), () => Wr._new(this._root, {
        themeTags: ie(this.labels.template.get("themeTags", []), this.get("themeTags", []))
      }, [this.labels.template]))
    }), Object.defineProperty(this, "axis", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "thumb", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  /**
   * @ignore
   */
  makeTick(e, t) {
    const s = this.ticks.make();
    return s._setDataItem(e), e.setRaw("tick", s), s.set("themeTags", ie(s.get("themeTags"), t)), this.axis.labelsContainer.children.push(s), this.ticks.push(s), s;
  }
  /**
   * @ignore
   */
  makeGrid(e, t) {
    const s = this.grid.make();
    return s._setDataItem(e), e.setRaw("grid", s), s.set("themeTags", ie(s.get("themeTags"), t)), this.axis.gridContainer.children.push(s), this.grid.push(s), s;
  }
  /**
   * @ignore
   */
  makeAxisFill(e, t) {
    const s = this.axisFills.make();
    return s._setDataItem(e), s.set("themeTags", ie(s.get("themeTags"), t)), this.axis.gridContainer.children.push(s), e.setRaw("axisFill", s), this.axisFills.push(s), s;
  }
  /**
   * @ignore
   */
  makeLabel(e, t) {
    const s = this.labels.make();
    return s.set("themeTags", ie(s.get("themeTags"), t)), this.axis.labelsContainer.children.moveValue(s, 0), s._setDataItem(e), e.setRaw("label", s), this.labels.push(s), s;
  }
  axisLength() {
    return 0;
  }
  /**
   * @ignore
   */
  gridCount() {
    return this.axisLength() / this.get("minGridDistance", 50);
  }
  _updatePositions() {
  }
  _afterNew() {
    super._afterNew(), this.set("isMeasured", !1);
    const e = this.thumb;
    e && (this._disposers.push(e.events.on("pointerdown", (t) => {
      this._handleThumbDown(t.originalEvent);
    })), this._disposers.push(e.events.on("globalpointerup", (t) => {
      this._handleThumbUp(t.originalEvent);
    })), this._disposers.push(e.events.on("globalpointermove", (t) => {
      this._handleThumbMove(t.originalEvent);
    })));
  }
  _changed() {
    if (super._changed(), this.isDirty("pan")) {
      const e = this.thumb;
      if (e) {
        const t = this.axis.labelsContainer, s = this.get("pan");
        s == "zoom" ? t.children.push(e) : s == "none" && t.children.removeValue(e);
      }
    }
  }
  _handleThumbDown(e) {
    this._thumbDownPoint = this.toLocal(this._root.documentPointToRoot({ x: e.clientX, y: e.clientY }));
    const t = this.axis;
    this._downStart = t.get("start"), this._downEnd = t.get("end");
  }
  _handleThumbUp(e) {
    this._thumbDownPoint = void 0;
  }
  _handleThumbMove(e) {
    const t = this._thumbDownPoint;
    if (t) {
      const s = this.toLocal(this._root.documentPointToRoot({ x: e.clientX, y: e.clientY })), r = this._downStart, n = this._downEnd, a = this._getPan(s, t) * Math.min(1, n - r) / 2;
      this.axis.setAll({ start: r - a, end: n + a });
    }
  }
  _getPan(e, t) {
    return 0;
  }
  /**
   * Converts relative position (0-1) on axis to a pixel coordinate.
   *
   * @param position  Position (0-1)
   * @return Coordinate (px)
   */
  positionToCoordinate(e) {
    return this._inversed ? (this._end - e) * this._axisLength : (e - this._start) * this._axisLength;
  }
  /**
   * @ignore
   */
  updateTooltipBounds(e) {
  }
  _updateSize() {
    this.markDirty(), this._clear = !0;
  }
  toAxisPosition(e) {
    const t = this._start || 0, s = this._end || 1;
    return e = e * (s - t), this.get("inversed") ? e = s - e : e = t + e, e;
  }
  /**
   * @ignore
   */
  fixPosition(e) {
    return this.get("inversed") ? 1 - e : e;
  }
  _updateLC() {
  }
  toggleVisibility(e, t, s, r) {
    let n = this.axis;
    const a = n.get("start", 0), o = n.get("end", 1);
    let l = a + (o - a) * (s - 1e-4), u = a + (o - a) * (r + 1e-4);
    t < l || t > u ? e.setPrivate("visible", !1) : e.setPrivate("visible", !0);
  }
  _positionTooltip(e, t) {
    const s = this.chart;
    s && (s.inPlot(t) ? e.set("pointTo", this._display.toGlobal(t)) : e.hide());
  }
  processAxis() {
  }
}
Object.defineProperty(Vi, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "AxisRenderer"
});
Object.defineProperty(Vi, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: le.classNames.concat([Vi.className])
});
class tr extends Vi {
  constructor() {
    super(...arguments), Object.defineProperty(this, "thumb", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: pt.new(this._root, { width: R, isMeasured: !1, themeTags: ["axis", "x", "thumb"] })
    });
  }
  _afterNew() {
    this._settings.themeTags = ie(this._settings.themeTags, ["renderer", "x"]), super._afterNew(), this.setPrivateRaw("letter", "X");
    const e = this.grid.template;
    e.set("height", R), e.set("width", 0), e.set("draw", (t, s) => {
      t.moveTo(0, 0), t.lineTo(0, s.height());
    }), this.set("draw", (t, s) => {
      t.moveTo(0, 0), t.lineTo(s.width(), 0);
    });
  }
  _changed() {
    super._changed();
    const e = this.axis;
    e.ghostLabel.setPrivate("visible", !this.get("inside")), e.ghostLabel.set("x", -1e3);
    const t = "opposite", s = "inside";
    if (this.isDirty(t) || this.isDirty(s)) {
      const r = this.chart, n = e.children;
      if (this.get(s) ? e.addTag(s) : e.removeTag(s), r) {
        if (this.get(t)) {
          const a = r.topAxesContainer.children;
          a.indexOf(e) == -1 && a.insertIndex(0, e), e.addTag(t), n.moveValue(this);
        } else {
          const a = r.bottomAxesContainer.children;
          a.indexOf(e) == -1 && a.moveValue(e), e.removeTag(t), n.moveValue(this, 0);
        }
        e.ghostLabel._applyThemes(), this.labels.each((a) => {
          a._applyThemes();
        }), this.root._markDirtyRedraw();
      }
      e.markDirtySize();
    }
    this.thumb.setPrivate("height", e.labelsContainer.height());
  }
  _getPan(e, t) {
    return (t.x - e.x) / this.width();
  }
  toAxisPosition(e) {
    const t = this._start || 0, s = this._end || 1;
    return e -= this._ls, e = e * (s - t) / this._lc, this.get("inversed") ? e = s - e : e = t + e, e;
  }
  _updateLC() {
    const e = this.axis, t = e.parent;
    if (t) {
      const s = t.innerWidth();
      this._lc = this.axisLength() / s, this._ls = (e.x() - t.get("paddingLeft", 0)) / s;
    }
  }
  _updatePositions() {
    const e = this.axis;
    e.gridContainer.set("x", e.x() - Re(e.get("centerX", 0), e.width()) - e.parent.get("paddingLeft", 0)), e.bulletsContainer.set("y", this.y());
    const t = e.chart;
    if (t) {
      const s = t.plotContainer, r = e.axisHeader;
      let n = e.get("marginLeft", 0), a = e.x() - n;
      const o = e.parent;
      o && (a -= o.get("paddingLeft", 0)), r.children.length > 0 ? (n = e.axisHeader.width(), e.set("marginLeft", n + 1)) : r.set("width", n), r.setAll({ x: a, y: -1, height: s.height() + 2 });
    }
  }
  /**
   * @ignore
   */
  processAxis() {
    super.processAxis();
    const e = this.axis;
    e.set("width", R);
    const t = this._root.verticalLayout;
    e.set("layout", t), e.labelsContainer.set("width", R), e.axisHeader.setAll({ layout: t });
  }
  /**
   * @ignore
   */
  axisLength() {
    return this.axis.width();
  }
  /**
   * Converts axis relative position to actual coordinate in pixels.
   *
   * @param   position  Position
   * @return            Point
   */
  positionToPoint(e) {
    return { x: this.positionToCoordinate(e), y: 0 };
  }
  /**
   * @ignore
   */
  updateTick(e, t, s, r) {
    if (e) {
      S(t) || (t = 0);
      let n = 0.5;
      S(r) && r > 1 ? n = e.get("multiLocation", n) : n = e.get("location", n), S(s) && s != t && (t = t + (s - t) * n), e.set("x", this.positionToCoordinate(t));
      let a = e.get("length", 0);
      const o = e.get("inside", this.get("inside", !1));
      this.get("opposite") ? (e.set("y", R), o || (a *= -1)) : (e.set("y", 0), o && (a *= -1)), e.set("draw", (l) => {
        l.moveTo(0, 0), l.lineTo(0, a);
      }), this.toggleVisibility(e, t, e.get("minPosition", 0), e.get("maxPosition", 1));
    }
  }
  /**
   * @ignore
   */
  updateLabel(e, t, s, r) {
    if (e) {
      let n = 0.5;
      S(r) && r > 1 ? n = e.get("multiLocation", n) : n = e.get("location", n), S(t) || (t = 0);
      const a = e.get("inside", this.get("inside", !1));
      this.get("opposite") ? a ? (e.set("position", "absolute"), e.set("y", 0)) : (e.set("position", "relative"), e.set("y", R)) : a ? (e.set("y", 0), e.set("position", "absolute")) : (e.set("y", void 0), e.set("position", "relative")), S(s) && s != t && (t = t + (s - t) * n), e.set("x", this.positionToCoordinate(t)), this.toggleVisibility(e, t, e.get("minPosition", 0), e.get("maxPosition", 1));
    }
  }
  /**
   * @ignore
   */
  updateGrid(e, t, s) {
    if (e) {
      S(t) || (t = 0);
      let r = e.get("location", 0.5);
      S(s) && s != t && (t = t + (s - t) * r), e.set("x", this.positionToCoordinate(t)), this.toggleVisibility(e, t, 0, 1);
    }
  }
  /**
   * @ignore
   */
  updateBullet(e, t, s) {
    if (e) {
      const r = e.get("sprite");
      if (r) {
        S(t) || (t = 0);
        let n = e.get("location", 0.5);
        S(s) && s != t && (t = t + (s - t) * n);
        let a = this.axis.roundAxisPosition(t, n), o = this.axis._bullets[a], l = -1;
        if (this.get("opposite") && (l = 1), e.get("stacked"))
          if (o) {
            let u = o.get("sprite");
            u && r.set("y", u.y() + u.height() * l);
          } else
            r.set("y", 0);
        this.axis._bullets[a] = e, r.set("x", this.positionToCoordinate(t)), this.toggleVisibility(r, t, 0, 1);
      }
    }
  }
  /**
   * @ignore
   */
  updateFill(e, t, s) {
    if (e) {
      S(t) || (t = 0), S(s) || (s = 1);
      let r = this.positionToCoordinate(t), n = this.positionToCoordinate(s);
      this.fillDrawMethod(e, r, n);
    }
  }
  fillDrawMethod(e, t, s) {
    e.set("draw", (r) => {
      const n = this.axis.gridContainer.height(), a = this.width();
      s < t && ([s, t] = [t, s]), !(t > a || s < 0) && (r.moveTo(t, 0), r.lineTo(s, 0), r.lineTo(s, n), r.lineTo(t, n), r.lineTo(t, 0));
    });
  }
  /**
   * @ignore
   */
  positionTooltip(e, t) {
    this._positionTooltip(e, { x: this.positionToCoordinate(t), y: 0 });
  }
  /**
   * @ignore
   */
  updateTooltipBounds(e) {
    const t = this.get("inside"), s = 1e5;
    let r = this._display.toGlobal({ x: 0, y: 0 }), n = r.x, a = 0, o = this.axisLength(), l = s, u = "up";
    this.get("opposite") ? t ? (u = "up", a = r.y, l = s) : (u = "down", a = r.y - s, l = s) : t ? (u = "down", a = r.y - s, l = s) : (u = "up", a = r.y, l = s);
    const c = { left: n, right: n + o, top: a, bottom: a + l }, h = e.get("bounds");
    mu(c, h) || (e.set("bounds", c), e.set("pointerOrientation", u));
  }
}
Object.defineProperty(tr, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "AxisRendererX"
});
Object.defineProperty(tr, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Vi.classNames.concat([tr.className])
});
class Mi extends Vi {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_downY", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "thumb", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: pt.new(this._root, { height: R, isMeasured: !1, themeTags: ["axis", "y", "thumb"] })
    });
  }
  _afterNew() {
    this._settings.themeTags = ie(this._settings.themeTags, ["renderer", "y"]), this._settings.opposite && this._settings.themeTags.push("opposite"), super._afterNew(), this.setPrivateRaw("letter", "Y");
    const e = this.grid.template;
    e.set("width", R), e.set("height", 0), e.set("draw", (t, s) => {
      t.moveTo(0, 0), t.lineTo(s.width(), 0);
    }), this.set("draw", (t, s) => {
      t.moveTo(0, 0), t.lineTo(0, s.height());
    });
  }
  _getPan(e, t) {
    return (e.y - t.y) / this.height();
  }
  _changed() {
    super._changed();
    const e = this.axis;
    e.ghostLabel.setPrivate("visible", !this.get("inside")), e.ghostLabel.set("y", -1e3);
    const t = this.thumb, s = "opposite", r = "inside", n = this.chart;
    if (this.isDirty(s) || this.isDirty(r)) {
      const o = e.children;
      if (this.get(r) ? e.addTag(r) : e.removeTag(r), n) {
        if (this.get(s)) {
          const l = n.rightAxesContainer.children;
          l.indexOf(e) == -1 && l.moveValue(e, 0), e.addTag(s), o.moveValue(this, 0);
        } else {
          const l = n.leftAxesContainer.children;
          l.indexOf(e) == -1 && l.moveValue(e), e.removeTag(s), o.moveValue(this);
        }
        e.ghostLabel._applyThemes(), this.labels.each((l) => {
          l._applyThemes();
        }), this.root._markDirtyRedraw();
      }
      e.markDirtySize();
    }
    var a = e.labelsContainer.width();
    n && (this.get(s) ? t.set("centerX", 0) : t.set("centerX", a)), t.setPrivate("width", a);
  }
  /**
   * @ignore
   */
  processAxis() {
    super.processAxis();
    const e = this.axis;
    e.get("height") == null && e.set("height", R);
    const t = this._root.horizontalLayout;
    e.set("layout", t), e.labelsContainer.set("height", R), e.axisHeader.set("layout", t);
  }
  _updatePositions() {
    const e = this.axis;
    e.gridContainer.set("y", e.y() - Re(e.get("centerY", 0), e.height())), e.bulletsContainer.set("x", this.x());
    const t = e.chart;
    if (t) {
      const s = t.plotContainer, r = e.axisHeader;
      let n = e.get("marginTop", 0);
      r.children.length > 0 ? (n = e.axisHeader.height(), e.set("marginTop", n + 1)) : r.set("height", n), r.setAll({ y: e.y() - n, x: -1, width: s.width() + 2 });
    }
  }
  /**
   * @ignore
   */
  axisLength() {
    return this.axis.innerHeight();
  }
  /**
   * Converts axis relative position to actual coordinate in pixels.
   *
   * @param   position  Position
   * @return            Point
   */
  positionToPoint(e) {
    return { x: 0, y: this.positionToCoordinate(e) };
  }
  /**
   * @ignore
   */
  updateLabel(e, t, s, r) {
    if (e) {
      S(t) || (t = 0);
      let n = 0.5;
      S(r) && r > 1 ? n = e.get("multiLocation", n) : n = e.get("location", n);
      const a = this.get("opposite"), o = e.get("inside", this.get("inside", !1));
      a ? (e.set("x", 0), o ? e.set("position", "absolute") : e.set("position", "relative")) : o ? (e.set("x", 0), e.set("position", "absolute")) : (e.set("x", void 0), e.set("position", "relative")), S(s) && s != t && (t = t + (s - t) * n), e.set("y", this.positionToCoordinate(t)), this.toggleVisibility(e, t, e.get("minPosition", 0), e.get("maxPosition", 1));
    }
  }
  /**
   * @ignore
   */
  updateGrid(e, t, s) {
    if (e) {
      S(t) || (t = 0);
      let r = e.get("location", 0.5);
      S(s) && s != t && (t = t + (s - t) * r), e.set("y", this.positionToCoordinate(t)), this.toggleVisibility(e, t, 0, 1);
    }
  }
  /**
   * @ignore
   */
  updateTick(e, t, s, r) {
    if (e) {
      S(t) || (t = 0);
      let n = 0.5;
      S(r) && r > 1 ? n = e.get("multiLocation", n) : n = e.get("location", n), S(s) && s != t && (t = t + (s - t) * n), e.set("y", this.positionToCoordinate(t));
      let a = e.get("length", 0);
      const o = e.get("inside", this.get("inside", !1));
      this.get("opposite") ? (e.set("x", 0), o && (a *= -1)) : o || (a *= -1), e.set("draw", (l) => {
        l.moveTo(0, 0), l.lineTo(a, 0);
      }), this.toggleVisibility(e, t, e.get("minPosition", 0), e.get("maxPosition", 1));
    }
  }
  /**
   * @ignore
   */
  updateBullet(e, t, s) {
    if (e) {
      const r = e.get("sprite");
      if (r) {
        S(t) || (t = 0);
        let n = e.get("location", 0.5);
        S(s) && s != t && (t = t + (s - t) * n);
        let a = this.axis.roundAxisPosition(t, n), o = this.axis._bullets[a], l = 1;
        if (this.get("opposite") && (l = -1), e.get("stacked"))
          if (o) {
            let u = o.get("sprite");
            u && r.set("x", u.x() + u.width() * l);
          } else
            r.set("x", 0);
        this.axis._bullets[a] = e, r.set("y", this.positionToCoordinate(t)), this.toggleVisibility(r, t, 0, 1);
      }
    }
  }
  /**
   * @ignore
   */
  updateFill(e, t, s) {
    if (e) {
      S(t) || (t = 0), S(s) || (s = 1);
      let r = this.positionToCoordinate(t), n = this.positionToCoordinate(s);
      this.fillDrawMethod(e, r, n);
    }
  }
  fillDrawMethod(e, t, s) {
    e.set("draw", (r) => {
      const n = this.axis.gridContainer.width(), a = this.height();
      s < t && ([s, t] = [t, s]), !(t > a || s < 0) && (r.moveTo(0, t), r.lineTo(n, t), r.lineTo(n, s), r.lineTo(0, s), r.lineTo(0, t));
    });
  }
  /**
   * Converts relative position (0-1) on axis to a pixel coordinate.
   *
   * @param position  Position (0-1)
   * @return Coordinate (px)
   */
  positionToCoordinate(e) {
    return this._inversed ? (e - this._start) * this._axisLength : (this._end - e) * this._axisLength;
  }
  /**
   * @ignore
   */
  positionTooltip(e, t) {
    this._positionTooltip(e, { x: 0, y: this.positionToCoordinate(t) });
  }
  /**
   * @ignore
   */
  updateTooltipBounds(e) {
    const t = this.get("inside"), s = 1e5;
    let r = this._display.toGlobal({ x: 0, y: 0 }), n = r.y, a = 0, o = this.axisLength(), l = s, u = "right";
    this.get("opposite") ? t ? (u = "right", a = r.x - s, l = s) : (u = "left", a = r.x, l = s) : t ? (u = "left", a = r.x, l = s) : (u = "right", a = r.x - s, l = s);
    const c = { left: a, right: a + l, top: n, bottom: n + o }, h = e.get("bounds");
    mu(c, h) || (e.set("bounds", c), e.set("pointerOrientation", u));
  }
  _updateLC() {
    const e = this.axis, t = e.parent;
    if (t) {
      const s = t.innerHeight();
      this._lc = this.axisLength() / s, this._ls = e.y() / s;
    }
  }
  /**
   * @ignore
   */
  toAxisPosition(e) {
    const t = this._start || 0, s = this._end || 1;
    return e -= this._ls, e = e * (s - t) / this._lc, this.get("inversed") ? e = t + e : e = s - e, e;
  }
  /**
   * @ignore
   */
  fixPosition(e) {
    return this.get("inversed") ? e : 1 - e;
  }
}
Object.defineProperty(Mi, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "AxisRendererY"
});
Object.defineProperty(Mi, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Vi.classNames.concat([Mi.className])
});
class Ui extends et {
  _beforeChanged() {
    super._beforeChanged(), (this.isDirty("lowX0") || this.isDirty("lowY0") || this.isDirty("lowX1") || this.isDirty("lowY1") || this.isDirty("highX0") || this.isDirty("highX1") || this.isDirty("highY0") || this.isDirty("highY1")) && (this._clear = !0);
  }
  _draw() {
    super._draw();
    const e = this._display;
    e.moveTo(this.get("lowX0", 0), this.get("lowY0", 0)), e.lineTo(this.get("lowX1", 0), this.get("lowY1", 0)), e.moveTo(this.get("highX0", 0), this.get("highY0", 0)), e.lineTo(this.get("highX1", 0), this.get("highY1", 0));
  }
}
Object.defineProperty(Ui, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "Candlestick"
});
Object.defineProperty(Ui, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: et.classNames.concat([Ui.className])
});
class Wi extends Hi {
  constructor() {
    super(...arguments), Object.defineProperty(this, "columns", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new ze(me.new({}), () => et._new(this._root, {
        position: "absolute",
        themeTags: ie(this.columns.template.get("themeTags", []), ["series", "column"])
      }, [this.columns.template]))
    });
  }
  /**
   * @ignore
   */
  makeColumn(e, t) {
    const s = this.mainContainer.children.push(t.make());
    return s._setDataItem(e), t.push(s), s;
  }
  _processAxisRange(e) {
    super._processAxisRange(e), e.columns = new ze(me.new({}), () => et._new(this._root, {
      position: "absolute",
      themeTags: ie(e.columns.template.get("themeTags", []), ["series", "column"])
    }, [this.columns.template, e.columns.template]));
  }
}
Object.defineProperty(Wi, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "ColumnSeries"
});
Object.defineProperty(Wi, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Hi.classNames.concat([Wi.className])
});
class Gi extends Wi {
  constructor() {
    super(...arguments), Object.defineProperty(this, "columns", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new ze(me.new({
        themeTags: ["autocolor"]
      }), () => Ui._new(this._root, {
        themeTags: ie(this.columns.template.get("themeTags", []), ["candlestick", "series", "column"])
      }, [this.columns.template]))
    });
  }
  /**
   * @ignore
   */
  makeColumn(e, t) {
    const s = this.mainContainer.children.push(t.make());
    return s._setDataItem(e), t.push(s), s;
  }
  _updateGraphics(e, t) {
    super._updateGraphics(e, t);
    const s = this.getRaw("xAxis"), r = this.getRaw("yAxis"), n = this.getRaw("baseAxis");
    let a = this.get("vcy", 1), o = this.get("vcx", 1), l, u, c, h, d, f, g, p, _ = this.get("locationX", e.get("locationX", 0.5)), m = this.get("locationY", e.get("locationY", 0.5)), v = this.get("openLocationX", e.get("openLocationX", _)), b = this.get("openLocationY", e.get("openLocationY", m)), y;
    if (r === n) {
      let x = s.getDataItemPositionX(e, this._xOpenField, 1, o), D = s.getDataItemPositionX(e, this._xField, 1, o);
      u = s.getDataItemPositionX(e, this._xLowField, 1, o), f = s.getDataItemPositionX(e, this._xHighField, 1, o), d = Math.max(x, D), l = Math.min(x, D);
      let A = this._aLocationY0 + b - 0.5, T = this._aLocationY1 + m - 0.5;
      c = r.getDataItemPositionY(e, this._yField, A + (T - A) / 2, a), h = c, g = c, p = c, y = "horizontal";
    } else {
      let x = r.getDataItemPositionY(e, this._yOpenField, 1, a), D = r.getDataItemPositionY(e, this._yField, 1, a);
      h = r.getDataItemPositionY(e, this._yLowField, 1, a), p = r.getDataItemPositionY(e, this._yHighField, 1, a), g = Math.max(x, D), c = Math.min(x, D);
      let A = this._aLocationX0 + v - 0.5, T = this._aLocationX1 + _ - 0.5;
      l = s.getDataItemPositionX(e, this._xField, A + (T - A) / 2, o), u = l, d = l, f = l, y = "vertical";
    }
    this._updateCandleGraphics(e, l, u, c, h, d, f, g, p, y);
  }
  _updateCandleGraphics(e, t, s, r, n, a, o, l, u, c) {
    let h = e.get("graphics");
    if (h) {
      let d = this.getPoint(t, r), f = this.getPoint(s, n), g = this.getPoint(a, l), p = this.getPoint(o, u), _ = h.x(), m = h.y();
      h.set("lowX0", d.x - _), h.set("lowY0", d.y - m), h.set("lowX1", f.x - _), h.set("lowY1", f.y - m), h.set("highX0", g.x - _), h.set("highY0", g.y - m), h.set("highX1", p.x - _), h.set("highY1", p.y - m), h.set("orientation", c);
      let v = e.get("rangeGraphics");
      v && w(v, (b) => {
        b.set("lowX0", d.x - _), b.set("lowY0", d.y - m), b.set("lowX1", f.x - _), b.set("lowY1", f.y - m), b.set("highX0", g.x - _), b.set("highY0", g.y - m), b.set("highX1", p.x - _), b.set("highY1", p.y - m), b.set("orientation", c);
      });
    }
  }
  _processAxisRange(e) {
    super._processAxisRange(e), e.columns = new ze(me.new({}), () => Ui._new(this._root, {
      themeTags: ie(e.columns.template.get("themeTags", []), ["candlestick", "series", "column"])
    }, [this.columns.template, e.columns.template]));
  }
}
Object.defineProperty(Gi, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "CandlestickSeries"
});
Object.defineProperty(Gi, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Wi.classNames.concat([Gi.className])
});
class ir extends Ui {
  _draw() {
    const e = this._display;
    e.moveTo(this.get("lowX1", 0), this.get("lowY1", 0)), e.lineTo(this.get("highX1", 0), this.get("highY1", 0));
    let t = this.width(), s = this.height();
    if (this.get("orientation") == "vertical") {
      let r = s, n = 0;
      e.moveTo(0, r), e.lineTo(t / 2, r), e.moveTo(t / 2, n), e.lineTo(t, n);
    } else {
      let r = 0, n = t;
      e.moveTo(r, 0), e.lineTo(r, s / 2), e.moveTo(n, s / 2), e.lineTo(n, s);
    }
  }
}
Object.defineProperty(ir, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "OHLC"
});
Object.defineProperty(ir, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Ui.classNames.concat([ir.className])
});
class xa extends Gi {
  constructor() {
    super(...arguments), Object.defineProperty(this, "columns", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new ze(me.new({
        themeTags: ["autocolor"]
      }), () => ir._new(this._root, {
        themeTags: ie(this.columns.template.get("themeTags", []), ["ohlc", "series", "column"])
      }, [this.columns.template]))
    });
  }
  /**
   * @ignore
   */
  makeColumn(e, t) {
    const s = this.mainContainer.children.push(t.make());
    return s._setDataItem(e), t.push(s), s;
  }
  _processAxisRange(e) {
    super._processAxisRange(e), e.columns = new ze(me.new({}), () => ir._new(this._root, {
      themeTags: ie(e.columns.template.get("themeTags", []), ["ohlc", "series", "column"])
    }, [this.columns.template, e.columns.template]));
  }
}
Object.defineProperty(xa, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "OHLCSeries"
});
Object.defineProperty(xa, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Gi.classNames.concat([xa.className])
});
class ot extends Bi {
  constructor() {
    super(...arguments), Object.defineProperty(this, "_endIndex", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_strokeGenerator", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Rd()
    }), Object.defineProperty(this, "_fillGenerator", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Ww()
    }), Object.defineProperty(this, "_legendStroke", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_legendFill", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "strokes", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new ze(me.new({}), () => le._new(this._root, {
        themeTags: ie(this.strokes.template.get("themeTags", []), ["line", "series", "stroke"])
      }, [this.strokes.template]))
    }), Object.defineProperty(this, "fills", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: new ze(me.new({}), () => le._new(this._root, {
        themeTags: ie(this.strokes.template.get("themeTags", []), ["line", "series", "fill"])
      }, [this.fills.template]))
    }), Object.defineProperty(this, "_fillTemplate", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_strokeTemplate", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_previousPoint", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: [0, 0, 0, 0]
    }), Object.defineProperty(this, "_dindex", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_sindex", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    });
  }
  _afterNew() {
    this._fillGenerator.y0(function(e) {
      return e[3];
    }), this._fillGenerator.x0(function(e) {
      return e[2];
    }), this._fillGenerator.y1(function(e) {
      return e[1];
    }), this._fillGenerator.x1(function(e) {
      return e[0];
    }), super._afterNew();
  }
  /**
   * @ignore
   */
  makeStroke(e) {
    const t = this.mainContainer.children.push(e.make());
    return e.push(t), t;
  }
  /**
   * @ignore
   */
  makeFill(e) {
    const t = this.mainContainer.children.push(e.make());
    return e.push(t), t;
  }
  _updateChildren() {
    this._strokeTemplate = void 0, this._fillTemplate = void 0;
    let e = this.get("xAxis"), t = this.get("yAxis");
    if (this.isDirty("stroke")) {
      const s = this.get("stroke");
      this.strokes.template.set("stroke", s);
      const r = this._legendStroke;
      r && r.states.lookup("default").set("stroke", s);
    }
    if (this.isDirty("fill")) {
      const s = this.get("fill");
      this.fills.template.set("fill", s);
      const r = this._legendFill;
      r && r.states.lookup("default").set("fill", s);
    }
    if (this.isDirty("curveFactory")) {
      const s = this.get("curveFactory");
      s && (this._strokeGenerator.curve(s), this._fillGenerator.curve(s));
    }
    if (e.inited && t.inited) {
      if (this._axesDirty || this._valuesDirty || this._stackDirty || this.isDirty("vcx") || this.isDirty("vcy") || this._sizeDirty || this.isDirty("connect") || this.isDirty("curveFactory")) {
        this.fills.each((c) => {
          c.setPrivate("visible", !1);
        }), this.strokes.each((c) => {
          c.setPrivate("visible", !1);
        }), this.axisRanges.each((c) => {
          let h = c.fills;
          h && h.each((f) => {
            f.setPrivate("visible", !1);
          });
          let d = c.strokes;
          d && d.each((f) => {
            f.setPrivate("visible", !1);
          });
        });
        let s = this.startIndex(), r = this.strokes.template.get("templateField"), n = this.fills.template.get("templateField"), a = !0, o = !0;
        r && (a = !1), n && (o = !1);
        for (let c = s - 1; c >= 0; c--) {
          let h = this.dataItems[c], d = !0, f = h.dataContext;
          if (r && f[r] && (a = !0), n && f[n] && (o = !0), w(this._valueFields, (g) => {
            S(h.get(g)) || (d = !1);
          }), d && a && o) {
            s = c;
            break;
          }
        }
        let l = this.dataItems.length, u = this.endIndex();
        if (u < l) {
          u++;
          for (let c = u; c < l; c++) {
            let h = this.dataItems[c], d = !0;
            if (w(this._valueFields, (f) => {
              S(h.get(f)) || (d = !1);
            }), d) {
              u = c + 1;
              break;
            }
          }
        }
        if (s > 0 && s--, this._endIndex = u, this._clearGraphics(), this._sindex = 0, this._dindex = s, this.dataItems.length == 1)
          this._startSegment(0);
        else
          for (; this._dindex < u - 1; )
            this._startSegment(this._dindex), this._sindex++;
      }
    } else
      this._skipped = !0;
    super._updateChildren();
  }
  _clearGraphics() {
    this.strokes.clear(), this.fills.clear();
  }
  _startSegment(e) {
    let t = this._endIndex, s = t;
    const r = this.get("autoGapCount"), n = this.get("connect"), a = this.makeFill(this.fills), o = this._fillTemplate, l = this.fills.template;
    o && o != l && (a.template = o), a.setPrivate("visible", !0);
    const u = this.makeStroke(this.strokes), c = this._strokeTemplate;
    c && c != this.strokes.template && (u.template = c), u.setPrivate("visible", !0);
    let h = this.get("xAxis"), d = this.get("yAxis"), f = this.get("baseAxis"), g = this.get("vcx", 1), p = this.get("vcy", 1), _ = this._xField, m = this._yField, v = this._xOpenField, b = this._yOpenField;
    const y = this.get("openValueXField"), x = this.get("openValueYField");
    y || (v = this._xField), x || (b = this._yField);
    const D = this.get("stacked"), A = h.basePosition(), T = d.basePosition();
    let j;
    f === d ? j = this._yField : j = this._xField;
    const C = [];
    let L = [];
    C.push(L);
    const E = this.strokes.template.get("templateField"), N = this.fills.template.get("templateField");
    let q = this.get("locationX", 0.5), z = this.get("locationY", 0.5), H = this.get("openLocationX", q), Y = this.get("openLocationY", z);
    const W = this.get("minDistance", 0);
    let B, oe = this.fills.template.get("visible");
    this.axisRanges.length > 0 && (oe = !0);
    let O = !1;
    (D || y || x) && (O = !0);
    const k = {
      points: L,
      segments: C,
      stacked: D,
      getOpen: O,
      basePosX: A,
      basePosY: T,
      fillVisible: oe,
      xField: _,
      yField: m,
      xOpenField: v,
      yOpenField: b,
      vcx: g,
      vcy: p,
      baseAxis: f,
      xAxis: h,
      yAxis: d,
      locationX: q,
      locationY: z,
      openLocationX: H,
      openLocationY: Y,
      minDistance: W
    };
    for (B = e; B < s; B++) {
      this._dindex = B;
      const M = this._dataItems[B];
      let $ = M.get(_), J = M.get(m);
      if ($ == null || J == null ? n || (L = [], C.push(L), k.points = L) : this._getPoints(M, k), E) {
        let U = M.dataContext[E];
        if (U)
          if (U instanceof me || (U = me.new(U)), this._strokeTemplate = U, B > e) {
            s = B;
            break;
          } else
            u.template = U;
      }
      if (N) {
        let U = M.dataContext[N];
        if (U)
          if (U instanceof me || (U = me.new(U)), this._fillTemplate = U, B > e) {
            s = B;
            break;
          } else
            a.template = U;
      }
      if (!n) {
        let U = this.dataItems[B + 1];
        U && f.shouldGap(M, U, r, j) && (L = [], C.push(L), k.points = L);
      }
    }
    a.setRaw("userData", [e, B]), u.setRaw("userData", [e, B]), B === t && this._endLine(L, C[0][0]), u && this._drawStroke(u, C), a && this._drawFill(a, C), this.axisRanges.each((M) => {
      const $ = M.container, J = M.fills, U = this.makeFill(J);
      $ && $.children.push(U), U.setPrivate("visible", !0), this._drawFill(U, C);
      const de = M.strokes, ve = this.makeStroke(de);
      $ && $.children.push(ve), ve.setPrivate("visible", !0), this._drawStroke(ve, C), U.setRaw("userData", [e, B]), ve.setRaw("userData", [e, B]);
    });
  }
  _getPoints(e, t) {
    let s = t.points, r = e.get("locationX", t.locationX), n = e.get("locationY", t.locationY), a = t.xAxis.getDataItemPositionX(e, t.xField, r, t.vcx), o = t.yAxis.getDataItemPositionY(e, t.yField, n, t.vcy);
    if (this._shouldInclude(a)) {
      const l = this.getPoint(a, o), u = [l.x, l.y];
      if (l.x += this._x, l.y += this._y, e.set("point", l), t.fillVisible) {
        let c = a, h = o;
        if (t.baseAxis === t.xAxis ? h = t.basePosY : t.baseAxis === t.yAxis && (c = t.basePosX), t.getOpen) {
          let f = e.get(t.xOpenField), g = e.get(t.yOpenField);
          if (f != null && g != null) {
            let p = e.get("openLocationX", t.openLocationX), _ = e.get("openLocationY", t.openLocationY);
            if (t.stacked) {
              let m = e.get("stackToItemX"), v = e.get("stackToItemY");
              m ? (c = t.xAxis.getDataItemPositionX(m, t.xField, p, m.component.get("vcx")), $t(c) && (c = t.basePosX)) : t.yAxis === t.baseAxis ? c = t.basePosX : c = t.xAxis.getDataItemPositionX(e, t.xOpenField, p, t.vcx), v ? (h = t.yAxis.getDataItemPositionY(v, t.yField, _, v.component.get("vcy")), $t(h) && (h = t.basePosY)) : t.xAxis === t.baseAxis ? h = t.basePosY : h = t.yAxis.getDataItemPositionY(e, t.yOpenField, _, t.vcy);
            } else
              c = t.xAxis.getDataItemPositionX(e, t.xOpenField, p, t.vcx), h = t.yAxis.getDataItemPositionY(e, t.yOpenField, _, t.vcy);
          }
        }
        let d = this.getPoint(c, h);
        u[2] = d.x, u[3] = d.y;
      }
      if (t.minDistance > 0) {
        const c = u[0], h = u[1], d = u[2], f = u[3], g = this._previousPoint, p = g[0], _ = g[1], m = g[2], v = g[3];
        (Math.hypot(c - p, h - _) > t.minDistance || d && f && Math.hypot(d - m, f - v) > t.minDistance) && (s.push(u), this._previousPoint = u);
      } else
        s.push(u);
    }
  }
  _endLine(e, t) {
  }
  _drawStroke(e, t) {
    e.get("visible") && !e.get("forceHidden") && e.set("draw", (s) => {
      w(t, (r) => {
        this._strokeGenerator.context(s), this._strokeGenerator(r);
      });
    });
  }
  _drawFill(e, t) {
    e.get("visible") && !e.get("forceHidden") && e.set("draw", (s) => {
      w(t, (r) => {
        this._fillGenerator.context(s), this._fillGenerator(r);
      });
    });
  }
  _processAxisRange(e) {
    super._processAxisRange(e), e.fills = new ze(me.new({}), () => le._new(this._root, {
      themeTags: ie(e.fills.template.get("themeTags", []), ["line", "series", "fill"])
    }, [this.fills.template, e.fills.template])), e.strokes = new ze(me.new({}), () => le._new(this._root, {
      themeTags: ie(e.strokes.template.get("themeTags", []), ["line", "series", "stroke"])
    }, [this.strokes.template, e.strokes.template]));
  }
  /**
   * @ignore
   */
  createLegendMarker(e) {
    const t = this.get("legendDataItem");
    if (t) {
      const s = t.get("marker"), r = t.get("markerRectangle");
      r && r.setPrivate("visible", !1), s.set("background", pt.new(s._root, { fillOpacity: 0, fill: pe(0) }));
      const n = s.children.push(le._new(s._root, {
        themeTags: ["line", "series", "legend", "marker", "stroke"],
        interactive: !1
      }, [this.strokes.template]));
      this._legendStroke = n;
      const a = s.children.push(le._new(s._root, {
        themeTags: ["line", "series", "legend", "marker", "fill"]
      }, [this.fills.template]));
      this._legendFill = a;
      const o = this._root.interfaceColors.get("disabled");
      if (n.states.create("disabled", { fill: o, stroke: o }), a.states.create("disabled", { fill: o, stroke: o }), this.bullets.length > 0) {
        const l = this.bullets.getIndex(0);
        if (l) {
          const u = l(s._root, this, new Gt(this, {}, {}));
          if (u) {
            const c = u.get("sprite");
            c instanceof le && c.states.create("disabled", { fill: o, stroke: o }), c && (c.set("tooltipText", void 0), c.set("tooltipHTML", void 0), s.children.push(c), c.setAll({ x: s.width() / 2, y: s.height() / 2 }));
          }
        }
      }
    }
  }
}
Object.defineProperty(ot, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "LineSeries"
});
Object.defineProperty(ot, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: Bi.classNames.concat([ot.className])
});
class sS {
  constructor(e, t) {
    Object.defineProperty(this, "_line", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_point", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_context", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_x0", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_x1", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_y0", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_y1", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_t0", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_tension", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), this._context = e, this._tension = t;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN, this._point = 0;
  }
  lineEnd() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        mo(this, this._t0, sh(this, this._t0));
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  }
  point(e, t) {
    [e, t] = [t, e];
    let s = NaN;
    if (e = +e, t = +t, !(e === this._x1 && t === this._y1)) {
      switch (this._point) {
        case 0:
          this._point = 1, this._line ? this._context.lineTo(t, e) : this._context.moveTo(t, e);
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3, mo(this, sh(this, s = ih(this, e, t)), s);
          break;
        default:
          mo(this, this._t0, s = ih(this, e, t));
          break;
      }
      this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t, this._t0 = s;
    }
  }
}
function ul(i) {
  function e(t) {
    return new sS(t, i);
  }
  return e.tension = function(t) {
    return ul(+t);
  }, e;
}
function th(i) {
  return i < 0 ? -1 : 1;
}
function ih(i, e, t) {
  let s = i._x1 - i._x0, r = e - i._x1, n = (i._y1 - i._y0) / (s || r < 0 && -0), a = (t - i._y1) / (r || s < 0 && -0), o = (n * r + a * s) / (s + r);
  return (th(n) + th(a)) * Math.min(Math.abs(n), Math.abs(a), 0.5 * Math.abs(o)) || 0;
}
function sh(i, e) {
  let t = i._x1 - i._x0;
  return t ? (3 * (i._y1 - i._y0) / t - e) / 2 : e;
}
function mo(i, e, t) {
  let s = i._x0, r = i._y0, n = i._x1, a = i._y1, o = (n - s) / 1.5 * (1 - i._tension);
  i._context.bezierCurveTo(r + o * e, s + o, a - o * t, n - o, a, n);
}
class wa extends ot {
  _afterNew() {
    this._setDefault("curveFactory", ul(this.get("tension", 0.5))), super._afterNew();
  }
  _updateChildren() {
    this.isDirty("tension") && (this.set("curveFactory", ul(this.get("tension", 0.5))), this._valuesDirty = !0), super._updateChildren();
  }
}
Object.defineProperty(wa, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "SmoothedYLineSeries"
});
Object.defineProperty(wa, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: ot.classNames.concat([wa.className])
});
class rS {
  constructor(e, t) {
    Object.defineProperty(this, "_line", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_point", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_context", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "_x0", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_x1", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_y0", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_y1", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_t0", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), Object.defineProperty(this, "_tension", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 0
    }), this._context = e, this._tension = t;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN, this._point = 0;
  }
  lineEnd() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        bo(this, this._t0, oh(this, this._t0));
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  }
  point(e, t) {
    let s = NaN;
    if (e = +e, t = +t, !(e === this._x1 && t === this._y1)) {
      switch (this._point) {
        case 0:
          this._point = 1, this._line ? this._context.lineTo(e, t) : this._context.moveTo(e, t);
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3, bo(this, oh(this, s = ah(this, e, t)), s);
          break;
        default:
          bo(this, this._t0, s = ah(this, e, t));
          break;
      }
      this._x0 = this._x1, this._x1 = e, this._y0 = this._y1, this._y1 = t, this._t0 = s;
    }
  }
}
function rh(i) {
  function e(t) {
    return new rS(t, i);
  }
  return e;
}
function nh(i) {
  return i < 0 ? -1 : 1;
}
function ah(i, e, t) {
  let s = i._x1 - i._x0, r = e - i._x1, n = (i._y1 - i._y0) / (s || r < 0 && -0), a = (t - i._y1) / (r || s < 0 && -0), o = (n * r + a * s) / (s + r);
  return (nh(n) + nh(a)) * Math.min(Math.abs(n), Math.abs(a), 0.5 * Math.abs(o)) || 0;
}
function oh(i, e) {
  let t = i._x1 - i._x0;
  return t ? (3 * (i._y1 - i._y0) / t - e) / 2 : e;
}
function bo(i, e, t) {
  let s = i._x0, r = i._y0, n = i._x1, a = i._y1, o = (n - s) / 1.5 * (1 - i._tension);
  i._context.bezierCurveTo(s + o, r + o * e, n - o, a - o * t, n, a);
}
class Zr extends ot {
  _afterNew() {
    this._setDefault("curveFactory", rh(this.get("tension", 0.5))), super._afterNew();
  }
  _updateChildren() {
    this.isDirty("tension") && (this.set("curveFactory", rh(this.get("tension", 0.5))), this._valuesDirty = !0), super._updateChildren();
  }
}
Object.defineProperty(Zr, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "SmoothedXLineSeries"
});
Object.defineProperty(Zr, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: ot.classNames.concat([Zr.className])
});
class Sa extends ot {
  _afterNew() {
    this._setDefault("curveFactory", eh.tension(this.get("tension", 0.5))), super._afterNew();
  }
  _updateChildren() {
    this.isDirty("tension") && (this.set("curveFactory", eh.tension(this.get("tension", 0.5))), this._valuesDirty = !0), super._updateChildren();
  }
}
Object.defineProperty(Sa, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "SmoothedXYLineSeries"
});
Object.defineProperty(Sa, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: ot.classNames.concat([Sa.className])
});
class Da extends ot {
  _afterNew() {
    this._setDefault("curveFactory", Gw), super._afterNew();
  }
  _getPoints(e, t) {
    let s = t.points, r = this.get("stepWidth", R).value / 2, n = e.get("locationX", t.locationX), a = e.get("locationY", t.locationY), o = n, l = a;
    t.baseAxis === t.xAxis ? (n -= r, o += r) : t.baseAxis === t.yAxis && (a -= r, l += r);
    let u = t.xAxis.getDataItemPositionX(e, t.xField, n, t.vcx), c = t.yAxis.getDataItemPositionY(e, t.yField, a, t.vcy), h = t.xAxis.getDataItemPositionX(e, t.xField, o, t.vcx), d = t.yAxis.getDataItemPositionY(e, t.yField, l, t.vcy);
    if (this._shouldInclude(u)) {
      const f = this.getPoint(u, c), g = [f.x, f.y], p = this.getPoint(h, d), _ = [p.x, p.y];
      if (t.fillVisible) {
        let m = u, v = c, b = h, y = d;
        if (t.baseAxis === t.xAxis ? (v = t.basePosY, y = t.basePosY) : t.baseAxis === t.yAxis && (m = t.basePosX, b = t.basePosX), t.getOpen) {
          let A = e.get(t.xOpenField), T = e.get(t.yOpenField);
          if (A != null && T != null)
            if (n = e.get("openLocationX", t.openLocationX), a = e.get("openLocationY", t.openLocationY), o = n, l = a, t.baseAxis === t.xAxis ? (n -= r, o += r) : t.baseAxis === t.yAxis && (a -= r, l += r), t.stacked) {
              let j = e.get("stackToItemX"), C = e.get("stackToItemY");
              j ? (m = t.xAxis.getDataItemPositionX(j, t.xField, n, j.component.get("vcx")), b = t.xAxis.getDataItemPositionX(j, t.xField, o, j.component.get("vcx"))) : t.yAxis === t.baseAxis ? (m = t.basePosX, b = t.basePosX) : t.baseAxis === t.yAxis && (m = t.xAxis.getDataItemPositionX(e, t.xOpenField, n, t.vcx), b = t.xAxis.getDataItemPositionX(e, t.xOpenField, o, t.vcx)), C ? (v = t.yAxis.getDataItemPositionY(C, t.yField, a, C.component.get("vcy")), y = t.yAxis.getDataItemPositionY(C, t.yField, l, C.component.get("vcy"))) : t.xAxis === t.baseAxis ? (v = t.basePosY, y = t.basePosY) : t.baseAxis === t.yAxis && (v = t.yAxis.getDataItemPositionY(e, t.yOpenField, a, t.vcy), y = t.yAxis.getDataItemPositionY(e, t.yOpenField, l, t.vcy));
            } else
              m = t.xAxis.getDataItemPositionX(e, t.xOpenField, n, t.vcx), v = t.yAxis.getDataItemPositionY(e, t.yOpenField, a, t.vcy), b = t.xAxis.getDataItemPositionX(e, t.xOpenField, o, t.vcx), y = t.yAxis.getDataItemPositionY(e, t.yOpenField, l, t.vcy);
        }
        let x = this.getPoint(m, v), D = this.getPoint(b, y);
        g[2] = x.x, g[3] = x.y, _[2] = D.x, _[3] = D.y;
      }
      s.push(g), s.push(_), e.set("point", { x: g[0] + (_[0] - g[0]) / 2, y: g[1] + (_[1] - g[1]) / 2 });
    }
    this.get("noRisers") && (t.points = [], t.segments.push(s));
  }
}
Object.defineProperty(Da, "className", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: "StepLineSeries"
});
Object.defineProperty(Da, "classNames", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: ot.classNames.concat([Da.className])
});
const xs = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Axis: zi,
  AxisBullet: ya,
  AxisLabel: Wr,
  AxisLabelRadial: va,
  AxisRenderer: Vi,
  AxisRendererX: tr,
  AxisRendererY: Mi,
  AxisTick: Gr,
  BaseColumnSeries: Hi,
  Candlestick: Ui,
  CandlestickSeries: Gi,
  CategoryAxis: mi,
  CategoryDateAxis: _a,
  ColumnSeries: Wi,
  DateAxis: er,
  DefaultTheme: Bd,
  DurationAxis: ba,
  GaplessDateAxis: ma,
  Grid: ms,
  LineSeries: ot,
  OHLC: ir,
  OHLCSeries: xa,
  SmoothedXLineSeries: Zr,
  SmoothedXYLineSeries: Sa,
  SmoothedYLineSeries: wa,
  StepLineSeries: Da,
  ValueAxis: Xi,
  XYChart: Js,
  XYChartScrollbar: Vr,
  XYCursor: Ur,
  XYSeries: Bi
}, Symbol.toStringTag, { value: "Module" }));
class nS extends rn {
  setupDefaultRules() {
    super.setupDefaultRules(), this.rule("Component").setAll({
      interpolationDuration: 600
    }), this.rule("Hierarchy").set("animationDuration", 600), this.rule("Scrollbar").set("animationDuration", 600), this.rule("Tooltip").set("animationDuration", 300), this.rule("MapChart").set("animationDuration", 1e3), this.rule("MapChart").set("wheelDuration", 300), this.rule("Entity").setAll({
      stateAnimationDuration: 600
    }), this.rule("Sprite").states.create("default", { stateAnimationDuration: 600 }), this.rule("Tooltip", ["axis"]).setAll({
      animationDuration: 200
    }), this.rule("WordCloud").set("animationDuration", 500);
  }
}
const aS = "_filter_1nevh_44", oS = "_icon_size_1nevh_47", lS = "_edit_1nevh_58", uS = "_trash_1nevh_64", hS = "_clone_1nevh_70", cS = "_check_1nevh_76", dS = "_previous_1nevh_88", fS = "_add_1nevh_116", pS = "_remove_1nevh_119", gS = "_download_1nevh_180", _S = "_next_1nevh_135", mS = "_expand_1nevh_250", yo = {
  default: "_default_1nevh_7",
  "customizing-data-table": "_customizing-data-table_1nevh_25",
  filter: aS,
  icon_size: oS,
  "custom-colum": "_custom-colum_1nevh_51",
  "kebab-menu": "_kebab-menu_1nevh_54",
  edit: lS,
  trash: uS,
  clone: hS,
  check: cS,
  previous: dS,
  "left-arrow": "_left-arrow_1nevh_102",
  add: fS,
  remove: pS,
  "row-inline-action-buttons": "_row-inline-action-buttons_1nevh_122",
  "next-previous-buttons": "_next-previous-buttons_1nevh_135",
  "plus-button": "_plus-button_1nevh_155",
  "minus-button": "_minus-button_1nevh_172",
  download: gS,
  next: _S,
  "arrow-backward-skinny": "_arrow-backward-skinny_1nevh_204",
  "arrow-forward-skinny": "_arrow-forward-skinny_1nevh_214",
  "arrow-backward": "_arrow-backward_1nevh_204",
  "arrow-forward": "_arrow-forward_1nevh_214",
  "bar-filter": "_bar-filter_1nevh_244",
  expand: mS
}, bS = {
  name: "icon-button",
  props: {
    styleProps: {
      type: String,
      default: ""
    },
    clickHandler: Function,
    active: Boolean,
    disabled: Boolean,
    buttonType: {
      type: String,
      default: "filter"
    },
    iconUrl: {
      type: String
    }
  },
  computed: {
    buttonClassComputed() {
      return `${yo.default} ${yo[this.buttonType]} ${yo[this.classTypeForButton]} `;
    },
    classTypeForButton() {
      switch (this.buttonType) {
        case "filter":
        case "download":
        case "custom-colum":
        case "kebab-menu":
          return "customizing-data-table";
        case "edit":
        case "trash":
        case "check":
        case "clone":
          return "row-inline-action-buttons";
        case "add":
          return "plus-button";
        case "remove":
          return "minus-button";
        default:
          return "";
      }
    }
  },
  methods: {
    executor() {
      this.clickHandler && this.clickHandler();
    }
  }
};
var yS = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    class: i.buttonClassComputed,
    style: i.styleProps,
    attrs: {
      active: i.active,
      disabled: i.disabled
    },
    on: {
      click: i.executor
    }
  }, [t("div", {
    class: i.$style.icon_size
  }, [i.buttonType === "custom-button" ? t("img", {
    attrs: {
      src: i.iconUrl,
      alt: "icon"
    }
  }) : t("img", {
    attrs: {
      src: "#",
      alt: "icon"
    }
  })])]);
}, vS = [];
const xS = "_filter_1nevh_44", wS = "_icon_size_1nevh_47", SS = "_edit_1nevh_58", DS = "_trash_1nevh_64", PS = "_clone_1nevh_70", TS = "_check_1nevh_76", kS = "_previous_1nevh_88", CS = "_add_1nevh_116", MS = "_remove_1nevh_119", OS = "_download_1nevh_180", AS = "_next_1nevh_135", LS = "_expand_1nevh_250", jS = {
  default: "_default_1nevh_7",
  "customizing-data-table": "_customizing-data-table_1nevh_25",
  filter: xS,
  icon_size: wS,
  "custom-colum": "_custom-colum_1nevh_51",
  "kebab-menu": "_kebab-menu_1nevh_54",
  edit: SS,
  trash: DS,
  clone: PS,
  check: TS,
  previous: kS,
  "left-arrow": "_left-arrow_1nevh_102",
  add: CS,
  remove: MS,
  "row-inline-action-buttons": "_row-inline-action-buttons_1nevh_122",
  "next-previous-buttons": "_next-previous-buttons_1nevh_135",
  "plus-button": "_plus-button_1nevh_155",
  "minus-button": "_minus-button_1nevh_172",
  download: OS,
  next: AS,
  "arrow-backward-skinny": "_arrow-backward-skinny_1nevh_204",
  "arrow-forward-skinny": "_arrow-forward-skinny_1nevh_214",
  "arrow-backward": "_arrow-backward_1nevh_204",
  "arrow-forward": "_arrow-forward_1nevh_214",
  "bar-filter": "_bar-filter_1nevh_244",
  expand: LS
}, hl = {};
hl.$style = jS;
var ES = /* @__PURE__ */ te(
  bS,
  yS,
  vS,
  !1,
  IS,
  "2883deae",
  null,
  null
);
function IS(i) {
  for (let e in hl)
    this[e] = hl[e];
}
const Hd = /* @__PURE__ */ function() {
  return ES.exports;
}();
var YS = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function RS(i) {
  return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i;
}
function NS(i) {
  if (i.__esModule)
    return i;
  var e = i.default;
  if (typeof e == "function") {
    var t = function s() {
      if (this instanceof s) {
        var r = [null];
        r.push.apply(r, arguments);
        var n = Function.bind.apply(e, r);
        return new n();
      }
      return e.apply(this, arguments);
    };
    t.prototype = e.prototype;
  } else
    t = {};
  return Object.defineProperty(t, "__esModule", { value: !0 }), Object.keys(i).forEach(function(s) {
    var r = Object.getOwnPropertyDescriptor(i, s);
    Object.defineProperty(t, s, r.get ? r : {
      enumerable: !0,
      get: function() {
        return i[s];
      }
    });
  }), t;
}
var $S = function(e) {
  return FS(e) && !BS(e);
};
function FS(i) {
  return !!i && typeof i == "object";
}
function BS(i) {
  var e = Object.prototype.toString.call(i);
  return e === "[object RegExp]" || e === "[object Date]" || XS(i);
}
var HS = typeof Symbol == "function" && Symbol.for, zS = HS ? Symbol.for("react.element") : 60103;
function XS(i) {
  return i.$$typeof === zS;
}
function VS(i) {
  return Array.isArray(i) ? [] : {};
}
function Kr(i, e) {
  return e.clone !== !1 && e.isMergeableObject(i) ? sr(VS(i), i, e) : i;
}
function US(i, e, t) {
  return i.concat(e).map(function(s) {
    return Kr(s, t);
  });
}
function WS(i, e) {
  if (!e.customMerge)
    return sr;
  var t = e.customMerge(i);
  return typeof t == "function" ? t : sr;
}
function GS(i) {
  return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(i).filter(function(e) {
    return Object.propertyIsEnumerable.call(i, e);
  }) : [];
}
function lh(i) {
  return Object.keys(i).concat(GS(i));
}
function zd(i, e) {
  try {
    return e in i;
  } catch {
    return !1;
  }
}
function ZS(i, e) {
  return zd(i, e) && !(Object.hasOwnProperty.call(i, e) && Object.propertyIsEnumerable.call(i, e));
}
function KS(i, e, t) {
  var s = {};
  return t.isMergeableObject(i) && lh(i).forEach(function(r) {
    s[r] = Kr(i[r], t);
  }), lh(e).forEach(function(r) {
    ZS(i, r) || (zd(i, r) && t.isMergeableObject(e[r]) ? s[r] = WS(r, t)(i[r], e[r], t) : s[r] = Kr(e[r], t));
  }), s;
}
function sr(i, e, t) {
  t = t || {}, t.arrayMerge = t.arrayMerge || US, t.isMergeableObject = t.isMergeableObject || $S, t.cloneUnlessOtherwiseSpecified = Kr;
  var s = Array.isArray(e), r = Array.isArray(i), n = s === r;
  return n ? s ? t.arrayMerge(i, e, t) : KS(i, e, t) : Kr(e, t);
}
sr.all = function(e, t) {
  if (!Array.isArray(e))
    throw new Error("first argument should be an array");
  return e.reduce(function(s, r) {
    return sr(s, r, t);
  }, {});
};
var QS = sr, qS = QS;
function Je(i, e) {
  const t = [];
  return i && t.push(i), e && t.push(e), qS.all(t);
}
var JS = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    staticStyle: {
      position: "relative",
      padding: "0px 20px"
    },
    style: i.styleProps
  }, [i.data.length === 0 ? t("div", {
    staticClass: "no-data-chart",
    style: i.styleProps
  }, [i._v(" No Data Available ")]) : i._e(), i.data.length > 0 ? t("div", {
    ref: i.chartSetComputed.refProps,
    style: i.styleProps,
    attrs: {
      id: i.chartSetComputed.id
    }
  }) : i._e(), i.previousButton.visible ? t("icon-button", {
    attrs: {
      "button-type": "arrow-backward-skinny",
      "click-handler": i.previousButton.handler,
      disabled: i.previousButton.disabled,
      "style-props": "position: absolute; left: 0; top: 50%"
    }
  }) : i._e(), i.nextButton.visible ? t("icon-button", {
    attrs: {
      "button-type": "arrow-forward-skinny",
      "click-handler": i.nextButton.handler,
      disabled: i.nextButton.disabled,
      "style-props": "position: absolute; right: 0; top: 50%;"
    }
  }) : i._e()], 1);
}, eD = [];
const tD = {
  components: {
    "icon-button": Hd
  },
  props: {
    // new
    xAxisAdditionalFunction: Function,
    // ====
    dataStartPoint: {
      type: String,
      default: ""
    },
    dataEndPoint: {
      type: String,
      default: ""
    },
    setDataStartPoint: Function,
    setDataEndPoint: Function,
    yAxisRange: Array,
    previousButton: {
      type: Object,
      default: () => ({ visible: !1, disabled: !1 })
    },
    nextButton: {
      type: Object,
      default: () => ({ visible: !1, disabled: !1 })
    },
    // =============================== requirement value =========================
    // data, category, axisDataBinder, (lineDataBinder || bubbleDataBinder || barDataBinder || candlestickDataBinder, timeScale, selectionMin, selectionMax)
    data: {
      type: Array,
      default: () => []
    },
    category: String,
    axisDataBinder: Object,
    lineDataBinder: Array,
    bubbleDataBinder: Array,
    barDataBinder: Array,
    candlestickDataBinder: Array,
    timeScale: String,
    selectionMin: String,
    selectionMax: String,
    tooltipHTML: {
      type: String,
      default: "<div>{name} in {categoryX}: {valueY}</div>"
    },
    // ============================== adpaters =================================
    xAxisGridStrokeOpacityAdapter: Function,
    // x축 grid 의 선을 custom
    xAxisLabelTextAdapter: Function,
    // x축 label을 custom
    xAxisTooltipLabelTextAdapter: Function,
    // x축 tooltip의 text를 custom
    seriesTooltipLabelHtmlAdapter: Function,
    // 시리즈 툴팁을 custom
    xScrollbarXAxisLabelTextAdapter: Function,
    // x스크롤바의 label을 custom
    seriesTooltipForceHiddenAdapter: Function,
    // 시리즈 툴팁의 숨김 여부를 custom
    // detailScrollbarXAxisLabelTextAdapter: Function,
    // ============================== adpaters end =================================
    // ============================== etc function ==============================
    getWheelCursorPositionX: Function,
    chartItemClickHandler: Function,
    setSelectionMin: Function,
    setSelectionMax: Function,
    zoomHandler: Function,
    panHandler: Function,
    // ============================== etc function end ==============================
    //  ============================== optional settings ==========================
    styleProps: {
      type: String,
      default: "height: 400px; width: 100%; min-width: 800px;"
    },
    chartSet: Object,
    legendSet: Object,
    candlestickSet: Object,
    lineSet: Object,
    bubbleSet: Object,
    barSet: Object,
    xScrollbarSet: Object
    //  ============================== optional settings end ==========================
  },
  data() {
    return {
      xySeries: "",
      xScrollbarOverallSeriesItem: "",
      chartTitle: "",
      xAxisExtraLabel: "",
      logTest: !1,
      range: "",
      rangeDataItem: "",
      root: "",
      chart: "",
      xAxis: "",
      yAxisList: [],
      lineSeriesList: [],
      lineSeries: "",
      columnSeriesList: [],
      columnSeries: "",
      bubbleSeriesList: [],
      bubbleSeries: "",
      candlestickSeriesList: [],
      candlestickSeries: "",
      xScrollbarSeriesList: [],
      xScrollbarSeries: "",
      xScrollbarOverallSeries: "",
      xScrollbarColumnSeriesList: [],
      xScrollbarColumnSeries: "",
      xScrollbarLineSeriesList: [],
      xScrollbarLineSeries: "",
      xScrollbarBubbleSeriesList: [],
      xScrollbarBubbleSeries: "",
      xScrollbarCandlestickSeriesList: [],
      xScrollbarCandlestickSeries: "",
      legend: "",
      legendSettings: "",
      xScrollbar: "",
      xScrollbarXAxis: "",
      xScrollbarYAxis: "",
      // settings
      // chartSetComputed.cursor.isAvailable
      chartSetData: {
        cursor: {
          isAvailable: !1
        },
        refProps: "defaultXYChart",
        id: "defaultXYChart",
        chartType: "default",
        titleLabel: {
          text: "",
          fontSize: 12,
          fontWeight: "normal",
          textAlign: "center",
          x: 5,
          centerX: 0,
          paddingTop: 0,
          paddingBottom: 0,
          color: "#555"
        },
        isZoomOutButton: !1,
        isYAxesPlotContainerVisible: !0,
        isBottomAxesContainerVisible: !0,
        chartLayout: "verticalLayout",
        panX: !1,
        panY: !1,
        wheelX: "",
        // 'zoomX', 'zoomY', 'zoomXY', 'panX', 'panY', 'panXY', 'none'
        wheelY: ""
        // 'zoomX', 'zoomY', 'zoomXY', 'panX', 'panY', 'panXY', 'none'
      },
      axisDataBinderData: {
        xAxis: {
          name: "",
          type: "CategoryAxis"
        },
        yAxis: {
          name: "",
          type: "ValueAxis",
          isLeft: !0
        },
        ySecondAxis: {
          name: "",
          type: "ValueAxis",
          isLeft: !1,
          isAvailable: !1
        }
      },
      legendSetData: {
        isVisible: !0,
        layout: "gridLayout",
        x: 50,
        centerX: 50,
        y: 100,
        centerY: 100,
        maxColumns: void 0
      },
      candlestickSetData: {
        riseColor: "#ff0000",
        dropColor: "#0000ff"
      },
      lineSetData: {
        isLineVisible: !1,
        isFillVisible: !1,
        isBullet: !0,
        strokeWidth: 2,
        fillOpacity: 0.1,
        bullet: { strokeWidth: 2, radius: 3 },
        colorList: [
          "#f08080",
          "#fa8072",
          "#e9967a",
          "#ff7f50",
          "#ff6347",
          "#f4a460",
          "#ffa07a"
        ]
      },
      bubbleSetData: {
        strokeWidth: 2,
        bullet: { strokeWidth: 2, radius: 3 },
        colorList: [
          "#f08080",
          "#fa8072",
          "#e9967a",
          "#ff7f50",
          "#ff6347",
          "#f4a460",
          "#ffa07a"
        ]
      },
      barSetData: {
        isStacked: !1,
        isClustered: !1,
        width: 15,
        strokeWidth: 1.5,
        fillOpacity: 0.3,
        cornerRadius: { topLeft: 0, topRight: 0 },
        colorList: [
          "#BCE2C7",
          "#4EBCD5",
          "#1A2281",
          "#4169e1",
          "#1e90ff",
          "#0000cd",
          "#000080"
        ]
      },
      xScrollbarSetData: {
        isVisible: !1,
        isDown: !1,
        gripScale: 0.9,
        isStartGrip: !1,
        isEndGrip: !1,
        startPosition: 0,
        endPosition: 1,
        thumb: { fill: "#550000", fillOpacity: 0.05 },
        detail: {
          isVisible: !1,
          height: 50,
          mainValue: { key: "", displayName: "" },
          line: { color: "#fb9f57", strokeWidth: 2, fillOpacity: 0.2 },
          background: {
            fill: "#000000",
            fillOpacity: 0.05,
            cornerRadius: {
              topLeft: 0,
              topRight: 10,
              bottomLeft: 10,
              bottomRight: 10
            }
          }
        }
      }
    };
  },
  updated() {
    this.logTest && (this.logTest && console.log("xy updated"), this.logTest && console.log("previousButton: ", this.previousButton), this.logTest && console.log("nextButton: ", this.nextButton));
  },
  mounted() {
    this.logTest && (console.log("xy mounted"), console.log("previousButton: ", this.previousButton), console.log("nextButton: ", this.nextButton), console.log("data: ", this.data), console.log("category: ", this.category), console.log("axisDataBinder: ", this.axisDataBinder), console.log("lineDataBinder: ", this.lineDataBinder), console.log("bubbleDataBinder: ", this.bubbleDataBinder), console.log("barDataBinder: ", this.barDataBinder), console.log("candlestickDataBinder: ", this.candlestickDataBinder), console.log("timeScale: ", this.timeScale), console.log("selectionMin: ", this.selectionMin), console.log("selectionMax: ", this.selectionMax), console.log("tooltipHTML: ", this.tooltipHTML), console.log(
      "xAxisGridStrokeOpacityAdapter: ",
      this.xAxisGridStrokeOpacityAdapter
    ), console.log("xAxisLabelTextAdapter: ", this.xAxisLabelTextAdapter), console.log(
      "xAxisTooltipLabelTextAdapter: ",
      this.xAxisTooltipLabelTextAdapter
    ), console.log(
      "seriesTooltipLabelHtmlAdapter: ",
      this.seriesTooltipLabelHtmlAdapter
    ), console.log(
      "xScrollbarXAxisLabelTextAdapter: ",
      this.xScrollbarXAxisLabelTextAdapter
    ), console.log(
      "seriesTooltipForceHiddenAdapter: ",
      this.seriesTooltipForceHiddenAdapter
    ), console.log("getWheelCursorPositionX: ", this.getWheelCursorPositionX), console.log("chartItemClickHandler: ", this.chartItemClickHandler), console.log("setSelectionMin: ", this.setSelectionMin), console.log("setSelectionMax: ", this.setSelectionMax), console.log("zoomHandler: ", this.zoomHandler), console.log("panHandler: ", this.panHandler), console.log("styleProps: ", this.styleProps), console.log("chartSet: ", this.chartSet), console.log("legendSet: ", this.legendSet), console.log("candlestickSet: ", this.candlestickSet), console.log("lineSet: ", this.lineSet), console.log("bubbleSet: ", this.bubbleSet), console.log("barSet: ", this.barSet), console.log("data: ", this.data), console.log("xScrollbarSet: ", this.xScrollbarSet)), this.createChart();
  },
  watch: {
    dataStartPoint: {
      handler(i) {
        console.log("watch dataStartPoint: ", i);
      }
    },
    dataEndPoint: {
      handler(i) {
        console.log("watch dataEndPoint: ", i);
      }
    },
    axisDataBinder: {
      handler() {
        this.logTest && console.log("watch axisDataBinder"), this.setAxes();
      },
      deep: !0
    },
    lineDataBinder: {
      handler() {
        this.logTest && console.log("watch lineDataBinder"), this.setLineSeries();
      },
      deep: !0
    },
    barDataBinder: {
      handler() {
        this.logTest && console.log("watch barDataBinder"), this.setColumnSeries();
      },
      deep: !0
    },
    bubbleDataBinder: {
      handler() {
        this.logTest && console.log("watch bubbleDataBinder"), this.setBubbleSeries();
      },
      deep: !0
    },
    candlestickDataBinder: {
      handler() {
        this.logTest && console.log("watch candlestickDataBinder"), this.setCandlestickSeries();
      },
      deep: !0
    },
    selectionMin: {
      handler(i) {
        this.xAxis && this.data && this.xAxis.data.setAll(this.data);
      },
      immediate: !0
    },
    selectionMax: {
      handler(i) {
        this.xAxis && this.data && this.xAxis.data.setAll(this.data);
      },
      immediate: !0
    },
    xScrollbarSetComputed: {
      handler(i) {
        this.logTest && console.log("watch xScrollbarSetComputed: ", i);
      },
      deep: !0,
      immediate: !0
    },
    "chartSetComputed.titleLabel.text": {
      handler(i, e) {
        this.logTest && console.log("watch chartSetComputed.titleLabel.text"), this.logTest && console.log(i), this.logTest && console.log(e), this.setXAxisExtraLabel();
      }
    },
    "xScrollbarSetComputed.detail.mainValue.displayName": {
      handler(i, e) {
        this.logTest && console.log(
          "watch xScrollbarSetComputed.detail.mainValue.displayName 11"
        ), this.logTest && console.log(i), this.logTest && console.log(e), this.setChartTitle(), this.setScrollbar();
      }
    },
    data(i) {
      if (console.log("watch data"), console.log(i), console.log("this.root: ", this.root), !this.root)
        return console.log("11111111"), this.createChart();
      if (this.root && i.length === 0)
        return console.log("this.root.dispose 22222222"), this.root.dispose();
      if (this.root && this.root.isDisposed())
        return console.log("33333333"), this.createChart();
      [
        "xAxis",
        "yAxis",
        "ySecondAxis",
        "candlestickSeries",
        "xScrollbarSeries",
        "xScrollbarColumnSeries",
        "xScrollbarLineSeries",
        "xScrollbarBubbleSeries",
        "xScrollbarCandlestickSeries",
        "xScrollbarXAxis",
        "xScrollbarYAxis",
        "xScrollbarSecondYAxis"
      ].map((t) => {
        this[t] && this[t].data && this[t].data.setAll(i);
      }), this.setLineSeries(), this.setColumnSeries(), this.setBubbleSeries();
    }
  },
  computed: {
    chartSetComputed() {
      let i = Je(this.chartSetData, this.chartSet);
      return Object.assign({}, i);
    },
    axisDataBinderComputed() {
      let i = Je(this.axisDataBinderData, this.axisDataBinder);
      return Object.assign({}, i);
    },
    legendSetComputed() {
      let i = Je(this.legendSetData, this.legendSet);
      return Object.assign({}, i);
    },
    barSetComputed() {
      return Je(this.barSetData, this.barSet);
    },
    bubbleSetComputed() {
      return Je(this.bubbleSetData, this.bubbleSet);
    },
    lineSetComputed() {
      return Je(this.lineSetData, this.lineSet);
    },
    candlestickSetComputed() {
      return Je(this.candlestickSetData, this.candlestickSet);
    },
    xScrollbarSetComputed() {
      return Je(this.xScrollbarSetData, this.xScrollbarSet);
    },
    closeDataStartPoint() {
      if (this.dataStartPoint && this.data.length > 0) {
        let i = P(
          this.dataStartPoint,
          "YYYYMMDDmmss"
        ).unix(), e = NaN, t = i;
        for (let s = 0; s < this.data.length; s++) {
          let r = P(
            this.data[s][this.category],
            "YYYYMMDDmmss"
          ).unix();
          t > Math.abs(r - i) && (t = Math.abs(r - i), e = this.data[s][this.category]);
        }
        if (!isNaN(e))
          return e;
      }
    },
    closeDataEndPoint() {
      if (this.dataEndPoint && this.data.length > 0) {
        let i = P(this.dataEndPoint, "YYYYMMDDmmss").unix(), e = NaN, t = i;
        for (let s = 0; s < this.data.length; s++) {
          let r = P(
            this.data[s][this.category],
            "YYYYMMDDmmss"
          ).unix();
          t > Math.abs(r - i) && (t = Math.abs(r - i), e = this.data[s][this.category]);
        }
        if (!isNaN(e))
          return e;
      }
    },
    // default 의 selectionMin 과 가장 가까운 overall 의 selectionMin
    closeSelectionMin() {
      if (this.selectionMin && this.selectionMax && this.data.length > 0) {
        this.logTest && console.log("yyyyyyyyyyyyyy");
        let i = P(this.selectionMin, "YYYYMMDDmmss").unix(), e = NaN, t = i;
        for (let s = 0; s < this.data.length; s++) {
          let r = P(
            this.data[s][this.category],
            "YYYYMMDDmmss"
          ).unix();
          t > Math.abs(r - i) && (t = Math.abs(r - i), e = this.data[s][this.category]);
        }
        if (!isNaN(e))
          return e;
      }
    },
    // default 의 selectionMax 과 가장 가까운 overall 의 selectionMax
    closeSelectionMax() {
      if (this.selectionMin && this.selectionMax && this.data.length > 0) {
        let i = P(this.selectionMax, "YYYYMMDDmmss").unix(), e = NaN, t = i;
        for (let s = 0; s < this.data.length; s++) {
          let r = P(
            this.data[s][this.category],
            "YYYYMMDDmmss"
          ).unix();
          t > Math.abs(r - i) && (t = Math.abs(r - i), e = this.data[s][this.category]);
        }
        if (!isNaN(e))
          return e;
      }
    }
  },
  methods: {
    setXAxisLabelHTML(i, e) {
      return '<div style="display: flex; flex-direction: column; align-items: center; font-size: 11px;">' + (i && `<div>${i}</div>`) + `<div>${e}</div></div>`;
    },
    getRanHex(i) {
      let e = [], t = [
        "0",
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        "a",
        "b",
        "c",
        "d",
        "e",
        "f"
      ];
      for (let s = 0; s < i; s++)
        e.push(t[Math.floor(Math.random() * 16)]);
      return e.join("");
    },
    getColor(i, e, t) {
      if (this.logTest && console.log("getColor"), t)
        return this.logTest && console.log("get specificColor: ", t), t;
      if (i && e >= 0 && i[e])
        return this.logTest && console.log("get colorList[index]: ", i[e]), i[e];
      {
        let s = "#" + this.getRanHex(6);
        return this.logTest && console.log("get random color: ", s), s;
      }
    },
    resetChart() {
      this.root && (this.logTest && console.log("root dipsose"), this.root.dispose()), this.createChart();
    },
    setZoomHandler(i = 0) {
      if (this.logTest && console.log("setZoomHandler"), this.xAxis) {
        let e = 0, t = 0;
        if (this.xAxis.getPrivate("startIndex") && (e = this.xAxis.getPrivate("startIndex")), this.xAxis.getPrivate("endIndex") && (t = this.xAxis.getPrivate("endIndex")), t > 0) {
          let s = this.xAxis.dataItems[e].dataContext[this.category], r = this.xAxis.dataItems[t - 1].dataContext[this.category];
          this.logTest && console.log("%c zoom !!!", "color: red;"), this.zoomHandler(s, r);
        }
      }
    },
    setPlotContainerPanHandler(i = 0) {
      if (console.log("setPlotContainerPanHandler"), this.xAxis) {
        let e = 0, t = 0;
        this.xAxis.getPrivate("startIndex") && (e = this.xAxis.getPrivate("startIndex")), this.xAxis.getPrivate("endIndex") && (t = this.xAxis.getPrivate("endIndex")), t > 0 && (this.setSelectionMin && (console.log(
          "setSelectionMin value: ",
          this.xAxis.dataItems[e].dataContext[this.category]
        ), this.setSelectionMin(
          this.xAxis.dataItems[e].dataContext[this.category]
        )), this.setSelectionMax && (console.log(
          "setSelectionMax value: ",
          this.xAxis.dataItems[t - 1].dataContext[this.category]
        ), this.setSelectionMax(
          this.xAxis.dataItems[t - 1].dataContext[this.category]
        )), e === 0 && (this.logTest && console.log("%c previous", "color: red;"), setTimeout(() => {
          this.panHandler("previous");
        }, 500)), t >= this.data.length - 1 && (this.logTest && console.log("%c next", "color: red;"), this.panHandler("next")));
      }
    },
    setZoomPanEvents() {
      const i = this;
      this.logTest && console.log("setZoomPanEvents"), this.logTest && console.log(
        "this.chartSetComputed.chartType: ",
        this.chartSetComputed.chartType
      ), this.logTest && console.log("this.zoomHandler: ", this.zoomHandler), this.logTest && console.log("this.panHandler: ", this.panHandler), this.logTest && console.log("this.xScrollbar: ", this.xScrollbar), this.zoomHandler && (this.logTest && console.log("xxxxxxxxxxxxxxx"), this.chart.events.on("wheelended", function(e) {
        i.setZoomHandler(i.xScrollbar, e);
      })), this.panHandler && (console.log("set pan handler"), this.xScrollbar.events.on("rangechanged", function(e) {
        if (console.log("rangeChanged !!!"), console.log("ev.target: ", e.target), console.log("ev.start: ", e.start), console.log("ev.end: ", e.end), e.target.chart.xAxes._values[0]) {
          let t = e.target.chart.xAxes._values[0].getSeriesItem(
            i.xySeries,
            e.start
          ), s = e.target.chart.xAxes._values[0].getSeriesItem(
            i.xySeries,
            e.end
          );
          i.chartSetComputed.chartType === "overall" && !(e.start === 0 && e.end === 1) && (i.setDataStartPoint(t.dataContext[i.category]), i.setDataEndPoint(s.dataContext[i.category]));
        }
        i.logTest && console.log("==================================");
      }), this.xScrollbar.thumb.events.on("pointerup", function(e) {
        console.log("x scrollbar thumb panning handler"), i.logTest && console.log("self.data: ", i.data);
        let t = 0;
        i.data.map((r, n) => {
          r[i.category] === i.dataStartPoint && (t = n);
        }), i.setSelectionMin(i.data[t][i.category]);
        let s = 0;
        i.data.map((r, n) => {
          r[i.category] === i.dataEndPoint && (s = n);
        }), startIndex === s ? i.setSelectionMax(i.data[t + 1][i.category]) : i.setSelectionMax(i.data[s][i.category]), console.log(
          "self.chartSetComputed.chartType: ",
          i.chartSetComputed.chartType
        ), i.panHandler();
      }), this.chart.plotContainer.events.on("pointerup", function(e) {
        console.log("plot container panning handler"), i.setPlotContainerPanHandler();
      }));
    },
    setSeries() {
      this.logTest && console.log("setSeries"), this.setLineSeries(), this.setColumnSeries(), this.setBubbleSeries(), this.setCandlestickSeries();
    },
    setLineSeries(i = 0, e = 0) {
      this.root && this.xAxis && this.yAxisList[e] && this.lineDataBinder && this.lineDataBinder.length > 0 && (this.lineSeriesList.map((t) => {
        console.log("lineSeries dispose"), t.dispose();
      }), this.lineSeriesList = [], this.lineDataBinder.map((t, s) => {
        let r = t == null ? void 0 : t.displayName, n = t == null ? void 0 : t.key, a = t == null ? void 0 : t.openKey, o = t == null ? void 0 : t.strokeWidth, l = t == null ? void 0 : t.isLineVisible;
        o === void 0 && (o = this.lineSetComputed.strokeWidth);
        let u = {
          strokeWidth: Number(o),
          visible: l !== void 0 ? l : !0
        }, c = this.getColor(
          this.lineSetComputed.colorList,
          s,
          t == null ? void 0 : t.color
        );
        t.color = c;
        let h = "";
        a && (h = { openValueYField: a });
        let d = {
          name: r,
          xAxis: this.xAxis,
          yAxis: t.isYSecondAxis ? this.ySecondAxis : this.yAxisList[e],
          valueYField: n,
          ...h,
          categoryXField: this.category,
          stroke: pe(t.color),
          fill: pe(t.color),
          userData: {
            chartType: "line",
            category: this.category,
            value: n,
            item: t
          }
        }, f = t.isFillVisible !== void 0 ? t.isFillVisible : this.lineSetComputed.isFillVisible, g = {
          fillOpacity: Number(this.lineSetComputed.fillOpacity),
          visible: f
        };
        this.lineSeries = ot.new(this.root, {
          ...d
        }), this.xySeries = this.chart.series.push(this.lineSeries), this.lineSeriesList.push(this.lineSeries), this.setLineSeriesChart(
          u,
          g,
          t,
          s
        ), this.setLineSeriesXScrollbar(
          d,
          u,
          t,
          s
        );
      }), this.setLegend());
    },
    setLineSeriesChart(i, e, t, s) {
      const r = this;
      let n = me.new(this.root, {});
      r.chartItemClickHandler && n.events.on("click", function(a) {
        r.logTest && console.log("click"), a.target.dataItem.component.className === "LineSeries" && r.chartItemClickHandler(a);
      }), ((t == null ? void 0 : t.isBullet) !== void 0 ? t != null && t.isBullet : this.lineSetComputed.isBullet) && this.lineSeries.bullets.push(function() {
        let o = r.getTooltipText(t).labelHTML;
        return r.seriesTooltipLabelHtmlAdapter && (o = r.seriesTooltipLabelHtmlAdapter(
          r.data[s],
          t
        )), ki.new(r.root, {
          sprite: Ci.new(
            r.root,
            {
              tooltipHTML: o,
              strokeWidth: r.lineSetComputed.bullet.strokeWidth,
              radius: Number(r.lineSetComputed.bullet.radius),
              stroke: pe(t.color),
              fill: r.root.interfaceColors.get("background"),
              userData: {
                chartType: "line",
                category: r.category
              }
            },
            n
          )
        });
      }), this.lineSeries.strokes.template.setAll({
        ...i
      }), this.lineSeries.fills.template.setAll({
        ...e
      }), this.lineSeries.data.setAll(this.data);
    },
    setLineSeriesXScrollbar(i, e, t, s) {
      this.logTest && console.log("setLineSeriesXScrollbar");
      const r = this;
      this.xScrollbarSetComputed.isDetailed && !this.xScrollbarSetComputed.detail.mainValue.key && this.xScrollbar && (this.logTest && console.log("setLineSeriesXScrollbar 22"), this.xScrollbarLineSeries = ot.new(r.root, {
        ...i,
        xAxis: r.xScrollbarXAxis,
        yAxis: t.ySecondAxis ? this.xScrollbarSecondYAxis : this.xScrollbarYAxis
      }), this.xScrollbar.chart.series.push(this.xScrollbarLineSeries), this.xScrollbarLineSeries.bullets.push(function() {
        return ki.new(r.root, {
          sprite: Ci.new(r.root, { ...lineBulletSettings })
          // sprite: am5.Circle.new(self.root, {}),
        });
      }), this.xScrollbarLineSeries.strokes.template.setAll({
        ...e
      }), this.xScrollbarLineSeries.data.setAll(this.data));
    },
    setBubbleSeries(i = 0, e = 0) {
      this.root && this.xAxis && this.yAxisList[e] && this.bubbleDataBinder && this.bubbleDataBinder.length > 0 && (this.logTest && console.log("setBubbleSeries"), this.logTest && console.log("this.chart: ", this.chart), this.logTest && console.log("this.chart.series: ", this.chart.series), this.logTest && console.log(" this.bubbleSeriesList: ", this.bubbleSeriesList), this.bubbleSeriesList.map((t) => {
        this.logTest && console.log("bubbleSeries dispose"), t.dispose();
      }), this.bubbleSeriesList = [], this.bubbleDataBinder.map((t, s) => {
        console.log("item.isYSecondAxis: ", t.isYSecondAxis), console.log("bubbleDataBinder item: ", t);
        let r = t == null ? void 0 : t.displayName, n = t == null ? void 0 : t.key, a = {
          strokeWidth: Number(this.bubbleSetComputed.strokeWidth),
          visible: !1
        }, o = this.getColor(
          this.bubbleSetComputed.colorList,
          s,
          t == null ? void 0 : t.color
        );
        t.color = o;
        let l = {
          name: r,
          xAxis: this.xAxis,
          yAxis: t.isYSecondAxis ? this.ySecondAxis : this.yAxisList[e],
          valueYField: n,
          categoryXField: this.category,
          stroke: pe(t.color),
          fill: pe(t.color),
          userData: {
            chartType: "bubble",
            category: this.category,
            value: n,
            item: t
          }
        }, u = {
          fillOpacity: Number(this.bubbleSetComputed.fillOpacity),
          visible: this.bubbleSetComputed.isFillVisible
        };
        this.bubbleSeries = ot.new(this.root, {
          ...l
        }), this.xySeries = this.chart.series.push(this.bubbleSeries), this.bubbleSeriesList.push(this.bubbleSeries), this.setBubbleSeriesChart(
          a,
          u,
          t,
          s
        ), this.setBubbleSeriesXScrollbar(
          l,
          a,
          t,
          s
        );
      }), this.setLegend());
    },
    setBubbleSeriesChart(i, e, t, s) {
      const r = this;
      let n = me.new(this.root, {});
      r.chartItemClickHandler && n.events.on("click", function(a) {
        r.logTest && console.log("click"), a.target.dataItem.component.className === "LineSeries" && r.chartItemClickHandler(a);
      }), this.bubbleSeries.bullets.push(function() {
        let o = r.getTooltipText(t).labelHTML;
        if (r.seriesTooltipLabelHtmlAdapter) {
          let l = JSON.parse(JSON.stringify(t));
          o = r.seriesTooltipLabelHtmlAdapter(
            r.data[s],
            l
          );
        }
        return ki.new(r.root, {
          sprite: Ci.new(
            r.root,
            {
              tooltipHTML: o,
              strokeWidth: r.bubbleSetComputed.bullet.strokeWidth,
              stroke: pe(t.color),
              fill: r.root.interfaceColors.get("background"),
              radius: Number(r.bubbleSetComputed.bullet.radius),
              userData: {
                chartType: "bubble",
                category: r.category
              }
            },
            n
          )
        });
      }), this.bubbleSeries.strokes.template.setAll({
        ...i
      }), this.bubbleSeries.fills.template.setAll({
        ...e
      }), this.bubbleSeries.data.setAll(this.data);
    },
    setBubbleSeriesXScrollbar(i, e, t, s, r) {
      this.logTest && console.log("setBubbleSeriesXScrollbar");
      const n = this;
      this.xScrollbarSetComputed.isDetailed && !this.xScrollbarSetComputed.detail.mainValue.key && (this.logTest && console.log("setBubbleSeriesXScrollbar 22"), this.xScrollbarBubbleSeries = ot.new(n.root, {
        ...i,
        xAxis: n.xScrollbarXAxis,
        yAxis: s.ySecondAxis ? n.xScrollbarSecondYAxis : n.xScrollbarYAxis
      }), this.xScrollbar.chart.series.push(this.xScrollbarBubbleSeries), this.xScrollbarBubbleSeries.bullets.push(function() {
        return ki.new(n.root, {
          sprite: Ci.new(n.root, { ...e })
        });
      }), this.xScrollbarBubbleSeries.strokes.template.setAll({
        ...t
      }), this.xScrollbarBubbleSeries.data.setAll(this.data));
    },
    hexToRgbA(i) {
      var e;
      if (/^#([A-Fa-f0-9]{3}){1,2}$/.test(i)) {
        e = i.substring(1).split(""), e.length == 3 && (e = [
          e[0],
          e[0],
          e[1],
          e[1],
          e[2],
          e[2]
        ]), e = "0x" + e.join("");
        let t = e >> 16 & 255, s = e >> 8 & 255, r = e & 255;
        return [t, r, s];
      }
      throw new Error("Bad Hex");
    },
    rgbaToHex(i) {
      this.logTest && console.log("rgbaStr: ", i);
      let e = i.replace(/\s/g, "").match(/^rgba?\((\d+),(\d+),(\d+),?([^,\s)]+)?/i);
      return this.logTest && console.log("rgb: ", e), e ? (e[1] | 1 << 8).toString(16).slice(1) + (e[2] | 1 << 8).toString(16).slice(1) + (e[3] | 1 << 8).toString(16).slice(1) : i;
    },
    setColumnSeries(i = 0, e = 0) {
      this.root && this.xAxis && this.yAxisList[e] && this.barDataBinder && this.barDataBinder.length > 0 && (this.columnSeriesList.length > 0 && (this.columnSeriesList.map((t) => {
        this.logTest && console.log("columnSeries dispose"), t.dispose();
      }), this.columnSeriesList = []), this.barDataBinder.map((t, s) => {
        let r = t == null ? void 0 : t.displayName, n = t == null ? void 0 : t.key;
        if (t == null ? void 0 : t.disabled) {
          let d = this.hexToRgbA(t == null ? void 0 : t.color), f = Math.floor((d[0] + d[1] + d[2]) / 3), g = this.rgbaToHex(
            `rgba(${f}, ${f}, ${f})`
          );
          t != null && t.color && (t.color = `#${g}`);
        }
        let o = {};
        this.axisDataBinderComputed.yAxis.isPercent && (o = { valueYShow: "valueYTotalPercent" });
        let l = {
          name: r,
          stacked: this.barSetComputed.isStacked,
          clustered: this.barSetComputed.isClustered,
          valueYField: n,
          categoryXField: this.category,
          ...o
        }, u = this.getTooltipText(t), c = this.getColor(
          this.barSetComputed.colorList,
          s,
          t == null ? void 0 : t.color
        ), h = {
          tooltipY: 0,
          tooltipHTML: u.labelHTML,
          templateField: "columnSettings",
          stroke: pe(c),
          fill: pe(c),
          width: Number(this.barSetComputed.width),
          fillOpacity: Number(this.barSetComputed.fillOpacity),
          strokeWidth: Number(this.barSetComputed.strokeWidth),
          cornerRadiusTL: Number(this.barSetComputed.cornerRadius.topLeft),
          cornerRadiusTR: Number(this.barSetComputed.cornerRadius.topRight),
          userData: {
            chartType: "bar",
            category: this.category,
            value: n
          }
        };
        this.setColumnSeriesChart(
          l,
          h,
          t,
          s
        ), this.setColumnSeriesXScrollbar(
          l,
          h,
          s
        );
      }));
    },
    setColumnSeriesChart(i, e, t, s) {
      const r = this;
      t.xAxisIndex && !this.xAxis && this.setXAxis(t.xAxisIndex), t.yAxisIndex && !this.yAxisList[t.yAxisIndex] && this.setYAxis(t.yAxisIndex);
      let n = this.xAxis ? this.xAxis : this.xAxis, a = this.yAxisList[t.yAxisIndex] ? this.yAxisList[t.yAxisIndex] : this.yAxisList[0];
      a.axisHeader.children.push(
        Xe.new(r.root, {
          text: t.yAxisHeaderName,
          fontWeight: "500"
        })
      ), a.axisHeader.set("paddingTop", 10), this.columnSeries = Wi.new(this.root, {
        ...i,
        xAxis: n,
        yAxis: t.isYSecondAxis ? this.ySecondAxis : a
        // yAxis: yAxis,
      }), this.columnSeriesList.push(this.columnSeries), this.xySeries = this.chart.series.push(this.columnSeries);
      let o = Mt.new(r.root, {
        getFillFromSprite: !1,
        getStrokeFromSprite: !0,
        autoTextColor: !1,
        getLabelFillFromSprite: !0
      });
      o.get("background").setAll({
        fill: pe(16777215),
        fillOpacity: 0.8
      }), this.logTest && console.log("columnTooltip: ", o), this.seriesTooltipLabelHtmlAdapter && o.label.adapters.add("html", function(l, u) {
        return r.seriesTooltipLabelHtmlAdapter(r.data[s], t);
      }), this.columnSeries.set("tooltip", o), this.columnSeries.columns.template.setAll({
        ...e
      }), this.seriesTooltipForceHiddenAdapter, this.columnSeries.columns.template.events.on(
        "click",
        this.chartItemClickHandler
      ), this.columnSeries.data.setAll(this.data), this.setLegend();
    },
    setColumnSeriesXScrollbar(i, e, t, s) {
      this.xScrollbarSetComputed.isDetailed && !this.xScrollbarSetComputed.detail.mainValue.key && this.xScrollbar && (this.xScrollbarColumnSeries = this.xScrollbar.chart.series.push(
        Wi.new(this.root, {
          ...i,
          xAxis: this.xScrollbarXAxis,
          yAxis: t.ySecondAxis ? this.xScrollbarSecondYAxis : this.xScrollbarYAxis
        })
      ), this.xScrollbarColumnSeries.columns.template.setAll({
        ...e
      }), this.xScrollbarColumnSeries.data.setAll(this.data));
    },
    setXAxisGridStrokeOpacityAdapter(i = 0) {
      const e = this;
      this.xAxisGridStrokeOpacityAdapter && this.xAxis.get("renderer").grid.template.adapters.add(
        "strokeOpacity",
        function(t, s) {
          return e.xAxisGridStrokeOpacityAdapter(s);
        }
      );
    },
    createChart() {
      console.log("createChart");
      const i = this;
      this.$nextTick(() => {
        if (i.data.length > 0) {
          (!i.root || i.root && i.root.isDisposed()) && (i.root = Ja.new(
            i.$refs[i.chartSetComputed.refProps]
          ));
          const e = rn.new(i.root);
          i.root.setThemes([nS.new(i.root), e]), i.setContainer(), i.setAxes(), i.setSeries(), i.setCursor(), i.setScrollbar(), i.setZoomPanEvents(), i.setZoomOutButton(), i.root.numberFormatter.setAll({
            // numberFormat: "#'%'",
            numberFormat: "#.#",
            numericFields: ["valueY"]
          }), i.chart.leftAxesContainer.set("layout", i.root.verticalLayout), i.setXAxisAdditionalFunction(), i.chart.appear(1e3, 100);
        }
      });
    },
    setXAxisAdditionalFunction() {
      this.xAxisAdditionalFunction && this.xAxisAdditionalFunction(this.xAxis, eS);
    },
    // 스크롤바 설정 함수
    setScrollbar() {
      this.logTest && console.log("setScrollbar 22");
      let i = {};
      this.xScrollbarSetComputed.isDetailed && (i = { height: Number(this.xScrollbarSetComputed.detail.height) }), this.xScrollbar = [], this.xScrollbar = this.chart.set(
        "scrollbarX",
        Vr.new(this.root, {
          orientation: "horizontal",
          ...i
        })
      ), this.logTest && console.log("this.xScrollbar 22: ", this.xScrollbar), this.setDetailScrollAxis(), this.setXScrollbarPosition(), this.setXScrollbarThumb(), this.setXScrollbarGrip(), this.setXScrollbarBackground(), this.setXScrollbarMainLine(), this.xScrollbarSetComputed.isDetailed || this.xScrollbar.set("visible", !1);
    },
    setDetailScrollAxis() {
      this.logTest && console.log("setDetailScrollAxis"), this.logTest && console.log(
        "this.xScrollbarSetComputed.isDetailed: ",
        this.xScrollbarSetComputed.isDetailed
      ), this.xScrollbarSetComputed.isDetailed && (this.setDetailScrollXAxis(), this.setDetailScrollYAxis(), this.setDetailScrollYSecondAxis());
    },
    setDetailScrollXAxis() {
      this.logTest && console.log("setDetailScrollXAxis"), this.logTest && console.log("this.xScrollbar: ", this.xScrollbar);
      const i = this;
      if (
        // this.axisDataBinderComputed &&
        // this.axisDataBinderComputed.xAxis &&
        this.xScrollbar
      ) {
        if (this.logTest && console.log(this.xScrollbar), this.logTest && console.log(this.xScrollbar.chart), this.logTest && console.log(this.xScrollbar.chart.xAxes), this.logTest && console.log(
          "this.xScrollbar.chart.xAxes.values.length: ",
          this.xScrollbar.chart.xAxes.values.length
        ), this.xScrollbar.chart.xAxes.values.length === 0) {
          let e = Mt.new(i.root, {});
          this.xScrollbarXAxis = this.xScrollbar.chart.xAxes.push(
            xs[this.axisDataBinderComputed.xAxis.type].new(i.root, {
              tooltip: e,
              categoryField: i.category,
              renderer: tr.new(i.root, {
                minGridDistance: 5
              })
            })
          );
        }
        this.xScrollbarXAxisLabelTextAdapter && this.xScrollbarXAxis.get("renderer").labels.template.adapters.add("text", function(e, t) {
          return i.xScrollbarXAxisLabelTextAdapter(
            e,
            t,
            i.data
          );
        }), this.xScrollbarXAxis.get("renderer").grid.template.adapters.add(
          "strokeOpacity",
          function(e, t) {
            return t.dataItem.dataContext.title === "1" ? 0.1 : 0;
          }
        ), this.xScrollbarXAxis.get("renderer").labels.template.setAll({
          fontSize: 10,
          textAlign: "center"
        }), this.xScrollbarXAxis.get("renderer").grid.template.setAll({
          strokeWidth: 1,
          strokeOpacity: 0,
          location: 0.5
        }), this.xScrollbarXAxis.data.setAll(this.data);
      }
    },
    setDetailScrollYAxis() {
      if (this.logTest && console.log("setDetailScrollYAxis"), this.logTest && console.log("this.xScrollbar: ", this.xScrollbar), this.xScrollbar) {
        const i = this;
        let e = this.axisDataBinderComputed.yAxis.type === "DateAxis" ? { baseInterval: { timeUnit: "day", count: 1 } } : "";
        this.logTest && console.log(
          "this.xScrollbar.chart.yAxes.values.length: ",
          this.xScrollbar.chart.yAxes.values.length
        ), this.xScrollbar.chart.yAxes.values.length === 0 && (this.xScrollbarYAxis = this.xScrollbar.chart.yAxes.push(
          xs[this.axisDataBinderComputed.yAxis.type].new(i.root, {
            ...e,
            min: 0,
            extraMax: 0.2,
            renderer: Mi.new(i.root, {})
          })
        )), this.xScrollbarYAxis.data.setAll(this.data);
      }
    },
    setDetailScrollYSecondAxis() {
      if (this.logTest && console.log("setDetailScrollYSecondAxis"), this.logTest && console.log("this.xScrollbar: ", this.xScrollbar), this.xScrollbar) {
        const i = this;
        let e = this.axisDataBinderComputed.yAxis.type === "DateAxis" ? { baseInterval: { timeUnit: "day", count: 1 } } : "";
        this.logTest && console.log(
          "this.xScrollbar.chart.yAxes.values.length (second axis): ",
          this.xScrollbar.chart.yAxes.values.length
        ), this.xScrollbar.chart.yAxes.values.length === 1 && (this.xScrollbarSecondYAxis = this.xScrollbar.chart.yAxes.push(
          xs[this.axisDataBinderComputed.ySecondAxis.type].new(i.root, {
            ...e,
            min: 0,
            extraMax: 0.1,
            renderer: Mi.new(i.root, {})
          })
        )), this.xScrollbarSecondYAxis.data.setAll(this.data);
      }
    },
    setXScrollbarPosition() {
      this.logTest && console.log("setXScrollbarPosition"), this.xScrollbar.set(
        "start",
        Number(this.xScrollbarSetComputed.startPosition)
      ), this.xScrollbar.set(
        "end",
        Number(this.xScrollbarSetComputed.endPosition)
      ), this.xScrollbarSetComputed.isDown && (this.logTest && console.log(
        "this.chart.bottomAxesContainer.children :",
        this.chart.bottomAxesContainer.children
      ), this.chart.bottomAxesContainer.children.push(this.xScrollbar));
    },
    setXScrollbarThumb() {
      this.xScrollbar.thumb.setAll({
        fill: pe(this.xScrollbarSetComputed.thumb.fill),
        fillOpacity: Number(this.xScrollbarSetComputed.thumb.fillOpacity)
      });
    },
    setXScrollbarGrip() {
      this.xScrollbar.startGrip.setAll({
        visible: this.xScrollbarSetComputed.isStartGrip,
        scale: this.xScrollbarSetComputed.gripScale
      }), this.xScrollbar.endGrip.setAll({
        visible: this.xScrollbarSetComputed.isEndGrip,
        scale: this.xScrollbarSetComputed.gripScale
      });
    },
    setXScrollbarBackground() {
      this.xScrollbarSetComputed.isDetailed && this.xScrollbar.get("background").setAll({
        fill: pe(this.xScrollbarSetComputed.detail.background.fill),
        fillOpacity: Number(
          this.xScrollbarSetComputed.detail.background.fillOpacity
        ),
        cornerRadiusTL: Number(
          this.xScrollbarSetComputed.detail.background.cornerRadius.topLeft
        ),
        cornerRadiusTR: Number(
          this.xScrollbarSetComputed.detail.background.cornerRadius.topRight
        ),
        cornerRadiusBL: Number(
          this.xScrollbarSetComputed.detail.background.cornerRadius.bottomLeft
        ),
        cornerRadiusBR: Number(
          this.xScrollbarSetComputed.detail.background.cornerRadius.bottomRight
        )
      });
    },
    setZoomOutButton() {
      this.chartSetComputed.isZoomOutButton || this.chart.zoomOutButton.set("forceHidden", !0);
    },
    setXScrollbarMainLine() {
      const i = this;
      this.logTest && (console.log("setXScrollbarMainLine"), console.log(
        "this.xScrollbarSetComputed.isDetailed: ",
        this.xScrollbarSetComputed.isDetailed
      ), console.log(
        "this.xScrollbarSetComputed.detail.mainValue.key: ",
        this.xScrollbarSetComputed.detail.mainValue.key
      ), console.log("this.xScrollbar: ", this.xScrollbar), console.log("this.xScrollbarXAxis: ", this.xScrollbarXAxis), console.log("this.xScrollbarYAxis: ", this.xScrollbarYAxis)), this.xScrollbar && this.xScrollbarXAxis && this.xScrollbarYAxis && this.xScrollbarSetComputed.isDetailed && this.xScrollbarSetComputed.detail.mainValue.key && (this.xScrollbarColumnSeries && this.xScrollbarColumnSeries.hide().then(function(e) {
        this.logTest && console.log("xScrollbarColumnSeries 를 숨겼습니다."), this.logTest && console.log(e);
      }), this.xScrollbarLineSeries && (this.xScrollbarLineSeries.hide().then(function(e) {
        this.logTest && console.log("xScrollbarLineSeries 를 숨겼습니다 4."), this.logTest && console.log(e);
      }), this.logTest && console.log(
        "this.xScrollbarLineSeries: ",
        this.xScrollbarLineSeries
      ), this.xScrollbarLineSeries.set("forceHidden", !0), this.logTest && console.log("333")), this.xScrollbarBubbleSeries && this.xScrollbarBubbleSeries.hide().then(function(e) {
        this.logTest && console.log("xScrollbarBubbleSeries 를 숨겼습니다."), this.logTest && console.log(e);
      }), this.xScrollbarCandlestickSeries && this.xScrollbarCandlestickSeries.hide().then(function(e) {
        this.logTest && console.log("xScrollbarCandlestickSeries 를 숨겼습니다."), this.logTest && console.log(e);
      }), this.xScrollbar.chart.series.values.length === 0 && (this.xScrollbarOverallSeries = Zr.new(
        i.root,
        {
          valueYField: i.xScrollbarSetComputed.detail.mainValue.key,
          categoryXField: i.category,
          fill: pe(i.xScrollbarSetComputed.detail.line.color),
          stroke: pe(i.xScrollbarSetComputed.detail.line.color),
          xAxis: i.xScrollbarXAxis,
          yAxis: i.xScrollbarYAxis
        }
      ), this.xScrollbar.chart.series.push(i.xScrollbarOverallSeries)), this.xScrollbarOverallSeries.set(
        "valueYField",
        i.xScrollbarSetComputed.detail.mainValue.key
      ), this.xScrollbarOverallSeries.strokes.template.setAll({
        strokeWidth: Number(
          this.xScrollbarSetComputed.detail.line.strokeWidth
        )
      }), this.xScrollbarOverallSeries.fills.template.setAll({
        fillOpacity: Number(
          this.xScrollbarSetComputed.detail.line.fillOpacity
        ),
        visible: !0
      }), this.xScrollbarOverallSeries.data.setAll(this.data));
    },
    setXAxis(i = 0) {
      this.createXAxis(i), this.setXAxisExtraLabel(i), this.setXAxisLabel(i), this.setXAxisGrid(i), this.setXAxisLabelTextAdapter(i), this.setXAxisTooltipLabelTextAdapter(i), this.setXAxisGridStrokeOpacityAdapter(i), this.setXAxisZoomToCategories(i), this.xAxis.data.setAll(this.data);
    },
    createXAxis(i = 0) {
      const e = this;
      let t = this.axisDataBinderComputed.xAxis.tooltipHTML ? { labelHTML: this.axisDataBinderComputed.xAxis.tooltipHTML } : {}, s = Mt.new(e.root, { ...t });
      this.xAxis || (this.xAxis = xs[e.axisDataBinderComputed.xAxis.type].new(
        e.root,
        {
          tooltip: s,
          maxDeviation: 0,
          categoryField: e.category,
          renderer: tr.new(e.root, {
            minGridDistance: 5
          }),
          // axisfill 활성화
          fillRule: function(r) {
            var n = r.get("axisFill");
            n.setPrivate("visible", !0);
          }
        }
      ), this.chart.xAxes.push(this.xAxis));
    },
    setXAxisExtraLabel(i = 0) {
      this.logTest && console.log("setXAxisExtraLabel");
      const e = this;
      this.xAxis && (this.xAxisExtraLabel || (this.xAxisExtraLabel = this.xAxis.children.push(
        Xe.new(e.root, {
          html: e.setXAxisLabelHTML(
            e.chartSetComputed.titleLabel.text,
            e.axisDataBinderComputed.xAxis.name
          ),
          x: ce,
          centerX: ce,
          paddingBottom: 25
        })
      )), this.logTest && console.log("7777777"), this.xAxisExtraLabel.set(
        "html",
        e.setXAxisLabelHTML(
          e.chartSetComputed.titleLabel.text,
          e.axisDataBinderComputed.xAxis.name
        )
      ));
    },
    setXAxisLabel(i = 0) {
      this.xAxis.get("renderer").labels.template.setAll({
        fontSize: 14,
        textAlign: "center",
        oversizedBehavior: "none"
        // 'none', 'hide', 'fit', 'wrap', 'wrap-no-break', 'truncate'
        // maxWidth: 150, // with 'truncate'
        // ellipsis: '...' // with 'truncate'
      });
    },
    setXAxisGrid(i = 0) {
      this.xAxis.get("renderer").grid.template.setAll({
        strokeWidth: 1,
        strokeOpacity: 0.1,
        location: 0.5
      });
    },
    setXAxisLabelTextAdapter(i = 0) {
      const e = this;
      this.xAxisLabelTextAdapter && this.xAxis.get("renderer").labels.template.adapters.add("text", function(t, s) {
        return e.xAxisLabelTextAdapter(t, s, e.timeScale);
      });
    },
    setXAxisTooltipLabelTextAdapter(i = 0) {
      const e = this;
      this.xAxisTooltipLabelTextAdapter && this.xAxis.get("tooltip").label.adapters.add("text", function(t, s) {
        return e.xAxisTooltipLabelTextAdapter(t, s);
      });
    },
    setXAxisZoomToCategories(i = 0) {
      const e = this;
      e.closeSelectionMin && e.closeSelectionMax && setTimeout(() => {
        console.log(
          "self.chartSetComputed.chartType: ",
          e.chartSetComputed.chartType
        ), e.chartSetComputed.chartType === "overall" && (console.log("self.closeDataPoint: "), console.log(e.closeDataStartPoint), console.log(e.closeDataEndPoint), e.xAxis.zoomToCategories(
          e.closeDataStartPoint,
          e.closeDataEndPoint
        )), e.chartSetComputed.chartType === "default" && (console.log("self.closeSelection"), console.log(e.closeSelectionMin), console.log(e.closeSelectionMax), e.xAxis.zoomToCategories(
          e.closeSelectionMin,
          e.closeSelectionMax
        ));
      }, 1e3);
    },
    setYAxis(i = 0) {
      this.axisDataBinderComputed && this.axisDataBinderComputed.yAxis && (this.createYAxis(i), this.setYAxisCreateRange(i), this.setYAxisLabel(i), this.yAxisList[i].data.setAll(this.data));
    },
    createYAxis(i) {
      const e = this;
      let t = this.axisDataBinderComputed.yAxis.tooltipHTML ? { labelHTML: this.axisDataBinderComputed.yAxis.tooltipHTML } : {}, s = {};
      this.axisDataBinderComputed.yAxis.isPercent && (s = {
        min: 0,
        max: 100,
        numberFormat: "#'%'",
        calculateTotals: !0
      });
      let r = Mt.new(e.root, { ...t });
      this.logTest && console.log("y axis push"), this.yAxisList[i] = this.chart.yAxes.push(
        xs[this.axisDataBinderComputed.yAxis.type].new(e.root, {
          strictMinMaxSelection: !0,
          min: 0,
          extraMax: 0.2,
          ...s,
          syncWithAxis: e.ySecondAxis,
          tooltip: r,
          renderer: Mi.new(e.root, {
            opposite: !e.axisDataBinderComputed.yAxis.isLeft
            // minGridDistance: 50,
            // inside: true,
          })
        })
      );
    },
    setYAxisLabel(i) {
      this.yAxisList[i].children[this.axisDataBinderComputed.yAxis.isLeft ? "unshift" : "push"](
        Xe.new(this.root, {
          rotation: this.axisDataBinderComputed.yAxis.isLeft ? -90 : 90,
          text: this.axisDataBinderComputed.yAxis.name,
          y: ce,
          centerX: ce
        })
      ), this.yAxisList[i].get("renderer").labels.template.setAll({
        fontSize: 14,
        textAlign: "center",
        visible: !0,
        minPosition: 0,
        maxPosition: 0.9
      });
    },
    setYAxisCreateRange(i) {
      this.yAxisRange && this.yAxisRange.map((e) => {
        let t = this.yAxisList[i].makeDataItem({
          value: e.value,
          endValue: e.endValue,
          above: !0
        });
        this.range = this.yAxisList[i].createAxisRange(t);
        let s = typeof e.location == "number" ? { location: e.location } : { location: 0.5 }, r = e.color ? e.color : "#579ffb", n = e.strokeDasharray ? { strokeDasharray: e.strokeDasharray } : {};
        this.setRangeGrid(r, n, s), this.setRangeAxisFill(r), this.setRangeLabel(e.text, s, r);
      });
    },
    setRangeGrid(i, e, t) {
      this.range.get("grid").setAll({
        stroke: pe(i),
        strokeOpacity: 1,
        ...e,
        ...t
      });
    },
    setRangeAxisFill(i) {
      this.range.get("axisFill").setAll({
        fill: pe(i),
        fillOpacity: 0.1,
        visible: !0
      });
    },
    setRangeLabel(i, e, t) {
      const s = this;
      i && this.range.get("label").setAll({
        fill: pe(16777215),
        text: i,
        ...e,
        background: et.new(s.root, {
          fill: pe(t)
        })
      });
    },
    setYSecondAxis(i = 0) {
      this.logTest && console.log("setYSecondAxis");
      const e = this;
      let t = {};
      t = this.axisDataBinderComputed.ySecondAxis.tooltipHTML && {
        labelHTML: this.axisDataBinderComputed.ySecondAxis.tooltipHTML
      };
      let s = Mt.new(e.root, { ...t });
      s.set(
        "forceHidden",
        !this.axisDataBinderComputed.ySecondAxis.isAvailable
      ), this.logTest && console.log(
        "this.chart.yAxes.values.length 22: ",
        this.chart.yAxes.values.length
      ), this.chart.yAxes.values.length === 1 && (this.logTest && console.log("second y axis push 22"), this.ySecondAxis = this.chart.yAxes.push(
        xs[this.axisDataBinderComputed.ySecondAxis.type].new(e.root, {
          tooltip: s,
          strictMinMaxSelection: !0,
          min: 0,
          extraMax: 0.2,
          syncWithAxis: e.yAxisList[i],
          renderer: Mi.new(e.root, {
            opposite: !this.axisDataBinderComputed.ySecondAxis.isLeft
            // minGridDistance: 50,
          })
        })
      ), this.ySecondAxis.children[this.axisDataBinderComputed.ySecondAxis.isLeft ? "unshift" : "push"](
        Xe.new(this.root, {
          rotation: this.axisDataBinderComputed.ySecondAxis.isLeft ? -90 : 90,
          text: this.axisDataBinderComputed.ySecondAxis.name,
          y: ce,
          centerX: ce
        })
      )), this.logTest && console.log("ySecondAxis data setAll"), this.ySecondAxis.data.setAll(this.data);
    },
    setAxes() {
      this.root && (this.logTest && console.log("setAxes"), this.setXAxis(), this.setYAxis(), this.setYSecondAxis());
    },
    setCursor() {
      if (this.chartSetComputed.cursor.isAvailable) {
        const i = this;
        this.logTest && console.log("setCursor"), this.chart.set(
          "cursor",
          Ur.new(i.root, {
            // behavior: "zoomXY", // default: 'none'
            // xAxis: this.xAxis
            // snapToSeries: [series1, series2],
            // snapToSeriesBy: "y!",
          })
        );
        let e = this.chart.get("cursor");
        i.getWheelCursorPositionX && e.events.on("wheel", function(t) {
          t.target.getPrivate("positionX") && i.getWheelCursorPositionX(t.target.getPrivate("positionX"));
        }), e.setAll({});
      }
    },
    setChartTitle() {
      this.logTest && console.log("setChartTitle");
      const i = this;
      if (this.chart && this.chartSetComputed.chartType === "overall") {
        let e = {
          text: i.chartSetComputed.titleLabel.text,
          fill: pe(i.chartSetComputed.titleLabel.color),
          fontSize: i.chartSetComputed.titleLabel.fontSize,
          fontWeight: i.chartSetComputed.titleLabel.fontWeight,
          textAlign: i.chartSetComputed.titleLabel.textAlign,
          x: Ke(i.chartSetComputed.titleLabel.x),
          centerX: Ke(i.chartSetComputed.titleLabel.centerX),
          paddingTop: i.chartSetComputed.titleLabel.paddingTop,
          paddingBottom: i.chartSetComputed.titleLabel.paddingBottom
        };
        this.chartTitle || (this.chartTitle = this.chart.children.push(
          Xe.new(i.root, { ...e })
        )), this.chartTitle.setAll({ ...e });
      }
    },
    setChartContainer() {
      this.logTest && (this.logTest && console.log("setChartContainer"), this.logTest && console.log("this.chart: ", this.chart));
      const i = this;
      this.chart || (this.chart = Js.new(i.root, {
        focusable: !1,
        maxTooltipDistance: -1,
        maxTooltipDistanceBy: "xy",
        panX: i.chartSetComputed.panX,
        panY: i.chartSetComputed.panY,
        wheelX: i.chartSetComputed.wheelX,
        wheelY: i.chartSetComputed.wheelY,
        layout: i.root[i.chartSetComputed.chartLayout],
        paddingTop: 0
      }), this.logTest && console.log("this.chart.plotContainer: ", this.chart.plotContainer), this.root.container.children.push(this.chart), this.logTest && console.log("2222")), this.chartSetComputed.isYAxesPlotContainerVisible || (this.chart.yAxesAndPlotContainer.set("forceHidden", !0), this.chart.yAxesAndPlotContainer.set("height", 0)), this.chartSetComputed.isBottomAxesContainerVisible || (this.chart.bottomAxesContainer.set("forceHidden", !0), this.chart.bottomAxesContainer.set("height", 0));
    },
    setContainer() {
      this.logTest && console.log("setContainer"), this.setChartContainer(), this.setChartTitle();
    },
    getTooltipText(i) {
      let e = { labelHTML: this.tooltipHTML };
      return i.tooltipHTML && (e = { labelHTML: i.tooltipHTML }), e;
    },
    setTooltip(i, e) {
      this.logTest && console.log("setTooltip"), this.logTest && console.log("tooltip: ", i), this.logTest && console.log("strokeColor: ", e), i.get("background").setAll({
        fill: pe("#fff"),
        fillOpacity: 0.9,
        strokeWidth: 2,
        stroke: e
      }), i.setAll({
        pointerOrientation: "horizontal"
      });
    },
    setCandlestickSeries(i = 0, e = 0) {
      var t, s, r, n, a, o, l, u, c;
      if (this.root && this.xAxis && this.yAxisList[e] && this.candlestickDataBinder && this.candlestickDataBinder.length > 0) {
        let d = {
          tooltip: Mt.new(this.root, {}),
          name: (t = this.candlestickDataBinder) == null ? void 0 : t.displayName,
          openValueYField: (r = (s = this.candlestickDataBinder) == null ? void 0 : s.openValue) == null ? void 0 : r.key,
          highValueYField: (a = (n = this.candlestickDataBinder) == null ? void 0 : n.highValue) == null ? void 0 : a.key,
          lowValueYField: (l = (o = this.candlestickDataBinder) == null ? void 0 : o.lowValue) == null ? void 0 : l.key,
          valueYField: (c = (u = this.candlestickDataBinder) == null ? void 0 : u.defaultValue) == null ? void 0 : c.key,
          categoryXField: this.category
        };
        this.setCandlestickSeriesChart(d), this.setCandlestickSeriesXScrollbar(d);
      }
    },
    setCandlestickSeriesChart(i, e = 0, t = 0) {
      var s, r, n, a, o, l, u, c, h, d;
      this.candlestickSeries = Gi.new(this.root, {
        xAxis: this.xAxis,
        yAxis: this.yAxisList[t],
        ...i
      }), this.xySeries = this.chart.series.push(this.candlestickSeries), this.candlestickSeries.columns.template.setAll({
        width: 30
      }), this.candlestickSeries.columns.template.states.create("riseFromOpen", {
        fill: pe(this.candlestickSetComputed.riseColor),
        stroke: pe(this.candlestickSetComputed.riseColor)
      }), this.candlestickSeries.columns.template.states.create("dropFromOpen", {
        fill: pe(this.candlestickSetComputed.dropColor),
        stroke: pe(this.candlestickSetComputed.dropColor)
      }), this.candlestickSeries.get("tooltip").label.set(
        "text",
        `${(r = (s = this.candlestickDataBinder) == null ? void 0 : s.openValue) == null ? void 0 : r.displayName}: {openValueY}
${(a = (n = this.candlestickDataBinder) == null ? void 0 : n.highValue) == null ? void 0 : a.displayName}: {highValueY}
${(l = (o = this.candlestickDataBinder) == null ? void 0 : o.lowValue) == null ? void 0 : l.displayName}: {lowValueY}
${(c = (u = this.candlestickDataBinder) == null ? void 0 : u.defaultValue) == null ? void 0 : c.displayName}: {valueY}`
      ), this.candlestickSeries.columns.template.setAll({
        userData: {
          chartType: "candlestick",
          category: this.category,
          value: (d = (h = this.candlestickDataBinder) == null ? void 0 : h.defaultValue) == null ? void 0 : d.key
        }
      }), this.candlestickSeries.columns.template.events.on(
        "click",
        this.chartItemClickHandler
      ), this.candlestickSeries.data.setAll(this.data), this.setLegend();
    },
    setCandlestickSeriesXScrollbar(i) {
      this.xScrollbarSetComputed.isDetailed && !this.xScrollbarSetComputed.detail.mainValue.key && (this.xScrollbarCandlestickSeries = Gi.new(
        this.root,
        {
          xAxis: this.xScrollbarXAxis,
          yAxis: this.xScrollbarYAxis,
          ...i
        }
      ), this.xScrollbar.chart.series.push(this.xScrollbarCandlestickSeries), this.xScrollbarCandlestickSeries.columns.template.states.create(
        "riseFromOpen",
        {
          fill: pe(this.candlestickSetComputed.riseColor),
          stroke: pe(this.candlestickSetComputed.riseColor)
        }
      ), this.xScrollbarCandlestickSeries.columns.template.states.create(
        "dropFromOpen",
        {
          fill: pe(this.candlestickSetComputed.dropColor),
          stroke: pe(this.candlestickSetComputed.dropColor)
        }
      ), this.xScrollbarCandlestickSeries.data.setAll(this.data));
    },
    setLegend() {
      this.logTest && console.log("setLegend");
      const i = this;
      this.legendSetComputed.isVisible && (this.legend || (this.legend = Hr.new(i.root, {}), this.chart.children.push(this.legend)), this.legendSettings = {
        x: Ke(Number(i.legendSetComputed.x)),
        centerX: Ke(Number(i.legendSetComputed.centerX)),
        y: Ke(Number(i.legendSetComputed.y)),
        centerY: Ke(Number(i.legendSetComputed.centerY)),
        layout: gi.new(i.root, {
          maxColumns: i.legendSetComputed.maxColumns,
          fixedWidthGrid: !1
        }),
        height: 50,
        verticalScrollbar: _i.new(i.root, {
          orientation: "vertical"
        }),
        nameField: "name",
        fillField: "fill",
        strokeField: "stroke",
        clickTarget: "itemContainer",
        // 'itemContainer'(default), 'marker', 'none'
        useDefaultMarker: !1
        // false(default), true, undefined
      }, this.logTest && console.log("this.legend: ", this.legend), this.logTest && console.log("this.legendSettings: ", this.legendSettings), this.legend.setAll({ ...this.legendSettings }), this.logTest && console.log("this.chart.series.values: ", this.chart.series.values), this.legend.data.setAll(this.chart.series.values));
    }
  },
  beforeUnmount() {
    this.logTest && console.log("xy-chart beforeDestroy"), this.root && (this.logTest && console.log("root dispose"), this.root.dispose());
  },
  unmounted() {
    this.logTest && console.log("xy-chart destroyed");
  }
}, uh = {};
var iD = /* @__PURE__ */ te(
  tD,
  JS,
  eD,
  !1,
  sD,
  "312e6220",
  null,
  null
);
function sD(i) {
  for (let e in uh)
    this[e] = uh[e];
}
const rD = /* @__PURE__ */ function() {
  return iD.exports;
}();
var nD = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", [t("xy-chart", {
    key: 1e3,
    ref: "defaultXYChart",
    attrs: {
      "data-start-point": i.dataStartPoint,
      "data-end-point": i.dataEndPoint,
      "set-data-start-point": i.setDataStartPoint,
      "set-data-end-point": i.setDataEndPoint,
      "time-scale": i.timeScale,
      "style-props": "width: 100%; height: 110px",
      "chart-set": i.overallChartSetComputed,
      "bar-set": i.barSetComputed,
      "bubble-set": i.bubbleSetComputed,
      "line-set": i.lineSetComputed,
      "candlestick-set": i.candlestickSetComputed,
      "legend-set": i.overallLegendSetComputed,
      "x-scrollbar-set": i.xScrollbarSetComputed,
      "set-selection-min": i.setSelectionMin,
      "set-selection-max": i.setSelectionMax,
      "selection-min": i.selectionMin,
      "selection-max": i.selectionMax,
      "pan-handler": i.overallPanHandler,
      "chart-item-click-handler": i.chartItemClickHandler,
      data: i.overallData,
      category: i.category,
      "bubble-data-binder": i.bubbleDataBinder,
      "line-data-binder": i.lineDataBinder,
      "bar-data-binder": i.barDataBinder,
      "candlestick-data-binder": i.candlestickDataBinder,
      "axis-data-binder": i.axisDataBinder,
      "x-scrollbar-x-axis-label-text-adapter": i.xScrollbarXAxisLabelTextAdapter
    }
  }), t("xy-chart", {
    key: 2e3,
    ref: "overallXYChart",
    attrs: {
      "data-start-point": i.dataStartPoint,
      "data-end-point": i.dataEndPoint,
      "set-data-start-point": i.setDataStartPoint,
      "set-data-end-point": i.setDataEndPoint,
      "time-scale": i.timeScale,
      "chart-set": i.defaultChartSetComputed,
      "get-wheel-cursor-position-x": i.getWheelCursorPositionX,
      "zoom-handler": i.defaultZoomHandler,
      "pan-handler": i.defaultPanHandler,
      "bar-set": i.barSetComputed,
      "bubble-set": i.bubbleSetComputed,
      "line-set": i.lineSetComputed,
      "candlestick-set": i.candlestickSetComputed,
      "legend-set": i.legendSetComputed,
      "style-props": i.styleProps,
      "set-selection-min": i.setSelectionMin,
      "set-selection-max": i.setSelectionMax,
      "selection-min": i.selectionMin,
      "selection-max": i.selectionMax,
      "chart-item-click-handler": i.chartItemClickHandler,
      category: i.category,
      "bubble-data-binder": i.bubbleDataBinder,
      "line-data-binder": i.lineDataBinder,
      "bar-data-binder": i.barDataBinder,
      "candlestick-data-binder": i.candlestickDataBinder,
      "axis-data-binder": i.axisDataBinder,
      "x-axis-grid-stroke-opacity-adapter": i.xAxisGridStrokeOpacityAdapter,
      "x-axis-label-text-adapter": i.xAxisLabelTextAdapter,
      "x-axis-tooltip-label-text-adapter": i.xAxisTooltipLabelTextAdapter,
      "series-tooltip-label-html-adapter": i.seriesTooltipLabelHtmlAdapter,
      "series-tooltip-force-hidden-adapter": i.seriesTooltipForceHiddenAdapter
    },
    model: {
      value: i.defaultData,
      callback: function(s) {
        i.defaultData = s;
      },
      expression: "defaultData"
    }
  })], 1);
}, aD = [];
const oD = {
  name: "OverallXYChart",
  components: {
    "xy-chart": rD
  },
  watch: {
    dataStartPoint: {
      handler(i) {
        console.log("watch dataStartPoint 22: ", i);
      }
    },
    dataEndPoint: {
      handler(i) {
        console.log("watch dataEndPoint 22: ", i);
      }
    },
    xScrollbarSetComputed: {
      handler(i, e) {
        this.logTest && console.log("watch overall-xy-chart xScrollbarSetComputed"), this.logTest && console.log(i), this.logTest && console.log(e);
      },
      deep: !0
    },
    "xScrollbarSetComputed.detail.mainValue.displayName": {
      handler(i, e) {
        this.logTest && console.log(
          "watch overall-xy-chart xScrollbarSetComputed.detail.mainValue.displayName"
        ), this.logTest && console.log(i), this.logTest && console.log(e);
      }
    },
    defaultData: {
      handler() {
        this.logTest && console.log("watch defaultData: ", this.defaultData);
      },
      immediate: !0,
      deep: !0
    },
    overallData: {
      handler() {
        this.logTest && console.log("watch overallData: ", this.overallData);
      },
      immediate: !0,
      deep: !0
    }
  },
  computed: {
    defaultChartSetComputed() {
      return Je(this.defaultChartSetData, this.defaultChartSet);
    },
    overallChartSetComputed() {
      return Je(this.overallChartSetData, this.overallChartSet);
    },
    barSetComputed() {
      return Je(this.barSetData, this.barSet);
    },
    bubbleSetComputed() {
      return Je(this.bubbleSetData, this.bubbleSet);
    },
    lineSetComputed() {
      return Je(this.lineSetData, this.lineSet);
    },
    candlestickSetComputed() {
      return Je(this.candlestickSetData, this.candlestickSet);
    },
    legendSetComputed() {
      return Je(this.defaultLegendSetData, this.defaultLegendSet);
    },
    overallLegendSetComputed() {
      return Je(this.overallLegendSetData, this.overallLegendSet);
    },
    xScrollbarSetComputed() {
      return Je(this.xScrollbarSetData, this.xScrollbarSet);
    }
  },
  data() {
    return {
      logTest: !1,
      candlestickSetData: {
        riseColor: "#ff0000",
        dropColor: "#0000ff"
      },
      lineSetData: {
        isLineVisible: !1,
        strokeWidth: 2,
        fillOpacity: 0.1,
        bullet: {
          strokeWidth: 2,
          radius: 3
        },
        colorList: [
          "#f08080",
          "#fa8072",
          "#e9967a",
          "#ff7f50",
          "#ff6347",
          "#f4a460",
          "#ffa07a"
        ]
      },
      bubbleSetData: {
        strokeWidth: 2,
        bullet: {
          strokeWidth: 2,
          radius: 3
        },
        colorList: [
          "#f08080",
          "#fa8072",
          "#e9967a",
          "#ff7f50",
          "#ff6347",
          "#f4a460",
          "#ffa07a"
        ]
      },
      barSetData: {
        isStacked: !1,
        isClustered: !1,
        width: 15,
        strokeWidth: 1.5,
        fillOpacity: 0.3,
        cornerRadius: {
          topLeft: 0,
          topRight: 0
        },
        colorList: [
          "#BCE2C7",
          "#4EBCD5",
          "#1A2281",
          "#4169e1",
          "#1e90ff",
          "#0000cd",
          "#000080"
        ]
      },
      overallLegendSetData: {
        isVisible: !1,
        layout: "gridLayout",
        x: 50,
        centerX: 50,
        y: 100,
        centerY: 100
      },
      overallChartSetData: {
        refProps: "overallXYChart",
        id: "overallXYChart",
        chartType: "overall",
        titleLabel: {
          text: "",
          fontSize: 12,
          fontWeight: "normal",
          textAlign: "center",
          x: 5,
          centerX: 0,
          paddingTop: 0,
          paddingBottom: 0,
          color: "#555"
        },
        isZoomOutButton: !1,
        isYAxesPlotContainerVisible: !1,
        isBottomAxesContainerVisible: !1,
        chartLayout: "verticalLayout",
        panX: !0,
        panY: !1,
        wheelX: "",
        wheelY: "zoomX"
      },
      xScrollbarSetData: {
        isVisible: !0,
        isDown: !1,
        gripScale: 0.9,
        isStartGrip: !1,
        isEndGrip: !1,
        // startPosition: 0.2,
        // endPosition: 0.8,
        startPosition: 0,
        endPosition: 1,
        thumb: { fill: "#550000", fillOpacity: 0.05 },
        isDetailed: !0,
        detail: {
          isVisible: !0,
          height: 50,
          mainValue: { key: "", displayName: "" },
          line: { color: "#fb9f57", strokeWidth: 2, fillOpacity: 0.2 },
          background: {
            fill: "#000000",
            fillOpacity: 0.05,
            cornerRadius: {
              topLeft: 0,
              topRight: 10,
              bottomLeft: 10,
              bottomRight: 10
            }
          }
        }
      },
      defaultLegendSetData: {
        isVisible: !0,
        layout: "gridLayout",
        x: 50,
        centerX: 50,
        y: 100,
        centerY: 100
      },
      defaultChartSetData: {
        refProps: "defaultXYChart",
        id: "defaultXYChart",
        chartType: "default",
        titleLabel: {
          text: "",
          fontSize: 12,
          fontWeight: "normal",
          textAlign: "center",
          x: 5,
          centerX: 0,
          paddingTop: 0,
          paddingBottom: 0,
          color: "#555"
        },
        isZoomOutButton: !1,
        isYAxesPlotContainerVisible: !0,
        isBottomAxesContainerVisible: !0,
        chartLayout: "verticalLayout",
        panX: !0,
        panY: !1,
        wheelX: "",
        wheelY: "zoomX"
      }
    };
  },
  props: {
    // new
    dataStartPoint: String,
    dataEndPoint: String,
    setDataStartPoint: Function,
    setDataEndPoint: Function,
    getWheelCursorPositionX: Function,
    xAxisGridStrokeOpacityAdapter: Function,
    xAxisLabelTextAdapter: Function,
    xAxisTooltipLabelTextAdapter: Function,
    seriesTooltipLabelHtmlAdapter: Function,
    xScrollbarXAxisLabelTextAdapter: Function,
    seriesTooltipForceHiddenAdapter: Function,
    // data binder
    axisDataBinder: Object,
    styleProps: {
      type: String,
      default: "height: 400px; width: 100%; min-width: 800px;"
    },
    // chart ui common settings
    candlestickSet: Object,
    lineSet: Object,
    bubbleSet: Object,
    barSet: Object,
    // common
    setSelectionMin: Function,
    setSelectionMax: Function,
    selectionMin: [String, Number],
    selectionMax: [String, Number],
    timeScale: String,
    xScrollbarSet: Object,
    // default
    defaultChartSet: Object,
    defaultLegendSet: Object,
    defaultZoomHandler: Function,
    defaultPanHandler: Function,
    // overall
    overallChartSet: Object,
    overallLegendSet: Object,
    overallZoomHandler: Function,
    overallPanHandler: Function,
    // data settings
    defaultData: Array,
    overallData: Array,
    category: String,
    bubbleDataBinder: Array,
    lineDataBinder: Array,
    barDataBinder: Array,
    candlestickDataBinder: Array,
    chartItemClickHandler: Function
  },
  // methods: {
  //   setDataStartPoint(result) {
  //     console.log("setDataStartPoint: ", result);
  //     this.dataStartPoint = result;
  //   },
  //   setDataEndPoint(result) {
  //     console.log("setDataEndPoint: ", result);
  //     this.dataEndPoint = result;
  //   },
  // },
  mounted() {
    this.logTest && console.log("overall-xy-chart mounted"), this.logTest && console.log("defaultData: ", this.defaultData), this.logTest && console.log("overallData: ", this.overallData);
  }
}, hh = {};
var lD = /* @__PURE__ */ te(
  oD,
  nD,
  aD,
  !1,
  uD,
  null,
  null,
  null
);
function uD(i) {
  for (let e in hh)
    this[e] = hh[e];
}
const qO = /* @__PURE__ */ function() {
  return lD.exports;
}(), hD = {
  props: {
    changeHandlerParam: {
      type: Array,
      default: () => []
    },
    changeHandler: {
      type: Function,
      default: () => !0
    },
    idName: {
      type: String,
      default: ""
    },
    valueName: {
      type: String,
      default: ""
    },
    checkedName: {
      type: String,
      default: "checked"
    },
    disabledName: {
      type: String,
      default: "disabled"
    },
    enabledName: {
      type: String,
      default: ""
    },
    labelTextName: {
      type: String,
      default: "name"
    },
    styleProps: {
      type: String,
      default: ""
    },
    size: {
      type: String,
      default: ""
    },
    flexDirection: {
      type: String,
      default: "column"
    },
    itemList: {
      type: Array,
      default: () => []
    },
    category: {
      type: String,
      default: ""
    }
  },
  computed: {
    checkListClassComputed() {
      return `${this.$style.check_list} ${this.$style[this.size]} ${this.$style[this.flexDirection]}`;
    }
  }
};
var cD = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("ul", {
    class: i.checkListClassComputed,
    style: i.styleProps
  }, i._l(i.itemList, function(s, r) {
    return t("li", {
      key: r
    }, [t("label", {
      attrs: {
        for: `${i.category ? i.category : "checkbox"}-${s[i.idName]}-${r}`,
        disabled: i.enabledName ? !s[i.enabledName] : !!s[i.disabledName]
      }
    }, [t("input", {
      attrs: {
        id: `${i.category ? i.category : "checkbox"}-${s[i.idName]}-${r}`,
        type: "checkbox"
      },
      domProps: {
        value: s[i.checkedName],
        checked: !!s[i.checkedName]
      },
      on: {
        input: function(n) {
          var a;
          return (a = i).changeHandler.apply(a, [n].concat(i.changeHandlerParam));
        }
      }
    }), t("div", {
      class: [`${i.$style.checkbox_custom} ${s[i.labelTextName] ? i.$style.with_label : ""}`]
    }), i._t("default")], 2)]);
  }), 0);
}, dD = [];
const fD = "_check_list_1ywte_5", pD = "_row_1ywte_13", gD = "_checkbox_custom_1ywte_20", _D = "_with_label_1ywte_47", mD = "_small_1ywte_66", bD = {
  check_list: fD,
  row: pD,
  checkbox_custom: gD,
  with_label: _D,
  small: mD
}, cl = {};
cl.$style = bD;
var yD = /* @__PURE__ */ te(
  hD,
  cD,
  dD,
  !1,
  vD,
  null,
  null,
  null
);
function vD(i) {
  for (let e in cl)
    this[e] = cl[e];
}
const JO = /* @__PURE__ */ function() {
  return yD.exports;
}(), xD = {
  props: {
    styleProps: {
      type: String,
      default: ""
    },
    inactive: {
      type: Boolean,
      default: !1
    },
    clickHandler: Function
  },
  methods: {
    executor() {
      this.clickHandler && this.clickHandler();
    }
  }
};
var wD = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    class: i.$style["chips-container"],
    style: i.styleProps,
    attrs: {
      inactive: i.inactive
    }
  }, [t("span", [i._t("default")], 2), i.inactive ? i._e() : t("div", {
    on: {
      click: i.executor
    }
  }, [t("img", {
    attrs: {
      alt: "close-icon"
    }
  })])]);
}, SD = [];
const DD = {
  "chips-container": "_chips-container_1bomp_1"
}, dl = {};
dl.$style = DD;
var PD = /* @__PURE__ */ te(
  xD,
  wD,
  SD,
  !1,
  TD,
  null,
  null,
  null
);
function TD(i) {
  for (let e in dl)
    this[e] = dl[e];
}
const eA = /* @__PURE__ */ function() {
  return PD.exports;
}();
var fl = {}, kD = {
  get exports() {
    return fl;
  },
  set exports(i) {
    fl = i;
  }
};
/**!
 * Sortable 1.10.2
 * @author	RubaXa   <trash@rubaxa.org>
 * @author	owenm    <owen23355@gmail.com>
 * @license MIT
 */
function Ln(i) {
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Ln = function(e) {
    return typeof e;
  } : Ln = function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Ln(i);
}
function CD(i, e, t) {
  return e in i ? Object.defineProperty(i, e, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : i[e] = t, i;
}
function Ft() {
  return Ft = Object.assign || function(i) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var s in t)
        Object.prototype.hasOwnProperty.call(t, s) && (i[s] = t[s]);
    }
    return i;
  }, Ft.apply(this, arguments);
}
function Zi(i) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {}, s = Object.keys(t);
    typeof Object.getOwnPropertySymbols == "function" && (s = s.concat(Object.getOwnPropertySymbols(t).filter(function(r) {
      return Object.getOwnPropertyDescriptor(t, r).enumerable;
    }))), s.forEach(function(r) {
      CD(i, r, t[r]);
    });
  }
  return i;
}
function MD(i, e) {
  if (i == null)
    return {};
  var t = {}, s = Object.keys(i), r, n;
  for (n = 0; n < s.length; n++)
    r = s[n], !(e.indexOf(r) >= 0) && (t[r] = i[r]);
  return t;
}
function OD(i, e) {
  if (i == null)
    return {};
  var t = MD(i, e), s, r;
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(i);
    for (r = 0; r < n.length; r++)
      s = n[r], !(e.indexOf(s) >= 0) && Object.prototype.propertyIsEnumerable.call(i, s) && (t[s] = i[s]);
  }
  return t;
}
function AD(i) {
  return LD(i) || jD(i) || ED();
}
function LD(i) {
  if (Array.isArray(i)) {
    for (var e = 0, t = new Array(i.length); e < i.length; e++)
      t[e] = i[e];
    return t;
  }
}
function jD(i) {
  if (Symbol.iterator in Object(i) || Object.prototype.toString.call(i) === "[object Arguments]")
    return Array.from(i);
}
function ED() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}
var ID = "1.10.2";
function di(i) {
  if (typeof window < "u" && window.navigator)
    return !!/* @__PURE__ */ navigator.userAgent.match(i);
}
var vi = di(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i), on = di(/Edge/i), ch = di(/firefox/i), pl = di(/safari/i) && !di(/chrome/i) && !di(/android/i), Xd = di(/iP(ad|od|hone)/i), YD = di(/chrome/i) && di(/android/i), Vd = {
  capture: !1,
  passive: !1
};
function fe(i, e, t) {
  i.addEventListener(e, t, !vi && Vd);
}
function ue(i, e, t) {
  i.removeEventListener(e, t, !vi && Vd);
}
function Pa(i, e) {
  if (e) {
    if (e[0] === ">" && (e = e.substring(1)), i)
      try {
        if (i.matches)
          return i.matches(e);
        if (i.msMatchesSelector)
          return i.msMatchesSelector(e);
        if (i.webkitMatchesSelector)
          return i.webkitMatchesSelector(e);
      } catch {
        return !1;
      }
    return !1;
  }
}
function RD(i) {
  return i.host && i !== document && i.host.nodeType ? i.host : i.parentNode;
}
function Vt(i, e, t, s) {
  if (i) {
    t = t || document;
    do {
      if (e != null && (e[0] === ">" ? i.parentNode === t && Pa(i, e) : Pa(i, e)) || s && i === t)
        return i;
      if (i === t)
        break;
    } while (i = RD(i));
  }
  return null;
}
var dh = /\s+/g;
function Ce(i, e, t) {
  if (i && e)
    if (i.classList)
      i.classList[t ? "add" : "remove"](e);
    else {
      var s = (" " + i.className + " ").replace(dh, " ").replace(" " + e + " ", " ");
      i.className = (s + (t ? " " + e : "")).replace(dh, " ");
    }
}
function G(i, e, t) {
  var s = i && i.style;
  if (s) {
    if (t === void 0)
      return document.defaultView && document.defaultView.getComputedStyle ? t = document.defaultView.getComputedStyle(i, "") : i.currentStyle && (t = i.currentStyle), e === void 0 ? t : t[e];
    !(e in s) && e.indexOf("webkit") === -1 && (e = "-webkit-" + e), s[e] = t + (typeof t == "string" ? "" : "px");
  }
}
function fs(i, e) {
  var t = "";
  if (typeof i == "string")
    t = i;
  else
    do {
      var s = G(i, "transform");
      s && s !== "none" && (t = s + " " + t);
    } while (!e && (i = i.parentNode));
  var r = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
  return r && new r(t);
}
function Ud(i, e, t) {
  if (i) {
    var s = i.getElementsByTagName(e), r = 0, n = s.length;
    if (t)
      for (; r < n; r++)
        t(s[r], r);
    return s;
  }
  return [];
}
function ei() {
  var i = document.scrollingElement;
  return i || document.documentElement;
}
function je(i, e, t, s, r) {
  if (!(!i.getBoundingClientRect && i !== window)) {
    var n, a, o, l, u, c, h;
    if (i !== window && i !== ei() ? (n = i.getBoundingClientRect(), a = n.top, o = n.left, l = n.bottom, u = n.right, c = n.height, h = n.width) : (a = 0, o = 0, l = window.innerHeight, u = window.innerWidth, c = window.innerHeight, h = window.innerWidth), (e || t) && i !== window && (r = r || i.parentNode, !vi))
      do
        if (r && r.getBoundingClientRect && (G(r, "transform") !== "none" || t && G(r, "position") !== "static")) {
          var d = r.getBoundingClientRect();
          a -= d.top + parseInt(G(r, "border-top-width")), o -= d.left + parseInt(G(r, "border-left-width")), l = a + n.height, u = o + n.width;
          break;
        }
      while (r = r.parentNode);
    if (s && i !== window) {
      var f = fs(r || i), g = f && f.a, p = f && f.d;
      f && (a /= p, o /= g, h /= g, c /= p, l = a + c, u = o + h);
    }
    return {
      top: a,
      left: o,
      bottom: l,
      right: u,
      width: h,
      height: c
    };
  }
}
function fh(i, e, t) {
  for (var s = Oi(i, !0), r = je(i)[e]; s; ) {
    var n = je(s)[t], a = void 0;
    if (t === "top" || t === "left" ? a = r >= n : a = r <= n, !a)
      return s;
    if (s === ei())
      break;
    s = Oi(s, !1);
  }
  return !1;
}
function Ta(i, e, t) {
  for (var s = 0, r = 0, n = i.children; r < n.length; ) {
    if (n[r].style.display !== "none" && n[r] !== ee.ghost && n[r] !== ee.dragged && Vt(n[r], t.draggable, i, !1)) {
      if (s === e)
        return n[r];
      s++;
    }
    r++;
  }
  return null;
}
function bu(i, e) {
  for (var t = i.lastElementChild; t && (t === ee.ghost || G(t, "display") === "none" || e && !Pa(t, e)); )
    t = t.previousElementSibling;
  return t || null;
}
function Ae(i, e) {
  var t = 0;
  if (!i || !i.parentNode)
    return -1;
  for (; i = i.previousElementSibling; )
    i.nodeName.toUpperCase() !== "TEMPLATE" && i !== ee.clone && (!e || Pa(i, e)) && t++;
  return t;
}
function ph(i) {
  var e = 0, t = 0, s = ei();
  if (i)
    do {
      var r = fs(i), n = r.a, a = r.d;
      e += i.scrollLeft * n, t += i.scrollTop * a;
    } while (i !== s && (i = i.parentNode));
  return [e, t];
}
function ND(i, e) {
  for (var t in i)
    if (i.hasOwnProperty(t)) {
      for (var s in e)
        if (e.hasOwnProperty(s) && e[s] === i[t][s])
          return Number(t);
    }
  return -1;
}
function Oi(i, e) {
  if (!i || !i.getBoundingClientRect)
    return ei();
  var t = i, s = !1;
  do
    if (t.clientWidth < t.scrollWidth || t.clientHeight < t.scrollHeight) {
      var r = G(t);
      if (t.clientWidth < t.scrollWidth && (r.overflowX == "auto" || r.overflowX == "scroll") || t.clientHeight < t.scrollHeight && (r.overflowY == "auto" || r.overflowY == "scroll")) {
        if (!t.getBoundingClientRect || t === document.body)
          return ei();
        if (s || e)
          return t;
        s = !0;
      }
    }
  while (t = t.parentNode);
  return ei();
}
function $D(i, e) {
  if (i && e)
    for (var t in e)
      e.hasOwnProperty(t) && (i[t] = e[t]);
  return i;
}
function vo(i, e) {
  return Math.round(i.top) === Math.round(e.top) && Math.round(i.left) === Math.round(e.left) && Math.round(i.height) === Math.round(e.height) && Math.round(i.width) === Math.round(e.width);
}
var Lr;
function Wd(i, e) {
  return function() {
    if (!Lr) {
      var t = arguments, s = this;
      t.length === 1 ? i.call(s, t[0]) : i.apply(s, t), Lr = setTimeout(function() {
        Lr = void 0;
      }, e);
    }
  };
}
function FD() {
  clearTimeout(Lr), Lr = void 0;
}
function Gd(i, e, t) {
  i.scrollLeft += e, i.scrollTop += t;
}
function yu(i) {
  var e = window.Polymer, t = window.jQuery || window.Zepto;
  return e && e.dom ? e.dom(i).cloneNode(!0) : t ? t(i).clone(!0)[0] : i.cloneNode(!0);
}
function gh(i, e) {
  G(i, "position", "absolute"), G(i, "top", e.top), G(i, "left", e.left), G(i, "width", e.width), G(i, "height", e.height);
}
function xo(i) {
  G(i, "position", ""), G(i, "top", ""), G(i, "left", ""), G(i, "width", ""), G(i, "height", "");
}
var rt = "Sortable" + new Date().getTime();
function BD() {
  var i = [], e;
  return {
    captureAnimationState: function() {
      if (i = [], !!this.options.animation) {
        var s = [].slice.call(this.el.children);
        s.forEach(function(r) {
          if (!(G(r, "display") === "none" || r === ee.ghost)) {
            i.push({
              target: r,
              rect: je(r)
            });
            var n = Zi({}, i[i.length - 1].rect);
            if (r.thisAnimationDuration) {
              var a = fs(r, !0);
              a && (n.top -= a.f, n.left -= a.e);
            }
            r.fromRect = n;
          }
        });
      }
    },
    addAnimationState: function(s) {
      i.push(s);
    },
    removeAnimationState: function(s) {
      i.splice(ND(i, {
        target: s
      }), 1);
    },
    animateAll: function(s) {
      var r = this;
      if (!this.options.animation) {
        clearTimeout(e), typeof s == "function" && s();
        return;
      }
      var n = !1, a = 0;
      i.forEach(function(o) {
        var l = 0, u = o.target, c = u.fromRect, h = je(u), d = u.prevFromRect, f = u.prevToRect, g = o.rect, p = fs(u, !0);
        p && (h.top -= p.f, h.left -= p.e), u.toRect = h, u.thisAnimationDuration && vo(d, h) && !vo(c, h) && // Make sure animatingRect is on line between toRect & fromRect
        (g.top - h.top) / (g.left - h.left) === (c.top - h.top) / (c.left - h.left) && (l = zD(g, d, f, r.options)), vo(h, c) || (u.prevFromRect = c, u.prevToRect = h, l || (l = r.options.animation), r.animate(u, g, h, l)), l && (n = !0, a = Math.max(a, l), clearTimeout(u.animationResetTimer), u.animationResetTimer = setTimeout(function() {
          u.animationTime = 0, u.prevFromRect = null, u.fromRect = null, u.prevToRect = null, u.thisAnimationDuration = null;
        }, l), u.thisAnimationDuration = l);
      }), clearTimeout(e), n ? e = setTimeout(function() {
        typeof s == "function" && s();
      }, a) : typeof s == "function" && s(), i = [];
    },
    animate: function(s, r, n, a) {
      if (a) {
        G(s, "transition", ""), G(s, "transform", "");
        var o = fs(this.el), l = o && o.a, u = o && o.d, c = (r.left - n.left) / (l || 1), h = (r.top - n.top) / (u || 1);
        s.animatingX = !!c, s.animatingY = !!h, G(s, "transform", "translate3d(" + c + "px," + h + "px,0)"), HD(s), G(s, "transition", "transform " + a + "ms" + (this.options.easing ? " " + this.options.easing : "")), G(s, "transform", "translate3d(0,0,0)"), typeof s.animated == "number" && clearTimeout(s.animated), s.animated = setTimeout(function() {
          G(s, "transition", ""), G(s, "transform", ""), s.animated = !1, s.animatingX = !1, s.animatingY = !1;
        }, a);
      }
    }
  };
}
function HD(i) {
  return i.offsetWidth;
}
function zD(i, e, t, s) {
  return Math.sqrt(Math.pow(e.top - i.top, 2) + Math.pow(e.left - i.left, 2)) / Math.sqrt(Math.pow(e.top - t.top, 2) + Math.pow(e.left - t.left, 2)) * s.animation;
}
var fr = [], wo = {
  initializeByDefault: !0
}, ln = {
  mount: function(e) {
    for (var t in wo)
      wo.hasOwnProperty(t) && !(t in e) && (e[t] = wo[t]);
    fr.push(e);
  },
  pluginEvent: function(e, t, s) {
    var r = this;
    this.eventCanceled = !1, s.cancel = function() {
      r.eventCanceled = !0;
    };
    var n = e + "Global";
    fr.forEach(function(a) {
      t[a.pluginName] && (t[a.pluginName][n] && t[a.pluginName][n](Zi({
        sortable: t
      }, s)), t.options[a.pluginName] && t[a.pluginName][e] && t[a.pluginName][e](Zi({
        sortable: t
      }, s)));
    });
  },
  initializePlugins: function(e, t, s, r) {
    fr.forEach(function(o) {
      var l = o.pluginName;
      if (!(!e.options[l] && !o.initializeByDefault)) {
        var u = new o(e, t, e.options);
        u.sortable = e, u.options = e.options, e[l] = u, Ft(s, u.defaults);
      }
    });
    for (var n in e.options)
      if (e.options.hasOwnProperty(n)) {
        var a = this.modifyOption(e, n, e.options[n]);
        typeof a < "u" && (e.options[n] = a);
      }
  },
  getEventProperties: function(e, t) {
    var s = {};
    return fr.forEach(function(r) {
      typeof r.eventProperties == "function" && Ft(s, r.eventProperties.call(t[r.pluginName], e));
    }), s;
  },
  modifyOption: function(e, t, s) {
    var r;
    return fr.forEach(function(n) {
      e[n.pluginName] && n.optionListeners && typeof n.optionListeners[t] == "function" && (r = n.optionListeners[t].call(e[n.pluginName], s));
    }), r;
  }
};
function wr(i) {
  var e = i.sortable, t = i.rootEl, s = i.name, r = i.targetEl, n = i.cloneEl, a = i.toEl, o = i.fromEl, l = i.oldIndex, u = i.newIndex, c = i.oldDraggableIndex, h = i.newDraggableIndex, d = i.originalEvent, f = i.putSortable, g = i.extraEventProperties;
  if (e = e || t && t[rt], !!e) {
    var p, _ = e.options, m = "on" + s.charAt(0).toUpperCase() + s.substr(1);
    window.CustomEvent && !vi && !on ? p = new CustomEvent(s, {
      bubbles: !0,
      cancelable: !0
    }) : (p = document.createEvent("Event"), p.initEvent(s, !0, !0)), p.to = a || t, p.from = o || t, p.item = r || t, p.clone = n, p.oldIndex = l, p.newIndex = u, p.oldDraggableIndex = c, p.newDraggableIndex = h, p.originalEvent = d, p.pullMode = f ? f.lastPutMode : void 0;
    var v = Zi({}, g, ln.getEventProperties(s, e));
    for (var b in v)
      p[b] = v[b];
    t && t.dispatchEvent(p), _[m] && _[m].call(e, p);
  }
}
var gt = function(e, t) {
  var s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, r = s.evt, n = OD(s, ["evt"]);
  ln.pluginEvent.bind(ee)(e, t, Zi({
    dragEl: F,
    parentEl: Fe,
    ghostEl: ne,
    rootEl: ke,
    nextEl: ns,
    lastDownEl: jn,
    cloneEl: Me,
    cloneHidden: Si,
    dragStarted: Sr,
    putSortable: Qe,
    activeSortable: ee.active,
    originalEvent: r,
    oldIndex: js,
    oldDraggableIndex: jr,
    newIndex: Tt,
    newDraggableIndex: wi,
    hideGhostForTarget: qd,
    unhideGhostForTarget: Jd,
    cloneNowHidden: function() {
      Si = !0;
    },
    cloneNowShown: function() {
      Si = !1;
    },
    dispatchSortableEvent: function(o) {
      ct({
        sortable: t,
        name: o,
        originalEvent: r
      });
    }
  }, n));
};
function ct(i) {
  wr(Zi({
    putSortable: Qe,
    cloneEl: Me,
    targetEl: F,
    rootEl: ke,
    oldIndex: js,
    oldDraggableIndex: jr,
    newIndex: Tt,
    newDraggableIndex: wi
  }, i));
}
var F, Fe, ne, ke, ns, jn, Me, Si, js, Tt, jr, wi, yn, Qe, Ts = !1, ka = !1, Ca = [], es, zt, So, Do, _h, mh, Sr, ws, Er, Ir = !1, vn = !1, En, it, Po = [], gl = !1, Ma = [], io = typeof document < "u", xn = Xd, bh = on || vi ? "cssFloat" : "float", XD = io && !YD && !Xd && "draggable" in document.createElement("div"), Zd = function() {
  if (io) {
    if (vi)
      return !1;
    var i = document.createElement("x");
    return i.style.cssText = "pointer-events:auto", i.style.pointerEvents === "auto";
  }
}(), Kd = function(e, t) {
  var s = G(e), r = parseInt(s.width) - parseInt(s.paddingLeft) - parseInt(s.paddingRight) - parseInt(s.borderLeftWidth) - parseInt(s.borderRightWidth), n = Ta(e, 0, t), a = Ta(e, 1, t), o = n && G(n), l = a && G(a), u = o && parseInt(o.marginLeft) + parseInt(o.marginRight) + je(n).width, c = l && parseInt(l.marginLeft) + parseInt(l.marginRight) + je(a).width;
  if (s.display === "flex")
    return s.flexDirection === "column" || s.flexDirection === "column-reverse" ? "vertical" : "horizontal";
  if (s.display === "grid")
    return s.gridTemplateColumns.split(" ").length <= 1 ? "vertical" : "horizontal";
  if (n && o.float && o.float !== "none") {
    var h = o.float === "left" ? "left" : "right";
    return a && (l.clear === "both" || l.clear === h) ? "vertical" : "horizontal";
  }
  return n && (o.display === "block" || o.display === "flex" || o.display === "table" || o.display === "grid" || u >= r && s[bh] === "none" || a && s[bh] === "none" && u + c > r) ? "vertical" : "horizontal";
}, VD = function(e, t, s) {
  var r = s ? e.left : e.top, n = s ? e.right : e.bottom, a = s ? e.width : e.height, o = s ? t.left : t.top, l = s ? t.right : t.bottom, u = s ? t.width : t.height;
  return r === o || n === l || r + a / 2 === o + u / 2;
}, UD = function(e, t) {
  var s;
  return Ca.some(function(r) {
    if (!bu(r)) {
      var n = je(r), a = r[rt].options.emptyInsertThreshold, o = e >= n.left - a && e <= n.right + a, l = t >= n.top - a && t <= n.bottom + a;
      if (a && o && l)
        return s = r;
    }
  }), s;
}, Qd = function(e) {
  function t(n, a) {
    return function(o, l, u, c) {
      var h = o.options.group.name && l.options.group.name && o.options.group.name === l.options.group.name;
      if (n == null && (a || h))
        return !0;
      if (n == null || n === !1)
        return !1;
      if (a && n === "clone")
        return n;
      if (typeof n == "function")
        return t(n(o, l, u, c), a)(o, l, u, c);
      var d = (a ? o : l).options.group.name;
      return n === !0 || typeof n == "string" && n === d || n.join && n.indexOf(d) > -1;
    };
  }
  var s = {}, r = e.group;
  (!r || Ln(r) != "object") && (r = {
    name: r
  }), s.name = r.name, s.checkPull = t(r.pull, !0), s.checkPut = t(r.put), s.revertClone = r.revertClone, e.group = s;
}, qd = function() {
  !Zd && ne && G(ne, "display", "none");
}, Jd = function() {
  !Zd && ne && G(ne, "display", "");
};
io && document.addEventListener("click", function(i) {
  if (ka)
    return i.preventDefault(), i.stopPropagation && i.stopPropagation(), i.stopImmediatePropagation && i.stopImmediatePropagation(), ka = !1, !1;
}, !0);
var ts = function(e) {
  if (F) {
    e = e.touches ? e.touches[0] : e;
    var t = UD(e.clientX, e.clientY);
    if (t) {
      var s = {};
      for (var r in e)
        e.hasOwnProperty(r) && (s[r] = e[r]);
      s.target = s.rootEl = t, s.preventDefault = void 0, s.stopPropagation = void 0, t[rt]._onDragOver(s);
    }
  }
}, WD = function(e) {
  F && F.parentNode[rt]._isOutsideThisEl(e.target);
};
function ee(i, e) {
  if (!(i && i.nodeType && i.nodeType === 1))
    throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(i));
  this.el = i, this.options = e = Ft({}, e), i[rt] = this;
  var t = {
    group: null,
    sort: !0,
    disabled: !1,
    store: null,
    handle: null,
    draggable: /^[uo]l$/i.test(i.nodeName) ? ">li" : ">*",
    swapThreshold: 1,
    // percentage; 0 <= x <= 1
    invertSwap: !1,
    // invert always
    invertedSwapThreshold: null,
    // will be set to same as swapThreshold if default
    removeCloneOnHide: !0,
    direction: function() {
      return Kd(i, this.options);
    },
    ghostClass: "sortable-ghost",
    chosenClass: "sortable-chosen",
    dragClass: "sortable-drag",
    ignore: "a, img",
    filter: null,
    preventOnFilter: !0,
    animation: 0,
    easing: null,
    setData: function(a, o) {
      a.setData("Text", o.textContent);
    },
    dropBubble: !1,
    dragoverBubble: !1,
    dataIdAttr: "data-id",
    delay: 0,
    delayOnTouchOnly: !1,
    touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
    forceFallback: !1,
    fallbackClass: "sortable-fallback",
    fallbackOnBody: !1,
    fallbackTolerance: 0,
    fallbackOffset: {
      x: 0,
      y: 0
    },
    supportPointer: ee.supportPointer !== !1 && "PointerEvent" in window,
    emptyInsertThreshold: 5
  };
  ln.initializePlugins(this, i, t);
  for (var s in t)
    !(s in e) && (e[s] = t[s]);
  Qd(e);
  for (var r in this)
    r.charAt(0) === "_" && typeof this[r] == "function" && (this[r] = this[r].bind(this));
  this.nativeDraggable = e.forceFallback ? !1 : XD, this.nativeDraggable && (this.options.touchStartThreshold = 1), e.supportPointer ? fe(i, "pointerdown", this._onTapStart) : (fe(i, "mousedown", this._onTapStart), fe(i, "touchstart", this._onTapStart)), this.nativeDraggable && (fe(i, "dragover", this), fe(i, "dragenter", this)), Ca.push(this.el), e.store && e.store.get && this.sort(e.store.get(this) || []), Ft(this, BD());
}
ee.prototype = /** @lends Sortable.prototype */
{
  constructor: ee,
  _isOutsideThisEl: function(e) {
    !this.el.contains(e) && e !== this.el && (ws = null);
  },
  _getDirection: function(e, t) {
    return typeof this.options.direction == "function" ? this.options.direction.call(this, e, t, F) : this.options.direction;
  },
  _onTapStart: function(e) {
    if (e.cancelable) {
      var t = this, s = this.el, r = this.options, n = r.preventOnFilter, a = e.type, o = e.touches && e.touches[0] || e.pointerType && e.pointerType === "touch" && e, l = (o || e).target, u = e.target.shadowRoot && (e.path && e.path[0] || e.composedPath && e.composedPath()[0]) || l, c = r.filter;
      if (e1(s), !F && !(/mousedown|pointerdown/.test(a) && e.button !== 0 || r.disabled) && !u.isContentEditable && (l = Vt(l, r.draggable, s, !1), !(l && l.animated) && jn !== l)) {
        if (js = Ae(l), jr = Ae(l, r.draggable), typeof c == "function") {
          if (c.call(this, e, l, this)) {
            ct({
              sortable: t,
              rootEl: u,
              name: "filter",
              targetEl: l,
              toEl: s,
              fromEl: s
            }), gt("filter", t, {
              evt: e
            }), n && e.cancelable && e.preventDefault();
            return;
          }
        } else if (c && (c = c.split(",").some(function(h) {
          if (h = Vt(u, h.trim(), s, !1), h)
            return ct({
              sortable: t,
              rootEl: h,
              name: "filter",
              targetEl: l,
              fromEl: s,
              toEl: s
            }), gt("filter", t, {
              evt: e
            }), !0;
        }), c)) {
          n && e.cancelable && e.preventDefault();
          return;
        }
        r.handle && !Vt(u, r.handle, s, !1) || this._prepareDragStart(e, o, l);
      }
    }
  },
  _prepareDragStart: function(e, t, s) {
    var r = this, n = r.el, a = r.options, o = n.ownerDocument, l;
    if (s && !F && s.parentNode === n) {
      var u = je(s);
      if (ke = n, F = s, Fe = F.parentNode, ns = F.nextSibling, jn = s, yn = a.group, ee.dragged = F, es = {
        target: F,
        clientX: (t || e).clientX,
        clientY: (t || e).clientY
      }, _h = es.clientX - u.left, mh = es.clientY - u.top, this._lastX = (t || e).clientX, this._lastY = (t || e).clientY, F.style["will-change"] = "all", l = function() {
        if (gt("delayEnded", r, {
          evt: e
        }), ee.eventCanceled) {
          r._onDrop();
          return;
        }
        r._disableDelayedDragEvents(), !ch && r.nativeDraggable && (F.draggable = !0), r._triggerDragStart(e, t), ct({
          sortable: r,
          name: "choose",
          originalEvent: e
        }), Ce(F, a.chosenClass, !0);
      }, a.ignore.split(",").forEach(function(c) {
        Ud(F, c.trim(), ko);
      }), fe(o, "dragover", ts), fe(o, "mousemove", ts), fe(o, "touchmove", ts), fe(o, "mouseup", r._onDrop), fe(o, "touchend", r._onDrop), fe(o, "touchcancel", r._onDrop), ch && this.nativeDraggable && (this.options.touchStartThreshold = 4, F.draggable = !0), gt("delayStart", this, {
        evt: e
      }), a.delay && (!a.delayOnTouchOnly || t) && (!this.nativeDraggable || !(on || vi))) {
        if (ee.eventCanceled) {
          this._onDrop();
          return;
        }
        fe(o, "mouseup", r._disableDelayedDrag), fe(o, "touchend", r._disableDelayedDrag), fe(o, "touchcancel", r._disableDelayedDrag), fe(o, "mousemove", r._delayedDragTouchMoveHandler), fe(o, "touchmove", r._delayedDragTouchMoveHandler), a.supportPointer && fe(o, "pointermove", r._delayedDragTouchMoveHandler), r._dragStartTimer = setTimeout(l, a.delay);
      } else
        l();
    }
  },
  _delayedDragTouchMoveHandler: function(e) {
    var t = e.touches ? e.touches[0] : e;
    Math.max(Math.abs(t.clientX - this._lastX), Math.abs(t.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1)) && this._disableDelayedDrag();
  },
  _disableDelayedDrag: function() {
    F && ko(F), clearTimeout(this._dragStartTimer), this._disableDelayedDragEvents();
  },
  _disableDelayedDragEvents: function() {
    var e = this.el.ownerDocument;
    ue(e, "mouseup", this._disableDelayedDrag), ue(e, "touchend", this._disableDelayedDrag), ue(e, "touchcancel", this._disableDelayedDrag), ue(e, "mousemove", this._delayedDragTouchMoveHandler), ue(e, "touchmove", this._delayedDragTouchMoveHandler), ue(e, "pointermove", this._delayedDragTouchMoveHandler);
  },
  _triggerDragStart: function(e, t) {
    t = t || e.pointerType == "touch" && e, !this.nativeDraggable || t ? this.options.supportPointer ? fe(document, "pointermove", this._onTouchMove) : t ? fe(document, "touchmove", this._onTouchMove) : fe(document, "mousemove", this._onTouchMove) : (fe(F, "dragend", this), fe(ke, "dragstart", this._onDragStart));
    try {
      document.selection ? In(function() {
        document.selection.empty();
      }) : window.getSelection().removeAllRanges();
    } catch {
    }
  },
  _dragStarted: function(e, t) {
    if (Ts = !1, ke && F) {
      gt("dragStarted", this, {
        evt: t
      }), this.nativeDraggable && fe(document, "dragover", WD);
      var s = this.options;
      !e && Ce(F, s.dragClass, !1), Ce(F, s.ghostClass, !0), ee.active = this, e && this._appendGhost(), ct({
        sortable: this,
        name: "start",
        originalEvent: t
      });
    } else
      this._nulling();
  },
  _emulateDragOver: function() {
    if (zt) {
      this._lastX = zt.clientX, this._lastY = zt.clientY, qd();
      for (var e = document.elementFromPoint(zt.clientX, zt.clientY), t = e; e && e.shadowRoot && (e = e.shadowRoot.elementFromPoint(zt.clientX, zt.clientY), e !== t); )
        t = e;
      if (F.parentNode[rt]._isOutsideThisEl(e), t)
        do {
          if (t[rt]) {
            var s = void 0;
            if (s = t[rt]._onDragOver({
              clientX: zt.clientX,
              clientY: zt.clientY,
              target: e,
              rootEl: t
            }), s && !this.options.dragoverBubble)
              break;
          }
          e = t;
        } while (t = t.parentNode);
      Jd();
    }
  },
  _onTouchMove: function(e) {
    if (es) {
      var t = this.options, s = t.fallbackTolerance, r = t.fallbackOffset, n = e.touches ? e.touches[0] : e, a = ne && fs(ne, !0), o = ne && a && a.a, l = ne && a && a.d, u = xn && it && ph(it), c = (n.clientX - es.clientX + r.x) / (o || 1) + (u ? u[0] - Po[0] : 0) / (o || 1), h = (n.clientY - es.clientY + r.y) / (l || 1) + (u ? u[1] - Po[1] : 0) / (l || 1);
      if (!ee.active && !Ts) {
        if (s && Math.max(Math.abs(n.clientX - this._lastX), Math.abs(n.clientY - this._lastY)) < s)
          return;
        this._onDragStart(e, !0);
      }
      if (ne) {
        a ? (a.e += c - (So || 0), a.f += h - (Do || 0)) : a = {
          a: 1,
          b: 0,
          c: 0,
          d: 1,
          e: c,
          f: h
        };
        var d = "matrix(".concat(a.a, ",").concat(a.b, ",").concat(a.c, ",").concat(a.d, ",").concat(a.e, ",").concat(a.f, ")");
        G(ne, "webkitTransform", d), G(ne, "mozTransform", d), G(ne, "msTransform", d), G(ne, "transform", d), So = c, Do = h, zt = n;
      }
      e.cancelable && e.preventDefault();
    }
  },
  _appendGhost: function() {
    if (!ne) {
      var e = this.options.fallbackOnBody ? document.body : ke, t = je(F, !0, xn, !0, e), s = this.options;
      if (xn) {
        for (it = e; G(it, "position") === "static" && G(it, "transform") === "none" && it !== document; )
          it = it.parentNode;
        it !== document.body && it !== document.documentElement ? (it === document && (it = ei()), t.top += it.scrollTop, t.left += it.scrollLeft) : it = ei(), Po = ph(it);
      }
      ne = F.cloneNode(!0), Ce(ne, s.ghostClass, !1), Ce(ne, s.fallbackClass, !0), Ce(ne, s.dragClass, !0), G(ne, "transition", ""), G(ne, "transform", ""), G(ne, "box-sizing", "border-box"), G(ne, "margin", 0), G(ne, "top", t.top), G(ne, "left", t.left), G(ne, "width", t.width), G(ne, "height", t.height), G(ne, "opacity", "0.8"), G(ne, "position", xn ? "absolute" : "fixed"), G(ne, "zIndex", "100000"), G(ne, "pointerEvents", "none"), ee.ghost = ne, e.appendChild(ne), G(ne, "transform-origin", _h / parseInt(ne.style.width) * 100 + "% " + mh / parseInt(ne.style.height) * 100 + "%");
    }
  },
  _onDragStart: function(e, t) {
    var s = this, r = e.dataTransfer, n = s.options;
    if (gt("dragStart", this, {
      evt: e
    }), ee.eventCanceled) {
      this._onDrop();
      return;
    }
    gt("setupClone", this), ee.eventCanceled || (Me = yu(F), Me.draggable = !1, Me.style["will-change"] = "", this._hideClone(), Ce(Me, this.options.chosenClass, !1), ee.clone = Me), s.cloneId = In(function() {
      gt("clone", s), !ee.eventCanceled && (s.options.removeCloneOnHide || ke.insertBefore(Me, F), s._hideClone(), ct({
        sortable: s,
        name: "clone"
      }));
    }), !t && Ce(F, n.dragClass, !0), t ? (ka = !0, s._loopId = setInterval(s._emulateDragOver, 50)) : (ue(document, "mouseup", s._onDrop), ue(document, "touchend", s._onDrop), ue(document, "touchcancel", s._onDrop), r && (r.effectAllowed = "move", n.setData && n.setData.call(s, r, F)), fe(document, "drop", s), G(F, "transform", "translateZ(0)")), Ts = !0, s._dragStartId = In(s._dragStarted.bind(s, t, e)), fe(document, "selectstart", s), Sr = !0, pl && G(document.body, "user-select", "none");
  },
  // Returns true - if no further action is needed (either inserted or another condition)
  _onDragOver: function(e) {
    var t = this.el, s = e.target, r, n, a, o = this.options, l = o.group, u = ee.active, c = yn === l, h = o.sort, d = Qe || u, f, g = this, p = !1;
    if (gl)
      return;
    function _(Y, W) {
      gt(Y, g, Zi({
        evt: e,
        isOwner: c,
        axis: f ? "vertical" : "horizontal",
        revert: a,
        dragRect: r,
        targetRect: n,
        canSort: h,
        fromSortable: d,
        target: s,
        completed: v,
        onMove: function(oe, O) {
          return To(ke, t, F, r, oe, je(oe), e, O);
        },
        changed: b
      }, W));
    }
    function m() {
      _("dragOverAnimationCapture"), g.captureAnimationState(), g !== d && d.captureAnimationState();
    }
    function v(Y) {
      return _("dragOverCompleted", {
        insertion: Y
      }), Y && (c ? u._hideClone() : u._showClone(g), g !== d && (Ce(F, Qe ? Qe.options.ghostClass : u.options.ghostClass, !1), Ce(F, o.ghostClass, !0)), Qe !== g && g !== ee.active ? Qe = g : g === ee.active && Qe && (Qe = null), d === g && (g._ignoreWhileAnimating = s), g.animateAll(function() {
        _("dragOverAnimationComplete"), g._ignoreWhileAnimating = null;
      }), g !== d && (d.animateAll(), d._ignoreWhileAnimating = null)), (s === F && !F.animated || s === t && !s.animated) && (ws = null), !o.dragoverBubble && !e.rootEl && s !== document && (F.parentNode[rt]._isOutsideThisEl(e.target), !Y && ts(e)), !o.dragoverBubble && e.stopPropagation && e.stopPropagation(), p = !0;
    }
    function b() {
      Tt = Ae(F), wi = Ae(F, o.draggable), ct({
        sortable: g,
        name: "change",
        toEl: t,
        newIndex: Tt,
        newDraggableIndex: wi,
        originalEvent: e
      });
    }
    if (e.preventDefault !== void 0 && e.cancelable && e.preventDefault(), s = Vt(s, o.draggable, t, !0), _("dragOver"), ee.eventCanceled)
      return p;
    if (F.contains(e.target) || s.animated && s.animatingX && s.animatingY || g._ignoreWhileAnimating === s)
      return v(!1);
    if (ka = !1, u && !o.disabled && (c ? h || (a = !ke.contains(F)) : Qe === this || (this.lastPutMode = yn.checkPull(this, u, F, e)) && l.checkPut(this, u, F, e))) {
      if (f = this._getDirection(e, s) === "vertical", r = je(F), _("dragOverValid"), ee.eventCanceled)
        return p;
      if (a)
        return Fe = ke, m(), this._hideClone(), _("revert"), ee.eventCanceled || (ns ? ke.insertBefore(F, ns) : ke.appendChild(F)), v(!0);
      var y = bu(t, o.draggable);
      if (!y || KD(e, f, this) && !y.animated) {
        if (y === F)
          return v(!1);
        if (y && t === e.target && (s = y), s && (n = je(s)), To(ke, t, F, r, s, n, e, !!s) !== !1)
          return m(), t.appendChild(F), Fe = t, b(), v(!0);
      } else if (s.parentNode === t) {
        n = je(s);
        var x = 0, D, A = F.parentNode !== t, T = !VD(F.animated && F.toRect || r, s.animated && s.toRect || n, f), j = f ? "top" : "left", C = fh(s, "top", "top") || fh(F, "top", "top"), L = C ? C.scrollTop : void 0;
        ws !== s && (D = n[j], Ir = !1, vn = !T && o.invertSwap || A), x = QD(e, s, n, f, T ? 1 : o.swapThreshold, o.invertedSwapThreshold == null ? o.swapThreshold : o.invertedSwapThreshold, vn, ws === s);
        var E;
        if (x !== 0) {
          var N = Ae(F);
          do
            N -= x, E = Fe.children[N];
          while (E && (G(E, "display") === "none" || E === ne));
        }
        if (x === 0 || E === s)
          return v(!1);
        ws = s, Er = x;
        var q = s.nextElementSibling, z = !1;
        z = x === 1;
        var H = To(ke, t, F, r, s, n, e, z);
        if (H !== !1)
          return (H === 1 || H === -1) && (z = H === 1), gl = !0, setTimeout(ZD, 30), m(), z && !q ? t.appendChild(F) : s.parentNode.insertBefore(F, z ? q : s), C && Gd(C, 0, L - C.scrollTop), Fe = F.parentNode, D !== void 0 && !vn && (En = Math.abs(D - je(s)[j])), b(), v(!0);
      }
      if (t.contains(F))
        return v(!1);
    }
    return !1;
  },
  _ignoreWhileAnimating: null,
  _offMoveEvents: function() {
    ue(document, "mousemove", this._onTouchMove), ue(document, "touchmove", this._onTouchMove), ue(document, "pointermove", this._onTouchMove), ue(document, "dragover", ts), ue(document, "mousemove", ts), ue(document, "touchmove", ts);
  },
  _offUpEvents: function() {
    var e = this.el.ownerDocument;
    ue(e, "mouseup", this._onDrop), ue(e, "touchend", this._onDrop), ue(e, "pointerup", this._onDrop), ue(e, "touchcancel", this._onDrop), ue(document, "selectstart", this);
  },
  _onDrop: function(e) {
    var t = this.el, s = this.options;
    if (Tt = Ae(F), wi = Ae(F, s.draggable), gt("drop", this, {
      evt: e
    }), Fe = F && F.parentNode, Tt = Ae(F), wi = Ae(F, s.draggable), ee.eventCanceled) {
      this._nulling();
      return;
    }
    Ts = !1, vn = !1, Ir = !1, clearInterval(this._loopId), clearTimeout(this._dragStartTimer), _l(this.cloneId), _l(this._dragStartId), this.nativeDraggable && (ue(document, "drop", this), ue(t, "dragstart", this._onDragStart)), this._offMoveEvents(), this._offUpEvents(), pl && G(document.body, "user-select", ""), G(F, "transform", ""), e && (Sr && (e.cancelable && e.preventDefault(), !s.dropBubble && e.stopPropagation()), ne && ne.parentNode && ne.parentNode.removeChild(ne), (ke === Fe || Qe && Qe.lastPutMode !== "clone") && Me && Me.parentNode && Me.parentNode.removeChild(Me), F && (this.nativeDraggable && ue(F, "dragend", this), ko(F), F.style["will-change"] = "", Sr && !Ts && Ce(F, Qe ? Qe.options.ghostClass : this.options.ghostClass, !1), Ce(F, this.options.chosenClass, !1), ct({
      sortable: this,
      name: "unchoose",
      toEl: Fe,
      newIndex: null,
      newDraggableIndex: null,
      originalEvent: e
    }), ke !== Fe ? (Tt >= 0 && (ct({
      rootEl: Fe,
      name: "add",
      toEl: Fe,
      fromEl: ke,
      originalEvent: e
    }), ct({
      sortable: this,
      name: "remove",
      toEl: Fe,
      originalEvent: e
    }), ct({
      rootEl: Fe,
      name: "sort",
      toEl: Fe,
      fromEl: ke,
      originalEvent: e
    }), ct({
      sortable: this,
      name: "sort",
      toEl: Fe,
      originalEvent: e
    })), Qe && Qe.save()) : Tt !== js && Tt >= 0 && (ct({
      sortable: this,
      name: "update",
      toEl: Fe,
      originalEvent: e
    }), ct({
      sortable: this,
      name: "sort",
      toEl: Fe,
      originalEvent: e
    })), ee.active && ((Tt == null || Tt === -1) && (Tt = js, wi = jr), ct({
      sortable: this,
      name: "end",
      toEl: Fe,
      originalEvent: e
    }), this.save()))), this._nulling();
  },
  _nulling: function() {
    gt("nulling", this), ke = F = Fe = ne = ns = Me = jn = Si = es = zt = Sr = Tt = wi = js = jr = ws = Er = Qe = yn = ee.dragged = ee.ghost = ee.clone = ee.active = null, Ma.forEach(function(e) {
      e.checked = !0;
    }), Ma.length = So = Do = 0;
  },
  handleEvent: function(e) {
    switch (e.type) {
      case "drop":
      case "dragend":
        this._onDrop(e);
        break;
      case "dragenter":
      case "dragover":
        F && (this._onDragOver(e), GD(e));
        break;
      case "selectstart":
        e.preventDefault();
        break;
    }
  },
  /**
   * Serializes the item into an array of string.
   * @returns {String[]}
   */
  toArray: function() {
    for (var e = [], t, s = this.el.children, r = 0, n = s.length, a = this.options; r < n; r++)
      t = s[r], Vt(t, a.draggable, this.el, !1) && e.push(t.getAttribute(a.dataIdAttr) || JD(t));
    return e;
  },
  /**
   * Sorts the elements according to the array.
   * @param  {String[]}  order  order of the items
   */
  sort: function(e) {
    var t = {}, s = this.el;
    this.toArray().forEach(function(r, n) {
      var a = s.children[n];
      Vt(a, this.options.draggable, s, !1) && (t[r] = a);
    }, this), e.forEach(function(r) {
      t[r] && (s.removeChild(t[r]), s.appendChild(t[r]));
    });
  },
  /**
   * Save the current sorting
   */
  save: function() {
    var e = this.options.store;
    e && e.set && e.set(this);
  },
  /**
   * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
   * @param   {HTMLElement}  el
   * @param   {String}       [selector]  default: `options.draggable`
   * @returns {HTMLElement|null}
   */
  closest: function(e, t) {
    return Vt(e, t || this.options.draggable, this.el, !1);
  },
  /**
   * Set/get option
   * @param   {string} name
   * @param   {*}      [value]
   * @returns {*}
   */
  option: function(e, t) {
    var s = this.options;
    if (t === void 0)
      return s[e];
    var r = ln.modifyOption(this, e, t);
    typeof r < "u" ? s[e] = r : s[e] = t, e === "group" && Qd(s);
  },
  /**
   * Destroy
   */
  destroy: function() {
    gt("destroy", this);
    var e = this.el;
    e[rt] = null, ue(e, "mousedown", this._onTapStart), ue(e, "touchstart", this._onTapStart), ue(e, "pointerdown", this._onTapStart), this.nativeDraggable && (ue(e, "dragover", this), ue(e, "dragenter", this)), Array.prototype.forEach.call(e.querySelectorAll("[draggable]"), function(t) {
      t.removeAttribute("draggable");
    }), this._onDrop(), this._disableDelayedDragEvents(), Ca.splice(Ca.indexOf(this.el), 1), this.el = e = null;
  },
  _hideClone: function() {
    if (!Si) {
      if (gt("hideClone", this), ee.eventCanceled)
        return;
      G(Me, "display", "none"), this.options.removeCloneOnHide && Me.parentNode && Me.parentNode.removeChild(Me), Si = !0;
    }
  },
  _showClone: function(e) {
    if (e.lastPutMode !== "clone") {
      this._hideClone();
      return;
    }
    if (Si) {
      if (gt("showClone", this), ee.eventCanceled)
        return;
      ke.contains(F) && !this.options.group.revertClone ? ke.insertBefore(Me, F) : ns ? ke.insertBefore(Me, ns) : ke.appendChild(Me), this.options.group.revertClone && this.animate(F, Me), G(Me, "display", ""), Si = !1;
    }
  }
};
function GD(i) {
  i.dataTransfer && (i.dataTransfer.dropEffect = "move"), i.cancelable && i.preventDefault();
}
function To(i, e, t, s, r, n, a, o) {
  var l, u = i[rt], c = u.options.onMove, h;
  return window.CustomEvent && !vi && !on ? l = new CustomEvent("move", {
    bubbles: !0,
    cancelable: !0
  }) : (l = document.createEvent("Event"), l.initEvent("move", !0, !0)), l.to = e, l.from = i, l.dragged = t, l.draggedRect = s, l.related = r || e, l.relatedRect = n || je(e), l.willInsertAfter = o, l.originalEvent = a, i.dispatchEvent(l), c && (h = c.call(u, l, a)), h;
}
function ko(i) {
  i.draggable = !1;
}
function ZD() {
  gl = !1;
}
function KD(i, e, t) {
  var s = je(bu(t.el, t.options.draggable)), r = 10;
  return e ? i.clientX > s.right + r || i.clientX <= s.right && i.clientY > s.bottom && i.clientX >= s.left : i.clientX > s.right && i.clientY > s.top || i.clientX <= s.right && i.clientY > s.bottom + r;
}
function QD(i, e, t, s, r, n, a, o) {
  var l = s ? i.clientY : i.clientX, u = s ? t.height : t.width, c = s ? t.top : t.left, h = s ? t.bottom : t.right, d = !1;
  if (!a) {
    if (o && En < u * r) {
      if (!Ir && (Er === 1 ? l > c + u * n / 2 : l < h - u * n / 2) && (Ir = !0), Ir)
        d = !0;
      else if (Er === 1 ? l < c + En : l > h - En)
        return -Er;
    } else if (l > c + u * (1 - r) / 2 && l < h - u * (1 - r) / 2)
      return qD(e);
  }
  return d = d || a, d && (l < c + u * n / 2 || l > h - u * n / 2) ? l > c + u / 2 ? 1 : -1 : 0;
}
function qD(i) {
  return Ae(F) < Ae(i) ? 1 : -1;
}
function JD(i) {
  for (var e = i.tagName + i.className + i.src + i.href + i.textContent, t = e.length, s = 0; t--; )
    s += e.charCodeAt(t);
  return s.toString(36);
}
function e1(i) {
  Ma.length = 0;
  for (var e = i.getElementsByTagName("input"), t = e.length; t--; ) {
    var s = e[t];
    s.checked && Ma.push(s);
  }
}
function In(i) {
  return setTimeout(i, 0);
}
function _l(i) {
  return clearTimeout(i);
}
io && fe(document, "touchmove", function(i) {
  (ee.active || Ts) && i.cancelable && i.preventDefault();
});
ee.utils = {
  on: fe,
  off: ue,
  css: G,
  find: Ud,
  is: function(e, t) {
    return !!Vt(e, t, e, !1);
  },
  extend: $D,
  throttle: Wd,
  closest: Vt,
  toggleClass: Ce,
  clone: yu,
  index: Ae,
  nextTick: In,
  cancelNextTick: _l,
  detectDirection: Kd,
  getChild: Ta
};
ee.get = function(i) {
  return i[rt];
};
ee.mount = function() {
  for (var i = arguments.length, e = new Array(i), t = 0; t < i; t++)
    e[t] = arguments[t];
  e[0].constructor === Array && (e = e[0]), e.forEach(function(s) {
    if (!s.prototype || !s.prototype.constructor)
      throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(s));
    s.utils && (ee.utils = Zi({}, ee.utils, s.utils)), ln.mount(s);
  });
};
ee.create = function(i, e) {
  return new ee(i, e);
};
ee.version = ID;
var Be = [], Dr, ml, bl = !1, Co, Mo, Oa, Pr;
function t1() {
  function i() {
    this.defaults = {
      scroll: !0,
      scrollSensitivity: 30,
      scrollSpeed: 10,
      bubbleScroll: !0
    };
    for (var e in this)
      e.charAt(0) === "_" && typeof this[e] == "function" && (this[e] = this[e].bind(this));
  }
  return i.prototype = {
    dragStarted: function(t) {
      var s = t.originalEvent;
      this.sortable.nativeDraggable ? fe(document, "dragover", this._handleAutoScroll) : this.options.supportPointer ? fe(document, "pointermove", this._handleFallbackAutoScroll) : s.touches ? fe(document, "touchmove", this._handleFallbackAutoScroll) : fe(document, "mousemove", this._handleFallbackAutoScroll);
    },
    dragOverCompleted: function(t) {
      var s = t.originalEvent;
      !this.options.dragOverBubble && !s.rootEl && this._handleAutoScroll(s);
    },
    drop: function() {
      this.sortable.nativeDraggable ? ue(document, "dragover", this._handleAutoScroll) : (ue(document, "pointermove", this._handleFallbackAutoScroll), ue(document, "touchmove", this._handleFallbackAutoScroll), ue(document, "mousemove", this._handleFallbackAutoScroll)), yh(), Yn(), FD();
    },
    nulling: function() {
      Oa = ml = Dr = bl = Pr = Co = Mo = null, Be.length = 0;
    },
    _handleFallbackAutoScroll: function(t) {
      this._handleAutoScroll(t, !0);
    },
    _handleAutoScroll: function(t, s) {
      var r = this, n = (t.touches ? t.touches[0] : t).clientX, a = (t.touches ? t.touches[0] : t).clientY, o = document.elementFromPoint(n, a);
      if (Oa = t, s || on || vi || pl) {
        Oo(t, this.options, o, s);
        var l = Oi(o, !0);
        bl && (!Pr || n !== Co || a !== Mo) && (Pr && yh(), Pr = setInterval(function() {
          var u = Oi(document.elementFromPoint(n, a), !0);
          u !== l && (l = u, Yn()), Oo(t, r.options, u, s);
        }, 10), Co = n, Mo = a);
      } else {
        if (!this.options.bubbleScroll || Oi(o, !0) === ei()) {
          Yn();
          return;
        }
        Oo(t, this.options, Oi(o, !1), !1);
      }
    }
  }, Ft(i, {
    pluginName: "scroll",
    initializeByDefault: !0
  });
}
function Yn() {
  Be.forEach(function(i) {
    clearInterval(i.pid);
  }), Be = [];
}
function yh() {
  clearInterval(Pr);
}
var Oo = Wd(function(i, e, t, s) {
  if (e.scroll) {
    var r = (i.touches ? i.touches[0] : i).clientX, n = (i.touches ? i.touches[0] : i).clientY, a = e.scrollSensitivity, o = e.scrollSpeed, l = ei(), u = !1, c;
    ml !== t && (ml = t, Yn(), Dr = e.scroll, c = e.scrollFn, Dr === !0 && (Dr = Oi(t, !0)));
    var h = 0, d = Dr;
    do {
      var f = d, g = je(f), p = g.top, _ = g.bottom, m = g.left, v = g.right, b = g.width, y = g.height, x = void 0, D = void 0, A = f.scrollWidth, T = f.scrollHeight, j = G(f), C = f.scrollLeft, L = f.scrollTop;
      f === l ? (x = b < A && (j.overflowX === "auto" || j.overflowX === "scroll" || j.overflowX === "visible"), D = y < T && (j.overflowY === "auto" || j.overflowY === "scroll" || j.overflowY === "visible")) : (x = b < A && (j.overflowX === "auto" || j.overflowX === "scroll"), D = y < T && (j.overflowY === "auto" || j.overflowY === "scroll"));
      var E = x && (Math.abs(v - r) <= a && C + b < A) - (Math.abs(m - r) <= a && !!C), N = D && (Math.abs(_ - n) <= a && L + y < T) - (Math.abs(p - n) <= a && !!L);
      if (!Be[h])
        for (var q = 0; q <= h; q++)
          Be[q] || (Be[q] = {});
      (Be[h].vx != E || Be[h].vy != N || Be[h].el !== f) && (Be[h].el = f, Be[h].vx = E, Be[h].vy = N, clearInterval(Be[h].pid), (E != 0 || N != 0) && (u = !0, Be[h].pid = setInterval(function() {
        s && this.layer === 0 && ee.active._onTouchMove(Oa);
        var z = Be[this.layer].vy ? Be[this.layer].vy * o : 0, H = Be[this.layer].vx ? Be[this.layer].vx * o : 0;
        typeof c == "function" && c.call(ee.dragged.parentNode[rt], H, z, i, Oa, Be[this.layer].el) !== "continue" || Gd(Be[this.layer].el, H, z);
      }.bind({
        layer: h
      }), 24))), h++;
    } while (e.bubbleScroll && d !== l && (d = Oi(d, !1)));
    bl = u;
  }
}, 30), ef = function(e) {
  var t = e.originalEvent, s = e.putSortable, r = e.dragEl, n = e.activeSortable, a = e.dispatchSortableEvent, o = e.hideGhostForTarget, l = e.unhideGhostForTarget;
  if (t) {
    var u = s || n;
    o();
    var c = t.changedTouches && t.changedTouches.length ? t.changedTouches[0] : t, h = document.elementFromPoint(c.clientX, c.clientY);
    l(), u && !u.el.contains(h) && (a("spill"), this.onSpill({
      dragEl: r,
      putSortable: s
    }));
  }
};
function vu() {
}
vu.prototype = {
  startIndex: null,
  dragStart: function(e) {
    var t = e.oldDraggableIndex;
    this.startIndex = t;
  },
  onSpill: function(e) {
    var t = e.dragEl, s = e.putSortable;
    this.sortable.captureAnimationState(), s && s.captureAnimationState();
    var r = Ta(this.sortable.el, this.startIndex, this.options);
    r ? this.sortable.el.insertBefore(t, r) : this.sortable.el.appendChild(t), this.sortable.animateAll(), s && s.animateAll();
  },
  drop: ef
};
Ft(vu, {
  pluginName: "revertOnSpill"
});
function xu() {
}
xu.prototype = {
  onSpill: function(e) {
    var t = e.dragEl, s = e.putSortable, r = s || this.sortable;
    r.captureAnimationState(), t.parentNode && t.parentNode.removeChild(t), r.animateAll();
  },
  drop: ef
};
Ft(xu, {
  pluginName: "removeOnSpill"
});
var Yt;
function i1() {
  function i() {
    this.defaults = {
      swapClass: "sortable-swap-highlight"
    };
  }
  return i.prototype = {
    dragStart: function(t) {
      var s = t.dragEl;
      Yt = s;
    },
    dragOverValid: function(t) {
      var s = t.completed, r = t.target, n = t.onMove, a = t.activeSortable, o = t.changed, l = t.cancel;
      if (a.options.swap) {
        var u = this.sortable.el, c = this.options;
        if (r && r !== u) {
          var h = Yt;
          n(r) !== !1 ? (Ce(r, c.swapClass, !0), Yt = r) : Yt = null, h && h !== Yt && Ce(h, c.swapClass, !1);
        }
        o(), s(!0), l();
      }
    },
    drop: function(t) {
      var s = t.activeSortable, r = t.putSortable, n = t.dragEl, a = r || this.sortable, o = this.options;
      Yt && Ce(Yt, o.swapClass, !1), Yt && (o.swap || r && r.options.swap) && n !== Yt && (a.captureAnimationState(), a !== s && s.captureAnimationState(), s1(n, Yt), a.animateAll(), a !== s && s.animateAll());
    },
    nulling: function() {
      Yt = null;
    }
  }, Ft(i, {
    pluginName: "swap",
    eventProperties: function() {
      return {
        swapItem: Yt
      };
    }
  });
}
function s1(i, e) {
  var t = i.parentNode, s = e.parentNode, r, n;
  !t || !s || t.isEqualNode(e) || s.isEqualNode(i) || (r = Ae(i), n = Ae(e), t.isEqualNode(s) && r < n && n++, t.insertBefore(e, t.children[r]), s.insertBefore(i, s.children[n]));
}
var se = [], Pt = [], pr, Xt, gr = !1, Dt = !1, Ss = !1, we, _r, wn;
function r1() {
  function i(e) {
    for (var t in this)
      t.charAt(0) === "_" && typeof this[t] == "function" && (this[t] = this[t].bind(this));
    e.options.supportPointer ? fe(document, "pointerup", this._deselectMultiDrag) : (fe(document, "mouseup", this._deselectMultiDrag), fe(document, "touchend", this._deselectMultiDrag)), fe(document, "keydown", this._checkKeyDown), fe(document, "keyup", this._checkKeyUp), this.defaults = {
      selectedClass: "sortable-selected",
      multiDragKey: null,
      setData: function(r, n) {
        var a = "";
        se.length && Xt === e ? se.forEach(function(o, l) {
          a += (l ? ", " : "") + o.textContent;
        }) : a = n.textContent, r.setData("Text", a);
      }
    };
  }
  return i.prototype = {
    multiDragKeyDown: !1,
    isMultiDrag: !1,
    delayStartGlobal: function(t) {
      var s = t.dragEl;
      we = s;
    },
    delayEnded: function() {
      this.isMultiDrag = ~se.indexOf(we);
    },
    setupClone: function(t) {
      var s = t.sortable, r = t.cancel;
      if (this.isMultiDrag) {
        for (var n = 0; n < se.length; n++)
          Pt.push(yu(se[n])), Pt[n].sortableIndex = se[n].sortableIndex, Pt[n].draggable = !1, Pt[n].style["will-change"] = "", Ce(Pt[n], this.options.selectedClass, !1), se[n] === we && Ce(Pt[n], this.options.chosenClass, !1);
        s._hideClone(), r();
      }
    },
    clone: function(t) {
      var s = t.sortable, r = t.rootEl, n = t.dispatchSortableEvent, a = t.cancel;
      this.isMultiDrag && (this.options.removeCloneOnHide || se.length && Xt === s && (vh(!0, r), n("clone"), a()));
    },
    showClone: function(t) {
      var s = t.cloneNowShown, r = t.rootEl, n = t.cancel;
      this.isMultiDrag && (vh(!1, r), Pt.forEach(function(a) {
        G(a, "display", "");
      }), s(), wn = !1, n());
    },
    hideClone: function(t) {
      var s = this;
      t.sortable;
      var r = t.cloneNowHidden, n = t.cancel;
      this.isMultiDrag && (Pt.forEach(function(a) {
        G(a, "display", "none"), s.options.removeCloneOnHide && a.parentNode && a.parentNode.removeChild(a);
      }), r(), wn = !0, n());
    },
    dragStartGlobal: function(t) {
      t.sortable, !this.isMultiDrag && Xt && Xt.multiDrag._deselectMultiDrag(), se.forEach(function(s) {
        s.sortableIndex = Ae(s);
      }), se = se.sort(function(s, r) {
        return s.sortableIndex - r.sortableIndex;
      }), Ss = !0;
    },
    dragStarted: function(t) {
      var s = this, r = t.sortable;
      if (this.isMultiDrag) {
        if (this.options.sort && (r.captureAnimationState(), this.options.animation)) {
          se.forEach(function(a) {
            a !== we && G(a, "position", "absolute");
          });
          var n = je(we, !1, !0, !0);
          se.forEach(function(a) {
            a !== we && gh(a, n);
          }), Dt = !0, gr = !0;
        }
        r.animateAll(function() {
          Dt = !1, gr = !1, s.options.animation && se.forEach(function(a) {
            xo(a);
          }), s.options.sort && Sn();
        });
      }
    },
    dragOver: function(t) {
      var s = t.target, r = t.completed, n = t.cancel;
      Dt && ~se.indexOf(s) && (r(!1), n());
    },
    revert: function(t) {
      var s = t.fromSortable, r = t.rootEl, n = t.sortable, a = t.dragRect;
      se.length > 1 && (se.forEach(function(o) {
        n.addAnimationState({
          target: o,
          rect: Dt ? je(o) : a
        }), xo(o), o.fromRect = a, s.removeAnimationState(o);
      }), Dt = !1, n1(!this.options.removeCloneOnHide, r));
    },
    dragOverCompleted: function(t) {
      var s = t.sortable, r = t.isOwner, n = t.insertion, a = t.activeSortable, o = t.parentEl, l = t.putSortable, u = this.options;
      if (n) {
        if (r && a._hideClone(), gr = !1, u.animation && se.length > 1 && (Dt || !r && !a.options.sort && !l)) {
          var c = je(we, !1, !0, !0);
          se.forEach(function(d) {
            d !== we && (gh(d, c), o.appendChild(d));
          }), Dt = !0;
        }
        if (!r)
          if (Dt || Sn(), se.length > 1) {
            var h = wn;
            a._showClone(s), a.options.animation && !wn && h && Pt.forEach(function(d) {
              a.addAnimationState({
                target: d,
                rect: _r
              }), d.fromRect = _r, d.thisAnimationDuration = null;
            });
          } else
            a._showClone(s);
      }
    },
    dragOverAnimationCapture: function(t) {
      var s = t.dragRect, r = t.isOwner, n = t.activeSortable;
      if (se.forEach(function(o) {
        o.thisAnimationDuration = null;
      }), n.options.animation && !r && n.multiDrag.isMultiDrag) {
        _r = Ft({}, s);
        var a = fs(we, !0);
        _r.top -= a.f, _r.left -= a.e;
      }
    },
    dragOverAnimationComplete: function() {
      Dt && (Dt = !1, Sn());
    },
    drop: function(t) {
      var s = t.originalEvent, r = t.rootEl, n = t.parentEl, a = t.sortable, o = t.dispatchSortableEvent, l = t.oldIndex, u = t.putSortable, c = u || this.sortable;
      if (s) {
        var h = this.options, d = n.children;
        if (!Ss)
          if (h.multiDragKey && !this.multiDragKeyDown && this._deselectMultiDrag(), Ce(we, h.selectedClass, !~se.indexOf(we)), ~se.indexOf(we))
            se.splice(se.indexOf(we), 1), pr = null, wr({
              sortable: a,
              rootEl: r,
              name: "deselect",
              targetEl: we,
              originalEvt: s
            });
          else {
            if (se.push(we), wr({
              sortable: a,
              rootEl: r,
              name: "select",
              targetEl: we,
              originalEvt: s
            }), s.shiftKey && pr && a.el.contains(pr)) {
              var f = Ae(pr), g = Ae(we);
              if (~f && ~g && f !== g) {
                var p, _;
                for (g > f ? (_ = f, p = g) : (_ = g, p = f + 1); _ < p; _++)
                  ~se.indexOf(d[_]) || (Ce(d[_], h.selectedClass, !0), se.push(d[_]), wr({
                    sortable: a,
                    rootEl: r,
                    name: "select",
                    targetEl: d[_],
                    originalEvt: s
                  }));
              }
            } else
              pr = we;
            Xt = c;
          }
        if (Ss && this.isMultiDrag) {
          if ((n[rt].options.sort || n !== r) && se.length > 1) {
            var m = je(we), v = Ae(we, ":not(." + this.options.selectedClass + ")");
            if (!gr && h.animation && (we.thisAnimationDuration = null), c.captureAnimationState(), !gr && (h.animation && (we.fromRect = m, se.forEach(function(y) {
              if (y.thisAnimationDuration = null, y !== we) {
                var x = Dt ? je(y) : m;
                y.fromRect = x, c.addAnimationState({
                  target: y,
                  rect: x
                });
              }
            })), Sn(), se.forEach(function(y) {
              d[v] ? n.insertBefore(y, d[v]) : n.appendChild(y), v++;
            }), l === Ae(we))) {
              var b = !1;
              se.forEach(function(y) {
                if (y.sortableIndex !== Ae(y)) {
                  b = !0;
                  return;
                }
              }), b && o("update");
            }
            se.forEach(function(y) {
              xo(y);
            }), c.animateAll();
          }
          Xt = c;
        }
        (r === n || u && u.lastPutMode !== "clone") && Pt.forEach(function(y) {
          y.parentNode && y.parentNode.removeChild(y);
        });
      }
    },
    nullingGlobal: function() {
      this.isMultiDrag = Ss = !1, Pt.length = 0;
    },
    destroyGlobal: function() {
      this._deselectMultiDrag(), ue(document, "pointerup", this._deselectMultiDrag), ue(document, "mouseup", this._deselectMultiDrag), ue(document, "touchend", this._deselectMultiDrag), ue(document, "keydown", this._checkKeyDown), ue(document, "keyup", this._checkKeyUp);
    },
    _deselectMultiDrag: function(t) {
      if (!(typeof Ss < "u" && Ss) && Xt === this.sortable && !(t && Vt(t.target, this.options.draggable, this.sortable.el, !1)) && !(t && t.button !== 0))
        for (; se.length; ) {
          var s = se[0];
          Ce(s, this.options.selectedClass, !1), se.shift(), wr({
            sortable: this.sortable,
            rootEl: this.sortable.el,
            name: "deselect",
            targetEl: s,
            originalEvt: t
          });
        }
    },
    _checkKeyDown: function(t) {
      t.key === this.options.multiDragKey && (this.multiDragKeyDown = !0);
    },
    _checkKeyUp: function(t) {
      t.key === this.options.multiDragKey && (this.multiDragKeyDown = !1);
    }
  }, Ft(i, {
    // Static methods & properties
    pluginName: "multiDrag",
    utils: {
      /**
       * Selects the provided multi-drag item
       * @param  {HTMLElement} el    The element to be selected
       */
      select: function(t) {
        var s = t.parentNode[rt];
        !s || !s.options.multiDrag || ~se.indexOf(t) || (Xt && Xt !== s && (Xt.multiDrag._deselectMultiDrag(), Xt = s), Ce(t, s.options.selectedClass, !0), se.push(t));
      },
      /**
       * Deselects the provided multi-drag item
       * @param  {HTMLElement} el    The element to be deselected
       */
      deselect: function(t) {
        var s = t.parentNode[rt], r = se.indexOf(t);
        !s || !s.options.multiDrag || !~r || (Ce(t, s.options.selectedClass, !1), se.splice(r, 1));
      }
    },
    eventProperties: function() {
      var t = this, s = [], r = [];
      return se.forEach(function(n) {
        s.push({
          multiDragElement: n,
          index: n.sortableIndex
        });
        var a;
        Dt && n !== we ? a = -1 : Dt ? a = Ae(n, ":not(." + t.options.selectedClass + ")") : a = Ae(n), r.push({
          multiDragElement: n,
          index: a
        });
      }), {
        items: AD(se),
        clones: [].concat(Pt),
        oldIndicies: s,
        newIndicies: r
      };
    },
    optionListeners: {
      multiDragKey: function(t) {
        return t = t.toLowerCase(), t === "ctrl" ? t = "Control" : t.length > 1 && (t = t.charAt(0).toUpperCase() + t.substr(1)), t;
      }
    }
  });
}
function n1(i, e) {
  se.forEach(function(t, s) {
    var r = e.children[t.sortableIndex + (i ? Number(s) : 0)];
    r ? e.insertBefore(t, r) : e.appendChild(t);
  });
}
function vh(i, e) {
  Pt.forEach(function(t, s) {
    var r = e.children[t.sortableIndex + (i ? Number(s) : 0)];
    r ? e.insertBefore(t, r) : e.appendChild(t);
  });
}
function Sn() {
  se.forEach(function(i) {
    i !== we && i.parentNode && i.parentNode.removeChild(i);
  });
}
ee.mount(new t1());
ee.mount(xu, vu);
const a1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  MultiDrag: r1,
  Sortable: ee,
  Swap: i1,
  default: ee
}, Symbol.toStringTag, { value: "Module" })), o1 = /* @__PURE__ */ NS(a1);
(function(i, e) {
  (function(s, r) {
    i.exports = r(o1);
  })(typeof self < "u" ? self : YS, function(t) {
    return (
      /******/
      function(s) {
        var r = {};
        function n(a) {
          if (r[a])
            return r[a].exports;
          var o = r[a] = {
            /******/
            i: a,
            /******/
            l: !1,
            /******/
            exports: {}
            /******/
          };
          return s[a].call(o.exports, o, o.exports, n), o.l = !0, o.exports;
        }
        return n.m = s, n.c = r, n.d = function(a, o, l) {
          n.o(a, o) || Object.defineProperty(a, o, { enumerable: !0, get: l });
        }, n.r = function(a) {
          typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(a, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(a, "__esModule", { value: !0 });
        }, n.t = function(a, o) {
          if (o & 1 && (a = n(a)), o & 8 || o & 4 && typeof a == "object" && a && a.__esModule)
            return a;
          var l = /* @__PURE__ */ Object.create(null);
          if (n.r(l), Object.defineProperty(l, "default", { enumerable: !0, value: a }), o & 2 && typeof a != "string")
            for (var u in a)
              n.d(l, u, function(c) {
                return a[c];
              }.bind(null, u));
          return l;
        }, n.n = function(a) {
          var o = a && a.__esModule ? (
            /******/
            function() {
              return a.default;
            }
          ) : (
            /******/
            function() {
              return a;
            }
          );
          return n.d(o, "a", o), o;
        }, n.o = function(a, o) {
          return Object.prototype.hasOwnProperty.call(a, o);
        }, n.p = "", n(n.s = "fb15");
      }({
        /***/
        "01f9": (
          /***/
          function(s, r, n) {
            var a = n("2d00"), o = n("5ca1"), l = n("2aba"), u = n("32e9"), c = n("84f2"), h = n("41a0"), d = n("7f20"), f = n("38fd"), g = n("2b4c")("iterator"), p = !([].keys && "next" in [].keys()), _ = "@@iterator", m = "keys", v = "values", b = function() {
              return this;
            };
            s.exports = function(y, x, D, A, T, j, C) {
              h(D, x, A);
              var L = function(M) {
                if (!p && M in z)
                  return z[M];
                switch (M) {
                  case m:
                    return function() {
                      return new D(this, M);
                    };
                  case v:
                    return function() {
                      return new D(this, M);
                    };
                }
                return function() {
                  return new D(this, M);
                };
              }, E = x + " Iterator", N = T == v, q = !1, z = y.prototype, H = z[g] || z[_] || T && z[T], Y = H || L(T), W = T ? N ? L("entries") : Y : void 0, B = x == "Array" && z.entries || H, oe, O, k;
              if (B && (k = f(B.call(new y())), k !== Object.prototype && k.next && (d(k, E, !0), !a && typeof k[g] != "function" && u(k, g, b))), N && H && H.name !== v && (q = !0, Y = function() {
                return H.call(this);
              }), (!a || C) && (p || q || !z[g]) && u(z, g, Y), c[x] = Y, c[E] = b, T)
                if (oe = {
                  values: N ? Y : L(v),
                  keys: j ? Y : L(m),
                  entries: W
                }, C)
                  for (O in oe)
                    O in z || l(z, O, oe[O]);
                else
                  o(o.P + o.F * (p || q), x, oe);
              return oe;
            };
          }
        ),
        /***/
        "02f4": (
          /***/
          function(s, r, n) {
            var a = n("4588"), o = n("be13");
            s.exports = function(l) {
              return function(u, c) {
                var h = String(o(u)), d = a(c), f = h.length, g, p;
                return d < 0 || d >= f ? l ? "" : void 0 : (g = h.charCodeAt(d), g < 55296 || g > 56319 || d + 1 === f || (p = h.charCodeAt(d + 1)) < 56320 || p > 57343 ? l ? h.charAt(d) : g : l ? h.slice(d, d + 2) : (g - 55296 << 10) + (p - 56320) + 65536);
              };
            };
          }
        ),
        /***/
        "0390": (
          /***/
          function(s, r, n) {
            var a = n("02f4")(!0);
            s.exports = function(o, l, u) {
              return l + (u ? a(o, l).length : 1);
            };
          }
        ),
        /***/
        "0bfb": (
          /***/
          function(s, r, n) {
            var a = n("cb7c");
            s.exports = function() {
              var o = a(this), l = "";
              return o.global && (l += "g"), o.ignoreCase && (l += "i"), o.multiline && (l += "m"), o.unicode && (l += "u"), o.sticky && (l += "y"), l;
            };
          }
        ),
        /***/
        "0d58": (
          /***/
          function(s, r, n) {
            var a = n("ce10"), o = n("e11e");
            s.exports = Object.keys || function(u) {
              return a(u, o);
            };
          }
        ),
        /***/
        1495: (
          /***/
          function(s, r, n) {
            var a = n("86cc"), o = n("cb7c"), l = n("0d58");
            s.exports = n("9e1e") ? Object.defineProperties : function(c, h) {
              o(c);
              for (var d = l(h), f = d.length, g = 0, p; f > g; )
                a.f(c, p = d[g++], h[p]);
              return c;
            };
          }
        ),
        /***/
        "214f": (
          /***/
          function(s, r, n) {
            n("b0c5");
            var a = n("2aba"), o = n("32e9"), l = n("79e5"), u = n("be13"), c = n("2b4c"), h = n("520a"), d = c("species"), f = !l(function() {
              var p = /./;
              return p.exec = function() {
                var _ = [];
                return _.groups = { a: "7" }, _;
              }, "".replace(p, "$<a>") !== "7";
            }), g = function() {
              var p = /(?:)/, _ = p.exec;
              p.exec = function() {
                return _.apply(this, arguments);
              };
              var m = "ab".split(p);
              return m.length === 2 && m[0] === "a" && m[1] === "b";
            }();
            s.exports = function(p, _, m) {
              var v = c(p), b = !l(function() {
                var j = {};
                return j[v] = function() {
                  return 7;
                }, ""[p](j) != 7;
              }), y = b ? !l(function() {
                var j = !1, C = /a/;
                return C.exec = function() {
                  return j = !0, null;
                }, p === "split" && (C.constructor = {}, C.constructor[d] = function() {
                  return C;
                }), C[v](""), !j;
              }) : void 0;
              if (!b || !y || p === "replace" && !f || p === "split" && !g) {
                var x = /./[v], D = m(
                  u,
                  v,
                  ""[p],
                  function(C, L, E, N, q) {
                    return L.exec === h ? b && !q ? { done: !0, value: x.call(L, E, N) } : { done: !0, value: C.call(E, L, N) } : { done: !1 };
                  }
                ), A = D[0], T = D[1];
                a(String.prototype, p, A), o(
                  RegExp.prototype,
                  v,
                  _ == 2 ? function(j, C) {
                    return T.call(j, this, C);
                  } : function(j) {
                    return T.call(j, this);
                  }
                );
              }
            };
          }
        ),
        /***/
        "230e": (
          /***/
          function(s, r, n) {
            var a = n("d3f4"), o = n("7726").document, l = a(o) && a(o.createElement);
            s.exports = function(u) {
              return l ? o.createElement(u) : {};
            };
          }
        ),
        /***/
        "23c6": (
          /***/
          function(s, r, n) {
            var a = n("2d95"), o = n("2b4c")("toStringTag"), l = a(function() {
              return arguments;
            }()) == "Arguments", u = function(c, h) {
              try {
                return c[h];
              } catch {
              }
            };
            s.exports = function(c) {
              var h, d, f;
              return c === void 0 ? "Undefined" : c === null ? "Null" : typeof (d = u(h = Object(c), o)) == "string" ? d : l ? a(h) : (f = a(h)) == "Object" && typeof h.callee == "function" ? "Arguments" : f;
            };
          }
        ),
        /***/
        2621: (
          /***/
          function(s, r) {
            r.f = Object.getOwnPropertySymbols;
          }
        ),
        /***/
        "2aba": (
          /***/
          function(s, r, n) {
            var a = n("7726"), o = n("32e9"), l = n("69a8"), u = n("ca5a")("src"), c = n("fa5b"), h = "toString", d = ("" + c).split(h);
            n("8378").inspectSource = function(f) {
              return c.call(f);
            }, (s.exports = function(f, g, p, _) {
              var m = typeof p == "function";
              m && (l(p, "name") || o(p, "name", g)), f[g] !== p && (m && (l(p, u) || o(p, u, f[g] ? "" + f[g] : d.join(String(g)))), f === a ? f[g] = p : _ ? f[g] ? f[g] = p : o(f, g, p) : (delete f[g], o(f, g, p)));
            })(Function.prototype, h, function() {
              return typeof this == "function" && this[u] || c.call(this);
            });
          }
        ),
        /***/
        "2aeb": (
          /***/
          function(s, r, n) {
            var a = n("cb7c"), o = n("1495"), l = n("e11e"), u = n("613b")("IE_PROTO"), c = function() {
            }, h = "prototype", d = function() {
              var f = n("230e")("iframe"), g = l.length, p = "<", _ = ">", m;
              for (f.style.display = "none", n("fab2").appendChild(f), f.src = "javascript:", m = f.contentWindow.document, m.open(), m.write(p + "script" + _ + "document.F=Object" + p + "/script" + _), m.close(), d = m.F; g--; )
                delete d[h][l[g]];
              return d();
            };
            s.exports = Object.create || function(g, p) {
              var _;
              return g !== null ? (c[h] = a(g), _ = new c(), c[h] = null, _[u] = g) : _ = d(), p === void 0 ? _ : o(_, p);
            };
          }
        ),
        /***/
        "2b4c": (
          /***/
          function(s, r, n) {
            var a = n("5537")("wks"), o = n("ca5a"), l = n("7726").Symbol, u = typeof l == "function", c = s.exports = function(h) {
              return a[h] || (a[h] = u && l[h] || (u ? l : o)("Symbol." + h));
            };
            c.store = a;
          }
        ),
        /***/
        "2d00": (
          /***/
          function(s, r) {
            s.exports = !1;
          }
        ),
        /***/
        "2d95": (
          /***/
          function(s, r) {
            var n = {}.toString;
            s.exports = function(a) {
              return n.call(a).slice(8, -1);
            };
          }
        ),
        /***/
        "2fdb": (
          /***/
          function(s, r, n) {
            var a = n("5ca1"), o = n("d2c8"), l = "includes";
            a(a.P + a.F * n("5147")(l), "String", {
              includes: function(c) {
                return !!~o(this, c, l).indexOf(c, arguments.length > 1 ? arguments[1] : void 0);
              }
            });
          }
        ),
        /***/
        "32e9": (
          /***/
          function(s, r, n) {
            var a = n("86cc"), o = n("4630");
            s.exports = n("9e1e") ? function(l, u, c) {
              return a.f(l, u, o(1, c));
            } : function(l, u, c) {
              return l[u] = c, l;
            };
          }
        ),
        /***/
        "38fd": (
          /***/
          function(s, r, n) {
            var a = n("69a8"), o = n("4bf8"), l = n("613b")("IE_PROTO"), u = Object.prototype;
            s.exports = Object.getPrototypeOf || function(c) {
              return c = o(c), a(c, l) ? c[l] : typeof c.constructor == "function" && c instanceof c.constructor ? c.constructor.prototype : c instanceof Object ? u : null;
            };
          }
        ),
        /***/
        "41a0": (
          /***/
          function(s, r, n) {
            var a = n("2aeb"), o = n("4630"), l = n("7f20"), u = {};
            n("32e9")(u, n("2b4c")("iterator"), function() {
              return this;
            }), s.exports = function(c, h, d) {
              c.prototype = a(u, { next: o(1, d) }), l(c, h + " Iterator");
            };
          }
        ),
        /***/
        "456d": (
          /***/
          function(s, r, n) {
            var a = n("4bf8"), o = n("0d58");
            n("5eda")("keys", function() {
              return function(u) {
                return o(a(u));
              };
            });
          }
        ),
        /***/
        4588: (
          /***/
          function(s, r) {
            var n = Math.ceil, a = Math.floor;
            s.exports = function(o) {
              return isNaN(o = +o) ? 0 : (o > 0 ? a : n)(o);
            };
          }
        ),
        /***/
        4630: (
          /***/
          function(s, r) {
            s.exports = function(n, a) {
              return {
                enumerable: !(n & 1),
                configurable: !(n & 2),
                writable: !(n & 4),
                value: a
              };
            };
          }
        ),
        /***/
        "4bf8": (
          /***/
          function(s, r, n) {
            var a = n("be13");
            s.exports = function(o) {
              return Object(a(o));
            };
          }
        ),
        /***/
        5147: (
          /***/
          function(s, r, n) {
            var a = n("2b4c")("match");
            s.exports = function(o) {
              var l = /./;
              try {
                "/./"[o](l);
              } catch {
                try {
                  return l[a] = !1, !"/./"[o](l);
                } catch {
                }
              }
              return !0;
            };
          }
        ),
        /***/
        "520a": (
          /***/
          function(s, r, n) {
            var a = n("0bfb"), o = RegExp.prototype.exec, l = String.prototype.replace, u = o, c = "lastIndex", h = function() {
              var g = /a/, p = /b*/g;
              return o.call(g, "a"), o.call(p, "a"), g[c] !== 0 || p[c] !== 0;
            }(), d = /()??/.exec("")[1] !== void 0, f = h || d;
            f && (u = function(p) {
              var _ = this, m, v, b, y;
              return d && (v = new RegExp("^" + _.source + "$(?!\\s)", a.call(_))), h && (m = _[c]), b = o.call(_, p), h && b && (_[c] = _.global ? b.index + b[0].length : m), d && b && b.length > 1 && l.call(b[0], v, function() {
                for (y = 1; y < arguments.length - 2; y++)
                  arguments[y] === void 0 && (b[y] = void 0);
              }), b;
            }), s.exports = u;
          }
        ),
        /***/
        "52a7": (
          /***/
          function(s, r) {
            r.f = {}.propertyIsEnumerable;
          }
        ),
        /***/
        5537: (
          /***/
          function(s, r, n) {
            var a = n("8378"), o = n("7726"), l = "__core-js_shared__", u = o[l] || (o[l] = {});
            (s.exports = function(c, h) {
              return u[c] || (u[c] = h !== void 0 ? h : {});
            })("versions", []).push({
              version: a.version,
              mode: n("2d00") ? "pure" : "global",
              copyright: "© 2019 Denis Pushkarev (zloirock.ru)"
            });
          }
        ),
        /***/
        "5ca1": (
          /***/
          function(s, r, n) {
            var a = n("7726"), o = n("8378"), l = n("32e9"), u = n("2aba"), c = n("9b43"), h = "prototype", d = function(f, g, p) {
              var _ = f & d.F, m = f & d.G, v = f & d.S, b = f & d.P, y = f & d.B, x = m ? a : v ? a[g] || (a[g] = {}) : (a[g] || {})[h], D = m ? o : o[g] || (o[g] = {}), A = D[h] || (D[h] = {}), T, j, C, L;
              m && (p = g);
              for (T in p)
                j = !_ && x && x[T] !== void 0, C = (j ? x : p)[T], L = y && j ? c(C, a) : b && typeof C == "function" ? c(Function.call, C) : C, x && u(x, T, C, f & d.U), D[T] != C && l(D, T, L), b && A[T] != C && (A[T] = C);
            };
            a.core = o, d.F = 1, d.G = 2, d.S = 4, d.P = 8, d.B = 16, d.W = 32, d.U = 64, d.R = 128, s.exports = d;
          }
        ),
        /***/
        "5eda": (
          /***/
          function(s, r, n) {
            var a = n("5ca1"), o = n("8378"), l = n("79e5");
            s.exports = function(u, c) {
              var h = (o.Object || {})[u] || Object[u], d = {};
              d[u] = c(h), a(a.S + a.F * l(function() {
                h(1);
              }), "Object", d);
            };
          }
        ),
        /***/
        "5f1b": (
          /***/
          function(s, r, n) {
            var a = n("23c6"), o = RegExp.prototype.exec;
            s.exports = function(l, u) {
              var c = l.exec;
              if (typeof c == "function") {
                var h = c.call(l, u);
                if (typeof h != "object")
                  throw new TypeError("RegExp exec method returned something other than an Object or null");
                return h;
              }
              if (a(l) !== "RegExp")
                throw new TypeError("RegExp#exec called on incompatible receiver");
              return o.call(l, u);
            };
          }
        ),
        /***/
        "613b": (
          /***/
          function(s, r, n) {
            var a = n("5537")("keys"), o = n("ca5a");
            s.exports = function(l) {
              return a[l] || (a[l] = o(l));
            };
          }
        ),
        /***/
        "626a": (
          /***/
          function(s, r, n) {
            var a = n("2d95");
            s.exports = Object("z").propertyIsEnumerable(0) ? Object : function(o) {
              return a(o) == "String" ? o.split("") : Object(o);
            };
          }
        ),
        /***/
        6762: (
          /***/
          function(s, r, n) {
            var a = n("5ca1"), o = n("c366")(!0);
            a(a.P, "Array", {
              includes: function(u) {
                return o(this, u, arguments.length > 1 ? arguments[1] : void 0);
              }
            }), n("9c6c")("includes");
          }
        ),
        /***/
        6821: (
          /***/
          function(s, r, n) {
            var a = n("626a"), o = n("be13");
            s.exports = function(l) {
              return a(o(l));
            };
          }
        ),
        /***/
        "69a8": (
          /***/
          function(s, r) {
            var n = {}.hasOwnProperty;
            s.exports = function(a, o) {
              return n.call(a, o);
            };
          }
        ),
        /***/
        "6a99": (
          /***/
          function(s, r, n) {
            var a = n("d3f4");
            s.exports = function(o, l) {
              if (!a(o))
                return o;
              var u, c;
              if (l && typeof (u = o.toString) == "function" && !a(c = u.call(o)) || typeof (u = o.valueOf) == "function" && !a(c = u.call(o)) || !l && typeof (u = o.toString) == "function" && !a(c = u.call(o)))
                return c;
              throw TypeError("Can't convert object to primitive value");
            };
          }
        ),
        /***/
        7333: (
          /***/
          function(s, r, n) {
            var a = n("0d58"), o = n("2621"), l = n("52a7"), u = n("4bf8"), c = n("626a"), h = Object.assign;
            s.exports = !h || n("79e5")(function() {
              var d = {}, f = {}, g = Symbol(), p = "abcdefghijklmnopqrst";
              return d[g] = 7, p.split("").forEach(function(_) {
                f[_] = _;
              }), h({}, d)[g] != 7 || Object.keys(h({}, f)).join("") != p;
            }) ? function(f, g) {
              for (var p = u(f), _ = arguments.length, m = 1, v = o.f, b = l.f; _ > m; )
                for (var y = c(arguments[m++]), x = v ? a(y).concat(v(y)) : a(y), D = x.length, A = 0, T; D > A; )
                  b.call(y, T = x[A++]) && (p[T] = y[T]);
              return p;
            } : h;
          }
        ),
        /***/
        7726: (
          /***/
          function(s, r) {
            var n = s.exports = typeof window < "u" && window.Math == Math ? window : typeof self < "u" && self.Math == Math ? self : Function("return this")();
            typeof __g == "number" && (__g = n);
          }
        ),
        /***/
        "77f1": (
          /***/
          function(s, r, n) {
            var a = n("4588"), o = Math.max, l = Math.min;
            s.exports = function(u, c) {
              return u = a(u), u < 0 ? o(u + c, 0) : l(u, c);
            };
          }
        ),
        /***/
        "79e5": (
          /***/
          function(s, r) {
            s.exports = function(n) {
              try {
                return !!n();
              } catch {
                return !0;
              }
            };
          }
        ),
        /***/
        "7f20": (
          /***/
          function(s, r, n) {
            var a = n("86cc").f, o = n("69a8"), l = n("2b4c")("toStringTag");
            s.exports = function(u, c, h) {
              u && !o(u = h ? u : u.prototype, l) && a(u, l, { configurable: !0, value: c });
            };
          }
        ),
        /***/
        8378: (
          /***/
          function(s, r) {
            var n = s.exports = { version: "2.6.5" };
            typeof __e == "number" && (__e = n);
          }
        ),
        /***/
        "84f2": (
          /***/
          function(s, r) {
            s.exports = {};
          }
        ),
        /***/
        "86cc": (
          /***/
          function(s, r, n) {
            var a = n("cb7c"), o = n("c69a"), l = n("6a99"), u = Object.defineProperty;
            r.f = n("9e1e") ? Object.defineProperty : function(h, d, f) {
              if (a(h), d = l(d, !0), a(f), o)
                try {
                  return u(h, d, f);
                } catch {
                }
              if ("get" in f || "set" in f)
                throw TypeError("Accessors not supported!");
              return "value" in f && (h[d] = f.value), h;
            };
          }
        ),
        /***/
        "9b43": (
          /***/
          function(s, r, n) {
            var a = n("d8e8");
            s.exports = function(o, l, u) {
              if (a(o), l === void 0)
                return o;
              switch (u) {
                case 1:
                  return function(c) {
                    return o.call(l, c);
                  };
                case 2:
                  return function(c, h) {
                    return o.call(l, c, h);
                  };
                case 3:
                  return function(c, h, d) {
                    return o.call(l, c, h, d);
                  };
              }
              return function() {
                return o.apply(l, arguments);
              };
            };
          }
        ),
        /***/
        "9c6c": (
          /***/
          function(s, r, n) {
            var a = n("2b4c")("unscopables"), o = Array.prototype;
            o[a] == null && n("32e9")(o, a, {}), s.exports = function(l) {
              o[a][l] = !0;
            };
          }
        ),
        /***/
        "9def": (
          /***/
          function(s, r, n) {
            var a = n("4588"), o = Math.min;
            s.exports = function(l) {
              return l > 0 ? o(a(l), 9007199254740991) : 0;
            };
          }
        ),
        /***/
        "9e1e": (
          /***/
          function(s, r, n) {
            s.exports = !n("79e5")(function() {
              return Object.defineProperty({}, "a", { get: function() {
                return 7;
              } }).a != 7;
            });
          }
        ),
        /***/
        a352: (
          /***/
          function(s, r) {
            s.exports = t;
          }
        ),
        /***/
        a481: (
          /***/
          function(s, r, n) {
            var a = n("cb7c"), o = n("4bf8"), l = n("9def"), u = n("4588"), c = n("0390"), h = n("5f1b"), d = Math.max, f = Math.min, g = Math.floor, p = /\$([$&`']|\d\d?|<[^>]*>)/g, _ = /\$([$&`']|\d\d?)/g, m = function(v) {
              return v === void 0 ? v : String(v);
            };
            n("214f")("replace", 2, function(v, b, y, x) {
              return [
                // `String.prototype.replace` method
                // https://tc39.github.io/ecma262/#sec-string.prototype.replace
                function(T, j) {
                  var C = v(this), L = T == null ? void 0 : T[b];
                  return L !== void 0 ? L.call(T, C, j) : y.call(String(C), T, j);
                },
                // `RegExp.prototype[@@replace]` method
                // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
                function(A, T) {
                  var j = x(y, A, this, T);
                  if (j.done)
                    return j.value;
                  var C = a(A), L = String(this), E = typeof T == "function";
                  E || (T = String(T));
                  var N = C.global;
                  if (N) {
                    var q = C.unicode;
                    C.lastIndex = 0;
                  }
                  for (var z = []; ; ) {
                    var H = h(C, L);
                    if (H === null || (z.push(H), !N))
                      break;
                    var Y = String(H[0]);
                    Y === "" && (C.lastIndex = c(L, l(C.lastIndex), q));
                  }
                  for (var W = "", B = 0, oe = 0; oe < z.length; oe++) {
                    H = z[oe];
                    for (var O = String(H[0]), k = d(f(u(H.index), L.length), 0), M = [], $ = 1; $ < H.length; $++)
                      M.push(m(H[$]));
                    var J = H.groups;
                    if (E) {
                      var U = [O].concat(M, k, L);
                      J !== void 0 && U.push(J);
                      var de = String(T.apply(void 0, U));
                    } else
                      de = D(O, L, k, M, J, T);
                    k >= B && (W += L.slice(B, k) + de, B = k + O.length);
                  }
                  return W + L.slice(B);
                }
              ];
              function D(A, T, j, C, L, E) {
                var N = j + A.length, q = C.length, z = _;
                return L !== void 0 && (L = o(L), z = p), y.call(E, z, function(H, Y) {
                  var W;
                  switch (Y.charAt(0)) {
                    case "$":
                      return "$";
                    case "&":
                      return A;
                    case "`":
                      return T.slice(0, j);
                    case "'":
                      return T.slice(N);
                    case "<":
                      W = L[Y.slice(1, -1)];
                      break;
                    default:
                      var B = +Y;
                      if (B === 0)
                        return H;
                      if (B > q) {
                        var oe = g(B / 10);
                        return oe === 0 ? H : oe <= q ? C[oe - 1] === void 0 ? Y.charAt(1) : C[oe - 1] + Y.charAt(1) : H;
                      }
                      W = C[B - 1];
                  }
                  return W === void 0 ? "" : W;
                });
              }
            });
          }
        ),
        /***/
        aae3: (
          /***/
          function(s, r, n) {
            var a = n("d3f4"), o = n("2d95"), l = n("2b4c")("match");
            s.exports = function(u) {
              var c;
              return a(u) && ((c = u[l]) !== void 0 ? !!c : o(u) == "RegExp");
            };
          }
        ),
        /***/
        ac6a: (
          /***/
          function(s, r, n) {
            for (var a = n("cadf"), o = n("0d58"), l = n("2aba"), u = n("7726"), c = n("32e9"), h = n("84f2"), d = n("2b4c"), f = d("iterator"), g = d("toStringTag"), p = h.Array, _ = {
              CSSRuleList: !0,
              // TODO: Not spec compliant, should be false.
              CSSStyleDeclaration: !1,
              CSSValueList: !1,
              ClientRectList: !1,
              DOMRectList: !1,
              DOMStringList: !1,
              DOMTokenList: !0,
              DataTransferItemList: !1,
              FileList: !1,
              HTMLAllCollection: !1,
              HTMLCollection: !1,
              HTMLFormElement: !1,
              HTMLSelectElement: !1,
              MediaList: !0,
              // TODO: Not spec compliant, should be false.
              MimeTypeArray: !1,
              NamedNodeMap: !1,
              NodeList: !0,
              PaintRequestList: !1,
              Plugin: !1,
              PluginArray: !1,
              SVGLengthList: !1,
              SVGNumberList: !1,
              SVGPathSegList: !1,
              SVGPointList: !1,
              SVGStringList: !1,
              SVGTransformList: !1,
              SourceBufferList: !1,
              StyleSheetList: !0,
              // TODO: Not spec compliant, should be false.
              TextTrackCueList: !1,
              TextTrackList: !1,
              TouchList: !1
            }, m = o(_), v = 0; v < m.length; v++) {
              var b = m[v], y = _[b], x = u[b], D = x && x.prototype, A;
              if (D && (D[f] || c(D, f, p), D[g] || c(D, g, b), h[b] = p, y))
                for (A in a)
                  D[A] || l(D, A, a[A], !0);
            }
          }
        ),
        /***/
        b0c5: (
          /***/
          function(s, r, n) {
            var a = n("520a");
            n("5ca1")({
              target: "RegExp",
              proto: !0,
              forced: a !== /./.exec
            }, {
              exec: a
            });
          }
        ),
        /***/
        be13: (
          /***/
          function(s, r) {
            s.exports = function(n) {
              if (n == null)
                throw TypeError("Can't call method on  " + n);
              return n;
            };
          }
        ),
        /***/
        c366: (
          /***/
          function(s, r, n) {
            var a = n("6821"), o = n("9def"), l = n("77f1");
            s.exports = function(u) {
              return function(c, h, d) {
                var f = a(c), g = o(f.length), p = l(d, g), _;
                if (u && h != h) {
                  for (; g > p; )
                    if (_ = f[p++], _ != _)
                      return !0;
                } else
                  for (; g > p; p++)
                    if ((u || p in f) && f[p] === h)
                      return u || p || 0;
                return !u && -1;
              };
            };
          }
        ),
        /***/
        c649: (
          /***/
          function(s, r, n) {
            (function(a) {
              n.d(r, "c", function() {
                return f;
              }), n.d(r, "a", function() {
                return h;
              }), n.d(r, "b", function() {
                return l;
              }), n.d(r, "d", function() {
                return d;
              }), n("a481");
              function o() {
                return typeof window < "u" ? window.console : a.console;
              }
              var l = o();
              function u(g) {
                var p = /* @__PURE__ */ Object.create(null);
                return function(m) {
                  var v = p[m];
                  return v || (p[m] = g(m));
                };
              }
              var c = /-(\w)/g, h = u(function(g) {
                return g.replace(c, function(p, _) {
                  return _ ? _.toUpperCase() : "";
                });
              });
              function d(g) {
                g.parentElement !== null && g.parentElement.removeChild(g);
              }
              function f(g, p, _) {
                var m = _ === 0 ? g.children[0] : g.children[_ - 1].nextSibling;
                g.insertBefore(p, m);
              }
            }).call(this, n("c8ba"));
          }
        ),
        /***/
        c69a: (
          /***/
          function(s, r, n) {
            s.exports = !n("9e1e") && !n("79e5")(function() {
              return Object.defineProperty(n("230e")("div"), "a", { get: function() {
                return 7;
              } }).a != 7;
            });
          }
        ),
        /***/
        c8ba: (
          /***/
          function(s, r) {
            var n;
            n = function() {
              return this;
            }();
            try {
              n = n || new Function("return this")();
            } catch {
              typeof window == "object" && (n = window);
            }
            s.exports = n;
          }
        ),
        /***/
        ca5a: (
          /***/
          function(s, r) {
            var n = 0, a = Math.random();
            s.exports = function(o) {
              return "Symbol(".concat(o === void 0 ? "" : o, ")_", (++n + a).toString(36));
            };
          }
        ),
        /***/
        cadf: (
          /***/
          function(s, r, n) {
            var a = n("9c6c"), o = n("d53b"), l = n("84f2"), u = n("6821");
            s.exports = n("01f9")(Array, "Array", function(c, h) {
              this._t = u(c), this._i = 0, this._k = h;
            }, function() {
              var c = this._t, h = this._k, d = this._i++;
              return !c || d >= c.length ? (this._t = void 0, o(1)) : h == "keys" ? o(0, d) : h == "values" ? o(0, c[d]) : o(0, [d, c[d]]);
            }, "values"), l.Arguments = l.Array, a("keys"), a("values"), a("entries");
          }
        ),
        /***/
        cb7c: (
          /***/
          function(s, r, n) {
            var a = n("d3f4");
            s.exports = function(o) {
              if (!a(o))
                throw TypeError(o + " is not an object!");
              return o;
            };
          }
        ),
        /***/
        ce10: (
          /***/
          function(s, r, n) {
            var a = n("69a8"), o = n("6821"), l = n("c366")(!1), u = n("613b")("IE_PROTO");
            s.exports = function(c, h) {
              var d = o(c), f = 0, g = [], p;
              for (p in d)
                p != u && a(d, p) && g.push(p);
              for (; h.length > f; )
                a(d, p = h[f++]) && (~l(g, p) || g.push(p));
              return g;
            };
          }
        ),
        /***/
        d2c8: (
          /***/
          function(s, r, n) {
            var a = n("aae3"), o = n("be13");
            s.exports = function(l, u, c) {
              if (a(u))
                throw TypeError("String#" + c + " doesn't accept regex!");
              return String(o(l));
            };
          }
        ),
        /***/
        d3f4: (
          /***/
          function(s, r) {
            s.exports = function(n) {
              return typeof n == "object" ? n !== null : typeof n == "function";
            };
          }
        ),
        /***/
        d53b: (
          /***/
          function(s, r) {
            s.exports = function(n, a) {
              return { value: a, done: !!n };
            };
          }
        ),
        /***/
        d8e8: (
          /***/
          function(s, r) {
            s.exports = function(n) {
              if (typeof n != "function")
                throw TypeError(n + " is not a function!");
              return n;
            };
          }
        ),
        /***/
        e11e: (
          /***/
          function(s, r) {
            s.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",");
          }
        ),
        /***/
        f559: (
          /***/
          function(s, r, n) {
            var a = n("5ca1"), o = n("9def"), l = n("d2c8"), u = "startsWith", c = ""[u];
            a(a.P + a.F * n("5147")(u), "String", {
              startsWith: function(d) {
                var f = l(this, d, u), g = o(Math.min(arguments.length > 1 ? arguments[1] : void 0, f.length)), p = String(d);
                return c ? c.call(f, p, g) : f.slice(g, g + p.length) === p;
              }
            });
          }
        ),
        /***/
        f6fd: (
          /***/
          function(s, r) {
            (function(n) {
              var a = "currentScript", o = n.getElementsByTagName("script");
              a in n || Object.defineProperty(n, a, {
                get: function() {
                  try {
                    throw new Error();
                  } catch (c) {
                    var l, u = (/.*at [^\(]*\((.*):.+:.+\)$/ig.exec(c.stack) || [!1])[1];
                    for (l in o)
                      if (o[l].src == u || o[l].readyState == "interactive")
                        return o[l];
                    return null;
                  }
                }
              });
            })(document);
          }
        ),
        /***/
        f751: (
          /***/
          function(s, r, n) {
            var a = n("5ca1");
            a(a.S + a.F, "Object", { assign: n("7333") });
          }
        ),
        /***/
        fa5b: (
          /***/
          function(s, r, n) {
            s.exports = n("5537")("native-function-to-string", Function.toString);
          }
        ),
        /***/
        fab2: (
          /***/
          function(s, r, n) {
            var a = n("7726").document;
            s.exports = a && a.documentElement;
          }
        ),
        /***/
        fb15: (
          /***/
          function(s, r, n) {
            if (n.r(r), typeof window < "u") {
              n("f6fd");
              var a;
              (a = window.document.currentScript) && (a = a.src.match(/(.+\/)[^/]+\.js(\?.*)?$/)) && (n.p = a[1]);
            }
            n("f751"), n("f559"), n("ac6a"), n("cadf"), n("456d");
            function o(O) {
              if (Array.isArray(O))
                return O;
            }
            function l(O, k) {
              if (!(typeof Symbol > "u" || !(Symbol.iterator in Object(O)))) {
                var M = [], $ = !0, J = !1, U = void 0;
                try {
                  for (var de = O[Symbol.iterator](), ve; !($ = (ve = de.next()).done) && (M.push(ve.value), !(k && M.length === k)); $ = !0)
                    ;
                } catch (wt) {
                  J = !0, U = wt;
                } finally {
                  try {
                    !$ && de.return != null && de.return();
                  } finally {
                    if (J)
                      throw U;
                  }
                }
                return M;
              }
            }
            function u(O, k) {
              (k == null || k > O.length) && (k = O.length);
              for (var M = 0, $ = new Array(k); M < k; M++)
                $[M] = O[M];
              return $;
            }
            function c(O, k) {
              if (O) {
                if (typeof O == "string")
                  return u(O, k);
                var M = Object.prototype.toString.call(O).slice(8, -1);
                if (M === "Object" && O.constructor && (M = O.constructor.name), M === "Map" || M === "Set")
                  return Array.from(O);
                if (M === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(M))
                  return u(O, k);
              }
            }
            function h() {
              throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            function d(O, k) {
              return o(O) || l(O, k) || c(O, k) || h();
            }
            n("6762"), n("2fdb");
            function f(O) {
              if (Array.isArray(O))
                return u(O);
            }
            function g(O) {
              if (typeof Symbol < "u" && Symbol.iterator in Object(O))
                return Array.from(O);
            }
            function p() {
              throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            function _(O) {
              return f(O) || g(O) || c(O) || p();
            }
            var m = n("a352"), v = /* @__PURE__ */ n.n(m), b = n("c649");
            function y(O, k, M) {
              return M === void 0 || (O = O || {}, O[k] = M), O;
            }
            function x(O, k) {
              return O.map(function(M) {
                return M.elm;
              }).indexOf(k);
            }
            function D(O, k, M, $) {
              if (!O)
                return [];
              var J = O.map(function(ve) {
                return ve.elm;
              }), U = k.length - $, de = _(k).map(function(ve, wt) {
                return wt >= U ? J.length : J.indexOf(ve);
              });
              return M ? de.filter(function(ve) {
                return ve !== -1;
              }) : de;
            }
            function A(O, k) {
              var M = this;
              this.$nextTick(function() {
                return M.$emit(O.toLowerCase(), k);
              });
            }
            function T(O) {
              var k = this;
              return function(M) {
                k.realList !== null && k["onDrag" + O](M), A.call(k, O, M);
              };
            }
            function j(O) {
              return ["transition-group", "TransitionGroup"].includes(O);
            }
            function C(O) {
              if (!O || O.length !== 1)
                return !1;
              var k = d(O, 1), M = k[0].componentOptions;
              return M ? j(M.tag) : !1;
            }
            function L(O, k, M) {
              return O[M] || (k[M] ? k[M]() : void 0);
            }
            function E(O, k, M) {
              var $ = 0, J = 0, U = L(k, M, "header");
              U && ($ = U.length, O = O ? [].concat(_(U), _(O)) : _(U));
              var de = L(k, M, "footer");
              return de && (J = de.length, O = O ? [].concat(_(O), _(de)) : _(de)), {
                children: O,
                headerOffset: $,
                footerOffset: J
              };
            }
            function N(O, k) {
              var M = null, $ = function(Ki, sf) {
                M = y(M, Ki, sf);
              }, J = Object.keys(O).filter(function(wt) {
                return wt === "id" || wt.startsWith("data-");
              }).reduce(function(wt, Ki) {
                return wt[Ki] = O[Ki], wt;
              }, {});
              if ($("attrs", J), !k)
                return M;
              var U = k.on, de = k.props, ve = k.attrs;
              return $("on", U), $("props", de), Object.assign(M.attrs, ve), M;
            }
            var q = ["Start", "Add", "Remove", "Update", "End"], z = ["Choose", "Unchoose", "Sort", "Filter", "Clone"], H = ["Move"].concat(q, z).map(function(O) {
              return "on" + O;
            }), Y = null, W = {
              options: Object,
              list: {
                type: Array,
                required: !1,
                default: null
              },
              value: {
                type: Array,
                required: !1,
                default: null
              },
              noTransitionOnDrag: {
                type: Boolean,
                default: !1
              },
              clone: {
                type: Function,
                default: function(k) {
                  return k;
                }
              },
              element: {
                type: String,
                default: "div"
              },
              tag: {
                type: String,
                default: null
              },
              move: {
                type: Function,
                default: null
              },
              componentData: {
                type: Object,
                required: !1,
                default: null
              }
            }, B = {
              name: "draggable",
              inheritAttrs: !1,
              props: W,
              data: function() {
                return {
                  transitionMode: !1,
                  noneFunctionalComponentMode: !1
                };
              },
              render: function(k) {
                var M = this.$slots.default;
                this.transitionMode = C(M);
                var $ = E(M, this.$slots, this.$scopedSlots), J = $.children, U = $.headerOffset, de = $.footerOffset;
                this.headerOffset = U, this.footerOffset = de;
                var ve = N(this.$attrs, this.componentData);
                return k(this.getTag(), ve, J);
              },
              created: function() {
                this.list !== null && this.value !== null && b.b.error("Value and list props are mutually exclusive! Please set one or another."), this.element !== "div" && b.b.warn("Element props is deprecated please use tag props instead. See https://github.com/SortableJS/Vue.Draggable/blob/master/documentation/migrate.md#element-props"), this.options !== void 0 && b.b.warn("Options props is deprecated, add sortable options directly as vue.draggable item, or use v-bind. See https://github.com/SortableJS/Vue.Draggable/blob/master/documentation/migrate.md#options-props");
              },
              mounted: function() {
                var k = this;
                if (this.noneFunctionalComponentMode = this.getTag().toLowerCase() !== this.$el.nodeName.toLowerCase() && !this.getIsFunctional(), this.noneFunctionalComponentMode && this.transitionMode)
                  throw new Error("Transition-group inside component is not supported. Please alter tag value or remove transition-group. Current tag value: ".concat(this.getTag()));
                var M = {};
                q.forEach(function(U) {
                  M["on" + U] = T.call(k, U);
                }), z.forEach(function(U) {
                  M["on" + U] = A.bind(k, U);
                });
                var $ = Object.keys(this.$attrs).reduce(function(U, de) {
                  return U[Object(b.a)(de)] = k.$attrs[de], U;
                }, {}), J = Object.assign({}, this.options, $, M, {
                  onMove: function(de, ve) {
                    return k.onDragMove(de, ve);
                  }
                });
                !("draggable" in J) && (J.draggable = ">*"), this._sortable = new v.a(this.rootContainer, J), this.computeIndexes();
              },
              beforeDestroy: function() {
                this._sortable !== void 0 && this._sortable.destroy();
              },
              computed: {
                rootContainer: function() {
                  return this.transitionMode ? this.$el.children[0] : this.$el;
                },
                realList: function() {
                  return this.list ? this.list : this.value;
                }
              },
              watch: {
                options: {
                  handler: function(k) {
                    this.updateOptions(k);
                  },
                  deep: !0
                },
                $attrs: {
                  handler: function(k) {
                    this.updateOptions(k);
                  },
                  deep: !0
                },
                realList: function() {
                  this.computeIndexes();
                }
              },
              methods: {
                getIsFunctional: function() {
                  var k = this._vnode.fnOptions;
                  return k && k.functional;
                },
                getTag: function() {
                  return this.tag || this.element;
                },
                updateOptions: function(k) {
                  for (var M in k) {
                    var $ = Object(b.a)(M);
                    H.indexOf($) === -1 && this._sortable.option($, k[M]);
                  }
                },
                getChildrenNodes: function() {
                  if (this.noneFunctionalComponentMode)
                    return this.$children[0].$slots.default;
                  var k = this.$slots.default;
                  return this.transitionMode ? k[0].child.$slots.default : k;
                },
                computeIndexes: function() {
                  var k = this;
                  this.$nextTick(function() {
                    k.visibleIndexes = D(k.getChildrenNodes(), k.rootContainer.children, k.transitionMode, k.footerOffset);
                  });
                },
                getUnderlyingVm: function(k) {
                  var M = x(this.getChildrenNodes() || [], k);
                  if (M === -1)
                    return null;
                  var $ = this.realList[M];
                  return {
                    index: M,
                    element: $
                  };
                },
                getUnderlyingPotencialDraggableComponent: function(k) {
                  var M = k.__vue__;
                  return !M || !M.$options || !j(M.$options._componentTag) ? !("realList" in M) && M.$children.length === 1 && "realList" in M.$children[0] ? M.$children[0] : M : M.$parent;
                },
                emitChanges: function(k) {
                  var M = this;
                  this.$nextTick(function() {
                    M.$emit("change", k);
                  });
                },
                alterList: function(k) {
                  if (this.list) {
                    k(this.list);
                    return;
                  }
                  var M = _(this.value);
                  k(M), this.$emit("input", M);
                },
                spliceList: function() {
                  var k = arguments, M = function(J) {
                    return J.splice.apply(J, _(k));
                  };
                  this.alterList(M);
                },
                updatePosition: function(k, M) {
                  var $ = function(U) {
                    return U.splice(M, 0, U.splice(k, 1)[0]);
                  };
                  this.alterList($);
                },
                getRelatedContextFromMoveEvent: function(k) {
                  var M = k.to, $ = k.related, J = this.getUnderlyingPotencialDraggableComponent(M);
                  if (!J)
                    return {
                      component: J
                    };
                  var U = J.realList, de = {
                    list: U,
                    component: J
                  };
                  if (M !== $ && U && J.getUnderlyingVm) {
                    var ve = J.getUnderlyingVm($);
                    if (ve)
                      return Object.assign(ve, de);
                  }
                  return de;
                },
                getVmIndex: function(k) {
                  var M = this.visibleIndexes, $ = M.length;
                  return k > $ - 1 ? $ : M[k];
                },
                getComponent: function() {
                  return this.$slots.default[0].componentInstance;
                },
                resetTransitionData: function(k) {
                  if (!(!this.noTransitionOnDrag || !this.transitionMode)) {
                    var M = this.getChildrenNodes();
                    M[k].data = null;
                    var $ = this.getComponent();
                    $.children = [], $.kept = void 0;
                  }
                },
                onDragStart: function(k) {
                  this.context = this.getUnderlyingVm(k.item), k.item._underlying_vm_ = this.clone(this.context.element), Y = k.item;
                },
                onDragAdd: function(k) {
                  var M = k.item._underlying_vm_;
                  if (M !== void 0) {
                    Object(b.d)(k.item);
                    var $ = this.getVmIndex(k.newIndex);
                    this.spliceList($, 0, M), this.computeIndexes();
                    var J = {
                      element: M,
                      newIndex: $
                    };
                    this.emitChanges({
                      added: J
                    });
                  }
                },
                onDragRemove: function(k) {
                  if (Object(b.c)(this.rootContainer, k.item, k.oldIndex), k.pullMode === "clone") {
                    Object(b.d)(k.clone);
                    return;
                  }
                  var M = this.context.index;
                  this.spliceList(M, 1);
                  var $ = {
                    element: this.context.element,
                    oldIndex: M
                  };
                  this.resetTransitionData(M), this.emitChanges({
                    removed: $
                  });
                },
                onDragUpdate: function(k) {
                  Object(b.d)(k.item), Object(b.c)(k.from, k.item, k.oldIndex);
                  var M = this.context.index, $ = this.getVmIndex(k.newIndex);
                  this.updatePosition(M, $);
                  var J = {
                    element: this.context.element,
                    oldIndex: M,
                    newIndex: $
                  };
                  this.emitChanges({
                    moved: J
                  });
                },
                updateProperty: function(k, M) {
                  k.hasOwnProperty(M) && (k[M] += this.headerOffset);
                },
                computeFutureIndex: function(k, M) {
                  if (!k.element)
                    return 0;
                  var $ = _(M.to.children).filter(function(ve) {
                    return ve.style.display !== "none";
                  }), J = $.indexOf(M.related), U = k.component.getVmIndex(J), de = $.indexOf(Y) !== -1;
                  return de || !M.willInsertAfter ? U : U + 1;
                },
                onDragMove: function(k, M) {
                  var $ = this.move;
                  if (!$ || !this.realList)
                    return !0;
                  var J = this.getRelatedContextFromMoveEvent(k), U = this.context, de = this.computeFutureIndex(J, k);
                  Object.assign(U, {
                    futureIndex: de
                  });
                  var ve = Object.assign({}, k, {
                    relatedContext: J,
                    draggedContext: U
                  });
                  return $(ve, M);
                },
                onDragEnd: function() {
                  this.computeIndexes(), Y = null;
                }
              }
            };
            typeof window < "u" && "Vue" in window && window.Vue.component("draggable", B);
            var oe = B;
            r.default = oe;
          }
        )
        /******/
      }).default
    );
  });
})(kD);
const l1 = /* @__PURE__ */ RS(fl), u1 = {
  components: { CtaButton: Qr, SearchBar: Va, draggable: l1 },
  props: {
    styleProps: {
      type: String,
      default: ""
    },
    itemList: {
      type: Array,
      default: []
    },
    setResult: Function
  },
  data() {
    return {
      availableList: [],
      selectedList: []
    };
  },
  computed: {
    selectedListComputed() {
      return 10 - Number(this.selectedList.length);
    }
  },
  methods: {
    setInitialData() {
      var i;
      this.availableList = this.itemList.map((e) => ({
        ...e,
        display: !0
      })), this.selectedList = (i = this.itemList) == null ? void 0 : i.filter((e) => e.default === !0).slice(0, 10);
    },
    setSearchCompleteKeyword(i) {
      if (!i) {
        this.availableList = this.availableList.map((e) => ({
          ...e,
          display: !0
        }));
        return;
      }
      this.availableList = this.availableList.map((e) => {
        let t = i.split(" ").join("").toLowerCase();
        return e.title.split(" ").join("").toLowerCase().includes(t) ? {
          ...e,
          display: !0
        } : {
          ...e,
          display: !1
        };
      });
    },
    selectItem(i) {
      this.selectedList.length !== 10 && (this.selectedList.push({ ...i, selected: !0 }), this.availableList = this.availableList.map(
        (e) => e.id === i.id ? { ...e, selected: !0 } : e
      ));
    },
    unselectItem(i) {
      this.selectedList = this.selectedList.filter(
        (e) => e.id !== i.id
      ), this.availableList = this.availableList.map(
        (e) => e.id === i.id ? { ...e, selected: !1 } : e
      );
    },
    isDraggable(i) {
      const { index: e, futureIndex: t } = i;
      return !(this.selectedList[e].fixed || this.selectedList[t].fixed);
    },
    checkMove(i) {
      return this.isDraggable(i.draggedContext);
    }
  },
  mounted() {
    this.setInitialData();
  },
  watch: {
    selectedList() {
      this.setResult && this.setResult(this.selectedList);
    }
  }
};
var h1 = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    class: i.$style.custom_list_container,
    style: i.styleProps
  }, [t("div", {
    class: i.$style.available_side
  }, [t("div", {
    class: i.$style.available_side_header
  }, [t("p", [i._v("Available Columns")])]), t("search-bar", {
    attrs: {
      setSearchCompleteKeyword: i.setSearchCompleteKeyword,
      "placeholder-text": "Search Available Columns"
    }
  }), t("div", {
    class: i.$style.available_side_contents
  }, i._l(i.availableList, function(s) {
    return s.display ? t("div", {
      key: s.id,
      class: i.$style.available_content
    }, [t("div", {
      attrs: {
        selected: s.selected
      }
    }, [i._v(i._s(s.title))]), t("span", {
      class: i.$style.list_plus_icon,
      style: {
        visibility: s.selected ? "hidden" : "visible"
      },
      on: {
        click: function() {
          return i.selectItem(s);
        }
      }
    })]) : i._e();
  }), 0)], 1), t("div", {
    class: i.$style.selected_side
  }, [t("div", {
    class: i.$style.selected_side_header
  }, [t("p", [i._v("Selected Columns")]), t("cta-button", {
    attrs: {
      "click-handler": i.setInitialData,
      "button-type": "text",
      "style-props": "font-size: 14px; padding: 0;"
    }
  }, [i._v("Reset To Default ")])], 1), t("draggable", {
    attrs: {
      move: i.checkMove
    },
    model: {
      value: i.selectedList,
      callback: function(s) {
        i.selectedList = s;
      },
      expression: "selectedList"
    }
  }, [t("transition-group", i._l(i.selectedList, function(s, r) {
    return t("div", {
      key: s.id,
      class: i.$style.selected_content
    }, [t("span", [i._v(i._s(r + 1))]), t("div", {
      attrs: {
        selected: s.selected,
        fixed: s.fixed
      }
    }, [i._v(" " + i._s(s.title) + " ")]), t("span", {
      class: i.$style.list_minus_icon,
      style: {
        visibility: !s.selected || s.fixed ? "hidden" : "visible"
      },
      on: {
        click: function() {
          return i.unselectItem(s);
        }
      }
    })]);
  }), 0)], 1), i._l(i.selectedListComputed, function(s) {
    return t("div", {
      key: s,
      class: i.$style.selected_content,
      staticStyle: {
        cursor: "default"
      }
    }, [t("span", [i._v(i._s(s + i.selectedList.length))]), t("div", {
      class: i.$style.empty_content
    }), t("span", {
      class: i.$style.empty_content_icon_area
    })]);
  })], 2)]);
}, c1 = [];
const d1 = "_custom_list_container_127sh_1", f1 = "_available_side_127sh_32", p1 = "_available_side_header_127sh_39", g1 = "_available_side_contents_127sh_46", _1 = "_available_content_127sh_57", m1 = "_list_plus_icon_127sh_78", b1 = "_selected_side_127sh_120", y1 = "_selected_side_header_127sh_127", v1 = "_selected_content_127sh_142", x1 = "_empty_content_127sh_195", w1 = "_list_minus_icon_127sh_203", S1 = "_empty_content_icon_area_127sh_240", D1 = "_sortable_ghost_127sh_246", P1 = {
  custom_list_container: d1,
  available_side: f1,
  available_side_header: p1,
  available_side_contents: g1,
  available_content: _1,
  list_plus_icon: m1,
  selected_side: b1,
  selected_side_header: y1,
  selected_content: v1,
  empty_content: x1,
  list_minus_icon: w1,
  empty_content_icon_area: S1,
  sortable_ghost: D1
}, yl = {};
yl.$style = P1;
var T1 = /* @__PURE__ */ te(
  u1,
  h1,
  c1,
  !1,
  k1,
  null,
  null,
  null
);
function k1(i) {
  for (let e in yl)
    this[e] = yl[e];
}
const tA = /* @__PURE__ */ function() {
  return T1.exports;
}(), C1 = {
  props: {
    styleProps: {
      type: String,
      default: ""
    },
    bgColor: {
      type: String,
      default: "#F5F8FF"
    },
    bodyHeight: {
      type: String,
      default: "156px"
    },
    columnWidthArray: Array
  },
  data() {
    return {
      hasScroll: !1
    };
  },
  computed: {
    bgColorComputed() {
      return {
        "--data-table-bg-color": this.bgColor
      };
    }
  },
  methods: {
    isOverflowing() {
      let i = this.$refs.bodyRef;
      this.$refs.bodyRef && i.clientHeight < i.scrollHeight && (this.hasScroll = !0);
    }
  },
  mounted() {
    this.isOverflowing();
  }
};
var M1 = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    staticClass: "data-table-container",
    style: i.styleProps
  }, [t("div", {
    staticClass: "data-table-header",
    class: {
      scrollbar: i.hasScroll
    },
    style: i.bgColorComputed
  }, [t("table", [t("colgroup", i._l(i.columnWidthArray, function(s, r) {
    return t("col", {
      key: r,
      style: {
        width: s
      }
    });
  }), 0), t("thead", [i._t("header")], 2)])]), t("div", {
    ref: "bodyRef",
    staticClass: "data-table-body",
    style: [i.bgColorComputed, {
      maxHeight: i.bodyHeight
    }]
  }, [t("table", [t("colgroup", i._l(i.columnWidthArray, function(s, r) {
    return t("col", {
      key: r,
      style: {
        width: s
      }
    });
  }), 0), t("tbody", [i._t("body")], 2)])]), i.$slots.footer ? t("div", [i._t("footer")], 2) : i._e()]);
}, O1 = [];
const xh = {};
var A1 = /* @__PURE__ */ te(
  C1,
  M1,
  O1,
  !1,
  L1,
  "ccfbd2b4",
  null,
  null
);
function L1(i) {
  for (let e in xh)
    this[e] = xh[e];
}
const iA = /* @__PURE__ */ function() {
  return A1.exports;
}(), j1 = {
  components: {
    CheckboxButton: $h
  },
  props: {
    columnWidthArray: Array,
    rows: Array,
    selectedRows: Array,
    checkboxes: {
      type: Boolean,
      default: !0
    }
  },
  data() {
    return {
      ascending: !1,
      sortColumn: ""
    };
  },
  created() {
    this.AddCheckboxes();
  },
  watch: {
    checkboxes(i) {
      this.AddCheckboxes(i);
    }
  },
  methods: {
    AddCheckboxes(i) {
      i && (this.rows = this.rows.map((e) => ({ checkbox: !1, ...e })));
    },
    handleHeading(i) {
      const e = i.replace(/([A-Z])/g, " $1");
      return e.charAt(0).toUpperCase() + e.slice(1);
    },
    handleAllCheckboxes(i) {
      this.rows.map((e) => e.checkbox = i), i ? this.selectedRows = this.rows : this.selectedRows = [];
    },
    handleEachSelection(i, e) {
      e.checkbox = !e.checkbox;
      var t = this.rows.filter((s) => s.checkbox == !0);
      this.selectedRows = t;
    },
    sortTable: function(e) {
      this.sortColumn === e ? this.ascending = !this.ascending : (this.ascending = !0, this.sortColumn = e);
      var t = this.ascending;
      this.rows.sort(function(s, r) {
        return s[e] > r[e] ? t ? 1 : -1 : s[e] < r[e] ? t ? -1 : 1 : 0;
      });
    }
  },
  computed: {
    columns: function() {
      return this.rows.length == 0 ? [] : Object.keys(this.rows[0]);
    }
  }
};
var E1 = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", [t("table", {
    attrs: {
      id: "fifthTable"
    }
  }, [t("colgroup", [i.checkboxes ? t("col", {
    staticStyle: {
      width: "10px"
    }
  }) : i._e(), i._l(i.columnWidthArray, function(s, r) {
    return t("col", {
      key: r,
      style: {
        width: s
      }
    });
  })], 2), t("thead", [t("tr", i._l(i.columns, function(s, r) {
    return t("th", {
      key: r,
      on: {
        click: function(n) {
          return i.sortTable(s);
        }
      }
    }, [s == "checkbox" && i.checkboxes ? t("div", [t("CheckboxButton", {
      attrs: {
        "button-type": "checkbox",
        "click-handler": function(n) {
          return i.handleAllCheckboxes(n);
        }
      }
    })], 1) : s !== "checkbox" ? t("div", {
      staticClass: "heading"
    }, [t("span", [i._v(i._s(i.handleHeading(s)))]), s == i.sortColumn ? t("div", {
      staticClass: "arrow",
      class: i.ascending ? "arrow_up" : "arrow_down"
    }) : i._e()]) : i._e()]);
  }), 0)]), t("tbody", i._l(i.rows, function(s, r) {
    return t("tr", {
      key: r
    }, i._l(i.columns, function(n, a) {
      return t("td", {
        key: a
      }, [n == "checkbox" && i.checkboxes ? t("div", [t("CheckboxButton", {
        attrs: {
          "button-type": "checkbox",
          active: s.checkbox,
          "click-handler": function(o) {
            return i.handleEachSelection(o, s);
          }
        }
      })], 1) : n !== "checkbox" ? t("div", [Array.isArray(s[n]) ? t("div", {
        staticClass: "arrayDiv"
      }, [t("span", [i._v(i._s(s[n][0]))]), t("span", [i._v(i._s(s[n][1]))])]) : t("div", [t("span", {
        staticClass: "singleDiv"
      }, [i._v(i._s(s[n]))])])]) : i._e()]);
    }), 0);
  }), 0)])]);
}, I1 = [];
const wh = {};
var Y1 = /* @__PURE__ */ te(
  j1,
  E1,
  I1,
  !1,
  R1,
  "5fef0d94",
  null,
  null
);
function R1(i) {
  for (let e in wh)
    this[e] = wh[e];
}
const sA = /* @__PURE__ */ function() {
  return Y1.exports;
}(), N1 = {
  name: "Dropdown",
  props: {
    titleName: {
      type: String,
      default: "title"
    },
    // props for popover
    visible: Boolean,
    items: Array,
    // option list (title: name to be displayed in option list, image: option image) (ex: {title: 'option1', [image: imageUrl, ...]})
    // On close dropdown when you click outside
    onClose: Function,
    setResult: {
      // Save the final result. (When using checkboxes)
      type: Function,
      default: () => 1
    },
    clickHandler: Function,
    // Click handler (if using list click without using checkbox)
    checkbox: Boolean,
    // // Set whether checkbox or no
    styleProps: {
      // type: String as PropType<StyleValue>,
      // default: "" as StyleValue,
      type: String,
      default: ""
    },
    // Set whether dropdown-list wrap-style or not (ex: {top: '10px', left: '10px', width: '10px'})
    placeholder: String,
    // Set whether placeholder or not
    infoText: {
      Type: String,
      default: ""
    },
    id: String
    // Set whether checkbox-id or not
  },
  // alice component
  components: {
    "search-bar": Va,
    "common-popover": uu
  },
  data() {
    return {
      filteredDependency: 1,
      logTest: !1,
      inputContent: "",
      // The input value. Shows the input list searched through filtered.
      isHover: !1,
      requestParam: {
        query: ""
      }
    };
  },
  computed: {
    // Filter your search terms
    filtered() {
      if (this.items && this.filteredDependency) {
        const i = this.inputContent.trim();
        return !i || i == "" ? this.items : this.items != null ? this.items.filter((s) => s[this.titleName] != null && s[this.titleName].toUpperCase().includes(i.toUpperCase())).sort((s, r) => s[this.titleName].toUpperCase() > r[this.titleName].toUpperCase() ? 1 : -1) : this.items;
      } else
        return this.items;
    },
    checkedArray() {
      let i = this.filtered.filter((e) => {
        if (e != null && e.checked)
          return e.checked === !0;
      });
      return this.setResult(i), i;
    }
  },
  methods: {
    getComputedStyle(i) {
      let e = "";
      return i.icon == "pie" ? e = "pie-icon" : i.icon == "tree" ? e = "tree-icon" : i.icon == "bar" ? e = "bar-icon" : i.icon == "line" && (e = "line-icon"), e;
    },
    search(i) {
      this.inputContent = i;
    },
    truncateText(i, e) {
      return i && i.length > e ? i.substring(0, e) + "..." : i;
    },
    changeHandler(i, e) {
      this.filtered[e] !== void 0 && (this.filtered[e].checked = i.target.checked, this.$set(this.filtered, e, this.filtered[e]), this.filteredDependency += 1);
    },
    // Click on option. If there is a click handler, the click handler is executed, and if there is no click handler, the checklist is saved.
    optionClick(i) {
      this.$nextTick(() => {
        this.clickHandler && this.clickHandler(i);
      });
    },
    // Full selection function. If you want to use it in the parent component, set refs and use this.$refs.locationDropdown.selectAll("location"); It can be used in the same format as
    // See OeeCenter.vue.
    selectAll() {
      let i = this.filtered.slice();
      this.filtered.splice(0), i == null || i.map((e) => {
        e.disabled || (e.checked = !0), this.filtered.push(e);
      }), this.filteredDependency += 1;
    },
    // Deselect all.
    unselectAll() {
      let i = this.filtered.slice();
      this.filtered.splice(0), i == null || i.map((e) => {
        e.default !== !0 && (e.checked = !1), this.filtered.push(e);
      }), this.filteredDependency += 1;
    },
    // handler for popover
    handleClose() {
      this.$nextTick(() => {
        this.onClose ? this.onClose() : this.visible = !1;
      });
    }
  }
};
var $1 = function() {
  var i, e, t, s, r = this, n = r.$createElement, a = r._self._c || n;
  return a("common-popover", {
    style: r.styleProps,
    attrs: {
      visible: r.visible
    },
    on: {
      close: r.handleClose
    }
  }, [a("div", {
    class: r.$style.dropdown_wrap,
    style: r.styleProps
  }, [r.items.length >= 5 ? a("div", [a("search-bar", {
    attrs: {
      "placeholder-text": r.placeholder || "Search",
      "request-param": r.requestParam,
      "set-search-complete-keyword": r.search
    }
  }), a("div", {
    class: r.$style.focus_border
  })], 1) : r._e(), a("ul", {
    class: r.$style.dropdown_list
  }, [r.checkbox && ((i = r.filtered) === null || i === void 0 ? void 0 : i.length) >= 5 ? a("li", {
    class: r.$style.all_select_list
  }, [a("div", {
    attrs: {
      disabled: ((e = r.checkedArray) === null || e === void 0 ? void 0 : e.length) === ((t = r.filtered) === null || t === void 0 ? void 0 : t.length)
    },
    on: {
      click: function(o) {
        return r.selectAll();
      }
    }
  }, [r._v(" Select All ")]), a("div", {
    attrs: {
      disabled: ((s = r.checkedArray) === null || s === void 0 ? void 0 : s.length) === 0
    },
    on: {
      click: function(o) {
        return r.unselectAll();
      }
    }
  }, [r._v(" Unselect All ")])]) : r._e(), r.infoText ? a("li", {
    class: r.$style.info_text
  }, [r._v(r._s(r.infoText))]) : r._e(), r._l(r.filtered, function(o, l) {
    return [o ? a("li", {
      key: l
    }, [a("label", {
      class: [r.checkbox ? "" : r.$style.list_hover_dropdown],
      attrs: {
        for: `dropdown-input-${l}-${r.id}`,
        disabled: o == null ? void 0 : o.disabled
      },
      on: {
        click: function(u) {
          return r.optionClick(o);
        }
      }
    }, [r.checkbox ? [a("input", {
      directives: [{
        name: "model",
        rawName: "v-model",
        value: o.checked,
        expression: "item.checked"
      }],
      attrs: {
        id: `dropdown-input-${l}-${r.id}`,
        type: "checkbox"
      },
      domProps: {
        value: JSON.stringify(o),
        checked: Array.isArray(o.checked) ? r._i(o.checked, JSON.stringify(o)) > -1 : o.checked
      },
      on: {
        input: function(u) {
          return r.changeHandler(u, l);
        },
        change: function(u) {
          var c = o.checked, h = u.target, d = !!h.checked;
          if (Array.isArray(c)) {
            var f = JSON.stringify(o), g = r._i(c, f);
            h.checked ? g < 0 && r.$set(o, "checked", c.concat([f])) : g > -1 && r.$set(o, "checked", c.slice(0, g).concat(c.slice(g + 1)));
          } else
            r.$set(o, "checked", d);
        }
      }
    }), a("div", {
      class: r.$style.checkbox_custom
    })] : r._e(), o != null && o.icon ? a("div", {
      class: [r.getComputedStyle(o), r.$style.defualt_style]
    }, [a("img", {
      attrs: {
        src: o.icon,
        alt: "dropdown-icon"
      }
    })]) : r._e(), r._v(" " + r._s(r.truncateText(o[r.titleName], 40)) + " ")], 2)]) : r._e()];
  })], 2)])]);
}, F1 = [];
const B1 = "_dropdown_wrap_xdaez_7", H1 = "_dropdown_list_xdaez_24", z1 = "_checkbox_custom_xdaez_44", X1 = "_all_select_list_xdaez_77", V1 = "_info_text_xdaez_96", U1 = "_list_hover_dropdown_xdaez_102", W1 = {
  dropdown_wrap: B1,
  dropdown_list: H1,
  checkbox_custom: z1,
  all_select_list: X1,
  info_text: V1,
  list_hover_dropdown: U1
}, vl = {};
vl.$style = W1;
var G1 = /* @__PURE__ */ te(
  N1,
  $1,
  F1,
  !1,
  Z1,
  "242cc473",
  null,
  null
);
function Z1(i) {
  for (let e in vl)
    this[e] = vl[e];
}
const rA = /* @__PURE__ */ function() {
  return G1.exports;
}(), K1 = {
  name: "DoubleDropdown",
  props: {
    visible: {
      default: !1,
      Type: Boolean
    },
    items: Array,
    clickHandler: Function,
    styleProp: String,
    // Set whether dropdown-list wrap-style or not (ex: {top: '10px', left: '10px', width: '10px'})
    placeholder: String,
    // Set whether placeholder or not
    id: String,
    applyHandler: Function,
    resetHandler: Function,
    onClose: Function,
    position: {
      type: Object,
      default: () => ({ top: "", left: "", right: "", bottom: "" })
    }
  },
  // component alies
  components: {
    CtaButton: Qr,
    "common-popover": uu
  },
  data() {
    return {
      colorType: "blue-fill",
      inputContent: "",
      // The input value. Shows the input list searched through filtered.
      checkedArray: []
      // The checked list is saved. Passed to the parent component through the setResult function
    };
  },
  mounted() {
    setTimeout(() => {
      this.filtered.forEach((i) => {
        this.selectAll(i, i, i.title);
      });
    }, 1e3);
  },
  computed: {
    // Filter your search terms
    filtered() {
      if (this.items) {
        const i = this.inputContent.trim();
        return !i || i == "" ? this.items : this.items != null ? this.items.filter((s) => s.title != null && s.title.toUpperCase().includes(i.toUpperCase())).sort((s, r) => s.title.toUpperCase() > r.title.toUpperCase() ? 1 : -1) : this.items;
      } else
        return this.items;
    }
  },
  methods: {
    toggleCheckValue(i, e, t) {
      e.checked = !e.checked, e.title == "All" && e.checked == !0 ? this.selectAllCheckBox(i, t, !0) : e.title == "All" && e.checked == !1 && this.selectAllCheckBox(i, t, !1), this.SyncCheckedArray();
      let s = this.checkedArray.find(
        (r) => r.title == i.title
      );
      s !== void 0 && (s == null ? void 0 : s.childrens.length) == this.filtered[t].childrens.length - 1 && this.selectOrDeselectAllbox(i, t), this.SyncCheckedArray();
    },
    selectOrDeselectAllbox(i) {
      let e = i.title, t = JSON.parse(JSON.stringify(this.filtered));
      this.filtered.splice(0), this.$nextTick(() => {
        t.map((s) => {
          let r = { id: s.id, title: s.title, childrens: [] };
          s.childrens.map((n) => {
            r.childrens.push({ title: n.title, code: n.code });
          }), this.filtered.push(r);
        }), this.filtered.map((s, r) => {
          this.selectAllBox(s, t[r], e);
        });
      });
    },
    selectAllBox(i, e, t) {
      i.childrens.forEach((s, r) => {
        i.title == t && s.title == "All" ? s.checked = !e.childrens[r].checked : s.checked = e.childrens[r].checked;
      }), this.$forceUpdate();
    },
    // Click on option. If there is a click handler, the click handler is executed, and if there is no click handler, the checklist is saved.
    applyHandlerMethod() {
      this.$nextTick(() => {
        this.applyHandler && (this.SyncCheckedArray(), this.applyHandler(this.checkedArray));
      }), this.$forceUpdate();
    },
    /* eslint-disable  no-unused-vars */
    selectAllCheckBox(i, e, t) {
      let s = i.title, r = JSON.parse(JSON.stringify(this.filtered));
      this.filtered.splice(0), this.$nextTick(() => {
        r.map((n) => {
          let a = { id: n.id, title: n.title }, o = [];
          n == null || n.childrens.map((l) => {
            o.push({ title: l.title, code: l.code });
          }), a.childrens = o, this.filtered.push(a);
        }), this.filtered.map((n, a) => {
          t ? this.selectAll(n, r[a], s) : this.unselectAll(n, r[a], s);
        });
      }), this.$forceUpdate();
    },
    // select all
    selectAll(i, e, t) {
      t == i.title ? i == null || i.childrens.forEach((s) => {
        s.checked = !0;
      }) : i == null || i.childrens.forEach((s, r) => {
        s.checked = e.childrens[r].checked;
      }), this.$forceUpdate();
    },
    // Deselect all.
    unselectAll(i, e, t) {
      t == i.title ? i == null || i.childrens.forEach((s) => {
        s.checked = !1;
      }) : i == null || i.childrens.forEach((s, r) => {
        s.checked = e.childrens[r].checked;
      }), this.$forceUpdate();
    },
    resetAllCheckBox() {
      let i = JSON.parse(JSON.stringify(this.filtered));
      this.filtered.splice(0), this.$nextTick(() => {
        i.map((e) => {
          let t = { id: e.id, title: e.title }, s = [];
          e == null || e.childrens.map((r) => {
            s.push({ title: r.title, code: r.code });
          }), t.childrens = s, this.filtered.push(t);
        }), this.filtered.map((e, t) => {
          this.selectAll(e, i[t], e.title);
        });
      }), this.$forceUpdate();
    },
    resetDataHandler() {
      this.resetAllCheckBox(), this.$nextTick(() => {
        this.resetHandler && this.resetHandler(this.checkedArray);
      }), this.$forceUpdate();
    },
    // Save checked array.
    SyncCheckedArray() {
      const i = JSON.parse(JSON.stringify(this.filtered)), e = [];
      i.forEach((t) => {
        const s = t.childrens.filter((r) => r.checked === !0);
        t.childrens = s, e.push(t);
      }), this.checkedArray = e;
    },
    handleClose() {
      this.$nextTick(() => {
        this.onClose ? this.onClose() : this.visible = !1;
      });
    }
  }
};
var Q1 = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("common-popover", {
    attrs: {
      visible: i.visible,
      position: i.position
    },
    on: {
      close: i.handleClose
    }
  }, [t("div", {
    class: i.$style.dropdown_wrap,
    style: i.styleProp
  }, [t("ul", {
    class: [i.$style.parent_item, i.$style.row]
  }, i._l(i.filtered, function(s, r) {
    return t("li", {
      key: r,
      class: [i.$style.col_md, i.$style.custom_padding]
    }, [t("label", {
      class: i.$style.label_height
    }, [t("h5", {
      class: i.$style.font_setting
    }, [i._v(i._s(s.title))])]), t("ul", {
      class: i.$style.child_item
    }, i._l(s.childrens, function(n, a) {
      return t("li", {
        key: `${a}-${r}`
      }, [t("label", {
        attrs: {
          for: `dropdown-input-${r}-${a}-${i.id}`
        },
        on: {
          mouseup: function(o) {
            return i.toggleCheckValue(s, n, r);
          }
        }
      }, [[t("input", {
        directives: [{
          name: "model",
          rawName: "v-model",
          value: n.checked,
          expression: "subItem.checked"
        }],
        attrs: {
          id: `dropdown-input-${r}-${a}-${i.id}`,
          type: "checkbox"
        },
        domProps: {
          value: JSON.stringify(n),
          checked: n.checked,
          checked: Array.isArray(n.checked) ? i._i(n.checked, JSON.stringify(n)) > -1 : n.checked
        },
        on: {
          change: function(o) {
            var l = n.checked, u = o.target, c = !!u.checked;
            if (Array.isArray(l)) {
              var h = JSON.stringify(n), d = i._i(l, h);
              u.checked ? d < 0 && i.$set(n, "checked", l.concat([h])) : d > -1 && i.$set(n, "checked", l.slice(0, d).concat(l.slice(d + 1)));
            } else
              i.$set(n, "checked", c);
          }
        }
      }), t("div", {
        class: i.$style.checkbox_custom
      })], n.image ? t("div", [t("img", {
        attrs: {
          src: n.image,
          alt: ""
        }
      })]) : i._e(), i._v(" " + i._s(n.title) + " ")], 2)]);
    }), 0), t("span", {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: r != i.items.length - 1,
        expression: "index != items.length - 1"
      }],
      class: i.$style.vertical_line
    })]);
  }), 0), t("div", {
    class: [i.$style.buttons_custom, i.$style.w_100, i.$style.align_items_center, i.$style.d_flex, i.$style.justify_content_between]
  }, [t("div", {
    class: [i.$style.all_select_list, i.$style.reset_styles]
  }, [t("div", {
    class: i.$style.reset_btn_styles,
    on: {
      click: function(s) {
        return i.resetDataHandler();
      }
    }
  }, [i._v(" Reset to Default ")])]), t("div", [t("CtaButton", {
    class: [i.$style.btn_custom, i.$style.btn_custom_primary, i.$style.animationPrimary],
    attrs: {
      type: "link",
      "click-handler": i.applyHandlerMethod,
      colorType: i.colorType
    }
  }, [t("span", [i._v("Apply")])])], 1)])])]);
}, q1 = [];
const J1 = "_dropdown_wrap_1ahj7_7", eP = "_parent_item_1ahj7_25", tP = "_row_1ahj7_34", iP = "_col_md_1ahj7_38", sP = "_custom_padding_1ahj7_47", rP = "_font_setting_1ahj7_55", nP = "_child_item_1ahj7_68", aP = "_checkbox_custom_1ahj7_88", oP = "_vertical_line_1ahj7_110", lP = "_buttons_custom_1ahj7_117", uP = "_w_100_1ahj7_121", hP = "_align_items_center_1ahj7_124", cP = "_d_flex_1ahj7_127", dP = "_justify_content_between_1ahj7_130", fP = "_reset_styles_1ahj7_133", pP = "_all_select_list_1ahj7_140", gP = "_reset_btn_styles_1ahj7_153", _P = "_btn_custom_1ahj7_157", mP = {
  dropdown_wrap: J1,
  parent_item: eP,
  row: tP,
  col_md: iP,
  custom_padding: sP,
  font_setting: rP,
  child_item: nP,
  checkbox_custom: aP,
  vertical_line: oP,
  buttons_custom: lP,
  w_100: uP,
  align_items_center: hP,
  d_flex: cP,
  justify_content_between: dP,
  reset_styles: fP,
  all_select_list: pP,
  reset_btn_styles: gP,
  btn_custom: _P
}, xl = {};
xl.$style = mP;
var bP = /* @__PURE__ */ te(
  K1,
  Q1,
  q1,
  !1,
  yP,
  "0144e24b",
  null,
  null
);
function yP(i) {
  for (let e in xl)
    this[e] = xl[e];
}
const nA = /* @__PURE__ */ function() {
  return bP.exports;
}(), vP = {
  props: {
    id: String,
    styleProps: {
      type: String,
      default: ""
    },
    placeholderText: {
      type: String,
      default: "Enter Number "
    },
    checkmark: {
      type: String,
      default: "outside"
    },
    active: Boolean,
    disabled: Boolean,
    error: {
      type: Boolean,
      default: !1
    },
    iconUrl: {
      type: Object,
      default: null
    },
    min: Number,
    max: Number,
    step: Number,
    changeHandler: Function,
    errorMessage: String,
    required: Boolean,
    readonly: Boolean
  },
  data() {
    return {
      text: "",
      validData: !1,
      keypressed: !1
    };
  },
  watch: {
    text() {
      var i, e;
      if (this.changeHandler && this.changeHandler({ value: this.text, id: this.id }), ((i = this.max) == null ? void 0 : i.length) < 1)
        parseInt(this.text) > this.min ? this.validData = !0 : this.validData = !1;
      else if (((e = this.min) == null ? void 0 : e.length) < 1)
        parseInt(this.text) < this.max ? this.validData = !0 : this.validData = !1;
      else {
        (parseInt(this.text) > this.min || parseInt(this.text) < this.max) && (this.validData = !0), (parseInt(this.text) < this.min || parseInt(this.text) > this.max) && (this.validData = !1);
        let t = parseInt(this.text);
        isNaN(t) && (this.validData = !1);
      }
    }
  },
  methods: {
    keyPressed() {
      this.keypressed || (this.keypressed = !0);
    }
  },
  computed: {
    positionComputed() {
      var i, e;
      return this.iconUrl && this.error === !1 && this.disabled === !1 ? `${this.$style[(i = this.iconUrl) == null ? void 0 : i.position]} ` : this.error === !0 && this.iconUrl ? `${this.$style[(e = this.iconUrl) == null ? void 0 : e.position]} ${this.$style.error}` : this.error === !0 ? `${this.$style.error}` : this.disabled === !0 && this.iconUrl ? `${this.$style.disable} ` : this.disabled === !0 ? `${this.$style.disable} ` : "";
    },
    textBoxClassComputed() {
      return this.error == !1 ? `${this.$style.base_input}` : this.error == !0 ? `${this.$style.base_input} ${this.$style.base_input_error} ` : "";
    },
    iconBorderComputed() {
      var i, e;
      return this.error === !0 && ((i = this.iconUrl) == null ? void 0 : i.position) == "left" ? `${this.$style.base_input__icon_error_left} ` : this.error === !0 && ((e = this.iconUrl) == null ? void 0 : e.position) == "right" ? `${this.$style.base_input__icon_error_right} ` : "";
    }
  }
};
var xP = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    class: i.$style.container
  }, [t("div", [t("div", {
    class: [i.$style.container_input, i.positionComputed]
  }, [i.iconUrl ? t("span", {
    class: [i.iconBorderComputed, i.$style.base_input__icon]
  }, [t("span", {
    class: i.$style.base_input_icon_img
  }, [t("img", {
    attrs: {
      src: i.iconUrl.url
    }
  })])]) : i._e(), t("input", {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: i.text,
      expression: "text"
    }],
    class: [i.textBoxClassComputed, i.$style.base_input, i.keypressed ? i.$style.caret_color : ""],
    style: i.styleProps,
    attrs: {
      id: i.id,
      placeholder: i.placeholderText,
      type: "number",
      active: i.active,
      disabled: i.disabled,
      error: i.error,
      min: i.min,
      max: i.max,
      step: i.step,
      required: i.required,
      readonly: i.readonly,
      "error-message": i.errorMessage
    },
    domProps: {
      value: i.text
    },
    on: {
      keyup: function(s) {
        return i.keyPressed();
      },
      input: function(s) {
        s.target.composing || (i.text = s.target.value);
      }
    }
  }), i.checkmark === "inside" ? t("span", {
    class: [i.validData ? i.$style.inside1 : i.$style.inside, i.$style.validity]
  }) : i._e()]), i.checkmark == "outside" ? t("span", {
    class: [i.validData ? i.$style.outside1 : i.$style.outside, i.$style.validity]
  }) : i._e()]), i.error ? t("div", [t("span", {
    class: i.$style.error_message
  }, [i._v(i._s(i.errorMessage))])]) : i._e()]);
}, wP = [];
const SP = "_container_1871l_1", DP = "_caret_color_1871l_1", PP = "_container_input_1871l_4", TP = "_base_input__icon_1871l_41", kP = "_base_input__icon_img_1871l_49", CP = "_base_input__icon_error_left_1871l_58", MP = "_base_input__icon_error_right_1871l_61", OP = "_validity_1871l_64", AP = "_inside_1871l_67", LP = "_inside1_1871l_72", jP = "_base_input_1871l_41", EP = "_base_input_error_1871l_98", IP = "_outside1_1871l_107", YP = "_outside_1871l_107", RP = "_error_1871l_117", NP = "_disable_1871l_124", $P = "_right_1871l_129", FP = "_left_1871l_132", BP = "_error_message_1871l_135", HP = {
  container: SP,
  caret_color: DP,
  container_input: PP,
  base_input__icon: TP,
  base_input__icon_img: kP,
  base_input__icon_error_left: CP,
  base_input__icon_error_right: MP,
  validity: OP,
  inside: AP,
  inside1: LP,
  base_input: jP,
  base_input_error: EP,
  outside1: IP,
  outside: YP,
  error: RP,
  disable: NP,
  right: $P,
  left: FP,
  error_message: BP
}, wl = {};
wl.$style = HP;
var zP = /* @__PURE__ */ te(
  vP,
  xP,
  wP,
  !1,
  XP,
  "29bed24a",
  null,
  null
);
function XP(i) {
  for (let e in wl)
    this[e] = wl[e];
}
const aA = /* @__PURE__ */ function() {
  return zP.exports;
}(), VP = {
  props: {
    id: String,
    styleProps: String,
    placeholderText: {
      type: String,
      default: "Memo"
    },
    active: Boolean,
    disabled: Boolean,
    error: Boolean,
    errorMessage: {
      type: String,
      default: "Error Message Here"
    },
    minlength: String,
    // minimum character
    maxlength: String,
    // maximum character
    cols: Number,
    readonly: Boolean,
    changeHandler: Function,
    required: Boolean
  },
  data() {
    return {
      text: "",
      inputHeight: "0",
      keypressed: !1
    };
  },
  watch: {
    text() {
      this.changeHandler && this.changeHandler({ value: this.value, id: this.id }), this.resize(), this.$emit("input", this.text);
    }
  },
  computed: {
    textBoxClassComputed() {
      return this.error == !0 ? `${this.$style.textarea_box_error}` : `${this.$style.textarea_box}`;
    }
  },
  methods: {
    keyPressed() {
      this.keypressed || (this.keypressed = !0);
    },
    resize() {
      this.inputHeight = `${this.$refs.input.scrollHeight}px`;
    }
  },
  mounted() {
    this.resize();
  }
};
var UP = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", [t("div", {
    class: i.$style.container
  }, [t("div", {
    class: i.$style.textarea_box_container
  }, [t("textarea", {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: i.text,
      expression: "text"
    }],
    ref: "input",
    class: [i.textBoxClassComputed, i.keypressed ? i.$style.caret_color : ""],
    style: i.styleProps,
    attrs: {
      id: i.id,
      placeholder: i.placeholderText,
      type: "text",
      active: i.active,
      disabled: i.disabled,
      minlength: i.minlength,
      maxlength: i.maxlength,
      readonly: i.readonly,
      cols: i.cols,
      error: i.error,
      required: i.required,
      "error-message": i.errorMessage
    },
    domProps: {
      value: i.text
    },
    on: {
      keyup: function(s) {
        return i.keyPressed();
      },
      input: function(s) {
        s.target.composing || (i.text = s.target.value);
      }
    }
  })]), i.error ? t("div", {
    class: i.$style.error_message
  }, [t("span", [i._v(i._s(i.errorMessage))])]) : i._e()])]);
}, WP = [];
const GP = "_container_d5fjq_1", ZP = "_caret_color_d5fjq_1", KP = "_textarea_box_container_d5fjq_4", QP = "_textarea_box_d5fjq_4", qP = "_textarea_box_error_d5fjq_64", JP = "_error_message_d5fjq_81", eT = {
  container: GP,
  caret_color: ZP,
  textarea_box_container: KP,
  textarea_box: QP,
  textarea_box_error: qP,
  error_message: JP
}, Sl = {};
Sl.$style = eT;
var tT = /* @__PURE__ */ te(
  VP,
  UP,
  WP,
  !1,
  iT,
  "60fbe7d8",
  null,
  null
);
function iT(i) {
  for (let e in Sl)
    this[e] = Sl[e];
}
const oA = /* @__PURE__ */ function() {
  return tT.exports;
}(), sT = "_container_1t5m0_1", rT = "_container_input_1t5m0_1", nT = "_base_input__icon_1t5m0_38", aT = "_base_input_icon_img_1t5m0_46", oT = "_base_input__icon_error_left_1t5m0_55", lT = "_base_input__icon_error_right_1t5m0_58", uT = "_validity_1t5m0_61", hT = "_inside_1t5m0_64", cT = "_inside1_1t5m0_69", dT = "_base_input_1t5m0_38", fT = "_caret_color_1t5m0_88", pT = "_base_input_error_1t5m0_97", gT = "_outside1_1t5m0_106", _T = "_outside_1t5m0_106", mT = "_error_1t5m0_116", bT = "_disable_1t5m0_123", yT = "_right_1t5m0_128", vT = "_left_1t5m0_131", xT = "_error_message_1t5m0_134", is = {
  container: sT,
  container_input: rT,
  base_input__icon: nT,
  base_input_icon_img: aT,
  base_input__icon_error_left: oT,
  base_input__icon_error_right: lT,
  validity: uT,
  inside: hT,
  inside1: cT,
  base_input: dT,
  caret_color: fT,
  base_input_error: pT,
  outside1: gT,
  outside: _T,
  error: mT,
  disable: bT,
  right: yT,
  left: vT,
  error_message: xT
}, wT = {
  props: {
    id: String,
    styleProps: String,
    placeholderText: {
      type: String,
      default: "Enter Text Here"
    },
    checkmark: String,
    active: Boolean,
    disabled: Boolean,
    error: {
      type: Boolean,
      default: !1
    },
    required: Boolean,
    iconUrl: {
      type: Object
    },
    minlength: {
      type: Number,
      default: 1
    },
    // minimum character
    maxlength: Number,
    // maximum character
    errorMessage: String,
    readonly: Boolean
  },
  data() {
    return {
      validData: !1,
      text: "",
      keyPressed: !1
    };
  },
  methods: {
    isValid(i) {
      const e = i.length;
      return !(e < this.minlength || this.maxlength && e > this.maxlength);
    },
    onKeyPressed() {
      this.keyPressed || (this.keyPressed = !0), this.validData = this.isValid(this.text);
    }
  },
  computed: {
    positionComputed() {
      var t;
      let i = "";
      const e = (t = this.iconUrl) == null ? void 0 : t.position;
      return e && (i += `${is[e]} `), this.error && (i += `${is.error} `), this.disabled && (i += `${is.disable} `), i;
    },
    textBoxClassComputed() {
      let i = `${is.base_input} `;
      return this.error && (i += `${is.base_input_error} `), i;
    },
    iconBorderComputed() {
      var e;
      return !this.error || !((e = this.iconUrl) != null && e.position) ? "" : this.iconUrl.position === "left" ? `${is.base_input__icon_error_left} ` : `${is.base_input__icon_error_right} `;
    }
  }
};
var ST = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    class: i.$style.container
  }, [t("div", {
    staticStyle: {
      display: "flex"
    }
  }, [t("div", {
    class: [i.$style.container_input, i.$style.search_bar__input, i.positionComputed],
    style: i.styleProps,
    attrs: {
      tabindex: "0"
    }
  }, [i.iconUrl ? t("span", {
    class: [i.iconBorderComputed, i.$style.base_input__icon]
  }, [t("span", {
    class: i.$style.base_input_icon_img
  }, [t("img", {
    attrs: {
      src: i.iconUrl.url
    }
  })])]) : i._e(), t("input", {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: i.text,
      expression: "text"
    }],
    class: [i.textBoxClassComputed, i.$style.base_input, i.keyPressed ? i.$style.caret_color : ""],
    attrs: {
      id: i.id,
      placeholder: i.placeholderText,
      type: "text",
      active: i.active,
      disabled: i.disabled,
      error: i.error,
      minlength: i.minlength,
      maxlength: i.maxlength,
      checkmark: i.checkmark,
      readonly: i.readonly,
      required: i.required
    },
    domProps: {
      value: i.text
    },
    on: {
      keyup: function(s) {
        return i.onKeyPressed();
      },
      input: function(s) {
        s.target.composing || (i.text = s.target.value);
      }
    }
  }), i.checkmark === "inside" ? t("span", {
    class: [i.validData ? i.$style.inside1 : i.$style.inside, i.$style.validity]
  }) : i._e()]), i.checkmark == "outside" ? t("span", {
    class: [i.validData ? i.$style.outside1 : i.$style.outside, i.$style.validity]
  }) : i._e()]), i.error ? t("div", [t("span", {
    class: i.$style.error_message
  }, [i._v(i._s(i.errorMessage))])]) : i._e()]);
}, DT = [];
const PT = "_container_1t5m0_1", TT = "_container_input_1t5m0_1", kT = "_base_input__icon_1t5m0_38", CT = "_base_input_icon_img_1t5m0_46", MT = "_base_input__icon_error_left_1t5m0_55", OT = "_base_input__icon_error_right_1t5m0_58", AT = "_validity_1t5m0_61", LT = "_inside_1t5m0_64", jT = "_inside1_1t5m0_69", ET = "_base_input_1t5m0_38", IT = "_caret_color_1t5m0_88", YT = "_base_input_error_1t5m0_97", RT = "_outside1_1t5m0_106", NT = "_outside_1t5m0_106", $T = "_error_1t5m0_116", FT = "_disable_1t5m0_123", BT = "_right_1t5m0_128", HT = "_left_1t5m0_131", zT = "_error_message_1t5m0_134", XT = {
  container: PT,
  container_input: TT,
  base_input__icon: kT,
  base_input_icon_img: CT,
  base_input__icon_error_left: MT,
  base_input__icon_error_right: OT,
  validity: AT,
  inside: LT,
  inside1: jT,
  base_input: ET,
  caret_color: IT,
  base_input_error: YT,
  outside1: RT,
  outside: NT,
  error: $T,
  disable: FT,
  right: BT,
  left: HT,
  error_message: zT
}, Dl = {};
Dl.$style = XT;
var VT = /* @__PURE__ */ te(
  wT,
  ST,
  DT,
  !1,
  UT,
  "2c66a39e",
  null,
  null
);
function UT(i) {
  for (let e in Dl)
    this[e] = Dl[e];
}
const lA = /* @__PURE__ */ function() {
  return VT.exports;
}(), WT = {
  name: "list-group",
  props: {
    list: {
      type: Array
    },
    setResult: Function,
    styleProps: {
      default: "",
      Type: String
    },
    itemId: {
      type: Boolean,
      default: () => !1
    },
    isSelected: {
      type: Boolean,
      default: () => !1
    }
  },
  computed: {
    selectedStyle() {
      return this.isSelected ? "assignedListItem" : "availableListItem";
    },
    listGroupClassComputed() {
      return `${this.$style[this.selectedStyle]}`;
    }
  },
  methods: {
    availableItem(i) {
      i.enable = !0, this.$nextTick(() => {
        this.setResult && this.setResult(i);
      });
    },
    selectedItem(i) {
      var t, s;
      let e = (t = this.list) == null ? void 0 : t[i];
      this.$nextTick(() => {
        this.setResult && this.setResult(e);
      }), (s = this.list) == null || s.splice(i, 1);
    }
  }
};
var GT = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    style: i.styleProps
  }, i._l(i.list, function(s, r) {
    return t("div", {
      key: r,
      class: i.$style.selected_item
    }, [i.itemId ? t("div", {
      class: i.listGroupClassComputed,
      attrs: {
        disabled: s.enable
      }
    }, [i._v(" " + i._s(s.id) + " ")]) : i._e(), t("div", {
      class: i.listGroupClassComputed,
      attrs: {
        disabled: s.enable
      }
    }, [i._v(" " + i._s(s.name) + " ")]), i.isSelected ? t("div", {
      class: i.$style.minus_item,
      on: {
        click: function(n) {
          return i.selectedItem(r);
        }
      }
    }, [t("svg", {
      class: i.$style.minus_item_default,
      attrs: {
        xmlns: "http://www.w3.org/2000/svg",
        width: "9.844",
        height: "1.641",
        viewBox: "0 0 9.844 1.641"
      }
    }, [t("g", {
      attrs: {
        id: "Group_8891",
        "data-name": "Group 8891",
        transform: "translate(0.861 -3.24)"
      }
    }, [t("rect", {
      attrs: {
        id: "Rectangle_10",
        "data-name": "Rectangle 10",
        width: "1.641",
        height: "9.843",
        transform: "translate(8.982 3.24) rotate(90)",
        fill: "#ddd"
      }
    }), t("rect", {
      attrs: {
        id: "Rectangle_11",
        "data-name": "Rectangle 11",
        width: "1.641",
        height: "9.843",
        transform: "translate(-0.861 4.88) rotate(-90)",
        fill: "#ddd"
      }
    })])]), t("svg", {
      class: i.$style.minus_item_hover,
      attrs: {
        xmlns: "http://www.w3.org/2000/svg",
        width: "9.844",
        height: "1.641",
        viewBox: "0 0 9.844 1.641"
      }
    }, [t("g", {
      attrs: {
        id: "Group_8891",
        "data-name": "Group 8891",
        transform: "translate(0.861 -3.24)"
      }
    }, [t("rect", {
      attrs: {
        id: "Rectangle_10",
        "data-name": "Rectangle 10",
        width: "1.641",
        height: "9.843",
        transform: "translate(8.982 3.24) rotate(90)",
        fill: "#3491ff"
      }
    }), t("rect", {
      attrs: {
        id: "Rectangle_11",
        "data-name": "Rectangle 11",
        width: "1.641",
        height: "9.843",
        transform: "translate(-0.861 4.88) rotate(-90)",
        fill: "#3491ff"
      }
    })])])]) : t("div", {
      class: i.$style.minus_item,
      attrs: {
        disabled: s.enable
      },
      on: {
        click: function(n) {
          return i.availableItem(s);
        }
      }
    }, [t("svg", {
      class: i.$style.minus_item_default,
      attrs: {
        xmlns: "http://www.w3.org/2000/svg",
        width: "9.843",
        height: "9.843",
        viewBox: "0 0 9.843 9.843"
      }
    }, [t("g", {
      attrs: {
        id: "Group_8883",
        "data-name": "Group 8883",
        transform: "translate(0.861 0.862)"
      }
    }, [t("rect", {
      attrs: {
        id: "Rectangle_10",
        "data-name": "Rectangle 10",
        width: "1.641",
        height: "9.843",
        transform: "translate(8.982 3.24) rotate(90)",
        fill: "#9d9d9d"
      }
    }), t("rect", {
      attrs: {
        id: "Rectangle_11",
        "data-name": "Rectangle 11",
        width: "1.641",
        height: "9.843",
        transform: "translate(4.881 8.982) rotate(180)",
        fill: "#9d9d9d"
      }
    })])]), t("svg", {
      class: i.$style.minus_item_hover,
      attrs: {
        xmlns: "http://www.w3.org/2000/svg",
        width: "9.843",
        height: "9.843",
        viewBox: "0 0 9.843 9.843"
      }
    }, [t("g", {
      attrs: {
        id: "Group_8883",
        "data-name": "Group 8883",
        transform: "translate(0.861 0.862)"
      }
    }, [t("rect", {
      attrs: {
        id: "Rectangle_10",
        "data-name": "Rectangle 10",
        width: "1.641",
        height: "9.843",
        transform: "translate(8.982 3.24) rotate(90)",
        fill: "#3491ff"
      }
    }), t("rect", {
      attrs: {
        id: "Rectangle_11",
        "data-name": "Rectangle 11",
        width: "1.641",
        height: "9.843",
        transform: "translate(4.881 8.982) rotate(180)",
        fill: "#3491ff"
      }
    })])])])]);
  }), 0);
}, ZT = [];
const KT = "_selected_item_xjqhp_17", QT = "_drag_icon_xjqhp_34", qT = "_assignedListItem_xjqhp_38", JT = "_availableListItem_xjqhp_54", ek = "_minus_item_xjqhp_73", tk = "_minus_item_default_xjqhp_90", ik = "_minus_item_hover_xjqhp_93", sk = "_primary_active_switch_xjqhp_1", rk = {
  selected_item: KT,
  drag_icon: QT,
  assignedListItem: qT,
  availableListItem: JT,
  minus_item: ek,
  minus_item_default: tk,
  minus_item_hover: ik,
  primary_active_switch: sk
}, Pl = {};
Pl.$style = rk;
var nk = /* @__PURE__ */ te(
  WT,
  GT,
  ZT,
  !1,
  ak,
  null,
  null,
  null
);
function ak(i) {
  for (let e in Pl)
    this[e] = Pl[e];
}
const uA = /* @__PURE__ */ function() {
  return nk.exports;
}(), ok = {
  props: {
    list: Array,
    removeListItem: Function,
    // responsible for remove item
    addListItem: Function
    // responsible for add item
  }
}, lk = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjUiIGhlaWdodD0iMjUiIHZpZXdCb3g9IjAgMCAyNSAyNSIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4NCiAgICA8cmVjdCB3aWR0aD0iMjUiIGhlaWdodD0iMjUiIHJ4PSIzIiBmaWxsPSIjRDlEOUQ5Ii8+DQogICAgPHBhdGggZD0iTTE3LjU1NiA3LjcwOEgxNC45TDE0LjY5NCA3LjI5NEMxNC42NDk5IDcuMjA1NTUgMTQuNTgyIDcuMTMxMTcgMTQuNDk3OSA3LjA3OTIzQzE0LjQxMzggNy4wMjcyOSAxNC4zMTY4IDYuOTk5ODUgMTQuMjE4IDdIMTEuNjlDMTEuNTkxNSA2Ljk5OTcxIDExLjQ5NDkgNy4wMjcxMyAxMS40MTEzIDcuMDc5MTFDMTEuMzI3NyA3LjEzMTEgMTEuMjYwMyA3LjIwNTU3IDExLjIxNyA3LjI5NEwxMS4wMDggNy43MDhIOC4zNTRDOC4yNjAxMSA3LjcwOCA4LjE3MDA3IDcuNzQ1MyA4LjEwMzY4IDcuODExNjlDOC4wMzczIDcuODc4MDcgOCA3Ljk2ODEyIDggOC4wNjJWOC43N0M4IDguODYzODkgOC4wMzczIDguOTUzOTMgOC4xMDM2OCA5LjAyMDMyQzguMTcwMDcgOS4wODY3MSA4LjI2MDExIDkuMTI0IDguMzU0IDkuMTI0SDE3LjU1NEMxNy42MDA3IDkuMTI0MjcgMTcuNjQ2OSA5LjExNTMgMTcuNjkwMSA5LjA5NzYzQzE3LjczMzMgOS4wNzk5NiAxNy43NzI1IDkuMDUzOTMgMTcuODA1NiA5LjAyMTAzQzE3LjgzODcgOC45ODgxMyAxNy44NjQ5IDguOTQ5MDIgMTcuODgyOSA4LjkwNTk0QzE3LjkwMDggOC44NjI4NiAxNy45MSA4LjgxNjY2IDE3LjkxIDguNzdWOC4wNjJDMTcuOTEgOC4wMTU1MSAxNy45MDA4IDcuOTY5NDggMTcuODgzMSA3LjkyNjUzQzE3Ljg2NTMgNy44ODM1OCAxNy44MzkyIDcuODQ0NTYgMTcuODA2MyA3LjgxMTY5QzE3Ljc3MzQgNy43Nzg4MSAxNy43MzQ0IDcuNzUyNzQgMTcuNjkxNSA3LjczNDk1QzE3LjY0ODUgNy43MTcxNiAxNy42MDI1IDcuNzA4IDE3LjU1NiA3LjcwOFY3LjcwOFpNOS4xNzcgMTcuMzNDOS4xOTI4MSAxNy42MDA0IDkuMzExMzggMTcuODU0NiA5LjUwODQyIDE4LjA0MDVDOS43MDU0NyAxOC4yMjY0IDkuOTY2MTEgMTguMzMgMTAuMjM3IDE4LjMzSDE1LjY3NEMxNS45NDQ5IDE4LjMzIDE2LjIwNTUgMTguMjI2NCAxNi40MDI2IDE4LjA0MDVDMTYuNTk5NiAxNy44NTQ2IDE2LjcxODIgMTcuNjAwNCAxNi43MzQgMTcuMzNMMTcuMjAzIDkuODNIOC43MDhMOS4xNzcgMTcuMzNaIiBmaWxsPSIjNTk1OTU5Ii8+DQo8L3N2Zz4NCg==";
var uk = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    class: i.$style.main
  }, [i._l(i.list, function(s, r) {
    return t("div", {
      key: `detailInput-${r}`,
      class: i.$style["form-inline"]
    }, [t("input", {
      directives: [{
        name: "model",
        rawName: "v-model",
        value: s.description,
        expression: "input.description"
      }],
      class: i.$style["custom-input"],
      attrs: {
        type: "text",
        id: `item-${r}`
      },
      domProps: {
        value: s.description
      },
      on: {
        input: function(n) {
          n.target.composing || i.$set(s, "description", n.target.value);
        }
      }
    }), i.list.length > 1 ? t("span", {
      class: i.$style["remove-item"],
      on: {
        click: function(n) {
          return i.removeListItem(r, i.list);
        }
      }
    }, [t("img", {
      class: i.$style["trash-custom-icon"],
      attrs: {
        src: lk,
        alt: "closeIcon"
      }
    })]) : i._e()]);
  }), t("div", {
    class: i.$style["add-items"]
  }, [t("span", {
    class: i.$style["add-more-item"],
    staticStyle: {
      cursor: "pointer"
    },
    on: {
      click: function(s) {
        return i.addListItem(i.list);
      }
    }
  }, [i._v(" + Add more ")])])], 2);
}, hk = [];
const ck = "_main_9uoce_1", dk = {
  main: ck,
  "form-inline": "_form-inline_9uoce_4",
  "remove-item": "_remove-item_9uoce_13",
  "trash-custom-icon": "_trash-custom-icon_9uoce_16",
  "custom-input": "_custom-input_9uoce_28",
  "add-items": "_add-items_9uoce_56",
  "add-more-item": "_add-more-item_9uoce_56"
}, Tl = {};
Tl.$style = dk;
var fk = /* @__PURE__ */ te(
  ok,
  uk,
  hk,
  !1,
  pk,
  "0a0cdad6",
  null,
  null
);
function pk(i) {
  for (let e in Tl)
    this[e] = Tl[e];
}
const hA = /* @__PURE__ */ function() {
  return fk.exports;
}(), gk = {
  props: {
    styleProps: {
      type: String,
      default: ""
    },
    modalType: {
      type: String
    },
    headingText: {
      type: String,
      default: "Header"
    },
    subHeadingText: {
      type: String
    },
    modalHandler: Function,
    isOpened: Boolean
  },
  data() {
    return {
      hide: !this.isOpened
    };
  },
  methods: {
    handleModal() {
      var i;
      this.hide = !this.hide, (i = this.modalHandler) == null || i.call(this);
    }
  },
  mounted() {
    document.body.style.cssText = "height: 100vh; overflow: hidden;";
  },
  unmounted() {
    document.body.style.cssText = "";
  },
  computed: {
    modalPositionComputed() {
      return this.modalType === "slide-in" ? "right" : "center";
    },
    modalSubHeaderComputed() {
      return this.subHeadingText ?? "";
    },
    modalClassComputed() {
      return `modal-default ${this.modalSubHeaderComputed} ${this.modalType ?? ""} `;
    },
    modalTransitionComputed() {
      return this.modalType === "slide-in" ? "slide-fade" : "fade";
    }
  }
}, _k = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTQiIGhlaWdodD0iMTQiIHZpZXdCb3g9IjAgMCAxNCAxNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4NCiAgICA8cGF0aCBkPSJNMTQgMS40MUwxMi41OSAwTDcgNS41OUwxLjQxIDBMMCAxLjQxTDUuNTkgN0wwIDEyLjU5TDEuNDEgMTRMNyA4LjQxTDEyLjU5IDE0TDE0IDEyLjU5TDguNDEgN0wxNCAxLjQxWiIgZmlsbD0iIzRCNEI0QiIvPg0KICAgIDwvc3ZnPg0KICAgIA==";
var mk = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("transition", {
    attrs: {
      name: "bg"
    }
  }, [i.isOpened ? t("div", {
    staticClass: "emdn-modal-wrapper"
  }, [t("div", {
    staticClass: "modal-background",
    class: i.modalPositionComputed,
    on: {
      click: i.handleModal
    }
  }, [t("transition", {
    attrs: {
      name: i.modalTransitionComputed
    }
  }, [i.isOpened ? t("div", {
    class: i.modalClassComputed,
    style: i.styleProps,
    on: {
      click: function(s) {
        s.stopPropagation();
      }
    }
  }, [t("section", [t("div", {
    staticClass: "modal-header-line"
  }), t("div", {
    staticClass: "modal-header-contents"
  }, [t("div", {
    staticClass: "modal-header-contents-left"
  }, [t("h1", [i._v(i._s(i.headingText))]), i._t("switch-tab")], 2), t("button", {
    attrs: {
      type: "button"
    },
    on: {
      click: i.handleModal
    }
  }, [t("img", {
    attrs: {
      src: _k
    }
  })])]), i.subHeadingText ? t("div", {
    staticClass: "modal-sub-header"
  }, [t("h2", [i._v(i._s(i.subHeadingText))])]) : i._e()]), t("section", {
    staticClass: "modal-body-area"
  }, [t("div", [i._t("body")], 2)]), t("section", {
    staticClass: "modal-footer-area"
  }, [i._t("footer")], 2)]) : i._e()])], 1)]) : i._e()]);
}, bk = [];
const Sh = {};
var yk = /* @__PURE__ */ te(
  gk,
  mk,
  bk,
  !1,
  vk,
  "e2361e66",
  null,
  null
);
function vk(i) {
  for (let e in Sh)
    this[e] = Sh[e];
}
const cA = /* @__PURE__ */ function() {
  return yk.exports;
}(), xk = {
  props: {
    head: String,
    body: String,
    range: Number,
    step: Number,
    multipleSteps: Boolean,
    clickHandler: Function,
    handleClose: Function,
    styleProp: Object,
    active: Boolean
  },
  components: {
    CtaButton: Qr
  },
  methods: {
    applyHandlerMethod() {
      this.$nextTick(() => {
        this.clickHandler && this.clickHandler();
      }), this.step == this.range && this.close();
    },
    close() {
      this.handleClose();
    }
  }
}, Dh = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTQiIGhlaWdodD0iMTQiIHZpZXdCb3g9IjAgMCAxNCAxNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4NCiAgICA8cGF0aCBkPSJNMTQgMS40MUwxMi41OSAwTDcgNS41OUwxLjQxIDBMMCAxLjQxTDUuNTkgN0wwIDEyLjU5TDEuNDEgMTRMNyA4LjQxTDEyLjU5IDE0TDE0IDEyLjU5TDguNDEgN0wxNCAxLjQxWiIgZmlsbD0iI0YwRjFGMyIvPg0KPC9zdmc+DQo=";
var wk = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return i.active ? t("div", {
    class: i.$style.tooltipMain
  }, [t("div", {
    class: i.$style.tooltip
  }, [i.multipleSteps ? t("span", {
    class: [i.step <= 1 ? i.$style.stepOne : "", i.step == 2 ? i.$style.stepTwo : "", i.step == 3 ? i.$style.stepThree : "", i.step == 4 ? i.$style.stepFour : "", i.step > 4 ? i.$style.stepOne : ""],
    style: i.styleProp
  }, [t("div", {
    class: i.$style.main
  }, [t("div", {
    class: i.$style.customTitle
  }, [t("div", {
    class: i.$style.head
  }, [i._v(i._s(i.head))]), t("div", {
    class: i.$style.crossImage,
    on: {
      click: i.close
    }
  }, [t("img", {
    attrs: {
      src: Dh,
      alt: "icon"
    }
  })])]), t("div", {
    class: i.$style.body
  }, [i._t("body")], 2), i.range >= 2 && i.range >= i.step && i.step >= 1 ? t("div", {
    staticStyle: {
      display: "flex"
    }
  }, [t("div", {
    class: i.$style.step
  }, [i._v("Step " + i._s(i.step) + " of " + i._s(i.range))]), t("div", {
    class: i.$style.button
  }, [t("CtaButton", {
    staticClass: "btn-custom btn-custom-primary animationPrimary",
    staticStyle: {
      background: "#ffffff"
    },
    attrs: {
      type: "link",
      "color-type": "blue",
      "click-handler": i.applyHandlerMethod
    }
  }, [i.step != i.range ? t("span", [i._v("Next")]) : t("span", [i._v("Done")])])], 1)]) : i._e()])]) : i._e(), i.multipleSteps == !1 ? t("span", {
    class: i.$style.stepOne,
    style: i.styleProp
  }, [t("div", {
    class: i.$style.main
  }, [t("div", {
    class: i.$style.customTitle
  }, [t("div", {
    class: i.$style.head
  }, [i._v(i._s(i.head))]), t("div", {
    class: i.$style.crossImage,
    on: {
      click: i.close
    }
  }, [t("img", {
    attrs: {
      src: Dh
    }
  })])]), t("div", {
    class: i.$style.body
  }, [i._t("body")], 2)])]) : i._e()])]) : i._e();
}, Sk = [];
const Dk = "_tooltipMain_qr8l8_1", Pk = "_tooltip_qr8l8_1", Tk = "_main_qr8l8_18", kk = "_customTitle_qr8l8_21", Ck = "_head_qr8l8_24", Mk = "_crossImage_qr8l8_31", Ok = "_body_qr8l8_36", Ak = "_step_qr8l8_44", Lk = "_button_qr8l8_50", jk = "_stepOne_qr8l8_55", Ek = "_stepTwo_qr8l8_65", Ik = "_stepThree_qr8l8_87", Yk = "_stepFour_qr8l8_106", Rk = {
  tooltipMain: Dk,
  tooltip: Pk,
  main: Tk,
  customTitle: kk,
  head: Ck,
  crossImage: Mk,
  body: Ok,
  step: Ak,
  button: Lk,
  stepOne: jk,
  stepTwo: Ek,
  stepThree: Ik,
  stepFour: Yk
}, kl = {};
kl.$style = Rk;
var Nk = /* @__PURE__ */ te(
  xk,
  wk,
  Sk,
  !1,
  $k,
  "1fe46990",
  null,
  null
);
function $k(i) {
  for (let e in kl)
    this[e] = kl[e];
}
const dA = /* @__PURE__ */ function() {
  return Nk.exports;
}(), Fk = {
  props: {
    src: {
      type: String,
      default: ""
    },
    styleData: {
      type: String,
      default: ""
    },
    preview: Boolean
  },
  methods: {
    chooseImage() {
      this.$refs.fileInput.click();
    },
    onSelectFile() {
      const e = this.$refs.fileInput.files;
      if (e && e[0]) {
        const t = new FileReader();
        t.onload = (s) => {
          this.src = s.target.result;
        }, t.readAsDataURL(e[0]), this.$emit("input", e[0]);
      }
    }
  }
}, Bk = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTQ2IiBoZWlnaHQ9IjExMiIgdmlld0JveD0iMCAwIDE0NiAxMTIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+DQo8cmVjdCB3aWR0aD0iMTQ2IiBoZWlnaHQ9IjExMiIgcng9IjEwIiBmaWxsPSIjQzRDNEM0Ii8+DQo8cGF0aCBkPSJNMTM2IDlIOVY3NS41TDQyLjM3OTggMzUuMzU5N0M0NS41NjgyIDMxLjUyNTUgNTEuNDQ5MiAzMS41MTEgNTQuNjU2NiAzNS4zMjkyTDkwLjUgNzhMMTA3LjU5NyA2MC4xNDMyQzExMC42MDEgNTcuMDA1MSAxMTUuNTYxIDU2LjgzODUgMTE4Ljc3IDU5Ljc2NzlMMTM2IDc1LjVWOVoiIGZpbGw9IiNGMEYxRjMiLz4NCjxjaXJjbGUgY3g9IjExMCIgY3k9IjMxIiByPSIxMyIgZmlsbD0iI0M0QzRDNCIvPg0KPC9zdmc+DQo=";
var Hk = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    style: i.styleData
  }, [t("div", {
    class: i.preview ? i.$style.main_image : i.$style.slider_image,
    style: {
      "background-image": `url(${i.src})`
    },
    attrs: {
      tabindex: "0"
    }
  }, [i.src ? i._e() : t("span", {
    class: i.$style.placeholder
  }, [t("div", {
    class: i.$style.imagesSpacing
  }, [t("img", {
    attrs: {
      src: Bk,
      alt: ""
    }
  })])])])]);
}, zk = [];
const Xk = "_main_image_1tnor_1", Vk = "_slider_image_1tnor_11", Uk = "_placeholder_1tnor_28", Wk = "_imagesSpacing_1tnor_39", Gk = {
  main_image: Xk,
  slider_image: Vk,
  placeholder: Uk,
  imagesSpacing: Wk
}, Cl = {};
Cl.$style = Gk;
var Zk = /* @__PURE__ */ te(
  Fk,
  Hk,
  zk,
  !1,
  Kk,
  null,
  null,
  null
);
function Kk(i) {
  for (let e in Cl)
    this[e] = Cl[e];
}
const tf = /* @__PURE__ */ function() {
  return Zk.exports;
}(), Qk = {
  components: {
    ImageViewer: tf
  },
  props: {
    slides: Array,
    SelectedImage: Function,
    preview: Boolean,
    numberOfSlides: Number
  },
  data() {
    return {
      current: 0,
      direction: 1,
      transitionName: "fade",
      show: !1,
      chunkSize: this.numberOfSlides,
      data: this.slides
    };
  },
  methods: {
    slide(i) {
      this.direction = i, i === 1 ? this.transitionName = "slide_next" : this.transitionName = "slide_prev";
      var e = this.data.length;
      this.current = (this.current + i % e + e) % e;
    },
    handleChunk() {
      var i = [];
      for (let e = 0; e < this.data.length; e += this.chunkSize) {
        const t = this.data.slice(e, e + this.chunkSize);
        i = [...i, t];
      }
      this.data = i;
    }
  },
  watch: {
    slides(i) {
      var e = [];
      for (let t = 0; t < i.length; t += this.chunkSize) {
        const s = i.slice(t, t + this.chunkSize);
        e = [...e, s];
      }
      this.data = e;
    }
  },
  beforeMount() {
    this.handleChunk();
  },
  mounted() {
    this.show = !0;
  }
};
var qk = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", [t("div", {
    attrs: {
      id: i.$style.slider
    }
  }, [t("transition-group", {
    class: i.$style.slides_group,
    attrs: {
      tag: "div",
      name: i.transitionName,
      "enter-class": i.$style[`${i.transitionName}_enter`],
      "enter-active-class": i.$style[`${i.transitionName}_enter_active`],
      "leave-active-class": i.$style[`${i.transitionName}_leave_active`],
      "leave-to-class": i.$style[`${i.transitionName}_leave_to`]
    }
  }, [i.show ? t("div", {
    key: i.current,
    class: i.$style.slide
  }, i._l(i.data[i.current], function(s, r) {
    return t("div", {
      key: r,
      class: i.$style.slider_body,
      attrs: {
        id: "slide1"
      }
    }, [t("div", {
      on: {
        click: function() {
          return i.SelectedImage(s);
        }
      }
    }, [t("ImageViewer", {
      class: i.$style.slider_content,
      attrs: {
        preview: i.preview,
        src: s
      }
    })], 1)]);
  }), 0) : i._e()]), t("div", {
    class: [i.$style.btn, i.$style.btn_prev],
    attrs: {
      "aria-label": "Previous slide"
    },
    on: {
      click: function(s) {
        return i.slide(-1);
      }
    }
  }, [t("div", {
    class: i.$style.button_left
  })]), t("div", {
    class: [i.$style.btn, i.$style.btn_next],
    attrs: {
      "aria-label": "Next slide"
    },
    on: {
      click: function(s) {
        return i.slide(1);
      }
    }
  }, [t("div", {
    class: i.$style.button_right
  })])], 1)]);
}, Jk = [];
const eC = "_slider_4xxlz_53", tC = "_slides_group_4xxlz_11", iC = "_fade_enter_active_4xxlz_18", sC = "_fade_enter_4xxlz_18", rC = "_slide_next_enter_active_4xxlz_24", nC = "_slide_next_leave_active_4xxlz_25", aC = "_slide_next_enter_4xxlz_24", oC = "_slide_next_leave_to_4xxlz_31", lC = "_slide_prev_enter_active_4xxlz_34", uC = "_slide_prev_leave_active_4xxlz_35", hC = "_slide_prev_enter_4xxlz_34", cC = "_slide_prev_leave_to_4xxlz_41", dC = "_slide_4xxlz_11", fC = "_slider_body_4xxlz_53", pC = "_slider_content_4xxlz_61", gC = "_btn_4xxlz_71", _C = "_btn_next_4xxlz_87", mC = "_button_right_4xxlz_91", bC = "_button_left_4xxlz_96", yC = {
  slider: eC,
  slides_group: tC,
  fade_enter_active: iC,
  fade_enter: sC,
  slide_next_enter_active: rC,
  slide_next_leave_active: nC,
  slide_next_enter: aC,
  slide_next_leave_to: oC,
  slide_prev_enter_active: lC,
  slide_prev_leave_active: uC,
  slide_prev_enter: hC,
  slide_prev_leave_to: cC,
  slide: dC,
  slider_body: fC,
  slider_content: pC,
  btn: gC,
  btn_next: _C,
  button_right: mC,
  button_left: bC
}, Ml = {};
Ml.$style = yC;
var vC = /* @__PURE__ */ te(
  Qk,
  qk,
  Jk,
  !1,
  xC,
  null,
  null,
  null
);
function xC(i) {
  for (let e in Ml)
    this[e] = Ml[e];
}
const wC = /* @__PURE__ */ function() {
  return vC.exports;
}(), SC = {
  components: {
    ImageViewer: tf,
    Slider: wC
  },
  props: {
    src: {
      type: String,
      default: ""
    },
    allSlides: {
      type: Array
    },
    showImageViewer: {
      type: Boolean
    },
    showSlider: {
      type: Boolean
    },
    numberOfSlides: {
      type: Number,
      default: 4
    },
    styleProps: {
      type: String,
      default: "width: 331px; height: 230px"
    }
  },
  computed: {},
  data() {
    return {
      selectedImage: ""
    };
  },
  methods: {
    handleImage(i) {
      this.selectedImage = i;
    }
  }
};
var DC = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", [i.showImageViewer ? t("ImageViewer", {
    attrs: {
      preview: !0,
      styleData: i.styleProps,
      src: i.src ? i.src : i.selectedImage
    }
  }) : i._e(), i.showSlider ? t("Slider", {
    style: {
      width: i.showImageViewer ? "" : "331px"
    },
    attrs: {
      numberOfSlides: i.numberOfSlides,
      preview: !1,
      slides: i.allSlides,
      "selected-image": i.handleImage
    }
  }) : i._e()], 1);
}, PC = [];
const Ph = {};
var TC = /* @__PURE__ */ te(
  SC,
  DC,
  PC,
  !1,
  kC,
  null,
  null,
  null
);
function kC(i) {
  for (let e in Ph)
    this[e] = Ph[e];
}
const fA = /* @__PURE__ */ function() {
  return TC.exports;
}(), CC = {
  props: {
    snackBarTitle: String,
    snackBarMessage: String
  },
  data() {
    return {
      active: !1
    };
  },
  mounted() {
    this.active = !0, setTimeout(() => {
      this.active = !1;
    }, 6e3);
  },
  watch: {
    active(i) {
      i && window.addEventListener("click", this.onClose);
    }
  },
  methods: {
    onClose() {
      this.active = !1;
    }
  }
}, MC = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI4IiBoZWlnaHQ9IjgiIHZpZXdCb3g9IjAgMCA4IDgiPg0KICA8cGF0aCBpZD0iUGF0aF8xOTU1IiBkYXRhLW5hbWU9IlBhdGggMTk1NSIgZD0iTTQuNzA4LDQsNy44NTMuODU1QS41LjUsMCwwLDAsNy4xNDYuMTQ4TDQsMy4yOTMuODU0LjE0OEEuNS41LDAsMCwwLC4xNDcuODU1TDMuMjkzLDQsLjE0Nyw3LjE0N2EuNS41LDAsMSwwLC43MDcuNzA3TDQsNC43MDgsNy4xNDYsNy44NTRhLjUuNSwwLDEsMCwuNzA3LS43MDdaIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwIC0wLjAwMSkiLz4NCjwvc3ZnPg0K";
var OC = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return i.active ? t("div", {
    class: i.$style.dialogbox
  }, [t("div", {
    class: i.$style.heading
  }, [i._v(i._s(i.snackBarTitle))]), t("p", [i._v(i._s(i.snackBarMessage))]), t("div", {
    class: i.$style.close,
    on: {
      click: i.onClose
    }
  }, [t("img", {
    attrs: {
      width: "11px",
      height: "11px",
      src: MC,
      alt: "cross icon"
    }
  })])]) : i._e();
}, AC = [];
const LC = "_customClose_1eguf_41", jC = "_fadein_1eguf_1", EC = "_fadeout_1eguf_1", IC = "_dialogbox_1eguf_46", YC = "_close_1eguf_60", RC = "_heading_1eguf_65", NC = {
  customClose: LC,
  fadein: jC,
  fadeout: EC,
  dialogbox: IC,
  close: YC,
  heading: RC
}, Ol = {};
Ol.$style = NC;
var $C = /* @__PURE__ */ te(
  CC,
  OC,
  AC,
  !1,
  FC,
  "a68fe790",
  null,
  null
);
function FC(i) {
  for (let e in Ol)
    this[e] = Ol[e];
}
const pA = /* @__PURE__ */ function() {
  return $C.exports;
}(), BC = {
  name: "tab-ui",
  props: {
    tabButtons: Array,
    clickHandler: Function,
    tabType: String,
    tabStyle: {
      type: String,
      default: ""
    }
  },
  computed: {
    buttonClassStyle() {
      return `${this.$style.default} ${this.$style[this.tabStyle]} ${this.$style[this.tabType]} ${this.$style.center}`;
    },
    ButtonComputedTabStyle() {
      return `${this.$style[this.computedTabStyle]}`;
    },
    computedTabStyle() {
      return `${this.tabStyle}-style-${this.tabType}`;
    }
  },
  data() {
    return {
      hover: !1
    };
  },
  methods: {
    executor(i) {
      this.tabButtons.forEach((e) => {
        e.active = !1;
      }), i.active = !0, this.clickHandler && this.clickHandler(i), this.$emit("tab-buttons-emit", this.tabButtons), this.$forceUpdate();
    }
  }
};
var HC = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    class: i.$style.parent
  }, [t("div", {
    class: i.ButtonComputedTabStyle
  }, i._l(i.tabButtons, function(s, r) {
    return t("div", {
      key: r,
      class: [i.buttonClassStyle, r === 0 && i.tabType === "secondary-tab" && i.tabStyle === "horizontal" ? i.$style.horizontal_secondary_first_tab : r === i.tabButtons.length - 1 && i.tabType === "secondary-tab" && i.tabStyle === "horizontal" ? i.$style.horizontal_secondary_last_tab : ""],
      attrs: {
        active: s.active
      },
      on: {
        click: function(n) {
          return i.executor(s);
        }
      }
    }, [i._v(" " + i._s(s.title) + " ")]);
  }), 0)]);
}, zC = [];
const XC = "_parent_xglzj_7", VC = "_center_xglzj_27", UC = "_horizontal_secondary_last_tab_xglzj_60", WC = "_horizontal_secondary_first_tab_xglzj_63", GC = {
  default: "_default_xglzj_7",
  parent: XC,
  "vertical-style-secondary-tab": "_vertical-style-secondary-tab_xglzj_7",
  "horizontal-style-secondary-tab": "_horizontal-style-secondary-tab_xglzj_7",
  center: VC,
  "secondary-tab": "_secondary-tab_xglzj_33",
  "blue-border-show": "_blue-border-show_xglzj_1",
  horizontal_secondary_last_tab: UC,
  horizontal_secondary_first_tab: WC,
  "default-vertical": "_default-vertical_xglzj_67",
  "horizontal-style-primary-tab": "_horizontal-style-primary-tab_xglzj_67",
  "vertical-style-primary-tab": "_vertical-style-primary-tab_xglzj_67",
  "primary-tab": "_primary-tab_xglzj_93"
}, Al = {};
Al.$style = GC;
var ZC = /* @__PURE__ */ te(
  BC,
  HC,
  zC,
  !1,
  KC,
  "007e6874",
  null,
  null
);
function KC(i) {
  for (let e in Al)
    this[e] = Al[e];
}
const gA = /* @__PURE__ */ function() {
  return ZC.exports;
}(), QC = {
  name: "tab-module",
  props: {
    tabButtons: Array,
    styleProps: {
      type: String,
      default: ""
    },
    clickHandler: Function,
    tabStyle: {
      type: String,
      default: ""
    },
    tabType: String
  },
  computed: {
    buttonClassComputed() {
      return `${this.$style[this.tabType]}`;
    },
    computedClassTabStyle() {
      return `${this.$style[this.computedTabStyle]}`;
    },
    computedTabStyle() {
      return `${this.tabStyle}-style-icon-tab`;
    }
  },
  data() {
    return {
      hover: !1
    };
  },
  methods: {
    executor(i) {
      this.tabButtons.forEach((e) => {
        e.active = !1;
      }), i.active = !0, this.clickHandler && this.clickHandler(i), this.$forceUpdate();
    }
  }
};
var qC = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", [t("div", {
    class: i.computedClassTabStyle,
    staticStyle: {
      "flex-wrap": "wrap",
      width: "100%"
    }
  }, i._l(i.tabButtons, function(s, r) {
    return t("div", {
      key: r,
      class: i.buttonClassComputed,
      attrs: {
        active: s.active,
        id: s.title
      },
      on: {
        mouseover: function(n) {
          i.hover = !0;
        },
        mouseleave: function(n) {
          i.hover = !1;
        }
      }
    }, [t("div", {
      class: i.$style.custom_style,
      on: {
        click: function(n) {
          return i.executor(s);
        }
      }
    }, [t("div", {
      class: [s.active || i.hover === !0 ? i.$style.img_zone_hover_background : "", i.$style.img_zone],
      attrs: {
        active: s.active
      }
    }, [t("img", {
      class: [s.active ? i.$style.hover_icon : ""],
      attrs: {
        src: s.icon,
        alt: ""
      }
    })]), t("div", {
      class: i.$style.chart_title
    }, [i._v(" " + i._s(s.title) + " ")])])]);
  }), 0)]);
}, JC = [];
const eM = "_img_zone_ttnic_27", tM = "_img_zone_hover_background_ttnic_45", iM = "_chart_title_ttnic_53", sM = "_custom_style_ttnic_87", rM = "_hover_icon_ttnic_138", nM = {
  "primary-tab": "_primary-tab_ttnic_8",
  "horizontal-style-icon-tab": "_horizontal-style-icon-tab_ttnic_8",
  "vertical-style-icon-tab": "_vertical-style-icon-tab_ttnic_8",
  img_zone: eM,
  img_zone_hover_background: tM,
  "hover-icon": "_hover-icon_ttnic_48",
  chart_title: iM,
  custom_style: sM,
  "secondary-tab": "_secondary-tab_ttnic_94",
  hover_icon: rM
}, Ll = {};
Ll.$style = nM;
var aM = /* @__PURE__ */ te(
  QC,
  qC,
  JC,
  !1,
  oM,
  "0cddebd6",
  null,
  null
);
function oM(i) {
  for (let e in Ll)
    this[e] = Ll[e];
}
const _A = /* @__PURE__ */ function() {
  return aM.exports;
}(), lM = {
  name: "tab-number",
  props: {
    tabButtons: Array,
    styleProps: {
      type: String,
      default: ""
    },
    clickHandler: Function,
    tabStyle: {
      type: String,
      default: ""
    },
    // '', 'small'
    size: {
      type: String,
      default: ""
    }
  },
  computed: {
    TabNumberClassComputed() {
      return `${this.$style[this.computedTabStyle]}`;
    },
    computedTabStyle() {
      return `${this.tabStyle}-style-icon-tab`;
    }
  },
  data() {
    return {
      hover: !1
    };
  },
  methods: {
    executor(i) {
      this.tabButtons.forEach((e) => {
        e.active = !1;
      }), i.active = !0, this.clickHandler && this.clickHandler(i), this.$forceUpdate();
    }
  }
};
var uM = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", [t("div", {
    class: i.TabNumberClassComputed,
    staticStyle: {
      "flex-wrap": "wrap",
      width: "100%"
    }
  }, i._l(i.tabButtons, function(s, r) {
    return t("div", {
      key: r,
      class: [i.size === "small" ? i.$style.small : "", i.$style.chart_wrapper],
      attrs: {
        active: s.active,
        id: s.title
      },
      on: {
        mouseover: function(n) {
          i.hover = !0;
        },
        mouseleave: function(n) {
          i.hover = !1;
        }
      }
    }, [t("div", {
      on: {
        click: function(n) {
          return i.executor(s);
        }
      }
    }, [t("div", {
      class: [s.active || i.hover === !0 ? i.$style.img_zone_hover_background : "", i.$style.img_zone],
      attrs: {
        active: s.active
      }
    }, [t("img", {
      class: [s.active ? i.$style.hover_icon : ""],
      attrs: {
        src: s.icon,
        alt: ""
      }
    })]), t("div", {
      class: i.$style.chart_title
    }, [t("b", [i._v(i._s(s.itemRate) + "%")]), t("span", [i._v(i._s(s.title))])])])]);
  }), 0)]);
}, hM = [];
const cM = "_chart_wrapper_16wo6_7", dM = "_img_zone_16wo6_26", fM = "_active_16wo6_38", pM = "_hover_icon_16wo6_41", gM = "_img_zone_hover_background_16wo6_45", _M = "_small_16wo6_51", mM = "_chart_title_16wo6_62", bM = {
  chart_wrapper: cM,
  "horizontal-style-icon-tab": "_horizontal-style-icon-tab_16wo6_7",
  "vertical-style-icon-tab": "_vertical-style-icon-tab_16wo6_7",
  img_zone: dM,
  active: fM,
  hover_icon: pM,
  img_zone_hover_background: gM,
  small: _M,
  chart_title: mM
}, jl = {};
jl.$style = bM;
var yM = /* @__PURE__ */ te(
  lM,
  uM,
  hM,
  !1,
  vM,
  "c2cf3c4e",
  null,
  null
);
function vM(i) {
  for (let e in jl)
    this[e] = jl[e];
}
const mA = /* @__PURE__ */ function() {
  return yM.exports;
}(), xM = {
  name: "tab-overview",
  props: {
    position: {
      type: String,
      default: "top",
      validator(i) {
        return ["top", "bottom"].includes(i);
      }
    },
    labelAlign: {
      type: String,
      default: "top",
      validator(i) {
        return ["top", "bottom"].includes(i);
      }
    },
    isActive: Boolean,
    label: String,
    field: String,
    trend: [String, Number, Object],
    value: {
      type: [String, Number, Object],
      default: ""
    },
    valueFormatter: Function,
    trendFormatter: Function,
    clickHandler: Function
  },
  methods: {
    handleClick() {
      this.clickHandler && this.clickHandler();
    }
  },
  computed: {
    hasTrend() {
      return this.trend !== null;
    },
    isTrendPositive() {
      const i = We(this.trend) ? ro(this.trend) : this.trend;
      return this.hasTrend ? Number(i) >= 0 : !1;
    },
    formattedValue() {
      const i = We(this == null ? void 0 : this.value) ? ro(this == null ? void 0 : this.value) : this == null ? void 0 : this.value;
      return this.valueFormatter ? this.valueFormatter(i) : "";
    },
    formattedTrend() {
      const i = We(this.trend) ? ro(this.trend) : this.trend;
      return this.hasTrend && (this != null && this.trendFormatter) ? i >= 0 ? `+${this.trendFormatter(i)}` : `${this.trendFormatter(i)}` : "";
    }
  }
};
var wM = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    class: [i.$style.tab_overview, i.$style[i.position]],
    attrs: {
      active: i.isActive
    },
    on: {
      click: i.handleClick
    }
  }, [t("div", {
    class: i.$style.tab_lead
  }, [t("div", {
    class: i.$style.lead_label
  }, [i._v(" " + i._s(i.label) + " ")]), i.hasTrend ? t("div", {
    class: [i.$style.lead_trail, i.isTrendPositive ? i.$style.positive : ""]
  }, [i._v(" " + i._s(i.formattedTrend) + " ")]) : i._e()]), t("div", {
    class: i.$style.tab_divider
  }), t("div", {
    class: i.$style.tab_content
  }, [i._v(" " + i._s(i.formattedValue) + " ")])]);
}, SM = [];
const DM = "_tab_overview_divzu_7", PM = "_top_divzu_44", TM = "_tab_lead_divzu_55", kM = "_bottom_divzu_59", CM = "_lead_label_divzu_80", MM = "_lead_trail_divzu_88", OM = "_positive_divzu_96", AM = "_tab_divider_divzu_104", LM = "_tab_content_divzu_108", jM = {
  tab_overview: DM,
  top: PM,
  tab_lead: TM,
  bottom: kM,
  lead_label: CM,
  lead_trail: MM,
  positive: OM,
  tab_divider: AM,
  tab_content: LM
}, El = {};
El.$style = jM;
var EM = /* @__PURE__ */ te(
  xM,
  wM,
  SM,
  !1,
  IM,
  "496e840b",
  null,
  null
);
function IM(i) {
  for (let e in El)
    this[e] = El[e];
}
const bA = /* @__PURE__ */ function() {
  return EM.exports;
}(), YM = {
  name: "tab-icon",
  props: {
    tabButtons: Array,
    styleProps: {
      type: String,
      default: ""
    },
    clickHandler: Function,
    tabStyle: {
      type: String,
      default: ""
    },
    // '', 'small'
    size: {
      type: String,
      default: ""
    }
  },
  computed: {
    TabIconClassComputed() {
      return `${this.$style[this.computedTabStyle]}`;
    },
    computedTabStyle() {
      return `${this.tabStyle}-style-icon-tab`;
    }
  },
  data() {
    return {
      hover: !1
    };
  },
  methods: {
    executor(i) {
      this.tabButtons.forEach((e) => {
        e.active = !1;
      }), i.active = !0, this.clickHandler && this.clickHandler(i), this.$forceUpdate();
    }
  }
};
var RM = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", [t("div", {
    class: i.TabIconClassComputed,
    staticStyle: {
      "flex-wrap": "wrap",
      width: "100%"
    }
  }, i._l(i.tabButtons, function(s, r) {
    return t("div", {
      key: r,
      class: [i.size === "small" ? i.$style.small : "", i.$style.chart_wrapper],
      attrs: {
        active: s.active,
        id: s.title
      },
      on: {
        mouseover: function(n) {
          i.hover = !0;
        },
        mouseleave: function(n) {
          i.hover = !1;
        }
      }
    }, [t("div", {
      on: {
        click: function(n) {
          return i.executor(s);
        }
      }
    }, [t("div", {
      class: [s.active || i.hover === !0 ? i.$style.img_zone_hover_background : "", i.$style.img_zone],
      attrs: {
        active: s.active
      }
    }, [t("img", {
      class: [s.active ? i.$style.hover_icon : ""],
      attrs: {
        src: s.icon,
        alt: ""
      }
    })]), t("div", {
      class: i.$style.chart_title
    }, [t("b", [i._v(i._s(s.title))])])])]);
  }), 0)]);
}, NM = [];
const $M = "_chart_wrapper_16wo6_7", FM = "_img_zone_16wo6_26", BM = "_active_16wo6_38", HM = "_hover_icon_16wo6_41", zM = "_img_zone_hover_background_16wo6_45", XM = "_small_16wo6_51", VM = "_chart_title_16wo6_62", UM = {
  chart_wrapper: $M,
  "horizontal-style-icon-tab": "_horizontal-style-icon-tab_16wo6_7",
  "vertical-style-icon-tab": "_vertical-style-icon-tab_16wo6_7",
  img_zone: FM,
  active: BM,
  hover_icon: HM,
  img_zone_hover_background: zM,
  small: XM,
  chart_title: VM
}, Il = {};
Il.$style = UM;
var WM = /* @__PURE__ */ te(
  YM,
  RM,
  NM,
  !1,
  GM,
  "2c12bbac",
  null,
  null
);
function GM(i) {
  for (let e in Il)
    this[e] = Il[e];
}
const yA = /* @__PURE__ */ function() {
  return WM.exports;
}(), ZM = {
  name: "time-picker",
  props: {
    changeTime: Function,
    submitTime: Function,
    id: {
      type: String,
      default: () => ""
    },
    minTime: {
      type: String,
      default: () => "0000"
    },
    maxTime: {
      type: String,
      default: () => "0000"
    },
    selectedTime: {
      type: Object,
      default: () => ({
        hour: 0,
        minute: 0,
        isAddDay: !1
      })
    },
    disabled: Boolean,
    enableMinute: {
      type: Boolean,
      default: () => !1
    },
    isRange: {
      type: Boolean,
      default: () => !1
    }
  },
  data() {
    return {
      visible: !1,
      dayStart: ""
    };
  },
  watch: {
    visible(i) {
      i ? window.addEventListener("click", this.handleClickOutside) : window.removeEventListener("click", this.handleClickOutside);
    },
    isRange() {
      this.isRange && (this.EnableMinute = !1);
    },
    disabled() {
      this.disabled && (this.visible = !1);
    }
  },
  computed: {
    getTitle() {
      return `${this.selectedTime.hour > 9 ? this.selectedTime.hour : "0" + parseInt(this.selectedTime.hour)}:${this.selectedTime.minute > 9 ? this.selectedTime.minute : "0" + parseInt(this.selectedTime.minute)}`;
    },
    getTimeRange() {
      let i = {
        hour: this.minTime.substr(0, 2),
        minute: this.minTime.substr(2, 2)
      }, e = {
        hour: this.maxTime.substr(0, 2),
        minute: this.maxTime.substr(2, 2)
      };
      return {
        min: i,
        max: e
      };
    },
    getHourRange() {
      let i = this.getTimeRange;
      return i.min.hour == i.max.hour ? 24 : +i.min.hour < +i.max.hour ? +i.max.hour - +i.min.hour : 24;
    }
  },
  methods: {
    addDay(i, e) {
      let t = this.getTimeRange, s = this.getTimeTitle(i, e), r = parseInt(t.min.hour);
      return s < r;
    },
    handleClickOutside(i) {
      const e = this.$refs.timePicker;
      e === i.target || e != null && e.contains(i.target) || this.closeTimeDropdownStart();
    },
    closeTimeDropdownStart() {
      this.visible && this.submitTime && this.submitTime(), this.visible = !1;
    },
    checkSelectedHour(i) {
      let e = this.getTimeRange;
      return this.selectedTime.isAddDay ? i == +this.selectedTime.hour + 1 - +e.min.hour + 24 : i == +this.selectedTime.hour + 1 - +e.min.hour;
    },
    getTimeTitle(i, e) {
      let t = i, s = this.getTimeRange;
      return e == "hour" && (t = parseInt(s.min.hour) + i, t > 24 && (t -= 24)), `${t - 1 >= 10 ? t - 1 : "0" + (t - 1)}`;
    },
    checkEnableMinute(i) {
      let e = this.getTimeRange;
      return !(this.selectedTime.isAddDay && this.selectedTime.hour == e.max.hour && i > e.max.minute);
    },
    handleChangeTime(i, e) {
      let t = i;
      if (e == "hour") {
        let s = this.getTimeRange;
        t = t + parseInt(s.min.hour), this.selectedTime.hour = t, this.selectedTime.hour >= 24 ? (this.selectedTime.hour -= 24, this.selectedTime.isAddDay = !0) : this.selectedTime.isAddDay = !1;
      } else
        this.getTimeRange, this.selectedTime.minute = t;
      this.changeTime(this.selectedTime, e);
    }
  },
  mounted() {
    this.isRange && (this.EnableMinute = !1);
  }
};
var KM = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    class: i.$style.dropdown_container,
    attrs: {
      id: i.id
    }
  }, [t("a", {
    class: [i.$style.time_dropdown, i.$style.time_dropdown_btn],
    attrs: {
      href: "javascript:void(0)",
      active: i.visible,
      disabled: i.disabled
    },
    on: {
      click: function(s) {
        s.stopPropagation(), i.visible = !0;
      }
    }
  }, [t("span", {
    class: i.$style.span_height
  }, [i._v(i._s(i.getTitle))]), t("span", {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: i.selectedTime.isAddDay,
      expression: "selectedTime.isAddDay"
    }],
    class: i.$style.bonus_time
  }, [i._v(i._s("+1"))])]), t("div", {
    directives: [{
      name: "show",
      rawName: "v-show",
      value: i.visible,
      expression: "visible"
    }],
    class: [i.visible ? i.$style.show : "", i.$style.dropdown_menu],
    staticStyle: {
      left: "auto !important",
      width: "105px",
      transform: "translate(0px, 10px)",
      "overflow-y": "unset"
    }
  }, [t("div", {
    staticStyle: {
      display: "flex"
    }
  }, [t("div", {
    class: i.$style.hour_dropdown_col
  }, [t("ul", {
    class: i.$style.hour_dropdown
  }, i._l(i.getHourRange, function(s) {
    return t("li", {
      key: s,
      class: [i.checkSelectedHour(s) ? i.$style.selected_item : ""]
    }, [t("span", {
      class: i.$style.dropdown_item,
      attrs: {
        onmouseover: "this.style.color='black';",
        onmouseout: "this.style.color='black';"
      },
      on: {
        click: function(r) {
          return i.handleChangeTime(s - 1, "hour");
        }
      }
    }, [i._v(" " + i._s(i.getTimeTitle(s, "hour")) + " "), t("span", {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: i.isRange && i.addDay(s, "hour"),
        expression: "isRange && addDay(index, 'hour')"
      }],
      class: i.$style.day_plus
    }, [i._v(i._s("+1"))])])]);
  }), 0)]), t("div", {
    class: i.$style.hour_dropdown_col
  }, [t("ul", {
    class: i.$style.hour_dropdown
  }, i._l(i.enableMinute ? 60 : 1, function(s) {
    return t("li", {
      key: s,
      class: [s == +i.selectedTime.minute + 1 ? i.$style.selected_item : ""]
    }, [t("span", {
      class: [i.checkEnableMinute(s - 1) ? "" : i.$style.disable_item, i.$style.dropdown_item],
      attrs: {
        onmouseover: "this.style.color='black';",
        onmouseout: "this.style.color='black';"
      },
      on: {
        click: function(r) {
          return i.handleChangeTime(s - 1, "minute");
        }
      }
    }, [i._v(" " + i._s(i.getTimeTitle(s, "minute")) + " ")])]);
  }), 0)])])])]);
}, QM = [];
const qM = "_dropdown_container_4jkp7_1", JM = "_time_dropdown_4jkp7_4", eO = "_span_height_4jkp7_21", tO = "_bonus_time_4jkp7_26", iO = "_time_dropdown_btn_4jkp7_37", sO = "_dropdown_menu_4jkp7_66", rO = "_hour_dropdown_col_4jkp7_82", nO = "_hour_dropdown_4jkp7_82", aO = "_selected_item_4jkp7_104", oO = "_dropdown_item_4jkp7_107", lO = "_day_plus_4jkp7_117", uO = {
  dropdown_container: qM,
  time_dropdown: JM,
  span_height: eO,
  bonus_time: tO,
  time_dropdown_btn: iO,
  dropdown_menu: sO,
  hour_dropdown_col: rO,
  hour_dropdown: nO,
  selected_item: aO,
  dropdown_item: oO,
  day_plus: lO
}, Yl = {};
Yl.$style = uO;
var hO = /* @__PURE__ */ te(
  ZM,
  KM,
  QM,
  !1,
  cO,
  "4180949f",
  null,
  null
);
function cO(i) {
  for (let e in Yl)
    this[e] = Yl[e];
}
const vA = /* @__PURE__ */ function() {
  return hO.exports;
}(), dO = {
  name: "toggle-button",
  props: {
    toggle: Boolean,
    disabled: Boolean,
    size: {
      type: String,
      default: "default"
    },
    clickHandler: Function
  },
  data() {
    return {
      checked: this.toggle
    };
  },
  watch: {
    toggle(i) {
      this.checked = i;
    }
  },
  methods: {
    handleToggle() {
      if (this.clickHandler && !this.disabled)
        return this.clickHandler(), this.checked = !this.checked, this.checked;
    }
  }
};
var fO = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    class: i.$style.d_flex
  }, [t("p", {
    class: [i.checked ? i.$style.btn_off : i.$style.btn_on, i.disabled && i.$style.default_off]
  }, [i._v(" Off ")]), t("div", {
    on: {
      click: i.handleToggle
    }
  }, [t("input", {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: i.checked,
      expression: "checked"
    }],
    attrs: {
      type: "checkbox",
      disabled: i.disabled
    },
    domProps: {
      checked: Array.isArray(i.checked) ? i._i(i.checked, null) > -1 : i.checked
    },
    on: {
      change: function(s) {
        var r = i.checked, n = s.target, a = !!n.checked;
        if (Array.isArray(r)) {
          var o = null, l = i._i(r, o);
          n.checked ? l < 0 && (i.checked = r.concat([o])) : l > -1 && (i.checked = r.slice(0, l).concat(r.slice(l + 1)));
        } else
          i.checked = a;
      }
    }
  }), t("label", {
    class: [i.disabled ? i.$style.disable_label : "", i.size === "default" ? i.$style.default_size_label : i.$style.large_size_label]
  }, [i._v("Toggle")])]), t("p", {
    class: [i.checked ? i.$style.btn_on : i.$style.btn_off, i.disabled && i.$style.default_off]
  }, [i._v(" On ")])]);
}, pO = [];
const gO = "_d_flex_19yvh_1", _O = "_btn_off_19yvh_46", mO = "_btn_on_19yvh_52", bO = "_default_off_19yvh_58", yO = "_disable_label_19yvh_61", vO = "_default_size_label_19yvh_69", xO = "_large_size_label_19yvh_81", wO = {
  d_flex: gO,
  btn_off: _O,
  btn_on: mO,
  default_off: bO,
  disable_label: yO,
  default_size_label: vO,
  large_size_label: xO
}, Rl = {};
Rl.$style = wO;
var SO = /* @__PURE__ */ te(
  dO,
  fO,
  pO,
  !1,
  DO,
  "f32ab90a",
  null,
  null
);
function DO(i) {
  for (let e in Rl)
    this[e] = Rl[e];
}
const xA = /* @__PURE__ */ function() {
  return SO.exports;
}(), PO = {
  name: "listSearchBar",
  props: {
    searchHandler: Function,
    // returns search string
    titleName: {
      type: String,
      default: "title"
    },
    items: Array,
    // option list (title: name to be displayed in option list, image: option image) (ex: {title: 'option1', [image: imageUrl, ...]})
    // On close dropdown when you click outside
    clickHandler: Function,
    // Click handler (if using list click without using checkbox)
    styleProps: {
      // type: String as PropType<StyleValue>,
      // default: "" as StyleValue,
      type: String,
      default: ""
    },
    // Set whether dropdown-list wrap-style or not (ex: {top: '10px', left: '10px', width: '10px'})
    placeholder: String,
    // Set whether placeholder or not
    id: String
    // Set whether checkbox-id or not
  },
  // alice component
  components: {
    "search-bar": Va
  },
  data() {
    return {};
  },
  methods: {
    search(i) {
      var e;
      (e = this.searchHandler) == null || e.call(this, i);
    },
    truncateText(i, e) {
      return i.length <= e ? i : i.substring(0, e) + "...";
    },
    // Click on option. If there is a click handler, the click handler is executed, and if there is no click handler, the checklist is saved.
    optionClick(i) {
      var e;
      (e = this.items) == null || e.forEach((t) => {
        t.active = !1;
      }), this.$nextTick(() => {
        var t;
        i.active = !0, (t = this.clickHandler) == null || t.call(this, i);
      });
    }
  }
};
var TO = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return t("div", {
    class: i.$style.list_wrap,
    style: i.styleProps
  }, [t("search-bar", {
    attrs: {
      "placeholder-text": i.placeholder || "Search",
      "set-search-complete-keyword": i.search,
      "style-props": "width:100%; margin-bottom: 6px;"
    }
  }), i._l(i.items, function(s, r) {
    return t("div", {
      key: r,
      class: i.$style.list_item_style
    }, [t("div", {
      class: i.$style.list_item,
      attrs: {
        active: s.active
      },
      on: {
        click: function(n) {
          return i.optionClick(s);
        }
      }
    }, [t("label", [i._v(i._s(i.truncateText(s[i.titleName], 40)))]), s.isLow ? t("div", {
      class: i.$style.triangle
    }, [t("svg", {
      attrs: {
        width: "59",
        height: "17",
        viewBox: "0 0 59 17",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
      }
    }, [t("path", {
      attrs: {
        d: "M0 0V17H52.5129L59 0H0Z",
        fill: "#E34537"
      }
    })]), t("label", [i._v("Low Comp.")])]) : i._e()])]);
  })], 2);
}, kO = [];
const CO = "_list_wrap_1tkvl_7", MO = "_list_item_style_1tkvl_23", OO = "_list_item_1tkvl_23", AO = "_triangle_1tkvl_64", LO = {
  list_wrap: CO,
  list_item_style: MO,
  list_item: OO,
  triangle: AO
}, Nl = {};
Nl.$style = LO;
var jO = /* @__PURE__ */ te(
  PO,
  TO,
  kO,
  !1,
  EO,
  "7b350f12",
  null,
  null
);
function EO(i) {
  for (let e in Nl)
    this[e] = Nl[e];
}
const wA = /* @__PURE__ */ function() {
  return jO.exports;
}(), IO = {
  components: {
    "icon-button": Hd
  },
  props: {
    styleProps: String,
    // currentPge
    currentPage: {
      type: Number,
      default: 1
    },
    totalPage: {
      type: Number,
      default: 1
    },
    disabled: {
      type: Boolean,
      default: !1
    },
    previousClickHandler: Function,
    nextClickHandler: Function
  },
  data() {
    return {
      disableNext: !1,
      disablePrevious: !1
    };
  },
  computed: {
    computeNextDisabled() {
      return this.currentPage == this.totalPage || this.disabled;
    },
    computePreviousDisabled() {
      return this.currentPage == 1 || this.disabled;
    }
  },
  methods: {
    nextHandler() {
      this.currentPage < this.totalPage && (this.currentPage += 1), this.nextClickHandler && this.nextClickHandler({
        currentPage: this.currentPage,
        totalPage: this.totalPage
      });
    },
    previousHandler() {
      this.currentPage > 1 && (this.currentPage -= 1), this.previousClickHandler && this.previousClickHandler({
        currentPage: this.currentPage,
        totalPage: this.totalPage
      });
    }
  }
};
var YO = function() {
  var i = this, e = i.$createElement, t = i._self._c || e;
  return i.totalPage > 1 ? t("div", {
    class: i.$style.pagination_container,
    style: i.styleProps
  }, [t("span", {
    class: i.$style.pagination_label
  }, [i._v(i._s(i.currentPage) + " of " + i._s(i.totalPage))]), t("icon-button", {
    attrs: {
      "button-type": "previous",
      "click-handler": i.previousHandler,
      disabled: i.computePreviousDisabled
    }
  }), t("icon-button", {
    attrs: {
      "button-type": "next",
      "click-handler": i.nextHandler,
      disabled: i.computeNextDisabled
    }
  })], 1) : i._e();
}, RO = [];
const NO = "_pagination_container_1t89v_7", $O = "_pagination_label_1t89v_15", FO = {
  pagination_container: NO,
  pagination_label: $O
}, $l = {};
$l.$style = FO;
var BO = /* @__PURE__ */ te(
  IO,
  YO,
  RO,
  !1,
  HO,
  "3f69ec14",
  null,
  null
);
function HO(i) {
  for (let e in $l)
    this[e] = $l[e];
}
const SA = /* @__PURE__ */ function() {
  return BO.exports;
}();
export {
  VO as Accordion,
  WO as AlertBox,
  GO as Calendar,
  zO as ChartJS,
  JO as CheckList,
  $h as CheckboxButton,
  eA as Chips,
  Qr as CtaButton,
  tA as CustomList,
  iA as DataTable,
  sA as DataTablev2,
  nA as DoubleDropdown,
  rA as Dropdown,
  Hd as IconButton,
  aA as InputNumber,
  lA as InputText,
  uA as ListGroup,
  hA as ListItem,
  wA as ListSearchBar,
  ZO as MasterFilter,
  cA as Modal,
  dA as Onboarding,
  qO as OverallXYChart,
  SA as Pagination,
  uu as Popover,
  Va as SearchBar,
  XO as SearchJS,
  fA as Slider,
  pA as Snackbar,
  gA as TabButton,
  yA as TabIcon,
  _A as TabModule,
  mA as TabNumber,
  bA as TabOverview,
  UO as TableActionbarButton,
  oA as Textarea,
  vA as TimePicker,
  xA as ToggleButton,
  nx as Tooltip,
  rD as XYChart
};
